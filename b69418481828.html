<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="description" content="梦里的竹蜻蜓 一个写bug的程序员"><meta name="author" content="Fool"><meta name="keywords" content="Hexo,JavaScript,html5,css3,Jquery,NodeJs,github,css,js,html,java,blog,博客"><meta name="baidu-site-verification" content="code-yIv1xTa1ed"><meta name="google-site-verification" content="1zwyY4tiPsHyxK1HeGG9l5f7srBaAW3y7T6oyfo-7Vk"><title>集成属性 - 梦里的竹蜻蜓</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"blog.guard.ren",root:"/",version:"1.8.11",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:1},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:"2d6a21bdd6e9c407e7e8a37193a8230b",google:"ga:192080150",gtag:"UA-136832726-1",tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"XhzUk14bCmCVREHE5ROg559J-MdYXbMMI",app_key:"c8Fw7RQke0iYCjQb2NX4jwSW",server_url:null}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>梦里的竹蜻蜓</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 时间轴</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 简介</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 链接</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(/img/default_post.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="集成属性"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-07-14 16:05" pubdate>2021-07-14 16:05</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 5.3k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 96 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">集成属性</h1><p class="note note-info">本文最后更新于：2021-08-15 18:05</p><div class="markdown-body"><h2 id="activemq"><a href="#activemq" class="headerlink" title="activemq"></a>activemq</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.activemq.broker-url</code></td><td></td><td>ActiveMQ broker 的 URL。默认情况下自动生成。</td></tr><tr><td><code>spring.activemq.close-timeout</code></td><td><code>15s</code></td><td>等到时间到了再考虑接近完整。</td></tr><tr><td><code>spring.activemq.in-memory</code></td><td><code>true</code></td><td>默认的 broker URL 是否应该在内存中。如果已经指定了显式经纪商，则忽略。</td></tr><tr><td><code>spring.activemq.non-blocking-redelivery</code></td><td><code>false</code></td><td>是否在从回滚的事务中重新传送消息之前停止消息传送。这意味着当启用该功能时，消息顺序不会被保留。</td></tr><tr><td><code>spring.activemq.packages.trust-all</code></td><td></td><td>是否信任所有的包。</td></tr><tr><td><code>spring.activemq.packages.trusted</code></td><td></td><td>以逗号分隔的特定软件包信任列表（当不信任所有软件包时）。</td></tr><tr><td><code>spring.activemq.password</code></td><td></td><td>经纪人的登录密码。</td></tr><tr><td><code>spring.activemq.pool.block-if-full</code></td><td><code>true</code></td><td>当请求连接且池已满时，是否要阻止。设置为 false，则会抛出一个 “JMSException”。</td></tr><tr><td><code>spring.activemq.pool.block-if-full-timeout</code></td><td><code>-1ms</code></td><td>如果池子仍然满了，在抛出异常之前的阻塞期。</td></tr><tr><td><code>spring.activemq.pool.enabled</code></td><td><code>false</code></td><td>是否应该创建一个 JmsPoolConnectionFactory，而不是一个普通的 ConnectionFactory。</td></tr><tr><td><code>spring.activemq.pool.idle-timeout</code></td><td><code>30s</code></td><td>连接闲置超时。</td></tr><tr><td><code>spring.activemq.pool.max-connections</code></td><td><code>1.0</code></td><td>集合连接的最大数量。</td></tr><tr><td><code>spring.activemq.pool.max-sessions-per-connection</code></td><td><code>500.0</code></td><td>池中每个连接的最大集合会话数。</td></tr><tr><td><code>spring.activemq.pool.time-between-expiration-check</code></td><td><code>-1ms</code></td><td>空闲连接驱逐线程运行之间的睡眠时间。为负值时，不运行空闲连接驱逐线程。</td></tr><tr><td><code>spring.activemq.pool.use-anonymous-producers</code></td><td><code>true</code></td><td>是否只使用一个匿名的 “MessageProducer “实例。设置为 false，每次需要创建一个 “MessageProducer “时，就会创建一个。</td></tr><tr><td><code>spring.activemq.send-timeout</code></td><td><code>0ms</code></td><td>消息发送后等待响应的时间。设置为 0 则永远等待。</td></tr><tr><td><code>spring.activemq.user</code></td><td></td><td>经纪人的登录用户。</td></tr></tbody></table><h2 id="artemis"><a href="#artemis" class="headerlink" title="artemis"></a>artemis</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.artemis.embedded.cluster-password</code></td><td></td><td>群集密码。默认情况下，在启动时随机生成。</td></tr><tr><td><code>spring.artemis.embedded.data-directory</code></td><td></td><td>日志文件目录。如果关闭了持久性，则不需要。</td></tr><tr><td><code>spring.artemis.embedded.enabled</code></td><td><code>true</code></td><td>如果 Artemis 服务器 API 可用，是否启用嵌入式模式。</td></tr><tr><td><code>spring.artemis.embedded.persistent</code></td><td><code>false</code></td><td>是否启用持久化存储。</td></tr><tr><td><code>spring.artemis.embedded.queues</code></td><td><code>[]</code></td><td>以逗号分隔的队列列表，以便在启动时创建。</td></tr><tr><td><code>spring.artemis.embedded.server-id</code></td><td><code>0.0</code></td><td>服务器 ID。默认情况下，使用自动递增的计数器</td></tr><tr><td><code>spring.artemis.embedded.topics</code></td><td><code>[]</code></td><td>逗号分隔的主题列表，在启动时创建。</td></tr><tr><td><code>spring.artemis.host</code></td><td><code>localhost</code></td><td>阿特米斯经纪公司主机。</td></tr><tr><td><code>spring.artemis.mode</code></td><td></td><td>Artemis 部署模式，默认为自动检测。</td></tr><tr><td><code>spring.artemis.password</code></td><td></td><td>经纪人的登录密码。</td></tr><tr><td><code>spring.artemis.pool.block-if-full</code></td><td><code>true</code></td><td>当请求连接且池已满时，是否要阻止。设置为 false，则会抛出一个 “JMSException”。</td></tr><tr><td><code>spring.artemis.pool.block-if-full-timeout</code></td><td><code>-1ms</code></td><td>如果池子仍然满了，在抛出异常之前的阻塞期。</td></tr><tr><td><code>spring.artemis.pool.enabled</code></td><td><code>false</code></td><td>是否应该创建一个 JmsPoolConnectionFactory，而不是一个普通的 ConnectionFactory。</td></tr><tr><td><code>spring.artemis.pool.idle-timeout</code></td><td><code>30s</code></td><td>连接闲置超时。</td></tr><tr><td><code>spring.artemis.pool.max-connections</code></td><td><code>1.0</code></td><td>集合连接的最大数量。</td></tr><tr><td><code>spring.artemis.pool.max-sessions-per-connection</code></td><td><code>500.0</code></td><td>池中每个连接的最大集合会话数。</td></tr><tr><td><code>spring.artemis.pool.time-between-expiration-check</code></td><td><code>-1ms</code></td><td>空闲连接驱逐线程运行之间的睡眠时间。为负值时，不运行空闲连接驱逐线程。</td></tr><tr><td><code>spring.artemis.pool.use-anonymous-producers</code></td><td><code>true</code></td><td>是否只使用一个匿名的 “MessageProducer “实例。设置为 false，每次需要创建一个 “MessageProducer “时，就会创建一个。</td></tr><tr><td><code>spring.artemis.port</code></td><td><code>61616.0</code></td><td>Artemis 经纪端口。</td></tr><tr><td><code>spring.artemis.user</code></td><td></td><td>经纪人的登录用户。</td></tr></tbody></table><h2 id="bacth"><a href="#bacth" class="headerlink" title="bacth"></a>bacth</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.batch.initialize-schema</code></td><td><code>embedded</code></td><td>数据库模式初始化模式。</td></tr><tr><td><code>spring.batch.job.enabled</code></td><td><code>true</code></td><td>启动时在上下文中执行所有 Spring Batch 作业。</td></tr><tr><td><code>spring.batch.job.names</code></td><td></td><td>要在启动时执行的以逗号分隔的工作名称列表（例如，<code>job1,job2</code>）。默认情况下，所有在上下文中找到的工作都会被执行。</td></tr><tr><td><code>spring.batch.schema</code></td><td><code>classpath:org/springframework/batch/core/schema-@@platform@@.sql</code></td><td>用于初始化数据库模式的 SQL 文件的路径。</td></tr><tr><td><code>spring.batch.table-prefix</code></td><td></td><td>所有批次元数据表的表前缀。</td></tr></tbody></table><h2 id="hazelcast"><a href="#hazelcast" class="headerlink" title="hazelcast"></a>hazelcast</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.hazelcast.config</code></td><td></td><td>用于初始化 Hazelcast 的配置文件的位置。</td></tr></tbody></table><h2 id="integration"><a href="#integration" class="headerlink" title="integration"></a>integration</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.integration.jdbc.initialize-schema</code></td><td><code>embedded</code></td><td>数据库模式初始化模式。</td></tr><tr><td><code>spring.integration.jdbc.schema</code></td><td><code>classpath:org/springframework/integration/jdbc/schema-@@platform@@.sql</code></td><td>用于初始化数据库模式的 SQL 文件的路径。</td></tr><tr><td><code>spring.integration.rsocket.client.host</code></td><td></td><td>要连接到的 TCP RSocket 服务器主机。</td></tr><tr><td><code>spring.integration.rsocket.client.port</code></td><td></td><td>要连接的 TCP RSocket 服务器端口。</td></tr><tr><td><code>spring.integration.rsocket.client.uri</code></td><td></td><td>要连接到的 WebSocket RSocket 服务器 uri。</td></tr><tr><td><code>spring.integration.rsocket.server.message-mapping-enabled</code></td><td><code>false</code></td><td>是否通过 Spring 集成处理 RSocket 的消息映射。</td></tr></tbody></table><h2 id="jms"><a href="#jms" class="headerlink" title="jms"></a>jms</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.jms.cache.consumers</code></td><td><code>false</code></td><td>是否缓存消息消费者。</td></tr><tr><td><code>spring.jms.cache.enabled</code></td><td><code>true</code></td><td>是否要缓存会话。</td></tr><tr><td><code>spring.jms.cache.producers</code></td><td><code>true</code></td><td>是否缓存消息生产者。</td></tr><tr><td><code>spring.jms.cache.session-cache-size</code></td><td><code>1.0</code></td><td>会话缓存的大小（每个 JMS 会话类型）。</td></tr><tr><td><code>spring.jms.jndi-name</code></td><td></td><td>连接工厂 JNDI 名称。设置后，优先于其他连接工厂的自动配置。</td></tr><tr><td><code>spring.jms.listener.acknowledge-mode</code></td><td></td><td>容器的确认模式。默认情况下，监听器是以自动确认的方式进行交易的。</td></tr><tr><td><code>spring.jms.listener.auto-startup</code></td><td><code>true</code></td><td>启动时自动启动容器。</td></tr><tr><td><code>spring.jms.listener.concurrency</code></td><td></td><td>同时消费的最低人数；</td></tr><tr><td><code>spring.jms.listener.max-concurrency</code></td><td></td><td>最大并发消费者数量。</td></tr><tr><td><code>spring.jms.listener.receive-timeout</code></td><td><code>1s</code></td><td>接收电话的超时时间，使用-1 表示无等待接收，0 表示无超时。使用-1 表示无等待接收，使用 0 表示完全没有超时。后者只有在不在事务管理器中运行的情况下才可行，而且一般不鼓励使用，因为它可以防止干净的关机。</td></tr><tr><td><code>spring.jms.pub-sub-domain</code></td><td><code>false</code></td><td>默认的目标类型是否为主题。</td></tr><tr><td><code>spring.jms.template.default-destination</code></td><td></td><td>在没有目的地参数的发送和接收操作中使用的默认目的地。</td></tr><tr><td><code>spring.jms.template.delivery-delay</code></td><td></td><td>送货延迟用于发送电话。</td></tr><tr><td><code>spring.jms.template.delivery-mode</code></td><td></td><td>交付模式。设置后启用 QoS（服务质量）。</td></tr><tr><td><code>spring.jms.template.priority</code></td><td></td><td>发送消息时的优先级。设置后启用 QoS（服务质量）。</td></tr><tr><td><code>spring.jms.template.qos-enabled</code></td><td></td><td>发送消息时是否启用显式 QoS（服务质量）。启用后，发送消息时将使用发送模式、优先级和存活时间属性。当至少有一项设置被自定义时，QoS 将自动启用。</td></tr><tr><td><code>spring.jms.template.receive-timeout</code></td><td></td><td>接听电话时使用的超时。</td></tr><tr><td><code>spring.jms.template.time-to-live</code></td><td></td><td>发送时信息的生存时间。设置时启用 QoS（服务质量）。</td></tr></tbody></table><h2 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.kafka.bootstrap-servers</code></td><td></td><td>用逗号分隔的主机：端口对列表，用于建立到 Kafka 集群的初始连接。除非被覆盖，否则适用于所有组件。</td></tr><tr><td><code>spring.kafka.client-id</code></td><td></td><td>发出请求时传递给服务器的 ID。用于服务器端的日志记录。</td></tr></tbody></table><h3 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.kafka.admin.client-id</code></td><td></td><td>发出请求时传递给服务器的 ID。用于服务器端的日志记录。</td></tr><tr><td><code>spring.kafka.admin.fail-fast</code></td><td><code>false</code></td><td>如果在启动时没有经纪人，是否要快速失败。</td></tr><tr><td><code>spring.kafka.admin.properties.*</code></td><td></td><td>用于配置客户端的其他管理员专用属性。</td></tr><tr><td><code>spring.kafka.admin.security.protocol</code></td><td></td><td>用于与经纪人通信的安全协议。</td></tr><tr><td><code>spring.kafka.admin.ssl.key-password</code></td><td></td><td>钥匙存储文件中私钥的密码。</td></tr><tr><td><code>spring.kafka.admin.ssl.key-store-location</code></td><td></td><td>钥匙存储文件的位置。</td></tr><tr><td><code>spring.kafka.admin.ssl.key-store-password</code></td><td></td><td>存储密钥存储文件的密码。</td></tr><tr><td><code>spring.kafka.admin.ssl.key-store-type</code></td><td></td><td>钥匙库的类型。</td></tr><tr><td><code>spring.kafka.admin.ssl.protocol</code></td><td></td><td>要使用的 SSL 协议。</td></tr><tr><td><code>spring.kafka.admin.ssl.trust-store-location</code></td><td></td><td>信任存储文件的位置。</td></tr><tr><td><code>spring.kafka.admin.ssl.trust-store-password</code></td><td></td><td>为信任存储文件存储密码。</td></tr><tr><td><code>spring.kafka.admin.ssl.trust-store-type</code></td><td></td><td>信托商店的类型。</td></tr></tbody></table><h3 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.kafka.consumer.auto-commit-interval</code></td><td></td><td>如果’enable.auto.commit’设置为 true，则消费者偏移量自动提交到 Kafka 的频率。</td></tr><tr><td><code>spring.kafka.consumer.auto-offset-reset</code></td><td></td><td>当 Kafka 中没有初始偏移量或者当前偏移量在服务器上已经不存在时，该怎么办。</td></tr><tr><td><code>spring.kafka.consumer.bootstrap-servers</code></td><td></td><td>用逗号分隔的主机:端口对列表，用于建立到 Kafka 集群的初始连接。对消费者而言，覆盖全局属性。</td></tr><tr><td><code>spring.kafka.consumer.client-id</code></td><td></td><td>出请求时传递给服务器的 ID。用于服务器端的日志记录。</td></tr><tr><td><code>spring.kafka.consumer.enable-auto-commit</code></td><td></td><td>消费者的抵偿是否定期在后台承诺。</td></tr><tr><td><code>spring.kafka.consumer.fetch-max-wait</code></td><td></td><td>如果没有足够的数据立即满足 “fetch-min-size “给出的要求，服务器在回应 fetch 请求前的最大阻塞时间。</td></tr><tr><td><code>spring.kafka.consumer.fetch-min-size</code></td><td></td><td>服务器为一个获取请求应返回的最小数据量。</td></tr><tr><td><code>spring.kafka.consumer.group-id</code></td><td></td><td>标识该消费者所属消费群体的唯一字符串。</td></tr><tr><td><code>spring.kafka.consumer.heartbeat-interval</code></td><td></td><td>消费者协调员的预期心跳间隔时间。</td></tr><tr><td><code>spring.kafka.consumer.isolation-level</code></td><td></td><td>读取以事务方式写入的消息的隔离级别。</td></tr><tr><td><code>spring.kafka.consumer.key-deserializer</code></td><td></td><td>密钥的解串器类。</td></tr><tr><td><code>spring.kafka.consumer.max-poll-records</code></td><td></td><td>单次调用 poll()时返回的最大记录数。</td></tr><tr><td><code>spring.kafka.consumer.properties.*</code></td><td></td><td>用于配置客户端的其他消费者特定属性。</td></tr><tr><td><code>spring.kafka.consumer.security.protocol</code></td><td></td><td>用于与经纪人通信的安全协议。</td></tr><tr><td><code>spring.kafka.consumer.ssl.key-password</code></td><td></td><td>钥匙存储文件中私钥的密码。</td></tr><tr><td><code>spring.kafka.consumer.ssl.key-store-location</code></td><td></td><td>钥匙存储文件的位置。</td></tr><tr><td><code>spring.kafka.consumer.ssl.key-store-password</code></td><td></td><td>存储密钥存储文件的密码。</td></tr><tr><td><code>spring.kafka.consumer.ssl.key-store-type</code></td><td></td><td>钥匙库的类型。</td></tr><tr><td><code>spring.kafka.consumer.ssl.protocol</code></td><td></td><td>要使用的 SSL 协议。</td></tr><tr><td><code>spring.kafka.consumer.ssl.trust-store-location</code></td><td></td><td>信任存储文件的位置。</td></tr><tr><td><code>spring.kafka.consumer.ssl.trust-store-password</code></td><td></td><td>为信任存储文件存储密码。</td></tr><tr><td><code>spring.kafka.consumer.ssl.trust-store-type</code></td><td></td><td>信托商店的类型。</td></tr><tr><td><code>spring.kafka.consumer.value-deserializer</code></td><td></td><td>值的解串器类。</td></tr></tbody></table><h3 id="jaas"><a href="#jaas" class="headerlink" title="jaas"></a>jaas</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.kafka.jaas.control-flag</code></td><td><code>required</code></td><td>登录配置的控制标志。</td></tr><tr><td><code>spring.kafka.jaas.enabled</code></td><td><code>false</code></td><td>是否启用 JAAS 配置。</td></tr><tr><td><code>spring.kafka.jaas.login-module</code></td><td><code>com.sun.security.auth.module.Krb5LoginModule</code></td><td>登录模块。</td></tr><tr><td><code>spring.kafka.jaas.options.*</code></td><td></td><td>额外的 JAAS 选项。</td></tr></tbody></table><h3 id="listener"><a href="#listener" class="headerlink" title="listener"></a>listener</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.kafka.listener.ack-count</code></td><td></td><td>ackMode 为 “COUNT “或 “COUNT_TIME “时，偏移提交之间的记录数。</td></tr><tr><td><code>spring.kafka.listener.ack-mode</code></td><td></td><td>Listener AckMode。参见 spring-kafka 文档。</td></tr><tr><td><code>spring.kafka.listener.ack-time</code></td><td></td><td>当 ackMode 为 “TIME “或 “COUNT_TIME “时，偏移提交之间的时间。</td></tr><tr><td><code>spring.kafka.listener.client-id</code></td><td></td><td>监听器的消费者 client.id 属性的前缀。</td></tr><tr><td><code>spring.kafka.listener.concurrency</code></td><td></td><td>在监听器容器中运行的线程数。</td></tr><tr><td><code>spring.kafka.listener.idle-event-interval</code></td><td></td><td>发布闲置消费者事件之间的时间（没有收到数据）。</td></tr><tr><td><code>spring.kafka.listener.log-container-config</code></td><td></td><td>是否在初始化期间记录容器配置（INFO 级别）。</td></tr><tr><td><code>spring.kafka.listener.missing-topics-fatal</code></td><td><code>false</code></td><td>如果至少一个配置的主题不存在于 broker 上，容器是否应该无法启动。</td></tr><tr><td><code>spring.kafka.listener.monitor-interval</code></td><td></td><td>对无反应的消费者进行检查的间隔时间。如果没有指定持续时间后缀，将使用秒。</td></tr><tr><td><code>spring.kafka.listener.no-poll-threshold</code></td><td></td><td>应用于 “pollTimeout “的乘数，以确定消费者是否不响应。</td></tr><tr><td><code>spring.kafka.listener.poll-timeout</code></td><td></td><td>对消费者进行投票时使用的超时。</td></tr><tr><td><code>spring.kafka.listener.type</code></td><td><code>single</code></td><td>倾听者类型。</td></tr></tbody></table><h3 id="producer"><a href="#producer" class="headerlink" title="producer"></a>producer</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.kafka.producer.acks</code></td><td></td><td>生产者要求领导在认为请求完成之前收到的确认数量。</td></tr><tr><td><code>spring.kafka.producer.batch-size</code></td><td></td><td>默认批次大小。批量小会使批处理不那么常见，并可能降低吞吐量（批量为零会使批处理完全失效）。</td></tr><tr><td><code>spring.kafka.producer.bootstrap-servers</code></td><td></td><td>用逗号分隔的主机:端口对列表，用于建立到 Kafka 集群的初始连接。覆盖全局属性，用于生产者。</td></tr><tr><td><code>spring.kafka.producer.buffer-memory</code></td><td></td><td>生产者可以用来缓冲等待发送到服务器的记录的总内存大小。</td></tr><tr><td><code>spring.kafka.producer.client-id</code></td><td></td><td>发出请求时传递给服务器的 ID。用于服务器端的日志记录。</td></tr><tr><td><code>spring.kafka.producer.compression-type</code></td><td></td><td>生产者生成的所有数据的压缩类型。</td></tr><tr><td><code>spring.kafka.producer.key-serializer</code></td><td></td><td>键的序列器类。</td></tr><tr><td><code>spring.kafka.producer.properties.*</code></td><td></td><td>用于配置客户端的附加生产者特定属性。</td></tr><tr><td><code>spring.kafka.producer.retries</code></td><td></td><td>当大于零时，启用重试发送失败。</td></tr><tr><td><code>spring.kafka.producer.security.protocol</code></td><td></td><td>用于与经纪人通信的安全协议。</td></tr><tr><td><code>spring.kafka.producer.ssl.key-password</code></td><td></td><td>钥匙存储文件中私钥的密码。</td></tr><tr><td><code>spring.kafka.producer.ssl.key-store-location</code></td><td></td><td>钥匙存储文件的位置。</td></tr><tr><td><code>spring.kafka.producer.ssl.key-store-password</code></td><td></td><td>存储密钥存储文件的密码。</td></tr><tr><td><code>spring.kafka.producer.ssl.key-store-type</code></td><td></td><td>钥匙库的类型。</td></tr><tr><td><code>spring.kafka.producer.ssl.protocol</code></td><td></td><td>要使用的 SSL 协议。</td></tr><tr><td><code>spring.kafka.producer.ssl.trust-store-location</code></td><td></td><td>信任存储文件的位置。</td></tr><tr><td><code>spring.kafka.producer.ssl.trust-store-password</code></td><td></td><td>为信任存储文件存储密码。</td></tr><tr><td><code>spring.kafka.producer.ssl.trust-store-type</code></td><td></td><td>信托商店的类型。</td></tr><tr><td><code>spring.kafka.producer.transaction-id-prefix</code></td><td></td><td>当非空时，启用对生产者的交易支持。</td></tr><tr><td><code>spring.kafka.producer.value-serializer</code></td><td></td><td>值的序列器类。</td></tr></tbody></table><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.kafka.properties.*</code></td><td></td><td>附加属性，生产者和消费者共有，用于配置客户端。</td></tr></tbody></table><h3 id="security"><a href="#security" class="headerlink" title="security"></a>security</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.kafka.security.protocol</code></td><td></td><td>用于与经纪人通信的安全协议。</td></tr></tbody></table><h3 id="ssl"><a href="#ssl" class="headerlink" title="ssl"></a>ssl</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.kafka.ssl.key-password</code></td><td></td><td>钥匙存储文件中私钥的密码。</td></tr><tr><td><code>spring.kafka.ssl.key-store-location</code></td><td></td><td>钥匙存储文件的位置。</td></tr><tr><td><code>spring.kafka.ssl.key-store-password</code></td><td></td><td>存储密钥存储文件的密码。</td></tr><tr><td><code>spring.kafka.ssl.key-store-type</code></td><td></td><td>钥匙库的类型。</td></tr><tr><td><code>spring.kafka.ssl.protocol</code></td><td></td><td>要使用的 SSL 协议。</td></tr><tr><td><code>spring.kafka.ssl.trust-store-location</code></td><td></td><td>信任存储文件的位置。</td></tr><tr><td><code>spring.kafka.ssl.trust-store-password</code></td><td></td><td>为信任存储文件存储密码。</td></tr><tr><td><code>spring.kafka.ssl.trust-store-type</code></td><td></td><td>信托商店的类型。</td></tr></tbody></table><h3 id="streams"><a href="#streams" class="headerlink" title="streams"></a>streams</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.kafka.streams.application-id</code></td><td></td><td>Kafka 流的 application.id 属性；默认为 spring.application.name。</td></tr><tr><td><code>spring.kafka.streams.auto-startup</code></td><td><code>true</code></td><td>是否自动启动流工厂豆。</td></tr><tr><td><code>spring.kafka.streams.bootstrap-servers</code></td><td></td><td>用逗号分隔的主机:端口对列表，用于建立到 Kafka 集群的初始连接。覆盖全局属性，用于流。</td></tr><tr><td><code>spring.kafka.streams.cache-max-size-buffering</code></td><td></td><td>用于所有线程缓冲的最大内存大小。</td></tr><tr><td><code>spring.kafka.streams.client-id</code></td><td></td><td>发出请求时传递给服务器的 ID。用于服务器端的日志记录。</td></tr><tr><td><code>spring.kafka.streams.properties.*</code></td><td></td><td>用于配置流的其他 Kafka 属性。</td></tr><tr><td><code>spring.kafka.streams.replication-factor</code></td><td></td><td>流处理应用程序创建的变更日志主题和重新分区主题的复制因子。</td></tr><tr><td><code>spring.kafka.streams.security.protocol</code></td><td></td><td>用于与经纪人通信的安全协议。</td></tr><tr><td><code>spring.kafka.streams.ssl.key-password</code></td><td></td><td>钥匙存储文件中私钥的密码。</td></tr><tr><td><code>spring.kafka.streams.ssl.key-store-location</code></td><td></td><td>钥匙存储文件的位置。</td></tr><tr><td><code>spring.kafka.streams.ssl.key-store-password</code></td><td></td><td>存储密钥存储文件的密码。</td></tr><tr><td><code>spring.kafka.streams.ssl.key-store-type</code></td><td></td><td>钥匙库的类型。</td></tr><tr><td><code>spring.kafka.streams.ssl.protocol</code></td><td></td><td>要使用的 SSL 协议。</td></tr><tr><td><code>spring.kafka.streams.ssl.trust-store-location</code></td><td></td><td>信任存储文件的位置。</td></tr><tr><td><code>spring.kafka.streams.ssl.trust-store-password</code></td><td></td><td>为信任存储文件存储密码。</td></tr><tr><td><code>spring.kafka.streams.ssl.trust-store-type</code></td><td></td><td>信托商店的类型。</td></tr><tr><td><code>spring.kafka.streams.state-dir</code></td><td></td><td>州店的目录位置。</td></tr></tbody></table><h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.kafka.template.default-topic</code></td><td></td><td>默认的邮件主题。</td></tr></tbody></table><h2 id="rabbitmq"><a href="#rabbitmq" class="headerlink" title="rabbitmq"></a>rabbitmq</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.rabbitmq.addresses</code></td><td></td><td>以逗号分隔的客户端应连接的地址列表。设置时，忽略主机和端口。</td></tr><tr><td><code>spring.rabbitmq.connection-timeout</code></td><td></td><td>连接超时。将其设置为零，以便永远等待。</td></tr><tr><td><code>spring.rabbitmq.dynamic</code></td><td><code>true</code></td><td>是否创建 AmqpAdmin bean。</td></tr><tr><td><code>spring.rabbitmq.host</code></td><td><code>localhost</code></td><td>RabbitMQ 主机。如果设置了地址，则忽略。</td></tr><tr><td><code>spring.rabbitmq.password</code></td><td><code>guest</code></td><td>登录对经纪人进行认证。</td></tr><tr><td><code>spring.rabbitmq.port</code></td><td></td><td>RabbitMQ 端口。如果设置了地址，则忽略。默认为 5672，如果启用了 SSL，则为 5671。</td></tr><tr><td><code>spring.rabbitmq.publisher-confirm-type</code></td><td></td><td>类型的发布者确认使用。</td></tr><tr><td><code>spring.rabbitmq.publisher-returns</code></td><td><code>false</code></td><td>是否启用发布者退货。</td></tr><tr><td><code>spring.rabbitmq.requested-channel-max</code></td><td><code>2047.0</code></td><td>客户端请求的每个连接的通道数。使用 0 表示无限制。</td></tr><tr><td><code>spring.rabbitmq.requested-heartbeat</code></td><td></td><td>要求的心跳超时；无心跳超时为零。如果没有指定持续时间后缀，将使用秒。</td></tr><tr><td><code>spring.rabbitmq.username</code></td><td><code>guest</code></td><td>登录用户来验证经纪人的身份。</td></tr><tr><td><code>spring.rabbitmq.virtual-host</code></td><td></td><td>连接到经纪人时要使用的虚拟主机。</td></tr></tbody></table><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.rabbitmq.cache.channel.checkout-timeout</code></td><td></td><td>如果缓存大小已经达到，等待获得通道的时间。如果为 0，则总是创建一个新的通道。</td></tr><tr><td><code>spring.rabbitmq.cache.channel.size</code></td><td></td><td>缓存中要保留的通道数，当 “check-timeout”&gt;0 时，每个连接的最大通道数。当 “check-timeout”&gt;0 时，每个连接的最大通道数。</td></tr><tr><td><code>spring.rabbitmq.cache.connection.mode</code></td><td><code>channel</code></td><td>连接工厂缓存模式。</td></tr><tr><td><code>spring.rabbitmq.cache.connection.size</code></td><td></td><td>缓存的连接数。仅适用于模式为 CONNECTION 时。</td></tr></tbody></table><h3 id="listener-1"><a href="#listener-1" class="headerlink" title="listener"></a>listener</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.rabbitmq.listener.direct.acknowledge-mode</code></td><td></td><td>容器的确认模式。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.auto-startup</code></td><td><code>true</code></td><td>是否在启动时自动启动容器。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.consumers-per-queue</code></td><td></td><td>每个队列的消费者人数。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.default-requeue-rejected</code></td><td></td><td>被拒绝的交付是否会被默认重新排队。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.idle-event-interval</code></td><td></td><td>闲置容器事件应该多久发布一次。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.missing-queues-fatal</code></td><td><code>false</code></td><td>如果容器声明的队列在经纪人上不可用，是否要失败。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.prefetch</code></td><td></td><td>在每个消费者那里可以未被确认的最大信息数量。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.retry.enabled</code></td><td><code>false</code></td><td>是否启用发布重试。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.retry.initial-interval</code></td><td><code>1000ms</code></td><td>第一次和第二次尝试传递信息之间的时间。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.retry.max-attempts</code></td><td><code>3.0</code></td><td>发送信息的最大尝试次数。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.retry.max-interval</code></td><td><code>10000ms</code></td><td>尝试之间的最大持续时间。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.retry.multiplier</code></td><td><code>1.0</code></td><td>适用于上一次重试间隔的倍数。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.retry.stateless</code></td><td><code>true</code></td><td>重试是无状态还是有状态。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.acknowledge-mode</code></td><td></td><td>容器的确认模式。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.auto-startup</code></td><td><code>true</code></td><td>是否在启动时自动启动容器。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.batch-size</code></td><td></td><td>批量大小，以容器要使用的物理报文的数量表示。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.concurrency</code></td><td></td><td>监听器调用者线程的最少数量。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.default-requeue-rejected</code></td><td></td><td>被拒绝的交付是否会被默认重新排队。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.idle-event-interval</code></td><td></td><td>闲置容器事件应该多久发布一次。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.max-concurrency</code></td><td></td><td>监听者调用者线程的最大数量。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.missing-queues-fatal</code></td><td><code>true</code></td><td>如果容器声明的队列在 broker 上不可用，是否要失败，和/或如果一个或多个队列在运行时被删除，是否要停止容器。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.prefetch</code></td><td></td><td>在每个消费者那里可以未被确认的最大信息数量。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.retry.enabled</code></td><td><code>false</code></td><td>是否启用发布重试。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.retry.initial-interval</code></td><td><code>1000ms</code></td><td>第一次和第二次尝试传递信息之间的时间。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.retry.max-attempts</code></td><td><code>3.0</code></td><td>发送信息的最大尝试次数。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.retry.max-interval</code></td><td><code>10000ms</code></td><td>尝试之间的最大持续时间。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.retry.multiplier</code></td><td><code>1.0</code></td><td>适用于上一次重试间隔的倍数。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.retry.stateless</code></td><td><code>true</code></td><td>重试是无状态还是有状态。</td></tr><tr><td><code>spring.rabbitmq.listener.type</code></td><td><code>simple</code></td><td>监听器容器类型。</td></tr></tbody></table><h3 id="ssl-1"><a href="#ssl-1" class="headerlink" title="ssl"></a>ssl</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.rabbitmq.ssl.algorithm</code></td><td></td><td>要使用的 SSL 算法。默认情况下，由 Rabbit 客户端库配置。</td></tr><tr><td><code>spring.rabbitmq.ssl.enabled</code></td><td></td><td>是否启用 SSL 支持。如果协议中提供了地址，则自动确定（amqp:// vs. amqps://）。</td></tr><tr><td><code>spring.rabbitmq.ssl.key-store</code></td><td></td><td>存放 SSL 证书的密钥库的路径。</td></tr><tr><td><code>spring.rabbitmq.ssl.key-store-password</code></td><td></td><td>用于访问钥匙库的密码。</td></tr><tr><td><code>spring.rabbitmq.ssl.key-store-type</code></td><td><code>PKCS12</code></td><td>钥匙库类型。</td></tr><tr><td><code>spring.rabbitmq.ssl.trust-store</code></td><td></td><td>持有 SSL 证书的信任商店。</td></tr><tr><td><code>spring.rabbitmq.ssl.trust-store-password</code></td><td></td><td>用于访问信托商店的密码。</td></tr><tr><td><code>spring.rabbitmq.ssl.trust-store-type</code></td><td><code>JKS</code></td><td>信任店型。</td></tr><tr><td><code>spring.rabbitmq.ssl.validate-server-certificate</code></td><td><code>true</code></td><td>是否启用服务器端证书验证。</td></tr><tr><td><code>spring.rabbitmq.ssl.verify-hostname</code></td><td><code>true</code></td><td>是否启用主机名验证。</td></tr></tbody></table><h3 id="template-1"><a href="#template-1" class="headerlink" title="template"></a>template</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.rabbitmq.template.default-receive-queue</code></td><td></td><td>当没有明确指定队列时，默认队列的名称。</td></tr><tr><td><code>spring.rabbitmq.template.exchange</code></td><td></td><td>用于发送操作的默认交易所的名称。</td></tr><tr><td><code>spring.rabbitmq.template.mandatory</code></td><td></td><td>是否启用强制消息。</td></tr><tr><td><code>spring.rabbitmq.template.receive-timeout</code></td><td></td><td><code>receive()</code>操作超时。</td></tr><tr><td><code>spring.rabbitmq.template.reply-timeout</code></td><td></td><td><code>sendAndReceive()</code>操作的超时。</td></tr><tr><td><code>spring.rabbitmq.template.retry.enabled</code></td><td><code>false</code></td><td>是否启用发布重试。</td></tr><tr><td><code>spring.rabbitmq.template.retry.initial-interval</code></td><td><code>1000ms</code></td><td>第一次和第二次尝试传递信息之间的时间。</td></tr><tr><td><code>spring.rabbitmq.template.retry.max-attempts</code></td><td><code>3.0</code></td><td>发送信息的最大尝试次数。</td></tr><tr><td><code>spring.rabbitmq.template.retry.max-interval</code></td><td><code>10000ms</code></td><td>尝试之间的最大持续时间。</td></tr><tr><td><code>spring.rabbitmq.template.retry.multiplier</code></td><td><code>1.0</code></td><td>适用于上一次重试间隔的倍数。</td></tr><tr><td><code>spring.rabbitmq.template.routing-key</code></td><td></td><td>用于发送操作的默认路由键的值。</td></tr></tbody></table><h2 id="webservices"><a href="#webservices" class="headerlink" title="webservices"></a>webservices</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.webservices.path</code></td><td><code>/services</code></td><td>作为服务的基本 URI 的路径。</td></tr><tr><td><code>spring.webservices.servlet.init.*</code></td><td></td><td>要传递给 Spring Web 服务的 Servlet init 参数。</td></tr><tr><td><code>spring.webservices.servlet.load-on-startup</code></td><td><code>-1.0</code></td><td>对 Spring Web 服务 servlet 的启动优先级进行加载。</td></tr><tr><td><code>spring.webservices.wsdl-locations</code></td><td></td><td>以逗号分隔的 WSDLs 和随附的 XSDs 的位置列表，这些 WSDLs 和 XSDs 将作为豆子暴露。</td></tr></tbody></table></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E8%AF%AD%E9%9B%80/">语雀</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/%E8%AF%AD%E9%9B%80/">语雀</a> <a class="hover-with-bg" href="/tags/Java/">Java</a> <a class="hover-with-bg" href="/tags/SpringBoot/">SpringBoot</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/e877f7d30bd2.html"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">网络属性</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/e337a70add48.html"><span class="hidden-mobile">数据迁移属性</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js",(function(){var e=Object.assign({appId:"XhzUk14bCmCVREHE5ROg559J-MdYXbMMI",appKey:"c8Fw7RQke0iYCjQb2NX4jwSW",placeholder:"说点什么...",path:"window.location.pathname",avatar:"retro",meta:["nick","mail","link"],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"",emojiCDN:null,emojiMaps:null,enableQQ:!0,requiredFields:[]},{el:"#valine",path:window.location.pathname});new Valine(e)}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content">Powered By - <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> Theme - <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a><div style="font-size:.85rem"><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="/js/duration.js"></script></div></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script defer>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?2d6a21bdd6e9c407e7e8a37193a8230b";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script defer>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","ga:192080150","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-136832726-1"></script><script defer>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-136832726-1")</script><script src="/js/boot.js"></script><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>