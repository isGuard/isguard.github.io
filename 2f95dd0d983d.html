<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>Gradle | zea</title><meta name="author" content="初。"><meta name="copyright" content="初。"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="Gradle 入门Gradle 简介Gradle 是一款Google 推出的基于 JVM、通用灵活的项目构建工具，支持 Maven，JCenter 多种第三方仓库;支持传递性依赖管理、废弃了繁杂的xml 文件，转而使用简洁的、支持多种语言(例如：java、groovy 等)的 build 脚本文件。"><meta property="og:type" content="article"><meta property="og:title" content="Gradle"><meta property="og:url" content="https://blog.48626.xyz/2f95dd0d983d.html"><meta property="og:site_name" content="zea"><meta property="og:description" content="Gradle 入门Gradle 简介Gradle 是一款Google 推出的基于 JVM、通用灵活的项目构建工具，支持 Maven，JCenter 多种第三方仓库;支持传递性依赖管理、废弃了繁杂的xml 文件，转而使用简洁的、支持多种语言(例如：java、groovy 等)的 build 脚本文件。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://q1.qlogo.cn/g?b=qq&nk=770600073&s=640"><meta property="article:published_time" content="2024-10-28T08:06:06.000Z"><meta property="article:modified_time" content="2024-10-28T08:06:06.000Z"><meta property="article:author" content="初。"><meta property="article:tag" content="Gradle"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://q1.qlogo.cn/g?b=qq&nk=770600073&s=640"><link rel="shortcut icon" href="/static/favicon.png"><link rel="canonical" href="https://blog.48626.xyz/2f95dd0d983d.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//www.clarity.ms"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="IRx06tBaTglUq66WChYv9bkH8lKr7PO60mUioFn--yM"><meta name="bing-site-verification" content="E4B8BD2F04290DD88CD9F8BF5853705F"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6558e13fa8bf20edf22ca260ae572e44";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-NRQETXBKL4"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-NRQETXBKL4")</script><script>!function(t,e,n,c,a,i,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(i=e.createElement(c)).async=1,i.src="https://www.clarity.ms/tag/n2i82v50oq",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(i,r)}(window,document,"clarity","script")</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 初。","link":"链接: ","source":"来源: zea","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Gradle",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-10-28 16:06:06"}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="zea" type="application/atom+xml"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://q1.qlogo.cn/g?b=qq&amp;nk=770600073&amp;s=640" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">153</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">52</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/menu/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/menu/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i> <span>插件</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/menu/plugins/aria2/"><i class="fa-fw fas fa-download"></i> <span>Aria2</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/menu/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="zea"><span class="site-name">zea</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/menu/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/menu/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i> <span>插件</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/menu/plugins/aria2/"><i class="fa-fw fas fa-download"></i> <span>Aria2</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/menu/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Gradle</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-28T08:06:06.000Z" title="发表于 2024-10-28 16:06:06">2024-10-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-28T08:06:06.000Z" title="更新于 2024-10-28 16:06:06">2024-10-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Gradle/">Gradle</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>63分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Gradle"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="Gradle-入门"><a href="#Gradle-入门" class="headerlink" title="Gradle 入门"></a>Gradle 入门</h2><h3 id="Gradle-简介"><a href="#Gradle-简介" class="headerlink" title="Gradle 简介"></a>Gradle 简介</h3><p>Gradle 是一款Google 推出的<strong>基于 JVM、</strong>通用灵活的<strong>项目构建工具，</strong>支持 Maven，JCenter 多种第三方仓库;支持传递性依赖管理、废弃了繁杂的xml 文件，转而使用<strong>简洁的</strong>、<strong>支持多种语言</strong>(例如：java、groovy 等)的 <strong>build 脚本文件</strong>。</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028160947472.png" class="" alt="image-20241028160947472"><p>官网地址： <a target="_blank" rel="noopener external nofollow noreferrer" href="https://gradle.org/">https://gradle.org/</a></p><p>学习Gradle 的原因：</p><ol><li>目前已经有相当一部分公司在逐渐使用Gradle作为项目构建工具了。</li><li>作为Java开发程序员，如果想下载Spring、SpringBoot等Spring家族的源码，基本上基于Gradle构建的。</li></ol><p><strong>总之，虽然目前市面上常见的项目构建工具有Ant、Maven、Gradle，主流还是Maven，但是未来趋势Gradle。</strong></p><h3 id="常见的项目构建工具"><a href="#常见的项目构建工具" class="headerlink" title="常见的项目构建工具"></a>常见的项目构建工具</h3><p>Ant： 2000 年 Apache 推出的纯Java 编写构建工具，通过 xml[build.xml]文件管理项目优点：使用灵活，速度快(快于 gradle 和 maven)。</p><p>缺点：Ant 没有强加任何编码约定的项目目录结构，开发人员需编写繁杂XML 文件构建指令，对开发人员是一个挑战。</p><p>Maven： 2004 年Apache 组织推出的再次使用xml 文件[pom.xml]管理项目的构建工具。</p><p>优点： 遵循一套约定大于配置的项目目录结构，使用统一的GAV 坐标进行依赖管理，<strong>侧重于包管理</strong>。缺点：项目构建过程僵化，配置文件编写不够灵活、不方便自定义组件，构建速度慢于 gradle。</p><p>Gradle： 2012 年Google 推出的基于Groovy 语言的全新项目构建工具，集合了Ant 和 Maven 各自的优势。</p><p>优点：集 Ant 脚本的灵活性+Maven 约定大于配置的项目目录优势，支持多种远程仓库和插件<strong>，侧重于大项目构建</strong>。缺点：学习成本高、资料少、脚本灵活、版本兼容性差等。</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028161146438.png" class="" alt="image-20241028161146438"><p><strong>Whatever：无论哪种项目构建工具，都有自身的优势和劣势，所以选择一款最适合自己的就是最好的。</strong></p><h3 id="Gradle-安装"><a href="#Gradle-安装" class="headerlink" title="Gradle 安装"></a>Gradle 安装</h3><h4 id="Gradle-安装说明"><a href="#Gradle-安装说明" class="headerlink" title="Gradle 安装说明"></a>Gradle 安装说明</h4><blockquote><p>Gradle官网：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://gradle.org/">https://gradle.org/</a></p><p>Gradle官方下载安装教程页面：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://gradle.org/install/">https://gradle.org/install/</a></p><p>Gradle官方用户手册：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.gradle.org/current/userguide/userguide.html">https://docs.gradle.org/current/userguide/userguide.html</a></p></blockquote><p>SpringBoot 官方文档明确指出，目前SpringBoot 的 Gradle 插件需要gradle6.8 版本及以上，所以我们这里选择 7.x 版本。</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028161306370.png" class="" alt="image-20241028161306370"><p>其中SpringBoot 与Gradle 存在版本兼容问题，Gradle 与Idea 也存在兼容问题，所以考虑到 java 程序员会使用SpringBoot，所以要选择 6.8 版本及高于 6.8 版本的Gradle，那么相应的idea 版本也要升级，不能太老哦。</p><p><strong>具体参考文档：</strong><a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.spring.io/spring-boot/docs/2.5.0/gradle-plugin/reference/htmlsingle/#getting-started">https://docs.spring.io/spring-boot/docs/2.5.0/gradle-plugin/reference/htmlsingle/#getting-started</a></p><h4 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h4><p>要求Jdk 为 1.8 或者 1.8 版本以上。</p><h4 id="下载并解压到指定目录"><a href="#下载并解压到指定目录" class="headerlink" title="下载并解压到指定目录"></a>下载并解压到指定目录</h4><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028161339729.png" class="" alt="image-20241028161339729"><p><strong>解压到指定目录：</strong> D:\software\gradle-7.4.1</p><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><blockquote><p>在win10及更高版本中，一般按下<code>win+s</code>搜索<code>环境变量</code>即可快速找到设置</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028161409485.png" class="" alt="image-20241028161409485"></blockquote> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028161420962.png" class="" alt="image-20241028161420962"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028161430974.png" class="" alt="image-20241028161430974"><p><strong>特别注意<strong><strong>：这里我们接着再配置一个</strong></strong>GRADLE_USER_HOME</strong> <strong>环境变量：</strong></p><p><strong>GRADLE_USER_HOME 相当于配置Gradle 本地仓库位置和 Gradle Wrapper 缓存目录。</strong></p><blockquote><p>Gradle本地仓库可以和Maven本地仓库目录一致</p></blockquote><h4 id="检测是否安装成功"><a href="#检测是否安装成功" class="headerlink" title="检测是否安装成功"></a>检测是否安装成功</h4><p><strong>gradle -v 或者 gradle –version： 通过gradle -v或者 gradle –version检测是否安装成功</strong></p><p>Gradle 7.4安装成功的提示文本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\yooyi&gt;gradle -v</span><br><span class="line"></span><br><span class="line">Welcome to Gradle 7.4!</span><br><span class="line"></span><br><span class="line">Here are the highlights of this release:</span><br><span class="line">- Aggregated <span class="built_in">test</span> and JaCoCo reports</span><br><span class="line">- Marking additional <span class="built_in">test</span> <span class="built_in">source</span> directories as tests <span class="keyword">in</span> IntelliJ</span><br><span class="line">- Support <span class="keyword">for</span> Adoptium JDKs <span class="keyword">in</span> Java toolchains</span><br><span class="line"></span><br><span class="line">For more details see https://docs.gradle.org/7.4/release-notes.html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Gradle 7.4</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Build time:   2022-02-08 09:58:38 UTC</span><br><span class="line">Revision:     f0d9291c04b90b59445041eaa75b2ee744162586</span><br><span class="line"></span><br><span class="line">Kotlin:       1.5.31</span><br><span class="line">Groovy:       3.0.9</span><br><span class="line">Ant:          Apache Ant(TM) version 1.10.11 compiled on July 10 2021</span><br><span class="line">JVM:          1.8.0_202 (Oracle Corporation 25.202-b08)</span><br><span class="line">OS:           Windows 10 10.0 amd64</span><br></pre></td></tr></table></figure><h3 id="Gradle-项目目录结构"><a href="#Gradle-项目目录结构" class="headerlink" title="Gradle 项目目录结构"></a>Gradle 项目目录结构</h3><p>Gradle 项目<strong>默认目录结构和Maven 项目的目录结构一致</strong>，都是基于<strong>约定大于配置</strong>【Convention Over Configuration】。其完整项目目录结构如下所示：</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028161538093.png" class="" alt="image-20241028161538093"><blockquote><p><strong>Tips</strong>：</p><ol><li>只有war工程才有webapp目录，对于普通的jar工程并没有webapp目录</li><li>gradlew与gradlew.bat执行的指定wrapper版本中的gradle指令，不是本地安装的gradle指令哦。</li></ol></blockquote><h3 id="Gradle-创建第一个项目"><a href="#Gradle-创建第一个项目" class="headerlink" title="Gradle 创建第一个项目"></a>Gradle 创建第一个项目</h3><p><strong>借助于 spring 脚手架创建gradle 第一个项目</strong>：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://start.spring.io/">https://start.spring.io/</a></p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028161616843.png" class="" alt="image-20241028161616843"><p>查看生成的gradle 项目目录结构如下所示：</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028161634270.png" class="" alt="image-20241028161634270"><p>与上图对比会发现：总体的目录结构与上图说明的是一致的。</p><h3 id="Gradle-中的常用指令"><a href="#Gradle-中的常用指令" class="headerlink" title="Gradle 中的常用指令"></a>Gradle 中的常用指令</h3><p>Gradle 常用命令说明：</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028161654489.png" class="" alt="image-20241028161654489"><p><strong>需要注意的是：gradle 的指令要在含有build.gradle 的目录执行。</strong></p><h3 id="修改maven-下载源"><a href="#修改maven-下载源" class="headerlink" title="修改maven 下载源"></a>修改maven 下载源</h3><p>Gradle 自带的Maven 源地址是国外的，该Maven 源在国内的访问速度是很慢的，除非使用了特别的手段。一般情况下，我们建议使用国内的第三方开放的Maven 源或企业内部自建Maven 源。</p><p><strong>认识init.d 文件夹</strong></p><p>我们可以在gradle 的init.d 目录下创建以.gradle 结尾的文件，.gradle 文件可以实现在build 开始之前执行，所以你可以在</p><p>这个文件配置一些你想预先加载的操作。</p><p><strong>在init.d 文件夹创建init.gradle 文件</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenLocal()</span><br><span class="line">        maven &#123; name <span class="string">&quot;Alibaba&quot;</span> ; url <span class="string">&quot;https://maven.aliyun.com/repository/public&quot;</span> &#125; </span><br><span class="line">        maven &#123; name <span class="string">&quot;Bstek&quot;</span> ; url <span class="string">&quot;https://nexus.bsdn.org/content/groups/public/&quot;</span> &#125; </span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    buildscript &#123;</span><br><span class="line">        repositories &#123;</span><br><span class="line">            maven &#123; name <span class="string">&quot;Alibaba&quot;</span> ; url <span class="string">&#x27;https://maven.aliyun.com/repository/public&#x27;</span> &#125; </span><br><span class="line">            maven &#123; name <span class="string">&quot;Bstek&quot;</span> ; url <span class="string">&#x27;https://nexus.bsdn.org/content/groups/public/&#x27;</span> &#125; </span><br><span class="line">            maven &#123; name <span class="string">&quot;M2&quot;</span> ; url <span class="string">&#x27;https://plugins.gradle.org/m2/&#x27;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拓展 1</strong>：启用init.gradle 文件的方法有：</p><p>1在命令行指定文件，例如：gradle –init-script yourdir&#x2F;init.gradle -q taskName。你可以多次输入此命令来指定多个init文件2.把init.gradle文件放到 USER_HOME&#x2F;.gradle&#x2F; 目录下</p><ol><li>把以.gradle结尾的文件放到 USER_HOME&#x2F;.gradle&#x2F;init.d&#x2F; 目录下</li><li>把以.gradle结尾的文件放到 GRADLE_HOME&#x2F;init.d&#x2F; 目录下</li></ol><p>如果存在上面的4种方式的2种以上，gradle会按上面的1-4序号依次执行这些文件，如果给定目录下存在多个init脚本，会按拼音a-z顺序执行这些脚本，每个init脚本都存在一个对应的gradle实例，你在这个文件中调用的所有方法和属性，都会委托给这个gradle实例，每个init脚本都实现了Script接口。</p><p><strong>拓展</strong> 2：仓库地址说明</p><p>mavenLocal()： 指定使用maven本地仓库，而本地仓库在配置maven时settings文件指定的仓库位置。如E:&#x2F;repository，gradle 查找jar包顺序如下：USER_HOME&#x2F;.m2&#x2F;settings.xml &gt;&gt; M2_HOME&#x2F;conf&#x2F;settings.xml &gt;&gt; USER_HOME&#x2F;.m2&#x2F;repository</p><p>maven { url 地址}：指定maven仓库，一般用私有仓库地址或其它的第三方库【比如阿里镜像仓库地址】。</p><p>mavenCentral()：这是Maven的中央仓库，无需配置，直接声明就可以使用。</p><p>jcenter()：JCenter中央仓库，实际也是是用的maven搭建的，但相比Maven仓库更友好，通过CDN分发，并且支持https访问，在新版本中已经废弃了，替换为了mavenCentral()。</p><p>总之， gradle可以通过指定仓库地址为本地maven仓库地址和远程仓库地址相结合的方式，避免每次都会去远程仓库下载依赖库。</p><p>这种方式也有一定的问题，如果本地maven仓库有这个依赖，就会从直接加载本地依赖，如果本地仓库没有该依赖，那么还是会从远程下载。</p><p>但是下载的jar不是存储在本地maven仓库中，而是放在自己的缓存目录中，默认在USER_HOME&#x2F;.gradle&#x2F;caches目录，当然如果我们配置过GRADLE_USER_HOME环境变量，则会放在GRADLE_USER_HOME&#x2F;caches目录，那么可不可以将gradle caches指向maven repository。我们说这是不行的，caches下载文件不是按照maven仓库中存放的方式。</p><p><strong>拓展</strong> 3：阿里云仓库地址请参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.aliyun.com/mvn/guide">https://developer.aliyun.com/mvn/guide</a></p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028162044267.png" class="" alt="image-20241028162044267"><p>在gradle 中的使用说明：</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028162056882.png" class="" alt="image-20241028162056882"><h3 id="Wrapper-包装器"><a href="#Wrapper-包装器" class="headerlink" title="Wrapper 包装器"></a>Wrapper 包装器</h3><p>Gradle Wrapper 实际上就是对 Gradle 的一层包装，用于解决实际开发中可能会遇到的不同的项目需要不同版本的 Gradle</p><p>问题。例如：把自己的代码共享给其他人使用，可能出现如下情况：</p><ol><li>对方电脑没有安装 gradle</li><li>对方电脑安装过 gradle，但是版本太旧了</li></ol><p>这时候，我们就可以考虑使用 Gradle Wrapper 了。这也是官方建议使用 Gradle Wrapper 的原因。实际上有了 Gradle Wrapper 之后，我们本地是可以不配置 Gradle 的,下载Gradle 项目后，使用 gradle 项目自带的wrapper 操作也是可以的。</p><p>那如何使用Gradle Wrapper 呢？</p><p>项目中的gradlew、gradlew.cmd脚本用的就是wrapper中规定的gradle版本。参见源码</p><p>而我们上面提到的gradle指令用的是本地gradle,所以gradle指令和gradlew指令所使用的gradle版本<strong>有可能是不一样的</strong>。</p><p>gradlew、gradlew.cmd的使用方式与gradle使用方式完全一致，只不过把gradle指令换成了gradlew指令。</p><p>当然,我们也可在终端执行 gradlew 指令时，指定指定一些参数,来控制 Wrapper 的生成，比如依赖的版本等，如下：</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028162145385.png" class="" alt="image-20241028162145385"><p>具体操作如下所示 ：</p><p>gradle wrapper –gradle-version&#x3D;4.4：升级wrapper版本号,只是修改gradle.properties中wrapper版本，未实际下载</p><p>gradle wrapper –gradle-version 5.2.1 –distribution-type all ：关联源码用</p><h4 id="GradleWrapper-的执行流程："><a href="#GradleWrapper-的执行流程：" class="headerlink" title="GradleWrapper 的执行流程："></a>GradleWrapper 的执行流程：</h4><ol><li>当我们第一次执行 .&#x2F;gradlew build 命令的时候，gradlew 会读取 gradle-wrapper.properties 文件的配置信息</li><li>准确的将指定版本的 gradle 下载并解压到指定的位置(GRADLE_USER_HOME目录下的wrapper&#x2F;dists目录中)</li><li>并构建本地缓存(GRADLE_USER_HOME目录下的caches目录中),下载再使用相同版本的gradle就不用下载了4.之后执行的 .&#x2F;gradlew 所有命令都是使用指定的 gradle 版本。<strong>如下图所示</strong>：</li></ol> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028162200905.png" class="" alt="image-20241028162200905"><p>gradle-wrapper.properties 文件解读：</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028162212556.png" class="" alt="image-20241028162212556"><blockquote><p>注意：前面提到的 <strong>GRALE_USER_HOME 环境变量</strong>用于这里的Gradle Wrapper 下载的特定版本的gradle 存储目录。如果我们<strong>没有配置过GRALE_USER_HOME 环境变量,默认在当前用户家目录下的.gradle 文件夹中。</strong></p></blockquote><p>那什么时候选择使用 gradle wrapper、什么时候选择使用本地gradle?</p><p>下载别人的项目或者使用操作以前自己写的不同版本的gradle项目时：用Gradle wrapper,也即：gradlew</p><p>什么时候使用本地gradle?新建一个项目时： 使用gradle指令即可。</p><h2 id="Gradle-与-Idea-整合"><a href="#Gradle-与-Idea-整合" class="headerlink" title="Gradle 与 Idea 整合"></a>Gradle 与 Idea 整合</h2><h3 id="Groovy-简介"><a href="#Groovy-简介" class="headerlink" title="Groovy 简介"></a>Groovy 简介</h3><p>在某种程度上，Groovy 可以被视为Java 的一种脚本化改良版,Groovy 也是运行在 JVM 上，它可以很好地与 Java 代码及其相关库进行交互操作。它是一种成熟的面向对象编程语言，既可以面向对象编程，又可以用作纯粹的脚本语言。大多数有效的 Java 代码也可以转换为有效的 Groovy 代码，Groovy 和 Java 语言的主要区别是：完成同样的任务所需的Groovy 代码比 Java 代码更少。其特点为：</p><ul><li>功能强大，例如提供了动态类型转换、<strong>闭包</strong>和元编程（metaprogramming）支持</li><li>支持函数式编程，不需要main 函数</li><li>默认导入常用的包</li><li>类不支持 default 作用域,且默认作用域为public。</li><li>Groovy 中基本类型也是对象，可以直接调用对象的方法。</li><li>支持DSL（Domain Specific Languages 领域特定语言）和其它简洁的语法，让代码变得易于阅读和维护。</li><li>Groovy 是基于Java 语言的，所以完全兼容Java 语法,所以对于java 程序员学习成本较低。详细了解请参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.groovy-lang.org/documentation.html">http://www.groovy-lang.org/documentation.html</a></li></ul> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028162325568.png" class="" alt="image-20241028162325568"><h3 id="Groovy-安装-非必须"><a href="#Groovy-安装-非必须" class="headerlink" title="Groovy 安装[非必须]"></a>Groovy 安装[非必须]</h3><p>下载地址： <a target="_blank" rel="noopener external nofollow noreferrer" href="https://groovy.apache.org/download.html">https://groovy.apache.org/download.html</a></p><p>解压配置环境变量：</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028162539783.png" class="" alt="image-20241028162539783"><h3 id="创建-Groovy-项目"><a href="#创建-Groovy-项目" class="headerlink" title="创建 Groovy 项目"></a>创建 Groovy 项目</h3><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028162623698.png" class="" alt="image-20241028162623698"><h3 id="Groovy-基本语法"><a href="#Groovy-基本语法" class="headerlink" title="Groovy 基本语法"></a>Groovy 基本语法</h3><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028162643015.png" class="" alt="image-20241028162643015"><p>类型转换：当需要时,类型之间会自动发生类型转换： 字符串（String）、基本类型(如int) 和类型的包装类 (如Integer)</p><p>类说明：如果在一个groovy 文件中没有任何类定义，它将被当做 script 来处理，也就意味着这个文件将被透明的转换为一个 Script 类型的类，这个自动转换得到的类将使用原始的 groovy 文件名作为类的名字。groovy 文件的内容被打包进run 方法，另外在新产生的类中被加入一个main 方法以进行外部执行该脚本。</p><h4 id="案例-1：基本注意点"><a href="#案例-1：基本注意点" class="headerlink" title="案例 1：基本注意点"></a>案例 1：基本注意点</h4><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028162731964.png" class="" alt="image-20241028162731964"><p>提示：方法调用时,在不含有歧义的地方可以省略方法调用时的括号。这类似于使用${变量名}时，括号在不引起歧义的地方可以省略是一样的：如</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> num1=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">def</span> num2= <span class="number">2</span>;</span><br><span class="line">println <span class="string">&quot;$num1 + $num2 = $&#123;num1+num2&#125;&quot;</span></span><br></pre></td></tr></table></figure><h4 id="案例-2：引号说明"><a href="#案例-2：引号说明" class="headerlink" title="案例 2：引号说明"></a>案例 2：引号说明</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> num1=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">def</span> num2=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">def</span> str1=<span class="string">&quot;1d&quot;</span>; <span class="comment">//双引号</span></span><br><span class="line"><span class="keyword">def</span> str2=<span class="string">&#x27;dsd&#x27;</span>; <span class="comment">//单引号</span></span><br><span class="line"><span class="comment">//双引号运算能力,单引号用于常量字符串,三引号相当于模板字符串，可以支持换行</span></span><br><span class="line">println <span class="string">&quot;$num1 + $num2 = $&#123;num1 + num2&#125;&quot;</span></span><br><span class="line"><span class="comment">//基本数据类型也可以作为对象使用,可以调用对象的方法</span></span><br><span class="line">println(num1.getClass().toString()) </span><br><span class="line">println(str1.getClass().toString()) </span><br><span class="line">println(str2.getClass().toString())</span><br></pre></td></tr></table></figure><h4 id="案例-3：三个语句结构"><a href="#案例-3：三个语句结构" class="headerlink" title="案例 3：三个语句结构"></a>案例 3：三个语句结构</h4><p>Groovy 支持顺序结构从上向下依次解析、分支结构(if..else、if..else if ..else..、switch..case、for、while、do..while)</p><p>具体参考官网：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.groovy-lang.org/semantics.html">http://www.groovy-lang.org/semantics.html#_conditional_structures</a></p><h4 id="案例-4：类型及权限修饰符"><a href="#案例-4：类型及权限修饰符" class="headerlink" title="案例 4：类型及权限修饰符"></a>案例 4：类型及权限修饰符</h4><p>Groovy 中的类型有：</p><ol><li>原生数据类型及包装类</li></ol> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028162904219.png" class="" alt="image-20241028162904219"><ol start="2"><li><p>类、内部类、抽象类、接口</p></li><li><p>注解</p></li><li><p>Trait： 可以看成是带有方法实现的接口</p></li></ol><p><strong>权限修饰符</strong>： public、protected、private</p><p>拓展：Groovy 类与 Java 类之间的主要区别是：</p><ol><li>没有可见性修饰符的类或方法自动是公共的(可以使用一个特殊的注释来实现包的私有可见性)。</li><li>没有可见性修饰符的字段将自动转换为属性，不需要显式的 getter 和 setter 方法。</li><li>如果属性声明为 final，则不会生成 setter。</li><li>一个源文件可能包含一个或多个类(但是如果一个文件不包含类定义的代码，则将其视为脚本)。脚本只是具有一些特殊约定的类,它们的名称与源文件相同(所以不要在脚本中包含与脚本源文件名相同的类定义)。</li></ol><p><strong>提 示 ：</strong> 有 关 Groovy 中 各 种 各 样 的 数 据 类 型 和 权 限 修 饰 符 及 Goovy 与 Java 区 别 请 参 考 ：</p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.groovy-lang.org/objectorientation.html">http://www.groovy-lang.org/objectorientation.html#_modifiers_on_a_property</a></p><h4 id="案例-5：集合操作"><a href="#案例-5：集合操作" class="headerlink" title="案例 5：集合操作"></a>案例 5：集合操作</h4><p>Groovy 支持List、Map 集合操作，并且拓展了 Java 中的API,具体参考如下方法：</p><p><code>List</code>：</p><ul><li><code>add()</code>：添加某个元素plus()：添加某个list 集合</li><li><code>remove()</code>：删除指定下标的元素removeElement()：删除某个指定的元素removeAll()： 移除某个集合中的元素</li><li><code>pop()</code>：弹出list 集合中最后一个元素putAt()：修改指定下标的元素</li><li><code>each()</code>：遍历</li><li><code>size()</code>： 获取list 列表中元素的个数</li><li><code>contains()</code>： 判断列表中是否包含指定的值，则返回 true</li></ul><p><code>Map</code>：</p><ul><li><code>put()</code>：向map 中添加元素</li><li><code>remove()</code>：根据某个键做移除，或者移除某个键值对</li><li><code>+、-</code>：支持 map 集合的加减操作</li><li><code>each()</code>：遍历map 集合</li></ul><p>请参考官网：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.groovy-lang.org/syntax.html">http://www.groovy-lang.org/syntax.html#_number_type_suffixes</a></p><p><strong>提示</strong>：可以把不同的基本类型添加到同一集合中。</p><h4 id="案例-6：类导入"><a href="#案例-6：类导入" class="headerlink" title="案例 6：类导入"></a>案例 6：类导入</h4><p>Groovy 遵循 Java 允许 import 语句解析类引用的概念。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> groovy.xml.MarkupBuilder </span><br><span class="line"><span class="keyword">def</span> xml = <span class="keyword">new</span> MarkupBuilder() </span><br><span class="line"><span class="keyword">assert</span> xml != <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>Groovy 语言默认提供的导入</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.* </span><br><span class="line"><span class="keyword">import</span> java.util.* </span><br><span class="line"><span class="keyword">import</span> java.io.* </span><br><span class="line"><span class="keyword">import</span> java.net.* </span><br><span class="line"><span class="keyword">import</span> groovy.lang.* </span><br><span class="line"><span class="keyword">import</span> groovy.util.*</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal</span><br></pre></td></tr></table></figure><p>这样做是因为这些包中的类最常用。通过导入这些样板代码减少了。</p><p>参考官网地址：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.groovy-lang.org/structure.html#_imports">http://www.groovy-lang.org/structure.html#_imports</a></p><h4 id="案例-7：异常处理"><a href="#案例-7：异常处理" class="headerlink" title="案例 7：异常处理"></a>案例 7：异常处理</h4><p>Groovy 中的异常处理和 java 中的异常处理是一样的。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> z </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">def</span> i = <span class="number">7</span>, j = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">def</span> k = i / j </span><br><span class="line">        <span class="keyword">assert</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        z = <span class="string">&#x27;reached here&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> ( e ) &#123;</span><br><span class="line">    <span class="keyword">assert</span> e <span class="keyword">in</span> ArithmeticException </span><br><span class="line">    <span class="keyword">assert</span> z == <span class="string">&#x27;reached here&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考官网地址： <a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.groovy-lang.org/semantics.html#_try_catch_finally">http://www.groovy-lang.org/semantics.html#_try_catch_finally</a></p><h4 id="案例-8：闭包"><a href="#案例-8：闭包" class="headerlink" title="案例 8：闭包"></a>案例 8：闭包</h4><p>闭包：Groovy 中的闭包是一个开放的、匿名的代码块，它可以接受参数、也可以有返回值。闭包可以引用其周围作用域中声明的变量。</p><p>语法：<code>&#123; [closureParameters -&gt; ] statements &#125;</code></p><p>其中<code>[ closureParameters-&gt; ]</code>是一个可选的逗号分隔的参数列表,参数后面是 Groovy 语句。参数类似于方法参数列表， 这些参数可以是类型化的,也可以是非类型化的。当指定参数列表时，需要使用<code>-&gt;</code> 字符，用于将参数与闭包体分离。</p><p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.groovy-lang.org/closures.html">http://www.groovy-lang.org/closures.html</a></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//闭包体完成变量自增操作</span></span><br><span class="line">&#123; item++ &#125;</span><br><span class="line"><span class="comment">//闭包使用 空参数列表 明确规定这是无参的</span></span><br><span class="line">&#123; -&gt; item++ &#125;</span><br><span class="line"><span class="comment">//闭包中有一个默认的参数[it]，写不写无所谓</span></span><br><span class="line">&#123; println it &#125;</span><br><span class="line">&#123; it -&gt; println it &#125;</span><br><span class="line"><span class="comment">//如果不想使用默认的闭包参数it,那需要显示自定义参数的名称</span></span><br><span class="line">&#123; name -&gt; println name &#125;</span><br><span class="line"><span class="comment">//闭包也可以接受多个参数</span></span><br><span class="line">&#123; String x, <span class="type">int</span> y -&gt;</span><br><span class="line">    println <span class="string">&quot;hey $&#123;x&#125; the value is $&#123;y&#125;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//闭包参数也可是一个对象</span></span><br><span class="line">&#123; reader -&gt;</span><br><span class="line">    <span class="keyword">def</span> line = reader.readLine() </span><br><span class="line">    line.trim()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包调用方式： 闭包是 <code>groovy.lang.Closure</code> 的实例。它可以像任何其他变量一样分配给一个变量或字段。</p><p>闭包对象(参数)</p><p>闭包对象.call(参数)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def isOdd = &#123; int i -&gt; i%2 != 0 &#125; </span><br><span class="line">assert isOdd(3) == true</span><br><span class="line">assert isOdd.call(2) == false</span><br><span class="line"></span><br><span class="line">def isEven = &#123; it%2 == 0 &#125; </span><br><span class="line">assert isEven(3) == false </span><br><span class="line">assert isEven.call(2) == true</span><br></pre></td></tr></table></figure><p>特殊说明： 可以把闭包当作一个对象，作为参数传递给方法使用</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参闭包</span></span><br><span class="line"><span class="keyword">def</span> run(Closure closure)&#123; </span><br><span class="line">    println(<span class="string">&quot;run start...&quot;</span>)</span><br><span class="line">    closure() println(<span class="string">&quot;run end...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &#123;</span><br><span class="line">    println <span class="string">&quot;running......&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参闭包</span></span><br><span class="line"><span class="keyword">def</span> caculate(Closure closure)&#123;</span><br><span class="line">    <span class="keyword">def</span> num1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">def</span> num2=<span class="number">3</span>; </span><br><span class="line">    println(<span class="string">&quot;caculate start...&quot;</span>)</span><br><span class="line">    closure(num1,num2) </span><br><span class="line">    println(<span class="string">&quot;caculate end...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">caculate &#123;x,y -&gt; println <span class="string">&quot;计算结果为：$x+$y=$&#123;x+y&#125;&quot;</span>&#125; <span class="comment">//在build.gradle文件中我们见到的很多都是闭包格式的。</span></span><br></pre></td></tr></table></figure><h3 id="在-idea-中创建普通java-工程"><a href="#在-idea-中创建普通java-工程" class="headerlink" title="在 idea 中创建普通java 工程"></a>在 idea 中创建普通java 工程</h3><p>具体整合：</p><p>第一步：创建由Gradle 管理的项目</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028163517667.png" class="" alt="image-20241028163517667"><p>第二步：修改当前项目使用本地安装的gradle：可以加快下载项目依赖jar 包的速度【配置了私服地址】。</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028163529330.png" class="" alt="image-20241028163529330"><p><strong>特别提示 1：</strong>使得在Terminal 中执行以gradlew 开头命令和操作图形化的IDEA 使用Gradle 版本<strong>不一定是同一个版本</strong>哦。</p><p>1.Terminal中以gradlew开头指令用的是Wrapper规定的gradle版本,wrapper中规定版本默认和idea插件中规定的版本一致。</p><p>2.而图形化的IDEA使用Gradle是本地安装的哦。</p><p><strong>特别提示 2：</strong>目前只能是在创建项目时重新设置本地gradle,创建新项目需要重新去改。</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028163541672.png" class="" alt="image-20241028163541672"><p><strong>特别提示3：</strong>当 我 们 在 gradle.build 文 件 添 加 依 赖 之 后 ， 这 些 依 赖 会 在 下 载 到<code>GRADLE_USER_HOME/caches/modules-2/files-2.1</code> 目录下面,所以这里的 <code>GRADLE_USER_HOME</code> 相当于 Gradle 的本地仓库,当然也可以如下方式找到jar 包位置。</p><blockquote><ul><li>此处可以设置Gradle user home，如需更改idea新项目的设置可以通过<code>文件</code>——<code>新项目的设置更改</code></li></ul> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028163608443.png" class="" alt="image-20241028163608443"><ul><li>调整使用的Gradle位置，可以加速Gradle构建</li></ul> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241028163622586.png" class="" alt="image-20241028163622586"></blockquote><h3 id="在-idea-中创建-web-工程"><a href="#在-idea-中创建-web-工程" class="headerlink" title="在 idea 中创建 web 工程"></a>在 idea 中创建 web 工程</h3><p>在idea 新版本的创建项目中,无法自己选择创建项目是普通 java 工程还是 web 工程了【IDEA 旧版本是可以的】，所以我们如果想创建 web 工程，只需要自己在 <code>src/main/</code>目录下添加<code>webapp/WEB-INF/web.xml</code> 及页面即可。</p><p>代码演示：参考视频+资料</p><p>接下来在我们对gradle 的其它知识点讲解之前我们先提一下在gradle 文件中需要用到的Groovy 语法。</p><h3 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h3><p>当我们将一个 java 项目打成war 包之后，就需要部署到服务器运行，这里有两种方式：</p><ul><li>我们将项目打成 war 包，部署到<strong>本地tomcat</strong> 运行：演示</li><li>使用 <strong>Gretty 插件</strong>中<strong>内置服务器</strong>方式部署项目： 演示</li></ul><h4 id="Gretty-部署项目"><a href="#Gretty-部署项目" class="headerlink" title="Gretty 部署项目"></a>Gretty 部署项目</h4><p>Gretty 是一个功能丰富的 gradle 插件，用于在嵌入的 servlet 容器上运行 web 应用程序,让项目开发和部署更加简单。目前Gretty 插件已经作为 gradle 的核心库使用了,Gretty 其核心功能为：</p><ol><li>底层支持 jetty,tomcat 等Servlet 容器</li><li>支持项目热部署、HTTPS、调试</li></ol><p>Gretty 官网地址：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://akhikhl.github.io/gretty-doc/index.html">http://akhikhl.github.io/gretty-doc/index.html</a></p><h4 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h4><p>第一步：引入 Gretty 插件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;war&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;org.gretty&#x27;</span> version <span class="string">&#x27;2.2.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：指定maven 仓库</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    <span class="comment">//指定jcenter仓库，一定要放在前面</span></span><br><span class="line">    jcenter() </span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：针对Gretty 插件的设置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gretty &#123;</span><br><span class="line">    httpPort = <span class="number">8888</span></span><br><span class="line">    contextPath = <span class="string">&quot;/web&quot;</span></span><br><span class="line">    debugPort = <span class="number">5005</span>	<span class="comment">// default </span></span><br><span class="line">    debugSuspend = <span class="literal">true</span> <span class="comment">// default </span></span><br><span class="line">    httpsEnabled = <span class="literal">true</span></span><br><span class="line">    managedClassReload=<span class="literal">true</span> <span class="comment">// 修改了类之后重新加载</span></span><br><span class="line">    <span class="comment">//servletContainer = &#x27;tomcat8&#x27; //如果不指定默认的servlet容器，支持tomcat7/8，默认是使用的是Jetty服务器</span></span><br><span class="line">    httpsPort = <span class="number">4431</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步：执行Gretty 插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle appRun</span><br></pre></td></tr></table></figure><p>如 果 大 家 想 进 一 步 了 解 的 属 性 配 置 , 比 如 Gretty 热 部 署 等 设 置 ， 欢 迎 参 考 其 官 方 文 档</p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://akhikhl.github.io/gretty-doc/Gretty-configuration.html%E3%80%82">http://akhikhl.github.io/gretty-doc/Gretty-configuration.html。</a></p><h3 id="Gradle-对测试支持"><a href="#Gradle-对测试支持" class="headerlink" title="Gradle 对测试支持"></a>Gradle 对测试支持</h3><p>测试任务自动检测并执行测试源集中的所有单元测试。测试执行完成后会生成一个报告。支持JUnit 和 TestNG 测试。</p><h4 id="默认测试目录及标准输出"><a href="#默认测试目录及标准输出" class="headerlink" title="默认测试目录及标准输出"></a>默认测试目录及标准输出</h4><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241101152255221.png" class="" alt="image-20241101152255221"><h4 id="Junit-使用"><a href="#Junit-使用" class="headerlink" title="Junit 使用"></a>Junit 使用</h4><p>Gradle 对于Junit4.x 支持</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="attr">group:</span> <span class="string">&#x27;junit&#x27;</span> ,<span class="attr">name:</span> <span class="string">&#x27;junit&#x27;</span>, <span class="attr">version:</span> <span class="string">&#x27;4.12&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">test &#123;</span><br><span class="line">    useJUnit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Gradle 对于Junit5.x 版本支持</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="string">&#x27;org.junit.jupiter:junit-jupiter-api:5.8.1&#x27;</span> </span><br><span class="line">    testRuntimeOnly <span class="string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.8.1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：无论是 Junt4.x 版本还是Junit5.x 版本，我们只需在 build.gradle 目录下执行gradle test 指令，gradle 就会帮我们执行所有的加了@Test 注解的测试，并生成测试报告。</p><blockquote><p><strong>提示：</strong></p><p>测试报告在项目<code>build-reports</code>目录下，浏览器打开index.html即可查看</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241101152348846.png" class="" alt="image-20241101152348846"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241101152358028.png" class="" alt="image-20241101152358028"></blockquote><h4 id="包含和排除特定测试"><a href="#包含和排除特定测试" class="headerlink" title="包含和排除特定测试"></a>包含和排除特定测试</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test &#123;</span><br><span class="line">    enabled <span class="literal">true</span> </span><br><span class="line">    useJUnit() </span><br><span class="line">    include <span class="string">&#x27;com/**&#x27;</span></span><br><span class="line">    exclude <span class="string">&#x27;com/abc/**&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gradle 在junit 中的批量测试,可以设置包含或者排除某些特定测试。</p><h2 id="Gradle-进阶说明"><a href="#Gradle-进阶说明" class="headerlink" title="Gradle 进阶说明"></a>Gradle 进阶说明</h2><p>为了让大家快速的入门gradle，本章将从整体构建脚本的角度介绍：</p><ul><li>什么是 setting 文件,它有什么作用;</li><li>说明什么是build 文件,它又有什么作用</li><li>我们可以创建多少个 build</li><li>project 和task,他们有什么作用;又是什么关系,如何配置</li><li>项目的生命周期</li><li>项目发布</li><li>使用Gradle 创建SpringBoot 项目等</li></ul><h3 id="项目的生命周期"><a href="#项目的生命周期" class="headerlink" title="项目的生命周期"></a>项目的生命周期</h3><p>Gradle 项目的生命周期分为三大阶段： Initialization -&gt; Configuration -&gt; Execution. 每个阶段都有自己的职责,具体如下图所示：</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241101152520407.png" class="" alt="image-20241101152520407"><ul><li><p><strong>Initialization 阶段</strong>主要目的是初始化构建, 它又分为两个子过程,一个是执行 Init Script,另一个是执行 Setting Script。</p></li><li><p>init.gradle 文件会在每个项目 build 之前被调用，用于做一些初始化的操作，它主要有如下作用：</p><ul><li><p>配置内部的仓库信息（如公司的 maven 仓库信息）；</p></li><li><p>配置一些全局属性；</p></li><li><p>配置用户名及密码信息（如公司仓库的用户名和密码信息）。</p></li></ul></li><li><p>Setting Script 则更重要, 它初始化了一次构建所参与的所有模块。</p></li><li><p><strong>Configuration 阶段</strong>：这个阶段开始加载项目中所有模块的 Build Script。所谓 “加载” 就是执行 build.gradle 中的语句, 根据脚本代码创建对应的 task, 最终根据所有 task 生成由 <strong>Task 组成的有向无环图</strong>(Directed Acyclic Graphs)，如下：</p></li></ul> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241101152538460.png" class="" alt="image-20241101152538460"><p>从而构成如下<strong>有向无环树</strong>：</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241101152551001.png" class="" alt="image-20241101152551001"><ul><li><strong>Execution 阶段</strong>：这个阶段会根据上个阶段构建好的有向无环图，按着顺序执行 Task【Action 动作】。</li></ul><h3 id="settings-文件"><a href="#settings-文件" class="headerlink" title="settings 文件"></a>settings 文件</h3><p>首先对 settings 文件的几点说明：</p><ol><li><p>作用：主要是在项目初始化阶段确定一下引入哪些工程需要加入到项目构建中,为构建项目工程树做准备。</p></li><li><p>工程树：gradle 中有工程树的概念，类似于 maven 中的project 与module。</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241101152641744.png" class="" alt="image-20241101152641744"></li><li><p>内容：里面主要定义了当前 gradle 项目及子 project 的项目名称</p></li><li><p>位置：必须放在根工程目录下。</p></li><li><p>名字：为<code>settings.gradle</code> 文件，不能发生变化</p></li><li><p>对应实例：与 org.gradle.api.initialization.Settings 实例是一一对应的关系。每个项目只有一个settings 文件。</p></li><li><p>关注：作为开发者我们只需要关注该文件中的include 方法即可。使用相对路径【 : 】引入子工程。</p></li><li><p>一个子工程只有在setting 文件中配置了才会被 gradle 识别,这样在构建的时候才会被包含进去。案例如下所示：</p></li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根工程项目名</span></span><br><span class="line">rootProject.name = <span class="string">&#x27;root&#x27;</span></span><br><span class="line"><span class="comment">//包含的子工程名称</span></span><br><span class="line">include <span class="string">&#x27;subject01&#x27;</span> </span><br><span class="line">include <span class="string">&#x27;subject02&#x27;</span> </span><br><span class="line">include <span class="string">&#x27;subject03&#x27;</span></span><br><span class="line"><span class="comment">//包含的子工程下的子工程名称</span></span><br><span class="line">include <span class="string">&#x27;subject01:subproject011&#x27;</span> </span><br><span class="line">include <span class="string">&#x27;subject01:subproject012&#x27;</span></span><br></pre></td></tr></table></figure><p>项目名称中 <strong>“:” 代表项目的分隔符</strong>, 类似路径中的 “&#x2F;“. 如果<strong>以 “:” 开头则表示相对于 root project</strong> 。然后 Gradle 会为每个带有 build.gradle 脚本文件的工程构建一个与之对应的 Project 对象。</p><h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>项目实质上是 Task 对象的集合。一个 Task 表示一个逻辑上较为独立的执行过程，比如编译Java 源代码，拷贝文件， 打包Jar 文件，甚至可以是执行一个系统命令。另外，一个 Task 可以读取和设置Project 的Property 以完成特定的操作。</p><h4 id="任务入门"><a href="#任务入门" class="headerlink" title="任务入门"></a>任务入门</h4><p>可参考官方文档：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.gradle.org/current/userguide/tutorial_using_tasks.html">https://docs.gradle.org/current/userguide/tutorial_using_tasks.html</a></p><p>让我们来先看一个例子:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">task A &#123;</span><br><span class="line">    println <span class="string">&quot;root taskA&quot;</span> </span><br><span class="line">    doFirst()&#123;</span><br><span class="line">        println <span class="string">&quot;root taskA doFirst&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    doLast()&#123;</span><br><span class="line">        println <span class="string">&quot;root taskA doLast&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在文件所在的目录执行命令： gradle A。</p><p><strong>提示 1：</strong> task 的配置段是在配置阶段完成</p><p><strong>提示 2：</strong> task 的doFirst、doLast 方法是执行阶段完成，并且doFirst 在doLast 执行之前执行。</p><p><strong>提示 3：</strong>区分任务的配置段和任务的行为,任务的配置段在配置阶段执行,任务的行为在执行阶段执行</p><h4 id="任务的行为"><a href="#任务的行为" class="headerlink" title="任务的行为"></a>任务的行为</h4><p>案例如下：doFirst、doLast 两个方法可以在任务内部定义，也可以在任务外部定义</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> map=<span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line"><span class="comment">//action属性可以设置为闭包，设置task自身的行为</span></span><br><span class="line">map.put(<span class="string">&quot;action&quot;</span>,&#123;println <span class="string">&quot;taskD..&quot;</span>&#125;)</span><br><span class="line">task(map,<span class="string">&quot;a&quot;</span>)&#123;</span><br><span class="line">    description   <span class="string">&#x27;taskA description	&#x27;</span></span><br><span class="line">    group <span class="string">&quot;atguigu&quot;</span></span><br><span class="line">    <span class="comment">//在task内部定义doFirst、doLast行为</span></span><br><span class="line">    doFirst &#123;</span><br><span class="line">        <span class="keyword">def</span> name = <span class="string">&#x27;doFirst..&#x27;</span> </span><br><span class="line">        println name</span><br><span class="line">    &#125;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        <span class="keyword">def</span> name = <span class="string">&#x27;doLast..&#x27;</span> </span><br><span class="line">        println name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在task外部定义doFirst、doLast行为</span></span><br><span class="line">a.doFirst &#123;</span><br><span class="line">    println it.description</span><br><span class="line">&#125;</span><br><span class="line">a.doLast &#123;</span><br><span class="line">    println it.group</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：gradle a , 输出如下所示：</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241101152925186.png" class="" alt="image-20241101152925186"><p><strong>底层原理分析</strong>：无论是定义任务自身的 action，还是添加的doLast、doFirst 方法，其实底层都被放入到一个Action 的List 中了，最初这个 action List 是空的，当我们设置了 action【任务自身的行为】,它先将action 添加到列表中，此时列表中只有一个action,后续执行doFirst 的时候doFirst 在action 前面添加，执行 doLast 的时候doLast 在action 后面添加。</p><p>doFirst 永远添加在actions List 的第一位，保证添加的Action 在现有的 action List 元素的最前面；doLast 永远都是在action List 末尾添加，保证其添加的Action 在现有的action List 元素的最后面。</p><p>一个往前面添加,一个往后面添加，最后这个action List 就按顺序形成了doFirst、doSelf、doLast 三部分的 Actions,就达到 doFirst、doSelf、doLast 三部分的 Actions 顺序执行的目的。</p><p><strong>提示 1：</strong>其中&lt;&lt;代表doLast,在gradle5.x 版本之后就废弃,不能使用了,如下所示：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task hello &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">&#x27;Hello world!&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="任务的依赖方式"><a href="#任务的依赖方式" class="headerlink" title="任务的依赖方式"></a>任务的依赖方式</h4><p>Task 之间的依赖关系可以在以下几部分设置：</p><ol><li>参数依赖</li><li>内部依赖</li><li>外部依赖</li></ol><h5 id="方式一：参数方式依赖"><a href="#方式一：参数方式依赖" class="headerlink" title="方式一：参数方式依赖"></a>方式一：参数方式依赖</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">task A &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&quot;TaskA..&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task <span class="string">&#x27;B&#x27;</span> &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&quot;TaskB..&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数方式依赖: dependsOn后面用冒号</span></span><br><span class="line">task <span class="string">&#x27;C&#x27;</span>(<span class="attr">dependsOn:</span> [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&quot;TaskC..&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h5 id="方式二：内部依赖"><a href="#方式二：内部依赖" class="headerlink" title="方式二：内部依赖"></a>方式二：内部依赖</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数方式依赖</span></span><br><span class="line">task <span class="string">&#x27;C&#x27;</span> &#123;</span><br><span class="line">    <span class="comment">//内部依赖：dependsOn后面用 = 号</span></span><br><span class="line">    dependsOn= [A,B] </span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&quot;TaskC..&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试： gradle C</p><h5 id="方式三：外部依赖"><a href="#方式三：外部依赖" class="headerlink" title="方式三：外部依赖"></a>方式三：外部依赖</h5><p>&#x2F;&#x2F;外部依赖：可变参数,引号可加可不加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C.dependsOn(B,<span class="string">&#x27;A&#x27;</span>)</span><br></pre></td></tr></table></figure><p>当然：task 也支持跨项目依赖</p><p>在subproject01 工程的 build.gradle 文件中定义：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task A &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&quot;TaskA..&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在subproject02 工程的 build.gradle 文件中定义：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task B&#123;</span><br><span class="line">    dependsOn(<span class="string">&quot;:subproject01:A&quot;</span>) <span class="comment">//依赖根工程下的subject01中的任务A ：跨项目依赖。</span></span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&quot;TaskB..&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：gradle B ,控制台显示如下</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241101153217804.png" class="" alt="image-20241101153217804"><p>拓展 1：当一个 Task 依赖多个Task 的时候，被依赖的Task 之间如果没有依赖关系，那么它们的执行顺序是随机的,并无影响。</p><p>拓展 2：重复依赖的任务只会执行一次,比如：</p><p>A-&gt;B、C</p><p>B-&gt;C</p><p>任务A 依赖任务 B 和任务 C、任务 B 依赖C 任务。执行任务A 的时候，显然任务C 被重复依赖了，C 只会执行一次。</p><h4 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h4><p>任务执行语法：gradle [taskName…] [–option-name…]。</p><table><thead><tr><th>分类</th><th>解释</th></tr></thead><tbody><tr><td><strong>常见的任务（*）</strong></td><td><code>gradle build</code>： 构建项目：编译、测试、打包等操作<code>gradle run</code> ：运行一个服务,需要application 插件支持，并且指定了主启动类才能运行<code>gradle clean</code>： 请求当前项目的 build 目录<code>gradle init</code> ： 初始化 gradle 项目使用<code>gradle wrapper</code>：生成wrapper 文件夹的。gradle wrapper 升级wrapper 版本号：<code>gradle wrapper --gradle-version=4.4``gradle wrapper --gradle-version 5.2.1 --distribution-type all</code> ：关联源码用</td></tr><tr><td><strong>项目报告相关任务</strong></td><td><code>gradle projects</code> ： 列出所选项目及子项目列表，以层次结构的形式显示<code>gradle tasks</code>： 列出所选项目【当前 project,不包含父、子】的已分配给任务组的那些任务。<code>gradle tasks --all</code> ：列出所选项目的所有任务。<code>gradle tasks --group=&quot;build setup&quot;</code>：列出所选项目中指定分组中的任务。<code>gradle help --task someTask</code> ：显示某个任务的详细信息<code>gradle dependencies</code> ：查看整个项目的依赖信息，以依赖树的方式显示<code>gradle properties</code> 列出所选项目的属性列表</td></tr><tr><td>调试相关选项</td><td>-h,–help： 查看帮助信息-v, –version：打印 Gradle、 Groovy、 Ant、 JVM 和操作系统版本信息。-S, –full-stacktrace：打印出所有异常的完整(非常详细)堆栈跟踪信息。-s,–stacktrace： 打印出用户异常的堆栈跟踪(例如编译错误)。-Dorg.gradle.daemon.debug&#x3D;true： 调试 Gradle 守护进程。-Dorg.gradle.debug&#x3D;true：调试 Gradle 客户端(非 daemon)进程。-Dorg.gradle.debug.port&#x3D;(port number)：指定启用调试时要侦听的端口号。默认值为 5005。</td></tr><tr><td>性能选项：【<strong>备注</strong>： 在gradle.properties 中指定这些选项中的许多选项，因此不需要命令行标志】</td><td>–build-cache, –no-build-cache： 尝试重用先前版本的输出。默认关闭(off)。–max-workers： 设置 Gradle 可以使用的woker 数。默认值是处理器数。-parallel, –no-parallel： 并行执行项目。有关此选项的限制，请参阅并行项目执行。默认设置为关闭(off)</td></tr><tr><td>守护进程选项</td><td>–daemon, –no-daemon： 使用 Gradle 守护进程运行构建。默认是on–foreground：在前台进程中启动 Gradle 守护进程。-Dorg.gradle.daemon.idletimeout&#x3D;(number of milliseconds)：Gradle Daemon 将在这个空闲时间的毫秒数之后停止自己。默认值为 10800000(3 小时)。</td></tr><tr><td>日志选项</td><td>-Dorg.gradle.logging.level&#x3D;(quiet,warn,lifecycle,info,debug)：通过 Gradle 属性设置日志记录级别。-q, –quiet： 只能记录错误信息-w, –warn： 设置日志级别为 warn-i, –info： 将日志级别设置为 info-d, –debug：登录调试模式(包括正常的堆栈跟踪)</td></tr><tr><td><strong>其它(*)</strong></td><td>-x：-x 等价于： –exclude-task ： 常见gradle -x test clean build–rerun-tasks： 强制执行任务，忽略up-to-date ,常见gradle build –rerun-tasks–continue： 忽略前面失败的任务,继续执行,而不是在遇到第一个失败时立即停止执行。每个遇到的故障都将在构建结束时报告，常见：gradle build –continue。gradle init –type pom ：将maven 项目转换为gradle 项目(根目录执行)gradle [taskName] ：执行自定义任务</td></tr><tr><td>…</td><td></td></tr></tbody></table><p>更 详 细 请 参 考 官 方 文 档 ： <a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.gradle.org/current/userguide/command_line_interface.html">https://docs.gradle.org/current/userguide/command_line_interface.html#sec:command_line_executing_tasks</a></p><p>拓展：gradle 任务名是缩写： 任务名支持驼峰式命名风格的任务名缩写，如：connectTask 简写为：cT,执行任务 gradle cT。</p><p>拓展：前面提到的Gradle 指令本质：一个个的task[任务], Gradle 中所有操作都是基于任务完成的。</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241101153348137.png" class="" alt="image-20241101153348137"><p><strong>拓展 2</strong>：gradle 默认各指令之间相互的依赖关系：</p><p>相关解释：</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241101153404152.png" class="" alt="image-20241101153404152"><h5 id="任务定义方式"><a href="#任务定义方式" class="headerlink" title="任务定义方式"></a>任务定义方式</h5><p>任务定义方式，总体分为两大类：一种是通过 Project 中的task()方法,另一种是通过tasks 对象的 create 或者register 方法。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">task(<span class="string">&#x27;A&#x27;</span>,&#123;<span class="comment">//任务名称,闭包都作为参数println &quot;taskA...&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line">task(<span class="string">&#x27;B&#x27;</span>)&#123;<span class="comment">//闭包作为最后一个参数可以直接从括号中拿出来println &quot;taskB...&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">task C&#123;<span class="comment">//groovy语法支持省略方法括号:上面三种本质是一种println &quot;taskC...&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">def</span> map=<span class="keyword">new</span> HashMap&lt;String,Object&gt;(); </span><br><span class="line">map.put(<span class="string">&quot;action&quot;</span>,&#123;println <span class="string">&quot;taskD..&quot;</span>&#125;) <span class="comment">//action属性可以设置为闭包task(map,&quot;D&quot;);</span></span><br><span class="line">tasks.create(<span class="string">&#x27;E&#x27;</span>)&#123;<span class="comment">//使用tasks的create方法println &quot;taskE..&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">tasks.register(<span class="string">&#x27;f&#x27;</span>)&#123; <span class="comment">//注：register执行的是延迟创建。也即只有当task被需要使用的时候才会被创建。</span></span><br><span class="line">    println <span class="string">&quot;taskF	&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然：我们也可以在定义任务的同时指定任务的属性，具体属性有：</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241111112522642.png" class="" alt="image-20241111112522642"><p><strong>在定义任务时也可以给任务分配属性</strong>：定义任务的时候可以直接指定任务属性，也可以给已有的任务动态分配属性：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//①.F是任务名，前面通过具名参数给map的属性赋值,以参数方式指定任务的属性信息</span></span><br><span class="line">task(<span class="attr">group:</span> <span class="string">&quot;atguigu&quot;</span>,<span class="attr">description:</span> <span class="string">&quot;this is task B&quot;</span>,<span class="string">&quot;F&quot;</span>)</span><br><span class="line"><span class="comment">//②.H是任务名，定义任务的同时，在内部直接指定属性信息</span></span><br><span class="line">task(<span class="string">&quot;H&quot;</span>) &#123;</span><br><span class="line">    group(<span class="string">&quot;atguigu&quot;</span>) description(<span class="string">&quot;this is the task H&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//③.Y是任务名，给已有的任务 在外部直接指定属性信息</span></span><br><span class="line">task <span class="string">&quot;y&quot;</span>&#123;&#125;</span><br><span class="line">y.group=<span class="string">&quot;atguigu&quot;</span></span><br><span class="line">clean.group(<span class="string">&quot;atguigu&quot;</span>) <span class="comment">//案例：给已有的clean任务重新指定组信息</span></span><br></pre></td></tr></table></figure><p>可以在 idea 中看到： 上面自定义的那几个任务和 gradle 自带的 clean 任务已经跑到：atguigu 组了。</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241111112634363.png" class="" alt="image-20241111112634363"><h5 id="任务类型"><a href="#任务类型" class="headerlink" title="任务类型"></a>任务类型</h5><p>前面我们定义的task 都是DefaultTask 类型的,如果要完成某些具体的操作完全需要我们自己去编写gradle 脚本，势必有些麻烦，那有没有一些现成的任务类型可以使用呢？有的，Gradle 官网给出了一些现成的任务类型帮助我们快速完成想要的任务，我们只需要在创建任务的时候，指定当前任务的类型即可，然后即可使用这种类型中的属性和API 方法了。</p><table><thead><tr><th>常见任务类型</th><th>该类型任务的作用</th></tr></thead><tbody><tr><td>Delete</td><td>删除文件或目录</td></tr><tr><td>Copy</td><td>将文件复制到目标目录中。此任务还可以在复制时重命名和筛选文件。</td></tr><tr><td>CreateStartScripts</td><td>创建启动脚本</td></tr><tr><td>Exec</td><td>执行命令行进程</td></tr><tr><td>GenerateMavenPom</td><td>生成 Maven 模块描述符(POM)文件。</td></tr><tr><td>GradleBuild</td><td>执行 Gradle 构建</td></tr><tr><td>Jar</td><td>组装 JAR 归档文件</td></tr><tr><td>JavaCompile</td><td>编译 Java 源文件</td></tr><tr><td>Javadoc</td><td>为 Java 类 生 成 HTML API 文 档</td></tr><tr><td>PublishToMavenRepository</td><td>将 MavenPublication 发布到 mavenartifactrepostal。</td></tr><tr><td>Tar</td><td>组装 TAR 存档文件</td></tr><tr><td>Test</td><td>执行 JUnit (3.8.x、4.x 或 5.x)或 TestNG 测试。</td></tr><tr><td>Upload</td><td>将 Configuration 的构件上传到一组存储库。</td></tr><tr><td>War</td><td>组装 WAR 档案。</td></tr><tr><td>Zip</td><td>组装 ZIP 归档文件。默认是压缩 ZIP 的内容。</td></tr></tbody></table><p><strong>提示 1</strong>：如果想看更详细的gradle 自带Task 类型，请参考官方文档： <a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.gradle.org/current/dsl/index.html">https://docs.gradle.org/current/dsl/index.html</a></p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241111112728206.png" class="" alt="image-20241111112728206"><p><strong>提示 2</strong>： 官方文档在给出这些任务类型的时候，同时给出了案例代码，可以点进去上述官网地址中的某个类型中观看</p><p>具体使用例如：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tasks.register(<span class="string">&#x27;myClean&#x27;</span>, Delete) &#123; </span><br><span class="line">    delete buildDir</span><br><span class="line">&#125;</span><br><span class="line">在命令行执行 gradle myClean 发现就可以将当前project 的 build 目录删除当然除了gradle 自带的 task 类型,我们也可以自定义task 类型，如下所示： 拓展 <span class="number">4</span>:自定义 Task 类型</span><br><span class="line"><span class="keyword">def</span> myTask=task MyDefinitionTask (<span class="attr">type:</span> CustomTask) myTask.doFirst()&#123;</span><br><span class="line">    println <span class="string">&quot;task 执行之前 执行的 doFirst方法&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">myTask.doLast()&#123;</span><br><span class="line">    println <span class="string">&quot;task 执行之后 执行的 doLast方法&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomTask</span> <span class="keyword">extends</span> <span class="title class_">DefaultTask</span> &#123;</span><br><span class="line">    <span class="comment">//@TaskAction表示Task本身要执行的方法@TaskAction</span></span><br><span class="line">    <span class="keyword">def</span> doSelf()&#123;</span><br><span class="line">    println <span class="string">&quot;Task 自身 在执行的in doSelf&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：gradle MyDefinitionTask</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241111112902113.png" class="" alt="image-20241111112902113"><h5 id="任务的执行顺序"><a href="#任务的执行顺序" class="headerlink" title="任务的执行顺序"></a>任务的执行顺序</h5><p>在 Gradle 中,有三种方式可以指定 Task 执行顺序：</p><p>1、dependsOn 强依赖方式</p><p>2、通过 Task 输入输出</p><p>3、通过 API 指定执行顺序</p><p>详细请参考官网：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.gradle.org/current/dsl/org.gradle.api.Task.html">https://docs.gradle.org/current/dsl/org.gradle.api.Task.html</a></p><h5 id="动态分配任务"><a href="#动态分配任务" class="headerlink" title="动态分配任务"></a>动态分配任务</h5><p>gradle 的强大功能不仅仅用于定义任务的功能。例如，可以使用它在循环中注册同一类型的多个任务</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">times &#123; counter -&gt; tasks.register(<span class="string">&quot;task$counter&quot;</span>) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&quot;I&#x27;m task number $counter&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦注册了任务,就可以通过 API 访问它们。例如，您可以使用它在运行时动态地向任务添加依赖项。Ant 不允许这样的事情发生。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">times &#123; counter -&gt; tasks.register(<span class="string">&quot;task$counter&quot;</span>) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&quot;I&#x27;m task number $counter&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">tasks.named(<span class="string">&#x27;task0&#x27;</span>) &#123; dependsOn(<span class="string">&#x27;task2&#x27;</span>, <span class="string">&#x27;task3&#x27;</span>) &#125;</span><br></pre></td></tr></table></figure><p>构建 4 个任务,但是任务 0 必须依赖于任务 2 和 3,那么代表任务 2 和 3 需要在任务 0 之前优先加载。具体测试如下：</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241111115452066.png" class="" alt="image-20241111115452066"><h5 id="任务的关闭与开启"><a href="#任务的关闭与开启" class="headerlink" title="任务的关闭与开启"></a>任务的关闭与开启</h5><p>每个任务都有一个 enabled 默认为的标志 true。将其设置为 false 阻止执行任何任务动作。禁用的任务将标记为“跳过”。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task disableMe &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;This task is Executing...&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    enabled(<span class="literal">true</span>)<span class="comment">//直接设置任务开启，默认值为true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//disableMe.enabled = false //设置关闭任务</span></span><br></pre></td></tr></table></figure><h5 id="任务的超时"><a href="#任务的超时" class="headerlink" title="任务的超时"></a>任务的超时</h5><p>每个任务都有一个 timeout 可用于限制其执行时间的属性。当任务达到超时时，其任务执行线程将被中断。该任务将被标记为失败。终结器任务仍将运行。如果 –continue 使用，其他任务可以在此之后继续运行。不响应中断的任务无法超时。Gradle 的所有内置任务均会及时响应超时</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">task a() &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">        println <span class="string">&quot;当前任务a执行了&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    timeout = Duration.ofMillis(<span class="number">500</span>)</span><br><span class="line">&#125;</span><br><span class="line">task b() &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&quot;当前任务b执行了&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在控制台使用<strong>： gradle a b</strong> 测试会发现执行a 的时候,由于a 执行超时，抛出异常，所以没有继续往下执行【b 也没执行】。然后在控制台使用： **gradle a b –continue,**测试会发现a 虽然执行失败，但是 b 还是执行了。</p><h5 id="任务的查找"><a href="#任务的查找" class="headerlink" title="任务的查找"></a>任务的查找</h5><p>常用的任务查找方法有：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task atguigu &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&quot;让天下没有难学的技术：尚硅谷&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据任务名查找</span></span><br><span class="line">tasks.findByName(<span class="string">&quot;atguigu&quot;</span>).doFirst(&#123;println <span class="string">&quot;尚硅谷校区1：北京	&quot;</span>&#125;)</span><br><span class="line">tasks.getByName(<span class="string">&quot;atguigu&quot;</span>).doFirst(&#123;println <span class="string">&quot;尚硅谷校区2：深圳	&quot;</span>&#125;)</span><br><span class="line"><span class="comment">//根据任务路径查找【相对路径】</span></span><br><span class="line">tasks.findByPath(<span class="string">&quot;:atguigu&quot;</span>).doFirst(&#123;println <span class="string">&quot;尚硅谷校区3：上海&quot;</span>&#125;) </span><br><span class="line">tasks.getByPath(<span class="string">&quot;:atguigu&quot;</span>).doFirst(&#123;println <span class="string">&quot;尚硅谷校区4：武汉	&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>执行task： gradle atguigu，输出结果如下所示：</p><p>尚硅谷校区4：武汉….</p><p>尚硅谷校区3：上海….</p><p>尚硅谷校区2：深圳….</p><p>尚硅谷校区1：北京….</p><p>让天下没有难学的技术：尚硅谷</p><h5 id="任务的规则"><a href="#任务的规则" class="headerlink" title="任务的规则"></a>任务的规则</h5><p>当我们执行、依赖一个不存在的任务时，Gradle 会执行失败,报错误信息。那我们能否对其进行改进,当执行一个不存在的任务时，不是报错而是打印提示信息呢？</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;hello 尚硅谷的粉丝们&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.addRule(<span class="string">&quot;对该规则的一个描述，便于调试、查看等&quot;</span>)&#123; </span><br><span class="line">    String taskName -&gt; task(taskName) &#123;</span><br><span class="line">    	doLast &#123;</span><br><span class="line">        		println <span class="string">&quot;该$&#123;taskName&#125;任务不存在，请查证后再执行&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试： 使用 gradle abc hello 进行测试,此时当 abc 任务不存在时，也不会报异常【不中断执行】而是提示自定义的规则信息，继续执行 hello 任务。此外，它还可以根据不同的规则动态创建需要的任务等情况。</p><h5 id="任务的-onlyIf-断言"><a href="#任务的-onlyIf-断言" class="headerlink" title="任务的 onlyIf 断言"></a>任务的 onlyIf 断言</h5><p>断言就是一个条件表达式。Task 有一个 onlyIf 方法。它接受一个闭包作为参数，如果该闭包返回 true 则该任务执行， 否则跳过。这有很多用途，比如控制程序哪些情况下打什么包，什么时候执行单元测试，什么情况下执行单元测试的时候不执行网络测试等。具体案例如下所示：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;hello 尚硅谷的粉丝们&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello.onlyIf &#123; !project.hasProperty(<span class="string">&#x27;fensi&#x27;</span>) &#125;</span><br></pre></td></tr></table></figure><p>测试：通过-P 为Project 添加fensi 属性</p><p><code>gradle hello -P fensi</code></p><h5 id="默认任务"><a href="#默认任务" class="headerlink" title="默认任务"></a>默认任务</h5><p>Gradle 允许您定义一个或多个在没有指定其他任务时执行的默认任务。代码如下所示：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">defaultTasks <span class="string">&#x27;myClean&#x27;</span>, <span class="string">&#x27;myRun&#x27;</span> tasks.register(<span class="string">&#x27;myClean&#x27;</span>)&#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">    	println <span class="string">&#x27;Default Cleaning!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">tasks.register(<span class="string">&#x27;myRun&#x27;</span>) &#123; </span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;Default Running!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.register(<span class="string">&#x27;other&#x27;</span>) &#123; </span><br><span class="line">    doLast &#123;</span><br><span class="line">    	println <span class="string">&quot;I&#x27;m not a default task!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试及结果如下：</p><p><code>gradle -q Default Cleaning!</code></p><p>Default Running!</p><h3 id="Gradle-中的文件操作"><a href="#Gradle-中的文件操作" class="headerlink" title="Gradle 中的文件操作"></a>Gradle 中的文件操作</h3><p>几种常见的文件操作方式：</p><ul><li>本地文件</li><li>文件集合</li><li>文件树</li><li>文件拷贝</li><li>归档文件</li></ul><p>各种文件操作类型的详细介绍如下所示：</p><h4 id="本地文件"><a href="#本地文件" class="headerlink" title="本地文件"></a>本地文件</h4><p>使用 <code>Project.file(java.lang.Object)</code>方法，通过指定文件的相对路径或绝对路径来对文件的操作,其中相对路径为相对当前project[根project 或者子project]的目录。其实使用 <code>Project.file(java.lang.Object)</code>方法创建的 File 对象就是 Java 中的 File 对象，我们可以使用它就像在 Java 中使用一样。示例代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用相对路径</span></span><br><span class="line">File configFile = file(<span class="string">&#x27;src/conf.xml&#x27;</span>)</span><br><span class="line">configFile.createNewFile();</span><br><span class="line"><span class="comment">// 使用绝对路径</span></span><br><span class="line">configFile = file(<span class="string">&#x27;D:\\conf.xml&#x27;</span>)</span><br><span class="line">println(configFile.createNewFile())</span><br><span class="line"><span class="comment">// 使用一个文件对象</span></span><br><span class="line">configFile = <span class="keyword">new</span> File(<span class="string">&#x27;src/config.xml&#x27;</span>)</span><br><span class="line">println(configFile.exists())</span><br></pre></td></tr></table></figure><h4 id="文件集合"><a href="#文件集合" class="headerlink" title="文件集合"></a>文件集合</h4><p>文 件 集 合 就 是 一 组 文 件 的 列 表 , 在 Gradle 中 , 文 件 集 合 用 FileCollection 接 口 表 示 。 我 们 可 以 使 用</p><p><code>Project.files(java.lang.Object[])</code>方法来获得一个文件集合对象，如下代码创建一个 FileCollection 实例：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> collection = files(<span class="string">&#x27;src/test1.txt&#x27;</span>,<span class="keyword">new</span> File(<span class="string">&#x27;src/test2.txt&#x27;</span>),[<span class="string">&#x27;src/test3.txt&#x27;</span>, <span class="string">&#x27;src/test4.txt&#x27;</span>]) </span><br><span class="line">collection.forEach()&#123;File it -&gt;</span><br><span class="line">    it.createNewFile() <span class="comment">//创建该文件</span></span><br><span class="line">    println it.name <span class="comment">//输出文件名</span></span><br><span class="line">&#125;</span><br><span class="line">Set set1 = collection.files <span class="comment">// 把文件集合转换为java中的Set类型</span></span><br><span class="line">Set set2 = collection <span class="keyword">as</span> Set</span><br><span class="line">List list = collection <span class="keyword">as</span> List<span class="comment">//  把文件集合转换为java中的List类型</span></span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> list) &#123; </span><br><span class="line">    println item.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">def</span> union = collection + files(<span class="string">&#x27;src/test5.txt&#x27;</span>) <span class="comment">// 添加或者删除一个集合</span></span><br><span class="line"><span class="keyword">def</span> minus = collection - files(<span class="string">&#x27;src/test3.txt&#x27;</span>) </span><br><span class="line">union.forEach()&#123;</span><br><span class="line">    File it -&gt; println it.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于文件集合我们可以遍历它；也可以把它转换成java 类型；同时还能使用+来添加一个集合，或使用-来删除集合。</p><h4 id="文件树"><a href="#文件树" class="headerlink" title="文件树"></a>文件树</h4><p><strong>文件树是有层级结构的文件集合</strong>,一个文件树它可以代表一个目录结构或一 ZIP 压缩包中的内容结构。文件树是从文件集合继承过来的,<strong>所以文件树具有文件集合所有的功能</strong>。我们可以使用 Project.fileTree(java.util.Map)方法来创建文件树对象， 还可以使用过虑条件来包含或排除相关文件。示例代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tree = fileTree(<span class="string">&#x27;src/main&#x27;</span>).include(<span class="string">&#x27;**/*.java&#x27;</span>)<span class="comment">// 第一种方式:使用路径创建文件树对象，同时指定包含的文件</span></span><br><span class="line"><span class="comment">//第二种方式:通过闭包创建文件树:</span></span><br><span class="line">tree = fileTree(<span class="string">&#x27;src/main&#x27;</span>) &#123;</span><br><span class="line">    include <span class="string">&#x27;**/*.java&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">tree = fileTree(<span class="attr">dir:</span> <span class="string">&#x27;src/main&#x27;</span>, <span class="attr">include:</span> <span class="string">&#x27;**/*.java&#x27;</span>) <span class="comment">//第三种方式:通过路径和闭包创建文件树：具名参数给map传值tree = fileTree(dir: &#x27;src/main&#x27;, includes: [&#x27;**/*.java&#x27;, &#x27;**/*.xml&#x27;, &#x27;**/*.txt&#x27;], exclude: &#x27;**/*test*/**&#x27;)</span></span><br><span class="line">tree.each &#123;File file -&gt; <span class="comment">// 遍历文件树的所有文件</span></span><br><span class="line">    println file println file.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h4><p>我们可以使用 Copy 任务来拷贝文件，通过它可以过虑指定拷贝内容，还能对文件进行重命名操作等。Copy 任务必须指定一组需要拷贝的文件和拷贝到的目录，这里使用<code>CopySpec.from(java.lang.Object[])</code>方法指定原文件；使用<code>CopySpec.into(java.lang.Object)</code>方法指定目标目录。示例代码如下</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task copyTask(<span class="attr">type:</span> Copy) &#123; </span><br><span class="line">    from <span class="string">&#x27;src/main/resources&#x27;</span> into <span class="string">&#x27;build/config&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>from()</code>方法接受的参数和文件集合时files()一样。当参数为一个目录时，该目录下所有的文件都会被拷贝到指定目录下（目录自身不会被拷贝）；当参数为一个文件时，该文件会被拷贝到指定目录；如果参数指定的文件不存在，就会被忽略； 当参数为一个 Zip 压缩文件，该压缩文件的内容会被拷贝到指定目录。</p><p><code>into()</code>方法接受的参数与本地文件时 file()一样。 示例代码如下</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task copyTask(<span class="attr">type:</span> Copy) &#123;</span><br><span class="line">    <span class="comment">// 拷贝src/main/webapp目录下所有的文件</span></span><br><span class="line">    from <span class="string">&#x27;src/main/webapp&#x27;</span></span><br><span class="line">    <span class="comment">// 拷贝单独的一个文件</span></span><br><span class="line">    from <span class="string">&#x27;src/staging/index.html&#x27;</span></span><br><span class="line">    <span class="comment">// 从Zip压缩文件中拷贝内容</span></span><br><span class="line">    from zipTree(<span class="string">&#x27;src/main/assets.zip&#x27;</span>)</span><br><span class="line">    <span class="comment">// 拷贝到的目标目录</span></span><br><span class="line">    into <span class="string">&#x27;build/explodedWar&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在拷贝文件的时候还可以添加过虑条件来指定包含或排除的文件，示例如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">task copyTaskWithPatterns(<span class="attr">type:</span> Copy) &#123; </span><br><span class="line">    from <span class="string">&#x27;src/main/webapp&#x27;</span></span><br><span class="line">    into <span class="string">&#x27;build/explodedWar&#x27;</span> include <span class="string">&#x27;**/*.html&#x27;</span> include <span class="string">&#x27;**/*.jsp&#x27;</span></span><br><span class="line">    exclude &#123; </span><br><span class="line">        details -&gt; details.file.name.endsWith(<span class="string">&#x27;.html&#x27;</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">在拷贝文件的时候还可以对文件进行重命名操作，示例如下：</span><br><span class="line">task rename(<span class="attr">type:</span> Copy) &#123; </span><br><span class="line">    from <span class="string">&#x27;src/main/webapp&#x27;</span> into <span class="string">&#x27;build/explodedWar&#x27;</span></span><br><span class="line">    <span class="comment">// 使用一个闭包方式重命名文件</span></span><br><span class="line">    rename &#123; </span><br><span class="line">        String fileName -&gt; fileName.replace(<span class="string">&#x27;-staging-&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中我们都是使用Copy 任务来完成拷贝功能的，那么有没有另外一种方式呢？答案是肯定的，那就是</p><p><code>Project.copy(org.gradle.api.Action)</code>方法。下面示例展示了 copy()方法的使用方式：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task copyMethod &#123; </span><br><span class="line">    doLast &#123;</span><br><span class="line">        copy &#123;</span><br><span class="line">        	from <span class="string">&#x27;src/main/webapp&#x27;</span> into <span class="string">&#x27;build/explodedWar&#x27;</span> include <span class="string">&#x27;**/*.html&#x27;</span> include <span class="string">&#x27;**/*.jsp&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用project 对象的copy 方法：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">copy &#123;</span><br><span class="line">    <span class="comment">//相对路径或者绝对路径</span></span><br><span class="line">    from file(<span class="string">&#x27;src/main/resources/ddd.txt&#x27;</span>) <span class="comment">//file也可以换成new File()</span></span><br><span class="line">    into <span class="variable language_">this</span>.buildDir.absolutePath</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>gradle build</code> 指令即可。去 build 目录的本地磁盘查看，就能看到。</p><h4 id="归档文件"><a href="#归档文件" class="headerlink" title="归档文件"></a>归档文件</h4><p>通常一个项目会有很多的 Jar 包，我们希望把项目打包成一个 WAR，ZIP 或 TAR 包进行发布，这时我们就可以使用</p><p>Zip，Tar，Jar，War 和Ear 任务来实现，不过它们的用法都一样，所以在这里我只介绍Zip 任务的示例。首先，创建一个 Zip 压缩文件,并指定压缩文件名称，如下代码所示：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;java&#x27;</span> version=<span class="number">1.0</span></span><br><span class="line">task myZip(<span class="attr">type:</span> Zip) &#123; </span><br><span class="line">    from <span class="string">&#x27;src/main‘</span></span><br><span class="line"><span class="string">    into ‘build’ //保存到build目录中</span></span><br><span class="line"><span class="string">    baseName = &#x27;</span>myGame<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">println myZip.archiveName</span></span><br></pre></td></tr></table></figure><p>执行命令gradle -q myZip，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; gradle -q myZip myGame-1.0.zip</span><br></pre></td></tr></table></figure><p>最后，我们可以使用 <code>Project.zipTree(java.lang.Object)</code>和 <code>Project.tarTree(java.lang.Object)</code>方法来创建访问 Zip 压缩包的文件树对象，示例代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用zipTree</span></span><br><span class="line">FileTree zip = zipTree(<span class="string">&#x27;someFile.zip&#x27;</span>)</span><br><span class="line"><span class="comment">// 使用tarTree</span></span><br><span class="line">FileTree tar = tarTree(<span class="string">&#x27;someFile.tar&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在这里，我们介绍了 Gradle 对本地文件、文件集合、文件树、文件拷贝和归档文件的操作方式。更详细的请参考官方文档：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.gradle.org/current/userguide/working_with_files.html">https://docs.gradle.org/current/userguide/working_with_files.html</a></p><h3 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h3><h4 id="依赖的方式"><a href="#依赖的方式" class="headerlink" title="依赖的方式"></a>依赖的方式</h4><p>Gradle 中的依赖分别为直接依赖，项目依赖，本地jar 依赖。案例如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">//①.依赖当前项目下的某个模块[子工程]</span></span><br><span class="line">    implementation project(<span class="string">&#x27;:subject01&#x27;</span>)</span><br><span class="line">    <span class="comment">//②.直接依赖本地的某个jar文件</span></span><br><span class="line">    implementation files(<span class="string">&#x27;libs/foo.jar&#x27;</span>, <span class="string">&#x27;libs/bar.jar&#x27;</span>)</span><br><span class="line">    <span class="comment">//②.配置某文件夹作为依赖项</span></span><br><span class="line">    implementation fileTree(<span class="attr">dir:</span> <span class="string">&#x27;libs&#x27;</span>, <span class="attr">include:</span> [<span class="string">&#x27;*.jar&#x27;</span>])</span><br><span class="line">    <span class="comment">//③.直接依赖</span></span><br><span class="line">    implementation <span class="string">&#x27;org.apache.logging.log4j:log4j:2.17.2&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>直接依赖</strong>：在项目中直接导入的依赖，就是直接依赖<code>implementation &#39;org.apache.logging.log4j:log4j:2.17.2&#39;</code> 上面是简写法，完整版写法如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="attr">group:</span> <span class="string">&#x27;org.apache.logging.log4j&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;log4j&#x27;</span>, <span class="attr">version:</span> <span class="string">&#x27;2.17.2&#x27;</span></span><br></pre></td></tr></table></figure><p>group&#x2F;name&#x2F;version 共同定位一个远程仓库,version 最好写一个固定的版本号，以防构建出问题，implementation 类似</p><p>maven 中的依赖的scope,对比 maven 中的依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.2</span><span class="number">.12</span>&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p><strong>项目依赖</strong>： 从项目的某个模块依赖另一个模块</p><p><code>implementation project(&#39;:subject01&#39;)</code></p><p>这种依赖方式是直接依赖本工程中的libary module，这个 libary module 需要在setting.gradle 中配置。</p><p><strong>本地jar 依赖</strong>：本地 jar 文件依赖，一般包含以下两种方式</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接依赖某文件</span></span><br><span class="line">implementation files(<span class="string">&#x27;libs/foo.jar&#x27;</span>, <span class="string">&#x27;libs/bar.jar&#x27;</span>)</span><br><span class="line"><span class="comment">//配置某文件夹作为依赖项</span></span><br><span class="line">implementation fileTree(<span class="attr">dir:</span> <span class="string">&#x27;libs&#x27;</span>, <span class="attr">include:</span> [<span class="string">&#x27;*.jar&#x27;</span>])</span><br></pre></td></tr></table></figure><h4 id="依赖的下载"><a href="#依赖的下载" class="headerlink" title="依赖的下载"></a>依赖的下载</h4><p>当执行 build 命令时，gradle 就会去配置的依赖仓库中下载对应的 Jar，并应用到项目中。</p><h4 id="依赖的类型"><a href="#依赖的类型" class="headerlink" title="依赖的类型"></a>依赖的类型</h4><p>类似于 Maven 的 scope 标签，gradle 也提供了依赖的类型,具体如下所示：</p><table><thead><tr><th>compileOnly</th><th>由java插件提供,曾短暂的叫provided,后续版本已经改成了compileOnly,适用于编译期需要而不需要打包的情况</th></tr></thead><tbody><tr><td><strong>runtimeOnly</strong></td><td>由 java 插件提供,只在运行期有效,编译时不需要,比如mysql 驱动包。,取代老版本中被移除的 runtime</td></tr><tr><td><strong>implementation</strong></td><td>由 java 插件提供,针对源码[src&#x2F;main 目录] ,在编译、运行时都有效,取代老版本中被移除的 compile</td></tr><tr><td>testCompileOnly</td><td>由 java 插件提供,用于编译测试的依赖项，运行时不需要</td></tr><tr><td>testRuntimeOnly</td><td>由 java 插件提供,只在测试运行时需要，而不是在测试编译时需要,取代老版本中被移除的testRuntime</td></tr><tr><td><strong>testImplementation</strong></td><td>由 java 插件提供,针对测试代码[src&#x2F;test 目录] 取代老版本中被移除的testCompile</td></tr><tr><td><strong>providedCompile</strong></td><td>war 插件提供支持，编译、测试阶段代码需要依赖此类jar 包，而运行阶段容器已经提供了相应的支持，所以无需将这些文件打入到war 包中了;例如servlet-api.jar、jsp-api.jar</td></tr><tr><td>compile</td><td>编译范围依赖在所有的 classpath 中可用，同时它们也会被打包。在gradle 7.0 已经移除</td></tr><tr><td>runtime</td><td>runtime 依赖在运行和测试系统的时候需要,在编译的时候不需要,比如mysql 驱动包。在 gradle 7.0 已经移除</td></tr><tr><td><strong>api</strong></td><td>java-library 插件提供支持,这些依赖项可以传递性地导出给使用者，用于编译时和运行时。取代老版本中被移除的 compile</td></tr><tr><td>compileOnlyApi</td><td>java-library 插件提供支持,在声明模块和使用者在编译时需要的依赖项，但在运行时不需要。</td></tr></tbody></table><p>官方文档参考：</p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.gradle.org/current/userguide/java_library_plugin.html">https://docs.gradle.org/current/userguide/java_library_plugin.html#java_library_plugin:</a> 各个依赖范围的关系和说明<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.gradle.org/current/userguide/upgrading_version_6.html">https://docs.gradle.org/current/userguide/upgrading_version_6.html#sec:configuration_removal</a> : 依赖范围升级和移除<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.gradle.org/current/userguide/java_library_plugin.html#java_library_plugin%EF%BC%9AAPI">https://docs.gradle.org/current/userguide/java_library_plugin.html#java_library_plugin：API</a> 和implemention 区别<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.gradle.org/current/userguide/java_plugin.html">https://docs.gradle.org/current/userguide/java_plugin.html#java_plugin:</a> 执行java 命令时都使用了哪些依赖范围的依赖。<strong>提示 1</strong>：java 插件提供的功能，java-library 插件都提供。</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241112111326021.png" class="" alt="image-20241112111326021"><h4 id="api-与implementation-区别"><a href="#api-与implementation-区别" class="headerlink" title="api 与implementation 区别"></a>api 与implementation 区别</h4><p>如下所示：</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241112111358674.png" class="" alt="image-20241112111358674"><p><strong>编译时</strong>:如果 libC 的内容发生变化,由于使用的是 api 依赖,依赖会传递,所以 libC、libA、projectX 都要发生变化,都需要重新编译,速度慢,<strong>运行时：</strong>libC、libA、projectX 中的class 都要被加载。</p><p>**编译时:**如果libD 的内容发生变化,由于使用的是implemetation 依赖,依赖不会传递,只有libD、libB 要变化并重新编译,速度快,<strong>运行时：</strong>libC、libA、projectX 中的class 都要被加载。</p><p>拓展 3:api 和implementation 案例分析</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241112111512170.png" class="" alt="image-20241112111512170"><p>api 的适用场景是多module 依赖，moduleA 工程依赖了 module B，同时module B 又需要依赖了 module C，modelA 工程也需要去依赖 module C,这个时候避免重复依赖module,可以使用 module B api 依赖的方式去依赖module C,modelA 工程只需要依赖 moduleB 即可。</p><p><strong>总之，除非涉及到多模块依赖，为了避免重复依赖，咱们会使用api,其它情况我们优先选择implementation，拥有大量的api 依赖项会显著增加构建时间。</strong></p><h4 id="依赖冲突及解决方案"><a href="#依赖冲突及解决方案" class="headerlink" title="依赖冲突及解决方案"></a>依赖冲突及解决方案</h4><p>依赖冲突是指 “在编译过程中, 如果存在某个依赖的多个版本, 构建系统应该选择哪个进行构建的问题”,如下所示:</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241112111559163.png" class="" alt="image-20241112111559163"><p>A、B、C 都是本地子项目 module，log4j 是远程依赖。</p><p><strong>编译时：</strong> B 用 1.4.2 版本的 log4j，C 用 2.2.4 版本的 log4j,B 和 C 之间没有冲突</p><p><strong>打包时：</strong> 只能有一个版本的代码最终打包进最终的A对应的jar |war包，对于 Gradle 来说这里就有冲突了</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241112111617434.png" class="" alt="image-20241112111617434"><p>案例演示：我们在 build.gradle 引入依赖库</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="string">&#x27;org.junit.jupiter:junit-jupiter-api:5.8.1&#x27;</span> </span><br><span class="line">    testRuntimeOnly <span class="string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.8.1&#x27;</span> </span><br><span class="line">    implementation <span class="string">&#x27;org.hibernate:hibernate-core:3.6.3.Final&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修 改 build.gradle</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="string">&#x27;org.junit.jupiter:junit-jupiter-api:5.8.1&#x27;</span> </span><br><span class="line">    testRuntimeOnly <span class="string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.8.1&#x27;</span> </span><br><span class="line">    implementation <span class="string">&#x27;org.hibernate:hibernate-core:3.6.3.Final&#x27;</span> </span><br><span class="line">    implementation <span class="string">&#x27;org.slf4j:slf4j-api:1.4.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241112111717707.png" class="" alt="image-20241112111717707"><p>如上所示：默认下，Gradle 会使用最新版本的 jar 包【考虑到新版本的 jar 包一般都是向下兼容的】，实际开发中，还是建议使用官方自带的这种解决方案。<strong>当然除此之外，Gradle 也为我们提供了一系列的解决依赖冲突的方法</strong>: <strong>exclude 移除一个依赖</strong>，<strong>不允许依赖传递</strong>，<strong>强制使用某个版本</strong>。</p><ul><li>Exclude 排除某个依赖</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	testImplementation <span class="string">&#x27;org.junit.jupiter:junit-jupiter-api:5.8.1&#x27;</span> </span><br><span class="line">    testRuntimeOnly <span class="string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.8.1&#x27;</span> </span><br><span class="line">    implementation(<span class="string">&#x27;org.hibernate:hibernate-core:3.6.3.Final&#x27;</span>)&#123;</span><br><span class="line">       <span class="comment">// 排除某一个库(slf4j)依赖：如下三种写法都行</span></span><br><span class="line">        exclude <span class="attr">group:</span> <span class="string">&#x27;org.slf4j&#x27;</span>, <span class="attr">module:</span> <span class="string">&#x27;slf4j-api&#x27;</span></span><br><span class="line">        exclude <span class="attr">group:</span> <span class="string">&#x27;org.slf4j&#x27;</span> exclude <span class="attr">module:</span> <span class="string">&#x27;slf4j-api&#x27;</span></span><br><span class="line">        exclude(<span class="attr">group:</span> <span class="string">&#x27;org.slf4j&#x27;</span>, <span class="attr">module:</span> <span class="string">&#x27;slf4j-api&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//排除之后,使用手动的引入即可。</span></span><br><span class="line">    implementation <span class="string">&#x27;org.slf4j:slf4j-api:1.4.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不允许依赖传递</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="string">&#x27;org.junit.jupiter:junit-jupiter-api:5.8.1&#x27;</span> </span><br><span class="line">    testRuntimeOnly <span class="string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.8.1&#x27;</span> </span><br><span class="line">    implementation(<span class="string">&#x27;org.hibernate:hibernate-core:3.6.3.Final&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">//不允许依赖传递，一般不用</span></span><br><span class="line">        transitive(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//排除之后,使用手动的引入即可</span></span><br><span class="line">    implementation <span class="string">&#x27;org.slf4j:slf4j-api:1.4.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在添加依赖项时,如果设置 transitive 为false,表示关闭依赖传递。即内部的所有依赖将不会添加到编译和运行时的类路径。</p><ul><li>强制使用某个版本</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation <span class="string">&#x27;org.junit.jupiter:junit-jupiter-api:5.8.1&#x27;</span> </span><br><span class="line">    testRuntimeOnly <span class="string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.8.1&#x27;</span> </span><br><span class="line">    implementation(<span class="string">&#x27;org.hibernate:hibernate-core:3.6.3.Final&#x27;</span>)</span><br><span class="line">    <span class="comment">//强制使用某个版本!!【官方建议使用这种方式】</span></span><br><span class="line">    implementation(<span class="string">&#x27;org.slf4j:slf4j-api:1.4.0!!&#x27;</span>)</span><br><span class="line">    <span class="comment">//这种效果和上面那种一样,强制指定某个版本</span></span><br><span class="line">    implementation(<span class="string">&#x27;org.slf4j:slf4j-api:1.4.0&#x27;</span>)&#123;</span><br><span class="line">        version&#123;</span><br><span class="line">            strictly(<span class="string">&quot;1.4.0&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拓展</strong>：我们可以先查看当前项目中到底有哪些依赖冲突：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面我们配置，当 Gradle 构建遇到依赖冲突时，就立即构建失败</span></span><br><span class="line">configurations.all() &#123;</span><br><span class="line">    Configuration configuration -&gt;</span><br><span class="line">    <span class="comment">//当遇到版本冲突时直接构建失败configuration.resolutionStrategy.failOnVersionConflict()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Gradle-插件"><a href="#Gradle-插件" class="headerlink" title="Gradle 插件"></a>Gradle 插件</h3><h4 id="使用插件的原因"><a href="#使用插件的原因" class="headerlink" title="使用插件的原因"></a>使用插件的原因</h4><p>简单的说,通过应用插件我们可以:</p><ol><li>促进代码重用、减少功能类似代码编写、提升工作效率</li><li>促进项目更高程度的模块化、自动化、便捷化</li><li>可插拔式的的扩展项目的功能</li></ol><h4 id="插件的作用"><a href="#插件的作用" class="headerlink" title="插件的作用"></a>插件的作用</h4><p>在项目构建过程中做很多事情，把插件应用到项目中，通常可以完成:</p><ol><li>可以添加任务【task】到项目中，从而帮助完成测试、编译、打包等。</li><li>可以添加依赖配置到项目中。</li><li>可以向项目中拓展新的扩展属性、方法等。</li><li>可以对项目进行一些约定，如应用 Java 插件后，约定src&#x2F;main&#x2F;java 目录是我们的源代码存在位置，编译时编译这个目录下的Java 源代码文件。</li></ol><h4 id="插件的分类和使用"><a href="#插件的分类和使用" class="headerlink" title="插件的分类和使用"></a>插件的分类和使用</h4><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241112114242010.png" class="" alt="image-20241112114242010"><h5 id="第一种：脚本插件"><a href="#第一种：脚本插件" class="headerlink" title="第一种：脚本插件"></a>第一种：脚本插件</h5><p>脚本插件的本质就是一个脚本文件，使用脚本插件时通过apply from:将脚本加载进来就可以了，后面的脚本文件可以是本地的也可以是网络上的脚本文件，下面定义一段脚本，我们在 build.gradle 文件中使用它，具体如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//version.gradle文件</span></span><br><span class="line">ext &#123;</span><br><span class="line">    company= <span class="string">&quot;尚硅谷&quot;</span> cfgs = [</span><br><span class="line">    	<span class="attr">compileSdkVersion :</span> JavaVersion.VERSION_1_8</span><br><span class="line">    ]</span><br><span class="line">    spring = [</span><br><span class="line">    	<span class="attr">version :</span> <span class="string">&#x27;5.0.0&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面将将在构建文件中使用这个脚本文件，具体如下:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//build.gradle文件</span></span><br><span class="line"><span class="comment">//map作为参数</span></span><br><span class="line">apply <span class="attr">from:</span> <span class="string">&#x27;version.gradle&#x27;</span> </span><br><span class="line">task taskVersion&#123;</span><br><span class="line">    doLast&#123;</span><br><span class="line">    	println <span class="string">&quot;公司名称为：$&#123;company&#125;,JDK版本是$&#123;cfgs.compileSdkVersion&#125;,版本号是$&#123;spring.version&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的执行结果如下：</p><p><code>PS D:\repos\idearepos\root&gt; gradle -q taskVersion</code></p><p>版本是2.0,版本号是1</p><p><strong>意义：</strong>脚本文件模块化的基础，可按功能把我们的脚本进行拆分一个个公用、职责分明的文件，然后在主脚本文件引用， 比如：将很多共有的库版本号一起管理、应用构建版本一起管理等。</p><h5 id="第二种：对象插件之内部插件-核心插件"><a href="#第二种：对象插件之内部插件-核心插件" class="headerlink" title="第二种：对象插件之内部插件[核心插件]"></a>第二种：对象插件之内部插件[核心插件]</h5><p>二进制插件[对象插件]就是实现了 org.gradle.api.Plugin 接口的插件，每个 Java Gradle 插件都有一个 plugin id。</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241112114506332.png" class="" alt="image-20241112114506332"><p>可通过如下方式使用一个 Java 插件： apply plugin : ‘java’ &#x2F;&#x2F;map具名参数方式或者：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以使用闭包作为project.apply方法的一个参数</span></span><br><span class="line">apply&#123;</span><br><span class="line">    plugin <span class="string">&#x27;java&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码就将 Java 插件应用到我们的项目中了，对于 Gradle 自带的核心插件都有唯一的 plugin id，其中 java 是Java 插件的 plugin id,这个 plugin id 必须是唯一的，可使用应用包名来保证 plugin id 的唯一性。这里的 java 对应的具体类型是 org.gradle.api.plugins.JavaPlugin，所以可以使用如下方式使用 Java 插件：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用方式1：Map具名参数,全类名</span></span><br><span class="line">apply <span class="attr">plugin:</span>org.gradle.api.plugins.JavaPlugin</span><br><span class="line"><span class="comment">//org.gradle.api.plugins默认导入：使用方式2 apply plugin:JavaPlugin</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;java&#x27;</span> <span class="comment">//核心插件，无需事先引入，使用方式3:插件的id</span></span><br></pre></td></tr></table></figure><p>Gradle 中提供的二进制插件【核心插件】,可参考: <a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.gradle.org/current/userguide/plugin_reference.html">https://docs.gradle.org/current/userguide/plugin_reference.html</a></p><h5 id="第二种：对象插件之第三方插件"><a href="#第二种：对象插件之第三方插件" class="headerlink" title="第二种：对象插件之第三方插件"></a>第二种：对象插件之第三方插件</h5><p>如果是使用第三方发布的二进制插件，一般需要配置对应的仓库和类路径,</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用传统的应用方式</span></span><br><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">    	springBootVersion = <span class="string">&quot;2.3.3.RELEASE&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenLocal()</span><br><span class="line">        maven &#123; url <span class="string">&#x27;http://maven.aliyun.com/nexus/content/groups/public&#x27;</span> &#125;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处先引入插件</span></span><br><span class="line">    dependencies &#123;</span><br><span class="line">    	classpath(<span class="string">&quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//再应用插件</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;org.springframework.boot&#x27;</span> <span class="comment">//社区插件,需要事先引入，不必写版本号</span></span><br></pre></td></tr></table></figure><p>但是如果是第三方插件已经被托管在 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://plugins.gradle.org/">https://plugins.gradle.org/</a> 网站上，就可以不用在 buildscript 里配置 classpath</p><p>依赖了，直接使用新出的 plugins DSL 的方式引用，案例如下： 使 用 plugins DSL 方 式</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;org.springframework.boot&#x27;</span> version <span class="string">&#x27;2.4.1&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>如果使用老式插件方式buildscript{}要放在build.gradle 文件的最前面,而新式plugins{}没有该限制。</li><li>托管在网站gradle 插件官网的第三方插件有两种使用方式，一是传统的buildscript 方式，一种是 plugins DSL 方式 。</li></ol><p>第二种：对象插件之用户自定义插件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GreetingPluginExtension</span> &#123; </span><br><span class="line">    Property&lt;String&gt; getMessage() Property&lt;String&gt; getGreeter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreetingPlugin</span> <span class="keyword">implements</span> <span class="title class_">Plugin</span>&lt;Project&gt; &#123;</span><br><span class="line">    <span class="type">void</span> apply(Project project) &#123;</span><br><span class="line">    <span class="keyword">def</span> extension = project.extensions.create(<span class="string">&#x27;greeting&#x27;</span>, GreetingPluginExtension) </span><br><span class="line">    project.task(<span class="string">&#x27;hello&#x27;</span>) &#123;</span><br><span class="line">        doLast &#123;</span><br><span class="line">           	 println <span class="string">&quot;$&#123;extension.message.get()&#125; from $&#123;extension.greeter.get()&#125;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="attr">plugin:</span> GreetingPlugin</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the extension using a DSL block </span></span><br><span class="line">greeting &#123;</span><br><span class="line">    message = <span class="string">&#x27;Hi&#x27;</span></span><br><span class="line">    greeter = <span class="string">&#x27;Gradle&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考地址：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.gradle.org/current/userguide/custom_plugins.html">https://docs.gradle.org/current/userguide/custom_plugins.html</a></p><p>我们直接执行 hello 任务.&#x2F;gradle hello 即可,这种方式实现的插件我们一般不使用，因为这种方式局限性太强，只能本</p><p>Project，而其他的Project 不能使用。</p><h4 id="buildSrc-项目"><a href="#buildSrc-项目" class="headerlink" title="buildSrc 项目"></a>buildSrc 项目</h4><p>buildSrc 是Gradle 默认的插件目录，编译 Gradle 的时候会自动识别这个目录，将其中的代码编译为插件。</p><ol><li>首先先建立一个名为 buildSrc 的 java Module,将 buildSrc 从 included modules 移除,重新构建,然后只保留 build.gradle和src&#x2F;main 目录，其他全部删掉,注意名字一定是 buildSrc,不然会找不到插件。</li><li>然后修改Gradle 中的内容</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;groovy&#x27;</span> <span class="comment">// 必 须</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;maven-publish&#x27;</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation gradleApi() <span class="comment">//必须</span></span><br><span class="line">    implementation localGroovy() <span class="comment">//必须</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    google() </span><br><span class="line">    jcenter()</span><br><span class="line">    mavenCentral() <span class="comment">//必须</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把项目入口设置为src/main/groovy </span></span><br><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        groovy &#123;</span><br><span class="line">            srcDir <span class="string">&#x27;src/main/groovy&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241203155152051.png" class="" alt="image-20241203155152051"><p>创建入口目录，在src&#x2F;main 下创建代码入口目录，如下：</p><p>然后实现插件代码Text.groovy，注意文件后缀为groovy,文件要引入package com.atguigu</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Plugin </span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Project</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Text</span> <span class="keyword">implements</span> <span class="title class_">Plugin</span>&lt;Project&gt;&#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">void</span> apply(Project project) &#123; </span><br><span class="line">        project.task(<span class="string">&quot;atguigu&quot;</span>)&#123;</span><br><span class="line">            doLast&#123;</span><br><span class="line">            	println(<span class="string">&quot;自定义atguigu插件&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在 main 目录下创建 resources 目录,在 resources 目录下创建 META-INF 目录，在 META-INF 目录下创建gradle-plugins 目录，在gradle-plugins 目录下创建properties 文件</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241203155443427.png" class="" alt="image-20241203155443427"><p>properties 文件可以自己命名，但是要以.properties 结尾，比如 com.atguigu.plugin.properties,其 com.atguigu.plugin 就是定义的包名路径</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241203155504085.png" class="" alt="image-20241203155504085"><p>最后需要在properties 文件中指明我们实现插件的全类名 implementation-class&#x3D;com.atguigu.Text 到目前为止我们的插件项目已经写完了，在 module 引入我们写的插件 apply plugin:’com.atguigu.plugin’,然后执行插件的Task</p><p>.&#x2F;gradle atguigu</p><p>输出:</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241203155544319.png" class="" alt="image-20241203155544319"><p>这种形式的写法，在我们整个工程的 module 都可以使用，但也只是限制在本工程，其他工程不能使用。</p><p><strong>改进</strong>：</p><p>第二种写插件的方式他只能在本工程中使用，而其他的项目工程不能使用，有时候我们需要一个插件在多个工程中使用， 这时候我们就需要把插件上传maven 中。</p><p>第一步: 首先将上述buildSrc 目录复制一份，修改文件夹名，然后在settings.gradle 文件中使用include 引入</p><p>第二步：修改build.gradle 文件，发布到maven 仓库中</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;groovy&#x27;</span> <span class="comment">// 必 须</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;maven-publish&#x27;</span> </span><br><span class="line">dependencies &#123;</span><br><span class="line">	implementation gradleApi() <span class="comment">//必须</span></span><br><span class="line">    implementation localGroovy() <span class="comment">//必须</span></span><br><span class="line">&#125;</span><br><span class="line">repositories &#123;</span><br><span class="line">	google() </span><br><span class="line">    jcenter()</span><br><span class="line">	mavenCentral() <span class="comment">//必须</span></span><br><span class="line">&#125;</span><br><span class="line">sourceSets &#123; <span class="comment">//把项目入口设置为src/main/groovy </span></span><br><span class="line">        main &#123;</span><br><span class="line">        groovy &#123;</span><br><span class="line">            srcDir <span class="string">&#x27;src/main/groovy&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">publishing &#123;</span><br><span class="line">    publications &#123;</span><br><span class="line">        myLibrary(MavenPublication) &#123;</span><br><span class="line">        groupId = <span class="string">&#x27;com.atguigu.plugin&#x27;</span> <span class="comment">//指定GAV坐标信息artifactId = &#x27;library&#x27;</span></span><br><span class="line">        version = <span class="string">&#x27;1.1&#x27;</span></span><br><span class="line">        from components.java<span class="comment">//发布jar包</span></span><br><span class="line">        <span class="comment">//from components.web///引入war插件，发布war包</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url <span class="string">&quot;$rootDir/lib/release&quot;</span> &#125;</span><br><span class="line">    <span class="comment">//发布项目到私服中</span></span><br><span class="line">    <span class="comment">//	maven &#123;</span></span><br><span class="line">    <span class="comment">//	name = &#x27;myRepo&#x27; //name属性可选,表示仓库名称，url必填</span></span><br><span class="line">    <span class="comment">//	//发布地址:可以是本地仓库或者maven私服</span></span><br><span class="line">    <span class="comment">//	//url = layout.buildDirectory.dir(&quot;repo&quot;)</span></span><br><span class="line">    <span class="comment">//	//url=&#x27;http://my.org/repo&#x27;</span></span><br><span class="line">    <span class="comment">//	// change URLs to point to your repos, e.g. http://my.org/repo</span></span><br><span class="line">    <span class="comment">//	//认证信息:用户名和密码</span></span><br><span class="line">    <span class="comment">//	credentials &#123;</span></span><br><span class="line">    <span class="comment">//	username = &#x27;joe&#x27;</span></span><br><span class="line">    <span class="comment">//	password = &#x27;secret&#x27;</span></span><br><span class="line">    <span class="comment">//	&#125;</span></span><br><span class="line">    <span class="comment">//	&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：执行publish 指令,发布到根 project 或者maven 私服仓库。</p><p>第四步：使用插件,在项目级 build.gradle 文件中将插件添加到 classpath：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url <span class="string">&quot;$rootDir/lib/release&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">    	classpath <span class="string">&quot;com.atguigu.plugin:library:1.1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;java&#x27;</span></span><br><span class="line"><span class="comment">//是在 atguiguplugin  中定义的插件 ID apply plugin: &#x27;com.atguigu.plugin&#x27;</span></span><br></pre></td></tr></table></figure><p>第五步：执行 gradle build 指令就会在控制台看到自定义插件的输出，说明自定义插件就已经生效了。</p><p>最后，至于如何写一个插件，能帮助项目更加自动化或者便捷化，是值得大家未来需要长期思考、关注、努力的点。</p><h4 id="插件的关注点"><a href="#插件的关注点" class="headerlink" title="插件的关注点"></a>插件的关注点</h4><h5 id="第一点-插件的引用"><a href="#第一点-插件的引用" class="headerlink" title="第一点: 插件的引用"></a>第一点: 插件的引用</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;插件名&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="第二点-主要的功能-任务"><a href="#第二点-主要的功能-任务" class="headerlink" title="第二点:主要的功能[任务]"></a>第二点:主要的功能[任务]</h5><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241203161756587.png" class="" alt="image-20241203161756587"><p>当我们在工程中引入插件后，插件会自动的为我们的工程添加一些额外的任务来完成相应的功能。以Java 插件为例，当我们加入java 插件之后，就加入了如下功能：</p><p>具体大家可通过gradle tasks 查看加入某个插件前后的区别。</p><p>说明：Gradle 中的任务依赖关系是很重要的，它们之间的依赖关系就形成了构建的基本流程。</p><h5 id="第三点-工程目录结构"><a href="#第三点-工程目录结构" class="headerlink" title="第三点:工程目录结构"></a>第三点:工程目录结构</h5><p>一些插件对工程目结构有约定，所以我们一般遵循它的约定结构来创建工程，这也是 Gradle 的“约定优于配置”原则。例如java 插件规定的项目源集目录结构如下所示：</p> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2f95dd0d983d/image-20241203161819479.png" class="" alt="image-20241203161819479"><p>如果要使用某个插件就应该按照它约定的目录结构设置，这样能大大提高我们的效率，当然各目录结构也可以自己定义。</p><h5 id="第四点：依赖管理"><a href="#第四点：依赖管理" class="headerlink" title="第四点：依赖管理"></a>第四点：依赖管理</h5><p>比如前面我们提到的 依赖的类型[依赖管理]部分，不同的插件提供了不同的依赖管理。</p><h5 id="第五点：常用的属性"><a href="#第五点：常用的属性" class="headerlink" title="第五点：常用的属性"></a>第五点：常用的属性</h5><p>例如：Java 插件会为工程添加一些常用的属性,我们可以直接在编译脚本中直接使用。</p><table><thead><tr><th>属性名称</th><th>类型</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>reportsDirName</td><td>String</td><td>reports</td><td>生成报告的目录名称</td></tr><tr><td>reportsDir</td><td>File（只读）</td><td>buildDir&#x2F;reportsDirName</td><td>生成报告的目录</td></tr><tr><td>testResultsDirName</td><td>String</td><td>test-results</td><td>生成测试result.xml 文件的目录名称</td></tr><tr><td>testResultsDir</td><td>File（只读）</td><td>reportsDir&#x2F;testReportDirName</td><td>生成测试报告的目录</td></tr><tr><td>libsDirName</td><td>String</td><td>libs</td><td>生成lib 库的目录名称</td></tr><tr><td>libsDir</td><td>File（只读）</td><td>buildDir&#x2F;libsDirName</td><td>生成lib 库的目录</td></tr><tr><td>distsDirName</td><td>String</td><td>distributions</td><td>生成发布文件的目录名称</td></tr><tr><td>distsDir</td><td>File（只读）</td><td>buildDir&#x2F;distsDirName</td><td>生成发布文件的目录</td></tr><tr><td>docsDirName</td><td>String</td><td>docs</td><td>生成帮助文档的目录名称</td></tr><tr><td>docsDir</td><td>File（只读）</td><td>buildDir&#x2F;docsDirName</td><td>生成帮助文档的目录</td></tr><tr><td>dependencyCacheDirName</td><td>String</td><td>dependency-cache</td><td>存储缓存资源依赖信息的目录名称</td></tr><tr><td>dependencyCacheDir</td><td>File（只读）</td><td>buildDir&#x2F;dependencyCacheDirName</td><td>存储缓存资源依赖信息的目录</td></tr></tbody></table><p>当然，这里还有一些其它属性</p><table><thead><tr><th>属性名称</th><th>类型</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者:</span> <span class="post-copyright-info"><a href="https://blog.48626.xyz">初。</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接:</span> <span class="post-copyright-info"><a href="https://blog.48626.xyz/2f95dd0d983d.html">https://blog.48626.xyz/2f95dd0d983d.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.48626.xyz" target="_blank">zea</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Gradle/">Gradle</a></div><div class="post_share"><div class="social-share" data-image="https://q1.qlogo.cn/g?b=qq&amp;nk=770600073&amp;s=640" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/4e0b2bc90707.html" title="多次链接错误被阻止"><div class="cover" style="background:var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">多次链接错误被阻止</div></div></a></div><div class="next-post pull-right"><a href="/745fda1b4f91.html" title="责任链模式"><div class="cover" style="background:var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">责任链模式</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://q1.qlogo.cn/g?b=qq&amp;nk=770600073&amp;s=640" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">初。</div><div class="author-info__description">一个简单的博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">153</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">52</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/isGuard"><i class="fab fa-github"></i><span>Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/isGuard" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="mailto:isguard@outlook.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#24292e"></i></a><a class="social-icon" href="tencent://message/?uin=770600073&amp;Site=&amp;Menu=yes" rel="external nofollow noreferrer" target="_blank" title="QQ"><i class="fab fa-qq" style="color:#24292e"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Gradle-%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">Gradle 入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Gradle-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">Gradle 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7"><span class="toc-number">1.2.</span> <span class="toc-text">常见的项目构建工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gradle-%E5%AE%89%E8%A3%85"><span class="toc-number">1.3.</span> <span class="toc-text">Gradle 安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Gradle-%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E"><span class="toc-number">1.3.1.</span> <span class="toc-text">Gradle 安装说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85JDK"><span class="toc-number">1.3.2.</span> <span class="toc-text">安装JDK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E5%B9%B6%E8%A7%A3%E5%8E%8B%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">下载并解压到指定目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.4.</span> <span class="toc-text">配置环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F"><span class="toc-number">1.3.5.</span> <span class="toc-text">检测是否安装成功</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gradle-%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">Gradle 项目目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gradle-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.5.</span> <span class="toc-text">Gradle 创建第一个项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gradle-%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">1.6.</span> <span class="toc-text">Gradle 中的常用指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9maven-%E4%B8%8B%E8%BD%BD%E6%BA%90"><span class="toc-number">1.7.</span> <span class="toc-text">修改maven 下载源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Wrapper-%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">1.8.</span> <span class="toc-text">Wrapper 包装器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GradleWrapper-%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-number">1.8.1.</span> <span class="toc-text">GradleWrapper 的执行流程：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Gradle-%E4%B8%8E-Idea-%E6%95%B4%E5%90%88"><span class="toc-number">2.</span> <span class="toc-text">Gradle 与 Idea 整合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Groovy-%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.</span> <span class="toc-text">Groovy 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Groovy-%E5%AE%89%E8%A3%85-%E9%9D%9E%E5%BF%85%E9%A1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">Groovy 安装[非必须]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-Groovy-%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.3.</span> <span class="toc-text">创建 Groovy 项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Groovy-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">Groovy 基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">2.4.1.</span> <span class="toc-text">案例 1：基本注意点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-2%EF%BC%9A%E5%BC%95%E5%8F%B7%E8%AF%B4%E6%98%8E"><span class="toc-number">2.4.2.</span> <span class="toc-text">案例 2：引号说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-3%EF%BC%9A%E4%B8%89%E4%B8%AA%E8%AF%AD%E5%8F%A5%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.3.</span> <span class="toc-text">案例 3：三个语句结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-4%EF%BC%9A%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">2.4.4.</span> <span class="toc-text">案例 4：类型及权限修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-5%EF%BC%9A%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.5.</span> <span class="toc-text">案例 5：集合操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-6%EF%BC%9A%E7%B1%BB%E5%AF%BC%E5%85%A5"><span class="toc-number">2.4.6.</span> <span class="toc-text">案例 6：类导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-7%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">2.4.7.</span> <span class="toc-text">案例 7：异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-8%EF%BC%9A%E9%97%AD%E5%8C%85"><span class="toc-number">2.4.8.</span> <span class="toc-text">案例 8：闭包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-idea-%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%99%AE%E9%80%9Ajava-%E5%B7%A5%E7%A8%8B"><span class="toc-number">2.5.</span> <span class="toc-text">在 idea 中创建普通java 工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-idea-%E4%B8%AD%E5%88%9B%E5%BB%BA-web-%E5%B7%A5%E7%A8%8B"><span class="toc-number">2.6.</span> <span class="toc-text">在 idea 中创建 web 工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2"><span class="toc-number">2.7.</span> <span class="toc-text">项目部署</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Gretty-%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.7.1.</span> <span class="toc-text">Gretty 部署项目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8"><span class="toc-number">2.7.2.</span> <span class="toc-text">具体使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gradle-%E5%AF%B9%E6%B5%8B%E8%AF%95%E6%94%AF%E6%8C%81"><span class="toc-number">2.8.</span> <span class="toc-text">Gradle 对测试支持</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%B5%8B%E8%AF%95%E7%9B%AE%E5%BD%95%E5%8F%8A%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA"><span class="toc-number">2.8.1.</span> <span class="toc-text">默认测试目录及标准输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Junit-%E4%BD%BF%E7%94%A8"><span class="toc-number">2.8.2.</span> <span class="toc-text">Junit 使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E5%90%AB%E5%92%8C%E6%8E%92%E9%99%A4%E7%89%B9%E5%AE%9A%E6%B5%8B%E8%AF%95"><span class="toc-number">2.8.3.</span> <span class="toc-text">包含和排除特定测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Gradle-%E8%BF%9B%E9%98%B6%E8%AF%B4%E6%98%8E"><span class="toc-number">3.</span> <span class="toc-text">Gradle 进阶说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.1.</span> <span class="toc-text">项目的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#settings-%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.</span> <span class="toc-text">settings 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Task"><span class="toc-number">3.3.</span> <span class="toc-text">Task</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%85%A5%E9%97%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">任务入门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">3.3.2.</span> <span class="toc-text">任务的行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.3.</span> <span class="toc-text">任务的依赖方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%8F%82%E6%95%B0%E6%96%B9%E5%BC%8F%E4%BE%9D%E8%B5%96"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">方式一：参数方式依赖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%86%85%E9%83%A8%E4%BE%9D%E8%B5%96"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">方式二：内部依赖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96"><span class="toc-number">3.3.3.3.</span> <span class="toc-text">方式三：外部依赖</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C"><span class="toc-number">3.3.4.</span> <span class="toc-text">任务执行</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">任务定义方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.4.2.</span> <span class="toc-text">任务类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.3.4.3.</span> <span class="toc-text">任务的执行顺序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.3.4.4.</span> <span class="toc-text">动态分配任务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%85%B3%E9%97%AD%E4%B8%8E%E5%BC%80%E5%90%AF"><span class="toc-number">3.3.4.5.</span> <span class="toc-text">任务的关闭与开启</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%B6%85%E6%97%B6"><span class="toc-number">3.3.4.6.</span> <span class="toc-text">任务的超时</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">3.3.4.7.</span> <span class="toc-text">任务的查找</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">3.3.4.8.</span> <span class="toc-text">任务的规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84-onlyIf-%E6%96%AD%E8%A8%80"><span class="toc-number">3.3.4.9.</span> <span class="toc-text">任务的 onlyIf 断言</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.3.4.10.</span> <span class="toc-text">默认任务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gradle-%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">3.4.</span> <span class="toc-text">Gradle 中的文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6"><span class="toc-number">3.4.1.</span> <span class="toc-text">本地文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%9B%86%E5%90%88"><span class="toc-number">3.4.2.</span> <span class="toc-text">文件集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%A0%91"><span class="toc-number">3.4.3.</span> <span class="toc-text">文件树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.4.4.</span> <span class="toc-text">文件拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E6%A1%A3%E6%96%87%E4%BB%B6"><span class="toc-number">3.4.5.</span> <span class="toc-text">归档文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dependencies"><span class="toc-number">3.5.</span> <span class="toc-text">Dependencies</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.5.1.</span> <span class="toc-text">依赖的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E7%9A%84%E4%B8%8B%E8%BD%BD"><span class="toc-number">3.5.2.</span> <span class="toc-text">依赖的下载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.3.</span> <span class="toc-text">依赖的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#api-%E4%B8%8Eimplementation-%E5%8C%BA%E5%88%AB"><span class="toc-number">3.5.4.</span> <span class="toc-text">api 与implementation 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.5.5.</span> <span class="toc-text">依赖冲突及解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gradle-%E6%8F%92%E4%BB%B6"><span class="toc-number">3.6.</span> <span class="toc-text">Gradle 插件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.6.1.</span> <span class="toc-text">使用插件的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.6.2.</span> <span class="toc-text">插件的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">3.6.3.</span> <span class="toc-text">插件的分类和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%EF%BC%9A%E8%84%9A%E6%9C%AC%E6%8F%92%E4%BB%B6"><span class="toc-number">3.6.3.1.</span> <span class="toc-text">第一种：脚本插件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%EF%BC%9A%E5%AF%B9%E8%B1%A1%E6%8F%92%E4%BB%B6%E4%B9%8B%E5%86%85%E9%83%A8%E6%8F%92%E4%BB%B6-%E6%A0%B8%E5%BF%83%E6%8F%92%E4%BB%B6"><span class="toc-number">3.6.3.2.</span> <span class="toc-text">第二种：对象插件之内部插件[核心插件]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%EF%BC%9A%E5%AF%B9%E8%B1%A1%E6%8F%92%E4%BB%B6%E4%B9%8B%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6"><span class="toc-number">3.6.3.3.</span> <span class="toc-text">第二种：对象插件之第三方插件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#buildSrc-%E9%A1%B9%E7%9B%AE"><span class="toc-number">3.6.4.</span> <span class="toc-text">buildSrc 项目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E7%9A%84%E5%85%B3%E6%B3%A8%E7%82%B9"><span class="toc-number">3.6.5.</span> <span class="toc-text">插件的关注点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%82%B9-%E6%8F%92%E4%BB%B6%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">3.6.5.1.</span> <span class="toc-text">第一点: 插件的引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%82%B9-%E4%B8%BB%E8%A6%81%E7%9A%84%E5%8A%9F%E8%83%BD-%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.6.5.2.</span> <span class="toc-text">第二点:主要的功能[任务]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%82%B9-%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">3.6.5.3.</span> <span class="toc-text">第三点:工程目录结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%82%B9%EF%BC%9A%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><span class="toc-number">3.6.5.4.</span> <span class="toc-text">第四点：依赖管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%82%B9%EF%BC%9A%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">3.6.5.5.</span> <span class="toc-text">第五点：常用的属性</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2016 - 2024 By 初。</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>