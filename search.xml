<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Debug追踪</title>
    <url>/2020/04/20/Intellij/Debug%E8%BF%BD%E8%B8%AA/</url>
    <content><![CDATA[<h2 id="Debug追踪"><a href="#Debug追踪" class="headerlink" title="Debug追踪"></a>Debug追踪</h2><p><strong>使用IDEA的断点调试功能，查看程序的运行过程</strong></p>
<ol>
<li><p>在有效代码行，点击行号右边的空白区域，设置断点，程序执行到断点将停止，我们可以手动来运行程序 	</p>
<img data-src="/2020/04/20/Intellij/Debug%E8%BF%BD%E8%B8%AA/debug1.png" class="">
</li>
<li><p>点击Debug运行模式       <img data-src="/2020/04/20/Intellij/Debug%E8%BF%BD%E8%B8%AA/debug2.png" class="">                                                                                                                                                                      </p>
</li>
<li><p>程序停止在断点上不再执行，而IDEA最下方打开了Debug调试窗口  </p>
 <img data-src="/2020/04/20/Intellij/Debug%E8%BF%BD%E8%B8%AA/debug4.png" class="">
</li>
<li><p>Debug调试窗口介绍</p>
<img data-src="/2020/04/20/Intellij/Debug%E8%BF%BD%E8%B8%AA/debug5.png" class="">
</li>
<li><p>快捷键F8，代码向下执行一行,第九行执行完毕，执行到第10行（第10行还未执行）</p>
<img data-src="/2020/04/20/Intellij/Debug%E8%BF%BD%E8%B8%AA/debug6.png" class="">
</li>
<li><p>切换到控制台面板，控制台显示 请录入一个字符串： 并且等待键盘录入</p>
<img data-src="/2020/04/20/Intellij/Debug%E8%BF%BD%E8%B8%AA/debug7.png" class="">
</li>
<li><p>快捷键F8，程序继续向后执行，执行键盘录入操作，在控制台录入数据 ababcea</p>
<img data-src="/2020/04/20/Intellij/Debug%E8%BF%BD%E8%B8%AA/debug8.png" class="">

<p>回车之后效果：<img data-src="/2020/04/20/Intellij/Debug%E8%BF%BD%E8%B8%AA/debug9.png" class=""></p>
<p>调试界面效果：<img data-src="/2020/04/20/Intellij/Debug%E8%BF%BD%E8%B8%AA/debug0.png" class=""></p>
</li>
<li><p>此时到达findChar方法，快捷键F7，进入方法findChar</p>
<img data-src="/2020/04/20/Intellij/Debug%E8%BF%BD%E8%B8%AA/debug11.png" class="">
</li>
<li><p>快捷键F8 接续执行，创建了map对象，变量区域显示</p>
<img data-src="/2020/04/20/Intellij/Debug%E8%BF%BD%E8%B8%AA/debug12.png" class="">
</li>
<li><p>快捷键F8 接续执行，进入到循环中，循环变量i为 0,F8再继续执行，就获取到变量c赋值为字符‘a’ 字节值97</p>
<img data-src="/2020/04/20/Intellij/Debug%E8%BF%BD%E8%B8%AA/debug13.png" class="">
</li>
<li><p>快捷键F8 接续执行，进入到判断语句中，因为该字符 不在Map集合键集中，再按F8执行，进入该判断中</p>
<img data-src="/2020/04/20/Intellij/Debug%E8%BF%BD%E8%B8%AA/debug14.png" class="">
</li>
<li><p>快捷键F8 接续执行，循环结束，进入下次循环，此时map中已经添加一对儿元素</p>
<img data-src="/2020/04/20/Intellij/Debug%E8%BF%BD%E8%B8%AA/debug15.png" class="">
</li>
<li><p>快捷键F8 接续执行，进入下次循环，再继续上面的操作，我们就可以看到代码每次是如何执行的了</p>
<img data-src="/2020/04/20/Intellij/Debug%E8%BF%BD%E8%B8%AA/debug16.png" class="">
</li>
<li><p>如果不想继续debug,那么可以使用快捷键F9,程序正常执行到结束，程序结果在控制台显示</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Intellij</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Intellij</tag>
      </tags>
  </entry>
  <entry>
    <title>开发工具Intellij-IDEA</title>
    <url>/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/</url>
    <content><![CDATA[<h2 id="开发工具概述"><a href="#开发工具概述" class="headerlink" title="开发工具概述"></a>开发工具概述</h2><p>IDEA是一个专门针对Java的集成开发工具（IDE），由Java语言编写。所以，需要有JRE运行环境并配置好环境变量它可以极大地提升我们的开发效率。可以自动编译，检查错误。在公司中，使用的就是IDEA进行开发。</p>
<p>下载地址：<a href="https://www.jetbrains.com/idea/">https://www.jetbrains.com/idea/</a></p>
<img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402170317121.png" class="" alt="image-20200402170317121">

<img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402170351577.png" class="" alt="image-20200402170351577">

<h2 id="IDEA软件安装"><a href="#IDEA软件安装" class="headerlink" title="IDEA软件安装"></a>IDEA软件安装</h2><p>此软件集成了32位和64位，双击<code>ideaIU-2017.3.2.exe</code>进入安装。</p>
<h3 id="欢迎界面"><a href="#欢迎界面" class="headerlink" title="欢迎界面"></a>欢迎界面</h3><img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402170525471.png" class="" alt="image-20200402170525471">

<h3 id="安装路径"><a href="#安装路径" class="headerlink" title="安装路径"></a>安装路径</h3><img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402170544275.png" class="" alt="image-20200402170544275">

<h3 id="配置安装选项"><a href="#配置安装选项" class="headerlink" title="配置安装选项"></a>配置安装选项</h3><img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402170608817.png" class="" alt="image-20200402170608817">

<h3 id="开始菜单"><a href="#开始菜单" class="headerlink" title="开始菜单"></a>开始菜单</h3><img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402170635952.png" class="" alt="image-20200402170635952">

<h3 id="安装完毕"><a href="#安装完毕" class="headerlink" title="安装完毕"></a>安装完毕</h3><img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402170652435.png" class="" alt="image-20200402170652435">

<h2 id="IDEA首次驱动"><a href="#IDEA首次驱动" class="headerlink" title="IDEA首次驱动"></a>IDEA首次驱动</h2><h3 id="选择不导入任何设置，点击OK"><a href="#选择不导入任何设置，点击OK" class="headerlink" title="选择不导入任何设置，点击OK"></a>选择不导入任何设置，点击OK</h3><img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402170744130.png" class="" alt="image-20200402170744130">

<h3 id="选择Create-New-Project"><a href="#选择Create-New-Project" class="headerlink" title="选择Create New Project"></a>选择Create New Project</h3><img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402170816522.png" class="" alt="image-20200402170816522">

<h3 id="点击new按钮，配置安装的JDK版本"><a href="#点击new按钮，配置安装的JDK版本" class="headerlink" title="点击new按钮，配置安装的JDK版本"></a>点击new按钮，配置安装的JDK版本</h3><img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402170854718.png" class="" alt="image-20200402170854718">

<h3 id="选择自己电脑上的JDK目录，点击确定"><a href="#选择自己电脑上的JDK目录，点击确定" class="headerlink" title="选择自己电脑上的JDK目录，点击确定"></a>选择自己电脑上的JDK目录，点击确定</h3><img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402170941742.png" class="" alt="image-20200402170941742">

<img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402171012124.png" class="" alt="image-20200402171012124">

<h3 id="不使用模板"><a href="#不使用模板" class="headerlink" title="不使用模板"></a>不使用模板</h3><img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402171036407.png" class="" alt="image-20200402171036407">

<h3 id="为工程起名称，这里未测试就用的demo，选择存储的位置，如果选择的没有这个目录，会自动创建"><a href="#为工程起名称，这里未测试就用的demo，选择存储的位置，如果选择的没有这个目录，会自动创建" class="headerlink" title="为工程起名称，这里未测试就用的demo，选择存储的位置，如果选择的没有这个目录，会自动创建"></a>为工程起名称，这里未测试就用的demo，选择存储的位置，如果选择的没有这个目录，会自动创建</h3><blockquote>
<p>首次新建项目时，默认的Project Location路径有问题，如<code>c:\\xxx</code>，正确写法为<code>c:\xxx</code>。更改后不会出现此类问题。</p>
</blockquote>
<img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402171237437.png" class="" alt="image-20200402171237437">

<h3 id="打开一个每日一帖对话框，勾掉每次启动显示，点击close"><a href="#打开一个每日一帖对话框，勾掉每次启动显示，点击close" class="headerlink" title="打开一个每日一帖对话框，勾掉每次启动显示，点击close"></a>打开一个每日一帖对话框，勾掉每次启动显示，点击close</h3><img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402171303668.png" class="" alt="image-20200402171303668">

<h3 id="IDEA的工作界面，我们的项目已经创建好了，如果再新建项目，点击File-new-Project"><a href="#IDEA的工作界面，我们的项目已经创建好了，如果再新建项目，点击File-new-Project" class="headerlink" title="IDEA的工作界面，我们的项目已经创建好了，如果再新建项目，点击File-&gt;new-&gt;Project"></a>IDEA的工作界面，我们的项目已经创建好了，如果再新建项目，点击File-&gt;new-&gt;Project</h3><img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402171333076.png" class="" alt="image-20200402171333076">

<h2 id="IDEA的项目结构"><a href="#IDEA的项目结构" class="headerlink" title="IDEA的项目结构"></a>IDEA的项目结构</h2><img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/02-IDEA%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" class="" alt="02-IDEA的项目结构">

<h3 id="创建包和类"><a href="#创建包和类" class="headerlink" title="创建包和类"></a>创建包和类</h3><p>展开创建的工程，在源代码目录<code>src</code>上，鼠标右键，选择<code>new-&gt;package</code>，输入包名<code>com.itheima.demo</code>（随便你自己）点击确定。</p>
<img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402171834576.png" class="" alt="image-20200402171834576">

<p>右键点击<code>com.itheima.demo</code>，选择<code>Show in Explorer</code>，会发现创建包的目录结构。</p>
<img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402171910062.png" class="" alt="image-20200402171910062">

<p>在创建好的包上，鼠标右键，选择<code>new-&gt;class </code>创建类，键入类名。</p>
<img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402172005458.png" class="" alt="image-20200402172005458">

<p>在代码编辑区，键入主方法，并输出<code>HelloWorld</code></p>
<img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402172028412.png" class="" alt="image-20200402172028412">

<p>运行程序，在代码编辑区鼠标右键，选择<code>Run HelloWorld</code>即可，或在菜单中选择<code>Run-&gt;Run HelloWor1d</code></p>
<img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402172155375.png" class="" alt="image-20200402172155375">

<h2 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h2><p>IDEA工具的默认字体非常小，代码编辑器和控制台的输出字体都需要进行调整。</p>
<ul>
<li>点击菜单栏上的<code>File-&gt;Settings-&gt;Editor-&gt;Font</code>修改字体。</li>
</ul>
<img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402172320302.png" class="" alt="image-20200402172320302">

<img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402172334670.png" class="" alt="image-20200402172334670">

<h2 id="IDEA的项目目录"><a href="#IDEA的项目目录" class="headerlink" title="IDEA的项目目录"></a>IDEA的项目目录</h2><ul>
<li>我们创建的项目，在<code>d:videawork</code>目录的<code>demo</code>下<ul>
<li><code>.idea</code>目录和<code>demo.iml</code>和我们开发无关，是IDEA工具自己使用的</li>
<li><code>out</code>目录是存储编译后的<code>.class</code>文件</li>
<li><code>src</code>目录是存储我们编写的<code>.java</code>源文件</li>
</ul>
</li>
</ul>
<img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402172453930.png" class="" alt="image-20200402172453930">

<h2 id="IDEA常用快捷键"><a href="#IDEA常用快捷键" class="headerlink" title="IDEA常用快捷键"></a>IDEA常用快捷键</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>Alt+Enter</code></td>
<td>导入包，自动修正代码</td>
</tr>
<tr>
<td><code>Ctrl+Y</code></td>
<td>删除光标所在行</td>
</tr>
<tr>
<td><code>Ctrl+D</code></td>
<td>复制光标所在行的内容，插入光标位置下面</td>
</tr>
<tr>
<td><code>Ctrl+Alt+L</code></td>
<td>格式化代码</td>
</tr>
<tr>
<td><code>Ctrl+/</code></td>
<td>单行注释</td>
</tr>
<tr>
<td><code>Ctrl+Shift+/</code></td>
<td>选中代码注释，多行注释，再按取消注释</td>
</tr>
<tr>
<td><code>Alt+Ins</code></td>
<td>自动生成代码，toString，get，set等方法</td>
</tr>
<tr>
<td><code>Alt+Shift+上下箭头</code></td>
<td>移动当前代码行</td>
</tr>
</tbody></table>
<h2 id="IDEA修改快捷键"><a href="#IDEA修改快捷键" class="headerlink" title="IDEA修改快捷键"></a>IDEA修改快捷键</h2><p>在IDEA工具中，<code>ctrl+空格</code>的快捷键，可以帮助我们补全代码，但是这个快捷键和Windows中的输入法切换快捷键冲突，需要修改IDEA中的快捷键。</p>
<p><code>File-&gt;Settings-&gt;keymap-&gt;Main menu-&gt;code-&gt;Completion-&gt;Basic</code></p>
<img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402173148296.png" class="" alt="image-20200402173148296">

<p>双击<code>Basic-&gt;remove-&gt;Ctrl+空格</code></p>
<img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402173230646.png" class="" alt="image-20200402173230646">

<p>再双击<code>Basic-&gt;Add Keyboard-&gt;输入 Alt+/-&gt;点击OK</code></p>
<img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402173336235.png" class="" alt="image-20200402173336235">

<h2 id="IDEA导入和关闭项目"><a href="#IDEA导入和关闭项目" class="headerlink" title="IDEA导入和关闭项目"></a>IDEA导入和关闭项目</h2><p>关闭IDEA中已经存在的项目，<code>File-&gt;Close Project</code></p>
<img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402173432324.png" class="" alt="image-20200402173432324">

<p><code>File-&gt;Close Project</code>这时IDEA回到了刚启动界面，点击项目上的<code>x</code>，IDEA中就没有这个项目了</p>
<img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402173507196.png" class="" alt="image-20200402173507196">

<p>在IDEA启界面上，点击<code>OPEN</code>，选择项目目录即可</p>
<img data-src="/2020/03/21/Intellij/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Intellij-IDEA/image-20200402173526958.png" class="" alt="image-20200402173526958">

<blockquote>
<p>若想通过IDEA同时开多个项目，点击OPEN打开项目时，点击New Window按钮</p>
</blockquote>




]]></content>
      <categories>
        <category>Intellij</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Intellij</tag>
      </tags>
  </entry>
  <entry>
    <title>代理Google站点</title>
    <url>/2024/06/24/cloudflare/%E4%BB%A3%E7%90%86Google%E7%AB%99%E7%82%B9/</url>
    <content><![CDATA[<h2 id="创建-Worker"><a href="#创建-Worker" class="headerlink" title="创建 Worker"></a>创建 Worker</h2><p>首先，登录 Cloudflare，切换至Workers &amp; Pages菜单，点击Create Application按钮：</p>
<img data-src="/2024/06/24/cloudflare/%E4%BB%A3%E7%90%86Google%E7%AB%99%E7%82%B9/image.png" class="" alt="alt text">

<p>然后，点击Create Worker按钮新建一个 Worker：</p>
<img data-src="/2024/06/24/cloudflare/%E4%BB%A3%E7%90%86Google%E7%AB%99%E7%82%B9/image-1.png" class="" alt="alt text">

<p>接着，设置一个三级域名 g.harrisonwang.workers.dev，点击Deploy按钮：</p>
<img data-src="/2024/06/24/cloudflare/%E4%BB%A3%E7%90%86Google%E7%AB%99%E7%82%B9/image-2.png" class="" alt="alt text">

<p>再接着，我们点击Edit code按钮编辑代码：</p>
<img data-src="/2024/06/24/cloudflare/%E4%BB%A3%E7%90%86Google%E7%AB%99%E7%82%B9/image-3.png" class="" alt="alt text">

<p>最后，粘贴以下代码片段后，点击Save and Deploy完成部署，然后通过域名 g.harrisonwang.workers.dev 访问镜像站：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反代目标网站</span></span><br><span class="line"><span class="keyword">const</span> upstream = <span class="string">&#x27;ipv6.google.com.hk&#x27;</span></span><br><span class="line"><span class="keyword">const</span> upstream_v4 = <span class="string">&#x27;www.google.com.hk&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问区域黑名单（按需设置）.</span></span><br><span class="line"><span class="keyword">const</span> blocked_region = [<span class="string">&#x27;TK&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源重定向</span></span><br><span class="line"><span class="keyword">const</span> replace_dict = &#123;</span><br><span class="line">  <span class="attr">$upstream</span>: <span class="string">&#x27;$custom_domain&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;www.google.com/&#x27;</span>: <span class="string">&#x27;g.wss.so/&#x27;</span>, <span class="comment">//填入你的子域名</span></span><br><span class="line">  <span class="string">&#x27;gstatic.com&#x27;</span>: <span class="string">&#x27;gstatic.cn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;ajax.googleapis.com&#x27;</span>: <span class="string">&#x27;ajax.lug.ustc.edu.cn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;fonts.googleapis.com&#x27;</span>: <span class="string">&#x27;fonts.googleapis.cn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;themes.googleusercontent.com&#x27;</span>: <span class="string">&#x27;google-themes.lug.ustc.edu.cn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;www.gravatar.com/avatar&#x27;</span>: <span class="string">&#x27;dn-qiniu-avatar.qbox.me/avatar&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;www.google.co.jp&#x27;</span>: <span class="string">&#x27;$custom_domain&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;www.google.com.sg&#x27;</span>: <span class="string">&#x27;$custom_domain&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;books.google.com.hk&#x27;</span>: <span class="string">&#x27;$custom_domain&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;books.google.co.jp&#x27;</span>: <span class="string">&#x27;$custom_domain&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;books.google.com.sg&#x27;</span>: <span class="string">&#x27;$custom_domain&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;maps.google.com.hk&#x27;</span>: <span class="string">&#x27;$custom_domain&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;maps.google.co.jp&#x27;</span>: <span class="string">&#x27;$custom_domain&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;maps.google.com.sg&#x27;</span>: <span class="string">&#x27;$custom_domain&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;maps.google.com&#x27;</span>: <span class="string">&#x27;$custom_domain&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;books.google.com&#x27;</span>: <span class="string">&#x27;$custom_domain&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addEventListener</span>(<span class="string">&#x27;fetch&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  event.<span class="title function_">respondWith</span>(<span class="title function_">fetchAndApply</span>(event.<span class="property">request</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchAndApply</span>(<span class="params">request</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> region = request.<span class="property">headers</span>.<span class="title function_">get</span>(<span class="string">&#x27;cf-ipcountry&#x27;</span>).<span class="title function_">toUpperCase</span>()</span><br><span class="line"><span class="comment">//   const ip_address = request.headers.get(&#x27;cf-connecting-ip&#x27;)</span></span><br><span class="line"><span class="comment">//   const user_agent = request.headers.get(&#x27;user-agent&#x27;)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> response = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(request.<span class="property">url</span>)</span><br><span class="line">  <span class="keyword">let</span> url_host = url.<span class="property">host</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (url.<span class="property">protocol</span> == <span class="string">&#x27;http:&#x27;</span>) &#123;</span><br><span class="line">    url.<span class="property">protocol</span> = <span class="string">&#x27;https:&#x27;</span></span><br><span class="line">    response = <span class="title class_">Response</span>.<span class="title function_">redirect</span>(url.<span class="property">href</span>)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查是否为图片搜索</span></span><br><span class="line">  <span class="keyword">var</span> key = url.<span class="property">href</span></span><br><span class="line">  <span class="keyword">var</span> ikey1 = <span class="string">&#x27;tbm=isch&#x27;</span></span><br><span class="line">  <span class="keyword">var</span> ikey2 = <span class="string">&#x27;/img&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> ((key.<span class="title function_">search</span>(ikey1) == -<span class="number">1</span>) &amp;&amp; (key.<span class="title function_">search</span>(ikey2) == -<span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> upstream_domain = upstream</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> upstream_domain = upstream_v4</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  url.<span class="property">host</span> = upstream_domain</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (blocked_region.<span class="title function_">includes</span>(region)) &#123;</span><br><span class="line">    response = <span class="keyword">new</span> <span class="title class_">Response</span>(</span><br><span class="line">      <span class="string">&#x27;Access denied: WorkersProxy is not available in your region yet.&#x27;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="number">403</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> method = request.<span class="property">method</span></span><br><span class="line">    <span class="keyword">let</span> request_headers = request.<span class="property">headers</span></span><br><span class="line">    <span class="keyword">let</span> new_request_headers = <span class="keyword">new</span> <span class="title class_">Headers</span>(request_headers)</span><br><span class="line"></span><br><span class="line">    new_request_headers.<span class="title function_">set</span>(<span class="string">&#x27;Host&#x27;</span>, upstream_domain)</span><br><span class="line">    new_request_headers.<span class="title function_">set</span>(<span class="string">&#x27;Referer&#x27;</span>, url.<span class="property">href</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> original_response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url.<span class="property">href</span>, &#123;</span><br><span class="line">      <span class="attr">method</span>: method,</span><br><span class="line">      <span class="attr">headers</span>: new_request_headers,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> original_response_clone = original_response.<span class="title function_">clone</span>()</span><br><span class="line">    <span class="keyword">let</span> original_text = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> response_headers = original_response.<span class="property">headers</span></span><br><span class="line">    <span class="keyword">let</span> new_response_headers = <span class="keyword">new</span> <span class="title class_">Headers</span>(response_headers)</span><br><span class="line">    <span class="keyword">let</span> status = original_response.<span class="property">status</span></span><br><span class="line"></span><br><span class="line">    new_response_headers.<span class="title function_">set</span>(<span class="string">&#x27;cache-control&#x27;</span>, <span class="string">&#x27;public, max-age=14400&#x27;</span>)</span><br><span class="line">    new_response_headers.<span class="title function_">set</span>(<span class="string">&#x27;access-control-allow-origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">    new_response_headers.<span class="title function_">set</span>(<span class="string">&#x27;access-control-allow-credentials&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">    new_response_headers.<span class="title function_">delete</span>(<span class="string">&#x27;content-security-policy&#x27;</span>)</span><br><span class="line">    new_response_headers.<span class="title function_">delete</span>(<span class="string">&#x27;content-security-policy-report-only&#x27;</span>)</span><br><span class="line">    new_response_headers.<span class="title function_">delete</span>(<span class="string">&#x27;clear-site-data&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> content_type = new_response_headers.<span class="title function_">get</span>(<span class="string">&#x27;content-type&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (content_type.<span class="title function_">includes</span>(<span class="string">&#x27;text/html&#x27;</span>) &amp;&amp; content_type.<span class="title function_">includes</span>(<span class="string">&#x27;UTF-8&#x27;</span>)) &#123;</span><br><span class="line">      <span class="comment">// &amp;&amp; content_type.includes(&#x27;UTF-8&#x27;)</span></span><br><span class="line">      original_text = <span class="keyword">await</span> <span class="title function_">replace_response_text</span>(</span><br><span class="line">        original_response_clone,</span><br><span class="line">        upstream_domain,</span><br><span class="line">        url_host</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      original_text = original_response_clone.<span class="property">body</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response = <span class="keyword">new</span> <span class="title class_">Response</span>(original_text, &#123;</span><br><span class="line">      status,</span><br><span class="line">      <span class="attr">headers</span>: new_response_headers,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">replace_response_text</span>(<span class="params">response, upstream_domain, host_name</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> text = <span class="keyword">await</span> response.<span class="title function_">text</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> i, j</span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> replace_dict) &#123;</span><br><span class="line">    j = replace_dict[i]</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="string">&#x27;$upstream&#x27;</span>) &#123;</span><br><span class="line">      i = upstream_domain</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="string">&#x27;$custom_domain&#x27;</span>) &#123;</span><br><span class="line">      i = host_name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == <span class="string">&#x27;$upstream&#x27;</span>) &#123;</span><br><span class="line">      j = upstream_domain</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="string">&#x27;$custom_domain&#x27;</span>) &#123;</span><br><span class="line">      j = host_name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> re = <span class="keyword">new</span> <span class="title class_">RegExp</span>(i, <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">    text = text.<span class="title function_">replace</span>(re, j)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> text</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>记得将 ‘<a href="http://www.google.com/">www.google.com/</a>‘: ‘g.wss.so&#x2F;‘, 此处的 g.wss.so 替换为你的子域名。</p>
</blockquote>
<p>至此，代理 Google 站点已完成，我们任意搜索输入一个关键字 strapi，搜索结果如下图图所示。但是由于国内 workers.dev 域名的 DNS 已污染导致无法访问，所以需要绑定一个自定义域名来绕过该问题。</p>
<img data-src="/2024/06/24/cloudflare/%E4%BB%A3%E7%90%86Google%E7%AB%99%E7%82%B9/image-4.png" class="" alt="alt text">

<h2 id="绑定自定义域名"><a href="#绑定自定义域名" class="headerlink" title="绑定自定义域名"></a>绑定自定义域名</h2><p>首先，点击Add Custom Domain添加一个自定义域名：</p>
<img data-src="/2024/06/24/cloudflare/%E4%BB%A3%E7%90%86Google%E7%AB%99%E7%82%B9/image-5.png" class="" alt="alt text">

<p>然后，输入要绑定自定义域名如 g.wss.so，点击Add Custom Domain绑定：</p>
<img data-src="/2024/06/24/cloudflare/%E4%BB%A3%E7%90%86Google%E7%AB%99%E7%82%B9/image-6.png" class="" alt="alt text">

<p>最后，等待 DNS 解析生效，然后使用 g.wss.so 域名访问：</p>
<img data-src="/2024/06/24/cloudflare/%E4%BB%A3%E7%90%86Google%E7%AB%99%E7%82%B9/image-7.png" class="" alt="alt text">

]]></content>
      <categories>
        <category>cloudflare</category>
      </categories>
      <tags>
        <tag>cloudflare</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装</title>
    <url>/2024/04/08/docker/Docker%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="使用官方安装脚本自动安装"><a href="#使用官方安装脚本自动安装" class="headerlink" title="使用官方安装脚本自动安装"></a>使用官方安装脚本自动安装</h2><p>安装命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure>

<p>也可以使用国内 daocloud 一键安装命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/docker | sh</span><br></pre></td></tr></table></figure>

<h2 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h2><h3 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                 docker-client \</span><br><span class="line">                 docker-client-latest \</span><br><span class="line">                 docker-common \</span><br><span class="line">                 docker-latest \</span><br><span class="line">                 docker-latest-logrotate \</span><br><span class="line">                 docker-logrotate \</span><br><span class="line">                 docker-engine</span><br></pre></td></tr></table></figure>

<h3 id="使用-Docker-仓库进行安装"><a href="#使用-Docker-仓库进行安装" class="headerlink" title="使用 Docker 仓库进行安装"></a>使用 Docker 仓库进行安装</h3><p>在新主机上首次安装 Docker Engine-Community 之前，需要设置 Docker 仓库。之后，您可以从仓库安装和更新 Docker。</p>
<h4 id="设置仓库"><a href="#设置仓库" class="headerlink" title="设置仓库"></a>设置仓库</h4><p>安装所需的软件包。yum-utils 提供了 yum-config-manager ，并且 device mapper 存储驱动程序需要 device-mapper-persistent-data 和 lvm2。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure>

<p>使用以下命令来设置稳定的仓库。</p>
<h5 id="使用官方源地址（比较慢）"><a href="#使用官方源地址（比较慢）" class="headerlink" title="使用官方源地址（比较慢）"></a>使用官方源地址（比较慢）</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<h5 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<h5 id="清华大学源"><a href="#清华大学源" class="headerlink" title="清华大学源"></a>清华大学源</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<h3 id="安装-Docker-Engine-Community"><a href="#安装-Docker-Engine-Community" class="headerlink" title="安装 Docker Engine-Community"></a>安装 Docker Engine-Community</h3><p>安装</p>
<p>最新版本的 Docker Engine-Community 和 containerd，或者转到下一步安装特定版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<p>如果提示您接受 GPG 密钥，请选是。</p>
<blockquote>
<p><strong>有多个 Docker 仓库吗？</strong></p>
<p>如果启用了多个 Docker 仓库，则在未在 yum install 或 yum update 命令中指定版本的情况下，进行的安装或更新将始终安装最高版本，这可能不适合您的稳定性需求。</p>
</blockquote>
<p>Docker 安装完默认未启动。并且已经创建好 docker 用户组，但该用户组下没有用户。</p>
<p><strong>要安装特定版本的 Docker Engine-Community，请在存储库中列出可用版本，然后选择并安装：</strong></p>
<p>1、列出并排序您存储库中可用的版本。此示例按版本号（从高到低）对结果进行排序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | <span class="built_in">sort</span> -r</span><br><span class="line"></span><br><span class="line">docker-ce.x86_64  3:18.09.1-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64  3:18.09.0-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64  18.06.1.ce-3.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64  18.06.0.ce-3.el7                    docker-ce-stable</span><br></pre></td></tr></table></figure>

<p>2、通过其完整的软件包名称安装特定版本，该软件包名称是软件包名称（docker-ce）加上版本字符串（第二列），从第一个冒号（:）一直到第一个连字符，并用连字符（-）分隔。例如：docker-ce-18.09.1。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io</span><br></pre></td></tr></table></figure>

<p>启动 Docker。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<p>通过运行 hello-world 映像来验证是否正确安装了 Docker Engine-Community 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>

<h3 id="卸载-docker"><a href="#卸载-docker" class="headerlink" title="卸载 docker"></a>卸载 docker</h3><p>删除安装包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove docker-ce</span><br></pre></td></tr></table></figure>

<p>删除镜像、容器、配置文件等内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /var/lib/docker</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装Redis</title>
    <url>/2024/06/25/docker/Docker%E5%AE%89%E8%A3%85Redis/</url>
    <content><![CDATA[<h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure>

<h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/redis/&#123;conf,data&#125;</span><br><span class="line">vim ~/redis/conf/redis.conf</span><br></pre></td></tr></table></figure>

<p>把下面的代码粘贴到redis.conf中即（该配置已经#daemonize yes，和设置requirepass 123456）</p>
<h3 id="完整redis-conf"><a href="#完整redis-conf" class="headerlink" title="完整redis.conf"></a>完整redis.conf</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Redis configuration file example.</span><br><span class="line">#</span><br><span class="line"># Note that in order to read the configuration file, Redis must be</span><br><span class="line"># started with the file path as first argument:</span><br><span class="line">#</span><br><span class="line"># ./redis-server /path/to/redis.conf</span><br><span class="line"> </span><br><span class="line"># Note on units: when memory size is needed, it is possible to specify</span><br><span class="line"># it in the usual form of 1k 5GB 4M and so forth:</span><br><span class="line">#</span><br><span class="line"># 1k =&gt; 1000 bytes</span><br><span class="line"># 1kb =&gt; 1024 bytes</span><br><span class="line"># 1m =&gt; 1000000 bytes</span><br><span class="line"># 1mb =&gt; 1024*1024 bytes</span><br><span class="line"># 1g =&gt; 1000000000 bytes</span><br><span class="line"># 1gb =&gt; 1024*1024*1024 bytes</span><br><span class="line">#</span><br><span class="line"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span><br><span class="line"> </span><br><span class="line">################################## INCLUDES ###################################</span><br><span class="line"> </span><br><span class="line"># Include one or more other config files here.  This is useful if you</span><br><span class="line"># have a standard template that goes to all Redis servers but also need</span><br><span class="line"># to customize a few per-server settings.  Include files can include</span><br><span class="line"># other files, so use this wisely.</span><br><span class="line">#</span><br><span class="line"># Notice option &quot;include&quot; won&#x27;t be rewritten by command &quot;CONFIG REWRITE&quot;</span><br><span class="line"># from admin or Redis Sentinel. Since Redis always uses the last processed</span><br><span class="line"># line as value of a configuration directive, you&#x27;d better put includes</span><br><span class="line"># at the beginning of this file to avoid overwriting config change at runtime.</span><br><span class="line">#</span><br><span class="line"># If instead you are interested in using includes to override configuration</span><br><span class="line"># options, it is better to use include as the last line.</span><br><span class="line">#</span><br><span class="line"># include /path/to/local.conf</span><br><span class="line"># include /path/to/other.conf</span><br><span class="line"> </span><br><span class="line">################################## MODULES #####################################</span><br><span class="line"> </span><br><span class="line"># Load modules at startup. If the server is not able to load modules</span><br><span class="line"># it will abort. It is possible to use multiple loadmodule directives.</span><br><span class="line">#</span><br><span class="line"># loadmodule /path/to/my_module.so</span><br><span class="line"># loadmodule /path/to/other_module.so</span><br><span class="line"> </span><br><span class="line">################################## NETWORK #####################################</span><br><span class="line"> </span><br><span class="line"># By default, if no &quot;bind&quot; configuration directive is specified, Redis listens</span><br><span class="line"># for connections from all the network interfaces available on the server.</span><br><span class="line"># It is possible to listen to just one or multiple selected interfaces using</span><br><span class="line"># the &quot;bind&quot; configuration directive, followed by one or more IP addresses.</span><br><span class="line">#</span><br><span class="line"># Examples:</span><br><span class="line">#</span><br><span class="line"># bind 192.168.1.100 10.0.0.1</span><br><span class="line"># bind 127.0.0.1 ::1</span><br><span class="line">#</span><br><span class="line"># ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the</span><br><span class="line"># internet, binding to all the interfaces is dangerous and will expose the</span><br><span class="line"># instance to everybody on the internet. So by default we uncomment the</span><br><span class="line"># following bind directive, that will force Redis to listen only into</span><br><span class="line"># the IPv4 lookback interface address (this means Redis will be able to</span><br><span class="line"># accept connections only from clients running into the same computer it</span><br><span class="line"># is running).</span><br><span class="line">#</span><br><span class="line"># IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES</span><br><span class="line"># JUST COMMENT THE FOLLOWING LINE.</span><br><span class="line"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">bind *</span><br><span class="line"> </span><br><span class="line"># Protected mode is a layer of security protection, in order to avoid that</span><br><span class="line"># Redis instances left open on the internet are accessed and exploited.</span><br><span class="line">#</span><br><span class="line"># When protected mode is on and if:</span><br><span class="line">#</span><br><span class="line"># 1) The server is not binding explicitly to a set of addresses using the</span><br><span class="line">#    &quot;bind&quot; directive.</span><br><span class="line"># 2) No password is configured.</span><br><span class="line">#</span><br><span class="line"># The server only accepts connections from clients connecting from the</span><br><span class="line"># IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain</span><br><span class="line"># sockets.</span><br><span class="line">#</span><br><span class="line"># By default protected mode is enabled. You should disable it only if</span><br><span class="line"># you are sure you want clients from other hosts to connect to Redis</span><br><span class="line"># even if no authentication is configured, nor a specific set of interfaces</span><br><span class="line"># are explicitly listed using the &quot;bind&quot; directive.</span><br><span class="line">protected-mode yes</span><br><span class="line"> </span><br><span class="line"># Accept connections on the specified port, default is 6379 (IANA #815344).</span><br><span class="line"># If port 0 is specified Redis will not listen on a TCP socket.</span><br><span class="line">port 6379</span><br><span class="line"> </span><br><span class="line"># TCP listen() backlog.</span><br><span class="line">#</span><br><span class="line"># In high requests-per-second environments you need an high backlog in order</span><br><span class="line"># to avoid slow clients connections issues. Note that the Linux kernel</span><br><span class="line"># will silently truncate it to the value of /proc/sys/net/core/somaxconn so</span><br><span class="line"># make sure to raise both the value of somaxconn and tcp_max_syn_backlog</span><br><span class="line"># in order to get the desired effect.</span><br><span class="line">tcp-backlog 511</span><br><span class="line"> </span><br><span class="line"># Unix socket.</span><br><span class="line">#</span><br><span class="line"># Specify the path for the Unix socket that will be used to listen for</span><br><span class="line"># incoming connections. There is no default, so Redis will not listen</span><br><span class="line"># on a unix socket when not specified.</span><br><span class="line">#</span><br><span class="line"># unixsocket /tmp/redis.sock</span><br><span class="line"># unixsocketperm 700</span><br><span class="line"> </span><br><span class="line"># Close the connection after a client is idle for N seconds (0 to disable)</span><br><span class="line">timeout 0</span><br><span class="line"> </span><br><span class="line"># TCP keepalive.</span><br><span class="line">#</span><br><span class="line"># If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence</span><br><span class="line"># of communication. This is useful for two reasons:</span><br><span class="line">#</span><br><span class="line"># 1) Detect dead peers.</span><br><span class="line"># 2) Take the connection alive from the point of view of network</span><br><span class="line">#    equipment in the middle.</span><br><span class="line">#</span><br><span class="line"># On Linux, the specified value (in seconds) is the period used to send ACKs.</span><br><span class="line"># Note that to close the connection the double of the time is needed.</span><br><span class="line"># On other kernels the period depends on the kernel configuration.</span><br><span class="line">#</span><br><span class="line"># A reasonable value for this option is 300 seconds, which is the new</span><br><span class="line"># Redis default starting with Redis 3.2.1.</span><br><span class="line">tcp-keepalive 300</span><br><span class="line"> </span><br><span class="line">################################# GENERAL #####################################</span><br><span class="line"> </span><br><span class="line"># By default Redis does not run as a daemon. Use &#x27;yes&#x27; if you need it.</span><br><span class="line"># Note that Redis will write a pid file in /var/run/redis.pid when daemonized.</span><br><span class="line">#daemonize yes</span><br><span class="line"> </span><br><span class="line"># If you run Redis from upstart or systemd, Redis can interact with your</span><br><span class="line"># supervision tree. Options:</span><br><span class="line">#   supervised no      - no supervision interaction</span><br><span class="line">#   supervised upstart - signal upstart by putting Redis into SIGSTOP mode</span><br><span class="line">#   supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET</span><br><span class="line">#   supervised auto    - detect upstart or systemd method based on</span><br><span class="line">#                        UPSTART_JOB or NOTIFY_SOCKET environment variables</span><br><span class="line"># Note: these supervision methods only signal &quot;process is ready.&quot;</span><br><span class="line">#       They do not enable continuous liveness pings back to your supervisor.</span><br><span class="line">supervised no</span><br><span class="line"> </span><br><span class="line"># If a pid file is specified, Redis writes it where specified at startup</span><br><span class="line"># and removes it at exit.</span><br><span class="line">#</span><br><span class="line"># When the server runs non daemonized, no pid file is created if none is</span><br><span class="line"># specified in the configuration. When the server is daemonized, the pid file</span><br><span class="line"># is used even if not specified, defaulting to &quot;/var/run/redis.pid&quot;.</span><br><span class="line">#</span><br><span class="line"># Creating a pid file is best effort: if Redis is not able to create it</span><br><span class="line"># nothing bad happens, the server will start and run normally.</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line"> </span><br><span class="line"># Specify the server verbosity level.</span><br><span class="line"># This can be one of:</span><br><span class="line"># debug (a lot of information, useful for development/testing)</span><br><span class="line"># verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="line"># notice (moderately verbose, what you want in production probably)</span><br><span class="line"># warning (only very important / critical messages are logged)</span><br><span class="line">loglevel notice</span><br><span class="line"> </span><br><span class="line"># Specify the log file name. Also the empty string can be used to force</span><br><span class="line"># Redis to log on the standard output. Note that if you use standard</span><br><span class="line"># output for logging but daemonize, logs will be sent to /dev/null</span><br><span class="line">logfile &quot;&quot;</span><br><span class="line"> </span><br><span class="line"># To enable logging to the system logger, just set &#x27;syslog-enabled&#x27; to yes,</span><br><span class="line"># and optionally update the other syslog parameters to suit your needs.</span><br><span class="line"># syslog-enabled no</span><br><span class="line"> </span><br><span class="line"># Specify the syslog identity.</span><br><span class="line"># syslog-ident redis</span><br><span class="line"> </span><br><span class="line"># Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.</span><br><span class="line"># syslog-facility local0</span><br><span class="line"> </span><br><span class="line"># Set the number of databases. The default database is DB 0, you can select</span><br><span class="line"># a different one on a per-connection basis using SELECT &lt;dbid&gt; where</span><br><span class="line"># dbid is a number between 0 and &#x27;databases&#x27;-1</span><br><span class="line">databases 16</span><br><span class="line"> </span><br><span class="line"># By default Redis shows an ASCII art logo only when started to log to the</span><br><span class="line"># standard output and if the standard output is a TTY. Basically this means</span><br><span class="line"># that normally a logo is displayed only in interactive sessions.</span><br><span class="line">#</span><br><span class="line"># However it is possible to force the pre-4.0 behavior and always show a</span><br><span class="line"># ASCII art logo in startup logs by setting the following option to yes.</span><br><span class="line">always-show-logo yes</span><br><span class="line"> </span><br><span class="line">################################ SNAPSHOTTING  ################################</span><br><span class="line">#</span><br><span class="line"># Save the DB on disk:</span><br><span class="line">#</span><br><span class="line">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#</span><br><span class="line">#   Will save the DB if both the given number of seconds and the given</span><br><span class="line">#   number of write operations against the DB occurred.</span><br><span class="line">#</span><br><span class="line">#   In the example below the behaviour will be to save:</span><br><span class="line">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">#   after 60 sec if at least 10000 keys changed</span><br><span class="line">#</span><br><span class="line">#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="line">#</span><br><span class="line">#   It is also possible to remove all the previously configured save</span><br><span class="line">#   points by adding a save directive with a single empty string argument</span><br><span class="line">#   like in the following example:</span><br><span class="line">#</span><br><span class="line">#   save &quot;&quot;</span><br><span class="line"> </span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"> </span><br><span class="line"># By default Redis will stop accepting writes if RDB snapshots are enabled</span><br><span class="line"># (at least one save point) and the latest background save failed.</span><br><span class="line"># This will make the user aware (in a hard way) that data is not persisting</span><br><span class="line"># on disk properly, otherwise chances are that no one will notice and some</span><br><span class="line"># disaster will happen.</span><br><span class="line">#</span><br><span class="line"># If the background saving process will start working again Redis will</span><br><span class="line"># automatically allow writes again.</span><br><span class="line">#</span><br><span class="line"># However if you have setup your proper monitoring of the Redis server</span><br><span class="line"># and persistence, you may want to disable this feature so that Redis will</span><br><span class="line"># continue to work as usual even if there are problems with disk,</span><br><span class="line"># permissions, and so forth.</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"> </span><br><span class="line"># Compress string objects using LZF when dump .rdb databases?</span><br><span class="line"># For default that&#x27;s set to &#x27;yes&#x27; as it&#x27;s almost always a win.</span><br><span class="line"># If you want to save some CPU in the saving child set it to &#x27;no&#x27; but</span><br><span class="line"># the dataset will likely be bigger if you have compressible values or keys.</span><br><span class="line">rdbcompression yes</span><br><span class="line"> </span><br><span class="line"># Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span><br><span class="line"># This makes the format more resistant to corruption but there is a performance</span><br><span class="line"># hit to pay (around 10%) when saving and loading RDB files, so you can disable it</span><br><span class="line"># for maximum performances.</span><br><span class="line">#</span><br><span class="line"># RDB files created with checksum disabled have a checksum of zero that will</span><br><span class="line"># tell the loading code to skip the check.</span><br><span class="line">rdbchecksum yes</span><br><span class="line"> </span><br><span class="line"># The filename where to dump the DB</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"> </span><br><span class="line"># The working directory.</span><br><span class="line">#</span><br><span class="line"># The DB will be written inside this directory, with the filename specified</span><br><span class="line"># above using the &#x27;dbfilename&#x27; configuration directive.</span><br><span class="line">#</span><br><span class="line"># The Append Only File will also be created inside this directory.</span><br><span class="line">#</span><br><span class="line"># Note that you must specify a directory here, not a file name.</span><br><span class="line">dir ./</span><br><span class="line"> </span><br><span class="line">################################# REPLICATION #################################</span><br><span class="line"> </span><br><span class="line"># Master-Slave replication. Use slaveof to make a Redis instance a copy of</span><br><span class="line"># another Redis server. A few things to understand ASAP about Redis replication.</span><br><span class="line">#</span><br><span class="line"># 1) Redis replication is asynchronous, but you can configure a master to</span><br><span class="line">#    stop accepting writes if it appears to be not connected with at least</span><br><span class="line">#    a given number of slaves.</span><br><span class="line"># 2) Redis slaves are able to perform a partial resynchronization with the</span><br><span class="line">#    master if the replication link is lost for a relatively small amount of</span><br><span class="line">#    time. You may want to configure the replication backlog size (see the next</span><br><span class="line">#    sections of this file) with a sensible value depending on your needs.</span><br><span class="line"># 3) Replication is automatic and does not need user intervention. After a</span><br><span class="line">#    network partition slaves automatically try to reconnect to masters</span><br><span class="line">#    and resynchronize with them.</span><br><span class="line">#</span><br><span class="line"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"> </span><br><span class="line"># If the master is password protected (using the &quot;requirepass&quot; configuration</span><br><span class="line"># directive below) it is possible to tell the slave to authenticate before</span><br><span class="line"># starting the replication synchronization process, otherwise the master will</span><br><span class="line"># refuse the slave request.</span><br><span class="line">#</span><br><span class="line"># masterauth &lt;master-password&gt;</span><br><span class="line"> </span><br><span class="line"># When a slave loses its connection with the master, or when the replication</span><br><span class="line"># is still in progress, the slave can act in two different ways:</span><br><span class="line">#</span><br><span class="line"># 1) if slave-serve-stale-data is set to &#x27;yes&#x27; (the default) the slave will</span><br><span class="line">#    still reply to client requests, possibly with out of date data, or the</span><br><span class="line">#    data set may just be empty if this is the first synchronization.</span><br><span class="line">#</span><br><span class="line"># 2) if slave-serve-stale-data is set to &#x27;no&#x27; the slave will reply with</span><br><span class="line">#    an error &quot;SYNC with master in progress&quot; to all the kind of commands</span><br><span class="line">#    but to INFO and SLAVEOF.</span><br><span class="line">#</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"> </span><br><span class="line"># You can configure a slave instance to accept writes or not. Writing against</span><br><span class="line"># a slave instance may be useful to store some ephemeral data (because data</span><br><span class="line"># written on a slave will be easily deleted after resync with the master) but</span><br><span class="line"># may also cause problems if clients are writing to it because of a</span><br><span class="line"># misconfiguration.</span><br><span class="line">#</span><br><span class="line"># Since Redis 2.6 by default slaves are read-only.</span><br><span class="line">#</span><br><span class="line"># Note: read only slaves are not designed to be exposed to untrusted clients</span><br><span class="line"># on the internet. It&#x27;s just a protection layer against misuse of the instance.</span><br><span class="line"># Still a read only slave exports by default all the administrative commands</span><br><span class="line"># such as CONFIG, DEBUG, and so forth. To a limited extent you can improve</span><br><span class="line"># security of read only slaves using &#x27;rename-command&#x27; to shadow all the</span><br><span class="line"># administrative / dangerous commands.</span><br><span class="line">slave-read-only yes</span><br><span class="line"> </span><br><span class="line"># Replication SYNC strategy: disk or socket.</span><br><span class="line">#</span><br><span class="line"># -------------------------------------------------------</span><br><span class="line"># WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY</span><br><span class="line"># -------------------------------------------------------</span><br><span class="line">#</span><br><span class="line"># New slaves and reconnecting slaves that are not able to continue the replication</span><br><span class="line"># process just receiving differences, need to do what is called a &quot;full</span><br><span class="line"># synchronization&quot;. An RDB file is transmitted from the master to the slaves.</span><br><span class="line"># The transmission can happen in two different ways:</span><br><span class="line">#</span><br><span class="line"># 1) Disk-backed: The Redis master creates a new process that writes the RDB</span><br><span class="line">#                 file on disk. Later the file is transferred by the parent</span><br><span class="line">#                 process to the slaves incrementally.</span><br><span class="line"># 2) Diskless: The Redis master creates a new process that directly writes the</span><br><span class="line">#              RDB file to slave sockets, without touching the disk at all.</span><br><span class="line">#</span><br><span class="line"># With disk-backed replication, while the RDB file is generated, more slaves</span><br><span class="line"># can be queued and served with the RDB file as soon as the current child producing</span><br><span class="line"># the RDB file finishes its work. With diskless replication instead once</span><br><span class="line"># the transfer starts, new slaves arriving will be queued and a new transfer</span><br><span class="line"># will start when the current one terminates.</span><br><span class="line">#</span><br><span class="line"># When diskless replication is used, the master waits a configurable amount of</span><br><span class="line"># time (in seconds) before starting the transfer in the hope that multiple slaves</span><br><span class="line"># will arrive and the transfer can be parallelized.</span><br><span class="line">#</span><br><span class="line"># With slow disks and fast (large bandwidth) networks, diskless replication</span><br><span class="line"># works better.</span><br><span class="line">repl-diskless-sync no</span><br><span class="line"> </span><br><span class="line"># When diskless replication is enabled, it is possible to configure the delay</span><br><span class="line"># the server waits in order to spawn the child that transfers the RDB via socket</span><br><span class="line"># to the slaves.</span><br><span class="line">#</span><br><span class="line"># This is important since once the transfer starts, it is not possible to serve</span><br><span class="line"># new slaves arriving, that will be queued for the next RDB transfer, so the server</span><br><span class="line"># waits a delay in order to let more slaves arrive.</span><br><span class="line">#</span><br><span class="line"># The delay is specified in seconds, and by default is 5 seconds. To disable</span><br><span class="line"># it entirely just set it to 0 seconds and the transfer will start ASAP.</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"> </span><br><span class="line"># Slaves send PINGs to server in a predefined interval. It&#x27;s possible to change</span><br><span class="line"># this interval with the repl_ping_slave_period option. The default value is 10</span><br><span class="line"># seconds.</span><br><span class="line">#</span><br><span class="line"># repl-ping-slave-period 10</span><br><span class="line"> </span><br><span class="line"># The following option sets the replication timeout for:</span><br><span class="line">#</span><br><span class="line"># 1) Bulk transfer I/O during SYNC, from the point of view of slave.</span><br><span class="line"># 2) Master timeout from the point of view of slaves (data, pings).</span><br><span class="line"># 3) Slave timeout from the point of view of masters (REPLCONF ACK pings).</span><br><span class="line">#</span><br><span class="line"># It is important to make sure that this value is greater than the value</span><br><span class="line"># specified for repl-ping-slave-period otherwise a timeout will be detected</span><br><span class="line"># every time there is low traffic between the master and the slave.</span><br><span class="line">#</span><br><span class="line"># repl-timeout 60</span><br><span class="line"> </span><br><span class="line"># Disable TCP_NODELAY on the slave socket after SYNC?</span><br><span class="line">#</span><br><span class="line"># If you select &quot;yes&quot; Redis will use a smaller number of TCP packets and</span><br><span class="line"># less bandwidth to send data to slaves. But this can add a delay for</span><br><span class="line"># the data to appear on the slave side, up to 40 milliseconds with</span><br><span class="line"># Linux kernels using a default configuration.</span><br><span class="line">#</span><br><span class="line"># If you select &quot;no&quot; the delay for data to appear on the slave side will</span><br><span class="line"># be reduced but more bandwidth will be used for replication.</span><br><span class="line">#</span><br><span class="line"># By default we optimize for low latency, but in very high traffic conditions</span><br><span class="line"># or when the master and slaves are many hops away, turning this to &quot;yes&quot; may</span><br><span class="line"># be a good idea.</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"> </span><br><span class="line"># Set the replication backlog size. The backlog is a buffer that accumulates</span><br><span class="line"># slave data when slaves are disconnected for some time, so that when a slave</span><br><span class="line"># wants to reconnect again, often a full resync is not needed, but a partial</span><br><span class="line"># resync is enough, just passing the portion of data the slave missed while</span><br><span class="line"># disconnected.</span><br><span class="line">#</span><br><span class="line"># The bigger the replication backlog, the longer the time the slave can be</span><br><span class="line"># disconnected and later be able to perform a partial resynchronization.</span><br><span class="line">#</span><br><span class="line"># The backlog is only allocated once there is at least a slave connected.</span><br><span class="line">#</span><br><span class="line"># repl-backlog-size 1mb</span><br><span class="line"> </span><br><span class="line"># After a master has no longer connected slaves for some time, the backlog</span><br><span class="line"># will be freed. The following option configures the amount of seconds that</span><br><span class="line"># need to elapse, starting from the time the last slave disconnected, for</span><br><span class="line"># the backlog buffer to be freed.</span><br><span class="line">#</span><br><span class="line"># Note that slaves never free the backlog for timeout, since they may be</span><br><span class="line"># promoted to masters later, and should be able to correctly &quot;partially</span><br><span class="line"># resynchronize&quot; with the slaves: hence they should always accumulate backlog.</span><br><span class="line">#</span><br><span class="line"># A value of 0 means to never release the backlog.</span><br><span class="line">#</span><br><span class="line"># repl-backlog-ttl 3600</span><br><span class="line"> </span><br><span class="line"># The slave priority is an integer number published by Redis in the INFO output.</span><br><span class="line"># It is used by Redis Sentinel in order to select a slave to promote into a</span><br><span class="line"># master if the master is no longer working correctly.</span><br><span class="line">#</span><br><span class="line"># A slave with a low priority number is considered better for promotion, so</span><br><span class="line"># for instance if there are three slaves with priority 10, 100, 25 Sentinel will</span><br><span class="line"># pick the one with priority 10, that is the lowest.</span><br><span class="line">#</span><br><span class="line"># However a special priority of 0 marks the slave as not able to perform the</span><br><span class="line"># role of master, so a slave with priority of 0 will never be selected by</span><br><span class="line"># Redis Sentinel for promotion.</span><br><span class="line">#</span><br><span class="line"># By default the priority is 100.</span><br><span class="line">slave-priority 100</span><br><span class="line"> </span><br><span class="line"># It is possible for a master to stop accepting writes if there are less than</span><br><span class="line"># N slaves connected, having a lag less or equal than M seconds.</span><br><span class="line">#</span><br><span class="line"># The N slaves need to be in &quot;online&quot; state.</span><br><span class="line">#</span><br><span class="line"># The lag in seconds, that must be &lt;= the specified value, is calculated from</span><br><span class="line"># the last ping received from the slave, that is usually sent every second.</span><br><span class="line">#</span><br><span class="line"># This option does not GUARANTEE that N replicas will accept the write, but</span><br><span class="line"># will limit the window of exposure for lost writes in case not enough slaves</span><br><span class="line"># are available, to the specified number of seconds.</span><br><span class="line">#</span><br><span class="line"># For example to require at least 3 slaves with a lag &lt;= 10 seconds use:</span><br><span class="line">#</span><br><span class="line"># min-slaves-to-write 3</span><br><span class="line"># min-slaves-max-lag 10</span><br><span class="line">#</span><br><span class="line"># Setting one or the other to 0 disables the feature.</span><br><span class="line">#</span><br><span class="line"># By default min-slaves-to-write is set to 0 (feature disabled) and</span><br><span class="line"># min-slaves-max-lag is set to 10.</span><br><span class="line"> </span><br><span class="line"># A Redis master is able to list the address and port of the attached</span><br><span class="line"># slaves in different ways. For example the &quot;INFO replication&quot; section</span><br><span class="line"># offers this information, which is used, among other tools, by</span><br><span class="line"># Redis Sentinel in order to discover slave instances.</span><br><span class="line"># Another place where this info is available is in the output of the</span><br><span class="line"># &quot;ROLE&quot; command of a master.</span><br><span class="line">#</span><br><span class="line"># The listed IP and address normally reported by a slave is obtained</span><br><span class="line"># in the following way:</span><br><span class="line">#</span><br><span class="line">#   IP: The address is auto detected by checking the peer address</span><br><span class="line">#   of the socket used by the slave to connect with the master.</span><br><span class="line">#</span><br><span class="line">#   Port: The port is communicated by the slave during the replication</span><br><span class="line">#   handshake, and is normally the port that the slave is using to</span><br><span class="line">#   list for connections.</span><br><span class="line">#</span><br><span class="line"># However when port forwarding or Network Address Translation (NAT) is</span><br><span class="line"># used, the slave may be actually reachable via different IP and port</span><br><span class="line"># pairs. The following two options can be used by a slave in order to</span><br><span class="line"># report to its master a specific set of IP and port, so that both INFO</span><br><span class="line"># and ROLE will report those values.</span><br><span class="line">#</span><br><span class="line"># There is no need to use both the options if you need to override just</span><br><span class="line"># the port or the IP address.</span><br><span class="line">#</span><br><span class="line"># slave-announce-ip 5.5.5.5</span><br><span class="line"># slave-announce-port 1234</span><br><span class="line"> </span><br><span class="line">################################## SECURITY ###################################</span><br><span class="line"> </span><br><span class="line"># Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other</span><br><span class="line"># commands.  This might be useful in environments in which you do not trust</span><br><span class="line"># others with access to the host running redis-server.</span><br><span class="line">#</span><br><span class="line"># This should stay commented out for backward compatibility and because most</span><br><span class="line"># people do not need auth (e.g. they run their own servers).</span><br><span class="line">#</span><br><span class="line"># Warning: since Redis is pretty fast an outside user can try up to</span><br><span class="line"># 150k passwords per second against a good box. This means that you should</span><br><span class="line"># use a very strong password otherwise it will be very easy to break.</span><br><span class="line">#</span><br><span class="line">requirepass 123456</span><br><span class="line"> </span><br><span class="line"># Command renaming.</span><br><span class="line">#</span><br><span class="line"># It is possible to change the name of dangerous commands in a shared</span><br><span class="line"># environment. For instance the CONFIG command may be renamed into something</span><br><span class="line"># hard to guess so that it will still be available for internal-use tools</span><br><span class="line"># but not available for general clients.</span><br><span class="line">#</span><br><span class="line"># Example:</span><br><span class="line">#</span><br><span class="line"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="line">#</span><br><span class="line"># It is also possible to completely kill a command by renaming it into</span><br><span class="line"># an empty string:</span><br><span class="line">#</span><br><span class="line"># rename-command CONFIG &quot;&quot;</span><br><span class="line">#</span><br><span class="line"># Please note that changing the name of commands that are logged into the</span><br><span class="line"># AOF file or transmitted to slaves may cause problems.</span><br><span class="line"> </span><br><span class="line">################################### CLIENTS ####################################</span><br><span class="line"> </span><br><span class="line"># Set the max number of connected clients at the same time. By default</span><br><span class="line"># this limit is set to 10000 clients, however if the Redis server is not</span><br><span class="line"># able to configure the process file limit to allow for the specified limit</span><br><span class="line"># the max number of allowed clients is set to the current file limit</span><br><span class="line"># minus 32 (as Redis reserves a few file descriptors for internal uses).</span><br><span class="line">#</span><br><span class="line"># Once the limit is reached Redis will close all the new connections sending</span><br><span class="line"># an error &#x27;max number of clients reached&#x27;.</span><br><span class="line">#</span><br><span class="line"># maxclients 10000</span><br><span class="line"> </span><br><span class="line">############################## MEMORY MANAGEMENT ################################</span><br><span class="line"> </span><br><span class="line"># Set a memory usage limit to the specified amount of bytes.</span><br><span class="line"># When the memory limit is reached Redis will try to remove keys</span><br><span class="line"># according to the eviction policy selected (see maxmemory-policy).</span><br><span class="line">#</span><br><span class="line"># If Redis can&#x27;t remove keys according to the policy, or if the policy is</span><br><span class="line"># set to &#x27;noeviction&#x27;, Redis will start to reply with errors to commands</span><br><span class="line"># that would use more memory, like SET, LPUSH, and so on, and will continue</span><br><span class="line"># to reply to read-only commands like GET.</span><br><span class="line">#</span><br><span class="line"># This option is usually useful when using Redis as an LRU or LFU cache, or to</span><br><span class="line"># set a hard memory limit for an instance (using the &#x27;noeviction&#x27; policy).</span><br><span class="line">#</span><br><span class="line"># WARNING: If you have slaves attached to an instance with maxmemory on,</span><br><span class="line"># the size of the output buffers needed to feed the slaves are subtracted</span><br><span class="line"># from the used memory count, so that network problems / resyncs will</span><br><span class="line"># not trigger a loop where keys are evicted, and in turn the output</span><br><span class="line"># buffer of slaves is full with DELs of keys evicted triggering the deletion</span><br><span class="line"># of more keys, and so forth until the database is completely emptied.</span><br><span class="line">#</span><br><span class="line"># In short... if you have slaves attached it is suggested that you set a lower</span><br><span class="line"># limit for maxmemory so that there is some free RAM on the system for slave</span><br><span class="line"># output buffers (but this is not needed if the policy is &#x27;noeviction&#x27;).</span><br><span class="line">#</span><br><span class="line"># maxmemory &lt;bytes&gt;</span><br><span class="line"> </span><br><span class="line"># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span><br><span class="line"># is reached. You can select among five behaviors:</span><br><span class="line">#</span><br><span class="line"># volatile-lru -&gt; Evict using approximated LRU among the keys with an expire set.</span><br><span class="line"># allkeys-lru -&gt; Evict any key using approximated LRU.</span><br><span class="line"># volatile-lfu -&gt; Evict using approximated LFU among the keys with an expire set.</span><br><span class="line"># allkeys-lfu -&gt; Evict any key using approximated LFU.</span><br><span class="line"># volatile-random -&gt; Remove a random key among the ones with an expire set.</span><br><span class="line"># allkeys-random -&gt; Remove a random key, any key.</span><br><span class="line"># volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</span><br><span class="line"># noeviction -&gt; Don&#x27;t evict anything, just return an error on write operations.</span><br><span class="line">#</span><br><span class="line"># LRU means Least Recently Used</span><br><span class="line"># LFU means Least Frequently Used</span><br><span class="line">#</span><br><span class="line"># Both LRU, LFU and volatile-ttl are implemented using approximated</span><br><span class="line"># randomized algorithms.</span><br><span class="line">#</span><br><span class="line"># Note: with any of the above policies, Redis will return an error on write</span><br><span class="line">#       operations, when there are no suitable keys for eviction.</span><br><span class="line">#</span><br><span class="line">#       At the date of writing these commands are: set setnx setex append</span><br><span class="line">#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span><br><span class="line">#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span><br><span class="line">#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span><br><span class="line">#       getset mset msetnx exec sort</span><br><span class="line">#</span><br><span class="line"># The default is:</span><br><span class="line">#</span><br><span class="line"># maxmemory-policy noeviction</span><br><span class="line"> </span><br><span class="line"># LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated</span><br><span class="line"># algorithms (in order to save memory), so you can tune it for speed or</span><br><span class="line"># accuracy. For default Redis will check five keys and pick the one that was</span><br><span class="line"># used less recently, you can change the sample size using the following</span><br><span class="line"># configuration directive.</span><br><span class="line">#</span><br><span class="line"># The default of 5 produces good enough results. 10 Approximates very closely</span><br><span class="line"># true LRU but costs more CPU. 3 is faster but not very accurate.</span><br><span class="line">#</span><br><span class="line"># maxmemory-samples 5</span><br><span class="line"> </span><br><span class="line">############################# LAZY FREEING ####################################</span><br><span class="line"> </span><br><span class="line"># Redis has two primitives to delete keys. One is called DEL and is a blocking</span><br><span class="line"># deletion of the object. It means that the server stops processing new commands</span><br><span class="line"># in order to reclaim all the memory associated with an object in a synchronous</span><br><span class="line"># way. If the key deleted is associated with a small object, the time needed</span><br><span class="line"># in order to execute the DEL command is very small and comparable to most other</span><br><span class="line"># O(1) or O(log_N) commands in Redis. However if the key is associated with an</span><br><span class="line"># aggregated value containing millions of elements, the server can block for</span><br><span class="line"># a long time (even seconds) in order to complete the operation.</span><br><span class="line">#</span><br><span class="line"># For the above reasons Redis also offers non blocking deletion primitives</span><br><span class="line"># such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and</span><br><span class="line"># FLUSHDB commands, in order to reclaim memory in background. Those commands</span><br><span class="line"># are executed in constant time. Another thread will incrementally free the</span><br><span class="line"># object in the background as fast as possible.</span><br><span class="line">#</span><br><span class="line"># DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.</span><br><span class="line"># It&#x27;s up to the design of the application to understand when it is a good</span><br><span class="line"># idea to use one or the other. However the Redis server sometimes has to</span><br><span class="line"># delete keys or flush the whole database as a side effect of other operations.</span><br><span class="line"># Specifically Redis deletes objects independently of a user call in the</span><br><span class="line"># following scenarios:</span><br><span class="line">#</span><br><span class="line"># 1) On eviction, because of the maxmemory and maxmemory policy configurations,</span><br><span class="line">#    in order to make room for new data, without going over the specified</span><br><span class="line">#    memory limit.</span><br><span class="line"># 2) Because of expire: when a key with an associated time to live (see the</span><br><span class="line">#    EXPIRE command) must be deleted from memory.</span><br><span class="line"># 3) Because of a side effect of a command that stores data on a key that may</span><br><span class="line">#    already exist. For example the RENAME command may delete the old key</span><br><span class="line">#    content when it is replaced with another one. Similarly SUNIONSTORE</span><br><span class="line">#    or SORT with STORE option may delete existing keys. The SET command</span><br><span class="line">#    itself removes any old content of the specified key in order to replace</span><br><span class="line">#    it with the specified string.</span><br><span class="line"># 4) During replication, when a slave performs a full resynchronization with</span><br><span class="line">#    its master, the content of the whole database is removed in order to</span><br><span class="line">#    load the RDB file just transfered.</span><br><span class="line">#</span><br><span class="line"># In all the above cases the default is to delete objects in a blocking way,</span><br><span class="line"># like if DEL was called. However you can configure each case specifically</span><br><span class="line"># in order to instead release memory in a non-blocking way like if UNLINK</span><br><span class="line"># was called, using the following configuration directives:</span><br><span class="line"> </span><br><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del no</span><br><span class="line">slave-lazy-flush no</span><br><span class="line"> </span><br><span class="line">############################## APPEND ONLY MODE ###############################</span><br><span class="line"> </span><br><span class="line"># By default Redis asynchronously dumps the dataset on disk. This mode is</span><br><span class="line"># good enough in many applications, but an issue with the Redis process or</span><br><span class="line"># a power outage may result into a few minutes of writes lost (depending on</span><br><span class="line"># the configured save points).</span><br><span class="line">#</span><br><span class="line"># The Append Only File is an alternative persistence mode that provides</span><br><span class="line"># much better durability. For instance using the default data fsync policy</span><br><span class="line"># (see later in the config file) Redis can lose just one second of writes in a</span><br><span class="line"># dramatic event like a server power outage, or a single write if something</span><br><span class="line"># wrong with the Redis process itself happens, but the operating system is</span><br><span class="line"># still running correctly.</span><br><span class="line">#</span><br><span class="line"># AOF and RDB persistence can be enabled at the same time without problems.</span><br><span class="line"># If the AOF is enabled on startup Redis will load the AOF, that is the file</span><br><span class="line"># with the better durability guarantees.</span><br><span class="line">#</span><br><span class="line"># Please check http://redis.io/topics/persistence for more information.</span><br><span class="line"> </span><br><span class="line">appendonly no</span><br><span class="line"> </span><br><span class="line"># The name of the append only file (default: &quot;appendonly.aof&quot;)</span><br><span class="line"> </span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"> </span><br><span class="line"># The fsync() call tells the Operating System to actually write data on disk</span><br><span class="line"># instead of waiting for more data in the output buffer. Some OS will really flush</span><br><span class="line"># data on disk, some other OS will just try to do it ASAP.</span><br><span class="line">#</span><br><span class="line"># Redis supports three different modes:</span><br><span class="line">#</span><br><span class="line"># no: don&#x27;t fsync, just let the OS flush the data when it wants. Faster.</span><br><span class="line"># always: fsync after every write to the append only log. Slow, Safest.</span><br><span class="line"># everysec: fsync only one time every second. Compromise.</span><br><span class="line">#</span><br><span class="line"># The default is &quot;everysec&quot;, as that&#x27;s usually the right compromise between</span><br><span class="line"># speed and data safety. It&#x27;s up to you to understand if you can relax this to</span><br><span class="line"># &quot;no&quot; that will let the operating system flush the output buffer when</span><br><span class="line"># it wants, for better performances (but if you can live with the idea of</span><br><span class="line"># some data loss consider the default persistence mode that&#x27;s snapshotting),</span><br><span class="line"># or on the contrary, use &quot;always&quot; that&#x27;s very slow but a bit safer than</span><br><span class="line"># everysec.</span><br><span class="line">#</span><br><span class="line"># More details please check the following article:</span><br><span class="line"># http://antirez.com/post/redis-persistence-demystified.html</span><br><span class="line">#</span><br><span class="line"># If unsure, use &quot;everysec&quot;.</span><br><span class="line"> </span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"> </span><br><span class="line"># When the AOF fsync policy is set to always or everysec, and a background</span><br><span class="line"># saving process (a background save or AOF log background rewriting) is</span><br><span class="line"># performing a lot of I/O against the disk, in some Linux configurations</span><br><span class="line"># Redis may block too long on the fsync() call. Note that there is no fix for</span><br><span class="line"># this currently, as even performing fsync in a different thread will block</span><br><span class="line"># our synchronous write(2) call.</span><br><span class="line">#</span><br><span class="line"># In order to mitigate this problem it&#x27;s possible to use the following option</span><br><span class="line"># that will prevent fsync() from being called in the main process while a</span><br><span class="line"># BGSAVE or BGREWRITEAOF is in progress.</span><br><span class="line">#</span><br><span class="line"># This means that while another child is saving, the durability of Redis is</span><br><span class="line"># the same as &quot;appendfsync none&quot;. In practical terms, this means that it is</span><br><span class="line"># possible to lose up to 30 seconds of log in the worst scenario (with the</span><br><span class="line"># default Linux settings).</span><br><span class="line">#</span><br><span class="line"># If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as</span><br><span class="line"># &quot;no&quot; that is the safest pick from the point of view of durability.</span><br><span class="line"> </span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"> </span><br><span class="line"># Automatic rewrite of the append only file.</span><br><span class="line"># Redis is able to automatically rewrite the log file implicitly calling</span><br><span class="line"># BGREWRITEAOF when the AOF log size grows by the specified percentage.</span><br><span class="line">#</span><br><span class="line"># This is how it works: Redis remembers the size of the AOF file after the</span><br><span class="line"># latest rewrite (if no rewrite has happened since the restart, the size of</span><br><span class="line"># the AOF at startup is used).</span><br><span class="line">#</span><br><span class="line"># This base size is compared to the current size. If the current size is</span><br><span class="line"># bigger than the specified percentage, the rewrite is triggered. Also</span><br><span class="line"># you need to specify a minimal size for the AOF file to be rewritten, this</span><br><span class="line"># is useful to avoid rewriting the AOF file even if the percentage increase</span><br><span class="line"># is reached but it is still pretty small.</span><br><span class="line">#</span><br><span class="line"># Specify a percentage of zero in order to disable the automatic AOF</span><br><span class="line"># rewrite feature.</span><br><span class="line"> </span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"> </span><br><span class="line"># An AOF file may be found to be truncated at the end during the Redis</span><br><span class="line"># startup process, when the AOF data gets loaded back into memory.</span><br><span class="line"># This may happen when the system where Redis is running</span><br><span class="line"># crashes, especially when an ext4 filesystem is mounted without the</span><br><span class="line"># data=ordered option (however this can&#x27;t happen when Redis itself</span><br><span class="line"># crashes or aborts but the operating system still works correctly).</span><br><span class="line">#</span><br><span class="line"># Redis can either exit with an error when this happens, or load as much</span><br><span class="line"># data as possible (the default now) and start if the AOF file is found</span><br><span class="line"># to be truncated at the end. The following option controls this behavior.</span><br><span class="line">#</span><br><span class="line"># If aof-load-truncated is set to yes, a truncated AOF file is loaded and</span><br><span class="line"># the Redis server starts emitting a log to inform the user of the event.</span><br><span class="line"># Otherwise if the option is set to no, the server aborts with an error</span><br><span class="line"># and refuses to start. When the option is set to no, the user requires</span><br><span class="line"># to fix the AOF file using the &quot;redis-check-aof&quot; utility before to restart</span><br><span class="line"># the server.</span><br><span class="line">#</span><br><span class="line"># Note that if the AOF file will be found to be corrupted in the middle</span><br><span class="line"># the server will still exit with an error. This option only applies when</span><br><span class="line"># Redis will try to read more data from the AOF file but not enough bytes</span><br><span class="line"># will be found.</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"> </span><br><span class="line"># When rewriting the AOF file, Redis is able to use an RDB preamble in the</span><br><span class="line"># AOF file for faster rewrites and recoveries. When this option is turned</span><br><span class="line"># on the rewritten AOF file is composed of two different stanzas:</span><br><span class="line">#</span><br><span class="line">#   [RDB file][AOF tail]</span><br><span class="line">#</span><br><span class="line"># When loading Redis recognizes that the AOF file starts with the &quot;REDIS&quot;</span><br><span class="line"># string and loads the prefixed RDB file, and continues loading the AOF</span><br><span class="line"># tail.</span><br><span class="line">#</span><br><span class="line"># This is currently turned off by default in order to avoid the surprise</span><br><span class="line"># of a format change, but will at some point be used as the default.</span><br><span class="line">aof-use-rdb-preamble no</span><br><span class="line"> </span><br><span class="line">################################ LUA SCRIPTING  ###############################</span><br><span class="line"> </span><br><span class="line"># Max execution time of a Lua script in milliseconds.</span><br><span class="line">#</span><br><span class="line"># If the maximum execution time is reached Redis will log that a script is</span><br><span class="line"># still in execution after the maximum allowed time and will start to</span><br><span class="line"># reply to queries with an error.</span><br><span class="line">#</span><br><span class="line"># When a long running script exceeds the maximum execution time only the</span><br><span class="line"># SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be</span><br><span class="line"># used to stop a script that did not yet called write commands. The second</span><br><span class="line"># is the only way to shut down the server in the case a write command was</span><br><span class="line"># already issued by the script but the user doesn&#x27;t want to wait for the natural</span><br><span class="line"># termination of the script.</span><br><span class="line">#</span><br><span class="line"># Set it to 0 or a negative value for unlimited execution without warnings.</span><br><span class="line">lua-time-limit 5000</span><br><span class="line"> </span><br><span class="line">################################ REDIS CLUSTER  ###############################</span><br><span class="line">#</span><br><span class="line"># ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"># WARNING EXPERIMENTAL: Redis Cluster is considered to be stable code, however</span><br><span class="line"># in order to mark it as &quot;mature&quot; we need to wait for a non trivial percentage</span><br><span class="line"># of users to deploy it in production.</span><br><span class="line"># ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">#</span><br><span class="line"># Normal Redis instances can&#x27;t be part of a Redis Cluster; only nodes that are</span><br><span class="line"># started as cluster nodes can. In order to start a Redis instance as a</span><br><span class="line"># cluster node enable the cluster support uncommenting the following:</span><br><span class="line">#</span><br><span class="line"># cluster-enabled yes</span><br><span class="line"> </span><br><span class="line"># Every cluster node has a cluster configuration file. This file is not</span><br><span class="line"># intended to be edited by hand. It is created and updated by Redis nodes.</span><br><span class="line"># Every Redis Cluster node requires a different cluster configuration file.</span><br><span class="line"># Make sure that instances running in the same system do not have</span><br><span class="line"># overlapping cluster configuration file names.</span><br><span class="line">#</span><br><span class="line"># cluster-config-file nodes-6379.conf</span><br><span class="line"> </span><br><span class="line"># Cluster node timeout is the amount of milliseconds a node must be unreachable</span><br><span class="line"># for it to be considered in failure state.</span><br><span class="line"># Most other internal time limits are multiple of the node timeout.</span><br><span class="line">#</span><br><span class="line"># cluster-node-timeout 15000</span><br><span class="line"> </span><br><span class="line"># A slave of a failing master will avoid to start a failover if its data</span><br><span class="line"># looks too old.</span><br><span class="line">#</span><br><span class="line"># There is no simple way for a slave to actually have an exact measure of</span><br><span class="line"># its &quot;data age&quot;, so the following two checks are performed:</span><br><span class="line">#</span><br><span class="line"># 1) If there are multiple slaves able to failover, they exchange messages</span><br><span class="line">#    in order to try to give an advantage to the slave with the best</span><br><span class="line">#    replication offset (more data from the master processed).</span><br><span class="line">#    Slaves will try to get their rank by offset, and apply to the start</span><br><span class="line">#    of the failover a delay proportional to their rank.</span><br><span class="line">#</span><br><span class="line"># 2) Every single slave computes the time of the last interaction with</span><br><span class="line">#    its master. This can be the last ping or command received (if the master</span><br><span class="line">#    is still in the &quot;connected&quot; state), or the time that elapsed since the</span><br><span class="line">#    disconnection with the master (if the replication link is currently down).</span><br><span class="line">#    If the last interaction is too old, the slave will not try to failover</span><br><span class="line">#    at all.</span><br><span class="line">#</span><br><span class="line"># The point &quot;2&quot; can be tuned by user. Specifically a slave will not perform</span><br><span class="line"># the failover if, since the last interaction with the master, the time</span><br><span class="line"># elapsed is greater than:</span><br><span class="line">#</span><br><span class="line">#   (node-timeout * slave-validity-factor) + repl-ping-slave-period</span><br><span class="line">#</span><br><span class="line"># So for example if node-timeout is 30 seconds, and the slave-validity-factor</span><br><span class="line"># is 10, and assuming a default repl-ping-slave-period of 10 seconds, the</span><br><span class="line"># slave will not try to failover if it was not able to talk with the master</span><br><span class="line"># for longer than 310 seconds.</span><br><span class="line">#</span><br><span class="line"># A large slave-validity-factor may allow slaves with too old data to failover</span><br><span class="line"># a master, while a too small value may prevent the cluster from being able to</span><br><span class="line"># elect a slave at all.</span><br><span class="line">#</span><br><span class="line"># For maximum availability, it is possible to set the slave-validity-factor</span><br><span class="line"># to a value of 0, which means, that slaves will always try to failover the</span><br><span class="line"># master regardless of the last time they interacted with the master.</span><br><span class="line"># (However they&#x27;ll always try to apply a delay proportional to their</span><br><span class="line"># offset rank).</span><br><span class="line">#</span><br><span class="line"># Zero is the only value able to guarantee that when all the partitions heal</span><br><span class="line"># the cluster will always be able to continue.</span><br><span class="line">#</span><br><span class="line"># cluster-slave-validity-factor 10</span><br><span class="line"> </span><br><span class="line"># Cluster slaves are able to migrate to orphaned masters, that are masters</span><br><span class="line"># that are left without working slaves. This improves the cluster ability</span><br><span class="line"># to resist to failures as otherwise an orphaned master can&#x27;t be failed over</span><br><span class="line"># in case of failure if it has no working slaves.</span><br><span class="line">#</span><br><span class="line"># Slaves migrate to orphaned masters only if there are still at least a</span><br><span class="line"># given number of other working slaves for their old master. This number</span><br><span class="line"># is the &quot;migration barrier&quot;. A migration barrier of 1 means that a slave</span><br><span class="line"># will migrate only if there is at least 1 other working slave for its master</span><br><span class="line"># and so forth. It usually reflects the number of slaves you want for every</span><br><span class="line"># master in your cluster.</span><br><span class="line">#</span><br><span class="line"># Default is 1 (slaves migrate only if their masters remain with at least</span><br><span class="line"># one slave). To disable migration just set it to a very large value.</span><br><span class="line"># A value of 0 can be set but is useful only for debugging and dangerous</span><br><span class="line"># in production.</span><br><span class="line">#</span><br><span class="line"># cluster-migration-barrier 1</span><br><span class="line"> </span><br><span class="line"># By default Redis Cluster nodes stop accepting queries if they detect there</span><br><span class="line"># is at least an hash slot uncovered (no available node is serving it).</span><br><span class="line"># This way if the cluster is partially down (for example a range of hash slots</span><br><span class="line"># are no longer covered) all the cluster becomes, eventually, unavailable.</span><br><span class="line"># It automatically returns available as soon as all the slots are covered again.</span><br><span class="line">#</span><br><span class="line"># However sometimes you want the subset of the cluster which is working,</span><br><span class="line"># to continue to accept queries for the part of the key space that is still</span><br><span class="line"># covered. In order to do so, just set the cluster-require-full-coverage</span><br><span class="line"># option to no.</span><br><span class="line">#</span><br><span class="line"># cluster-require-full-coverage yes</span><br><span class="line"> </span><br><span class="line"># In order to setup your cluster make sure to read the documentation</span><br><span class="line"># available at http://redis.io web site.</span><br><span class="line"> </span><br><span class="line">########################## CLUSTER DOCKER/NAT support  ########################</span><br><span class="line"> </span><br><span class="line"># In certain deployments, Redis Cluster nodes address discovery fails, because</span><br><span class="line"># addresses are NAT-ted or because ports are forwarded (the typical case is</span><br><span class="line"># Docker and other containers).</span><br><span class="line">#</span><br><span class="line"># In order to make Redis Cluster working in such environments, a static</span><br><span class="line"># configuration where each node knows its public address is needed. The</span><br><span class="line"># following two options are used for this scope, and are:</span><br><span class="line">#</span><br><span class="line"># * cluster-announce-ip</span><br><span class="line"># * cluster-announce-port</span><br><span class="line"># * cluster-announce-bus-port</span><br><span class="line">#</span><br><span class="line"># Each instruct the node about its address, client port, and cluster message</span><br><span class="line"># bus port. The information is then published in the header of the bus packets</span><br><span class="line"># so that other nodes will be able to correctly map the address of the node</span><br><span class="line"># publishing the information.</span><br><span class="line">#</span><br><span class="line"># If the above options are not used, the normal Redis Cluster auto-detection</span><br><span class="line"># will be used instead.</span><br><span class="line">#</span><br><span class="line"># Note that when remapped, the bus port may not be at the fixed offset of</span><br><span class="line"># clients port + 10000, so you can specify any port and bus-port depending</span><br><span class="line"># on how they get remapped. If the bus-port is not set, a fixed offset of</span><br><span class="line"># 10000 will be used as usually.</span><br><span class="line">#</span><br><span class="line"># Example:</span><br><span class="line">#</span><br><span class="line"># cluster-announce-ip 10.1.1.5</span><br><span class="line"># cluster-announce-port 6379</span><br><span class="line"># cluster-announce-bus-port 6380</span><br><span class="line"> </span><br><span class="line">################################## SLOW LOG ###################################</span><br><span class="line"> </span><br><span class="line"># The Redis Slow Log is a system to log queries that exceeded a specified</span><br><span class="line"># execution time. The execution time does not include the I/O operations</span><br><span class="line"># like talking with the client, sending the reply and so forth,</span><br><span class="line"># but just the time needed to actually execute the command (this is the only</span><br><span class="line"># stage of command execution where the thread is blocked and can not serve</span><br><span class="line"># other requests in the meantime).</span><br><span class="line">#</span><br><span class="line"># You can configure the slow log with two parameters: one tells Redis</span><br><span class="line"># what is the execution time, in microseconds, to exceed in order for the</span><br><span class="line"># command to get logged, and the other parameter is the length of the</span><br><span class="line"># slow log. When a new command is logged the oldest one is removed from the</span><br><span class="line"># queue of logged commands.</span><br><span class="line"> </span><br><span class="line"># The following time is expressed in microseconds, so 1000000 is equivalent</span><br><span class="line"># to one second. Note that a negative number disables the slow log, while</span><br><span class="line"># a value of zero forces the logging of every command.</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"> </span><br><span class="line"># There is no limit to this length. Just be aware that it will consume memory.</span><br><span class="line"># You can reclaim memory used by the slow log with SLOWLOG RESET.</span><br><span class="line">slowlog-max-len 128</span><br><span class="line"> </span><br><span class="line">################################ LATENCY MONITOR ##############################</span><br><span class="line"> </span><br><span class="line"># The Redis latency monitoring subsystem samples different operations</span><br><span class="line"># at runtime in order to collect data related to possible sources of</span><br><span class="line"># latency of a Redis instance.</span><br><span class="line">#</span><br><span class="line"># Via the LATENCY command this information is available to the user that can</span><br><span class="line"># print graphs and obtain reports.</span><br><span class="line">#</span><br><span class="line"># The system only logs operations that were performed in a time equal or</span><br><span class="line"># greater than the amount of milliseconds specified via the</span><br><span class="line"># latency-monitor-threshold configuration directive. When its value is set</span><br><span class="line"># to zero, the latency monitor is turned off.</span><br><span class="line">#</span><br><span class="line"># By default latency monitoring is disabled since it is mostly not needed</span><br><span class="line"># if you don&#x27;t have latency issues, and collecting data has a performance</span><br><span class="line"># impact, that while very small, can be measured under big load. Latency</span><br><span class="line"># monitoring can easily be enabled at runtime using the command</span><br><span class="line"># &quot;CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;&quot; if needed.</span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line"> </span><br><span class="line">############################# EVENT NOTIFICATION ##############################</span><br><span class="line"> </span><br><span class="line"># Redis can notify Pub/Sub clients about events happening in the key space.</span><br><span class="line"># This feature is documented at http://redis.io/topics/notifications</span><br><span class="line">#</span><br><span class="line"># For instance if keyspace events notification is enabled, and a client</span><br><span class="line"># performs a DEL operation on key &quot;foo&quot; stored in the Database 0, two</span><br><span class="line"># messages will be published via Pub/Sub:</span><br><span class="line">#</span><br><span class="line"># PUBLISH __keyspace@0__:foo del</span><br><span class="line"># PUBLISH __keyevent@0__:del foo</span><br><span class="line">#</span><br><span class="line"># It is possible to select the events that Redis will notify among a set</span><br><span class="line"># of classes. Every class is identified by a single character:</span><br><span class="line">#</span><br><span class="line">#  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.</span><br><span class="line">#  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.</span><br><span class="line">#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...</span><br><span class="line">#  $     String commands</span><br><span class="line">#  l     List commands</span><br><span class="line">#  s     Set commands</span><br><span class="line">#  h     Hash commands</span><br><span class="line">#  z     Sorted set commands</span><br><span class="line">#  x     Expired events (events generated every time a key expires)</span><br><span class="line">#  e     Evicted events (events generated when a key is evicted for maxmemory)</span><br><span class="line">#  A     Alias for g$lshzxe, so that the &quot;AKE&quot; string means all the events.</span><br><span class="line">#</span><br><span class="line">#  The &quot;notify-keyspace-events&quot; takes as argument a string that is composed</span><br><span class="line">#  of zero or multiple characters. The empty string means that notifications</span><br><span class="line">#  are disabled.</span><br><span class="line">#</span><br><span class="line">#  Example: to enable list and generic events, from the point of view of the</span><br><span class="line">#           event name, use:</span><br><span class="line">#</span><br><span class="line">#  notify-keyspace-events Elg</span><br><span class="line">#</span><br><span class="line">#  Example 2: to get the stream of the expired keys subscribing to channel</span><br><span class="line">#             name __keyevent@0__:expired use:</span><br><span class="line">#</span><br><span class="line">#  notify-keyspace-events Ex</span><br><span class="line">#</span><br><span class="line">#  By default all notifications are disabled because most users don&#x27;t need</span><br><span class="line">#  this feature and the feature has some overhead. Note that if you don&#x27;t</span><br><span class="line">#  specify at least one of K or E, no events will be delivered.</span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line"> </span><br><span class="line">############################### ADVANCED CONFIG ###############################</span><br><span class="line"> </span><br><span class="line"># Hashes are encoded using a memory efficient data structure when they have a</span><br><span class="line"># small number of entries, and the biggest entry does not exceed a given</span><br><span class="line"># threshold. These thresholds can be configured using the following directives.</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line"> </span><br><span class="line"># Lists are also encoded in a special way to save a lot of space.</span><br><span class="line"># The number of entries allowed per internal list node can be specified</span><br><span class="line"># as a fixed maximum size or a maximum number of elements.</span><br><span class="line"># For a fixed maximum size, use -5 through -1, meaning:</span><br><span class="line"># -5: max size: 64 Kb  &lt;-- not recommended for normal workloads</span><br><span class="line"># -4: max size: 32 Kb  &lt;-- not recommended</span><br><span class="line"># -3: max size: 16 Kb  &lt;-- probably not recommended</span><br><span class="line"># -2: max size: 8 Kb   &lt;-- good</span><br><span class="line"># -1: max size: 4 Kb   &lt;-- good</span><br><span class="line"># Positive numbers mean store up to _exactly_ that number of elements</span><br><span class="line"># per list node.</span><br><span class="line"># The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),</span><br><span class="line"># but if your use case is unique, adjust the settings as necessary.</span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line"> </span><br><span class="line"># Lists may also be compressed.</span><br><span class="line"># Compress depth is the number of quicklist ziplist nodes from *each* side of</span><br><span class="line"># the list to *exclude* from compression.  The head and tail of the list</span><br><span class="line"># are always uncompressed for fast push/pop operations.  Settings are:</span><br><span class="line"># 0: disable all list compression</span><br><span class="line"># 1: depth 1 means &quot;don&#x27;t start compressing until after 1 node into the list,</span><br><span class="line">#    going from either the head or tail&quot;</span><br><span class="line">#    So: [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]</span><br><span class="line">#    [head], [tail] will always be uncompressed; inner nodes will compress.</span><br><span class="line"># 2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]</span><br><span class="line">#    2 here means: don&#x27;t compress head or head-&gt;next or tail-&gt;prev or tail,</span><br><span class="line">#    but compress all nodes between them.</span><br><span class="line"># 3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]</span><br><span class="line"># etc.</span><br><span class="line">list-compress-depth 0</span><br><span class="line"> </span><br><span class="line"># Sets have a special encoding in just one case: when a set is composed</span><br><span class="line"># of just strings that happen to be integers in radix 10 in the range</span><br><span class="line"># of 64 bit signed integers.</span><br><span class="line"># The following configuration setting sets the limit in the size of the</span><br><span class="line"># set in order to use this special memory saving encoding.</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"> </span><br><span class="line"># Similarly to hashes and lists, sorted sets are also specially encoded in</span><br><span class="line"># order to save a lot of space. This encoding is only used when the length and</span><br><span class="line"># elements of a sorted set are below the following limits:</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"> </span><br><span class="line"># HyperLogLog sparse representation bytes limit. The limit includes the</span><br><span class="line"># 16 bytes header. When an HyperLogLog using the sparse representation crosses</span><br><span class="line"># this limit, it is converted into the dense representation.</span><br><span class="line">#</span><br><span class="line"># A value greater than 16000 is totally useless, since at that point the</span><br><span class="line"># dense representation is more memory efficient.</span><br><span class="line">#</span><br><span class="line"># The suggested value is ~ 3000 in order to have the benefits of</span><br><span class="line"># the space efficient encoding without slowing down too much PFADD,</span><br><span class="line"># which is O(N) with the sparse encoding. The value can be raised to</span><br><span class="line"># ~ 10000 when CPU is not a concern, but space is, and the data set is</span><br><span class="line"># composed of many HyperLogLogs with cardinality in the 0 - 15000 range.</span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line"> </span><br><span class="line"># Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in</span><br><span class="line"># order to help rehashing the main Redis hash table (the one mapping top-level</span><br><span class="line"># keys to values). The hash table implementation Redis uses (see dict.c)</span><br><span class="line"># performs a lazy rehashing: the more operation you run into a hash table</span><br><span class="line"># that is rehashing, the more rehashing &quot;steps&quot; are performed, so if the</span><br><span class="line"># server is idle the rehashing is never complete and some more memory is used</span><br><span class="line"># by the hash table.</span><br><span class="line">#</span><br><span class="line"># The default is to use this millisecond 10 times every second in order to</span><br><span class="line"># actively rehash the main dictionaries, freeing memory when possible.</span><br><span class="line">#</span><br><span class="line"># If unsure:</span><br><span class="line"># use &quot;activerehashing no&quot; if you have hard latency requirements and it is</span><br><span class="line"># not a good thing in your environment that Redis can reply from time to time</span><br><span class="line"># to queries with 2 milliseconds delay.</span><br><span class="line">#</span><br><span class="line"># use &quot;activerehashing yes&quot; if you don&#x27;t have such hard requirements but</span><br><span class="line"># want to free memory asap when possible.</span><br><span class="line">activerehashing yes</span><br><span class="line"> </span><br><span class="line"># The client output buffer limits can be used to force disconnection of clients</span><br><span class="line"># that are not reading data from the server fast enough for some reason (a</span><br><span class="line"># common reason is that a Pub/Sub client can&#x27;t consume messages as fast as the</span><br><span class="line"># publisher can produce them).</span><br><span class="line">#</span><br><span class="line"># The limit can be set differently for the three different classes of clients:</span><br><span class="line">#</span><br><span class="line"># normal -&gt; normal clients including MONITOR clients</span><br><span class="line"># slave  -&gt; slave clients</span><br><span class="line"># pubsub -&gt; clients subscribed to at least one pubsub channel or pattern</span><br><span class="line">#</span><br><span class="line"># The syntax of every client-output-buffer-limit directive is the following:</span><br><span class="line">#</span><br><span class="line"># client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br><span class="line">#</span><br><span class="line"># A client is immediately disconnected once the hard limit is reached, or if</span><br><span class="line"># the soft limit is reached and remains reached for the specified number of</span><br><span class="line"># seconds (continuously).</span><br><span class="line"># So for instance if the hard limit is 32 megabytes and the soft limit is</span><br><span class="line"># 16 megabytes / 10 seconds, the client will get disconnected immediately</span><br><span class="line"># if the size of the output buffers reach 32 megabytes, but will also get</span><br><span class="line"># disconnected if the client reaches 16 megabytes and continuously overcomes</span><br><span class="line"># the limit for 10 seconds.</span><br><span class="line">#</span><br><span class="line"># By default normal clients are not limited because they don&#x27;t receive data</span><br><span class="line"># without asking (in a push way), but just after a request, so only</span><br><span class="line"># asynchronous clients may create a scenario where data is requested faster</span><br><span class="line"># than it can read.</span><br><span class="line">#</span><br><span class="line"># Instead there is a default limit for pubsub and slave clients, since</span><br><span class="line"># subscribers and slaves receive data in a push fashion.</span><br><span class="line">#</span><br><span class="line"># Both the hard or the soft limit can be disabled by setting them to zero.</span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line"> </span><br><span class="line"># Client query buffers accumulate new commands. They are limited to a fixed</span><br><span class="line"># amount by default in order to avoid that a protocol desynchronization (for</span><br><span class="line"># instance due to a bug in the client) will lead to unbound memory usage in</span><br><span class="line"># the query buffer. However you can configure it here if you have very special</span><br><span class="line"># needs, such us huge multi/exec requests or alike.</span><br><span class="line">#</span><br><span class="line"># client-query-buffer-limit 1gb</span><br><span class="line"> </span><br><span class="line"># In the Redis protocol, bulk requests, that are, elements representing single</span><br><span class="line"># strings, are normally limited ot 512 mb. However you can change this limit</span><br><span class="line"># here.</span><br><span class="line">#</span><br><span class="line"># proto-max-bulk-len 512mb</span><br><span class="line"> </span><br><span class="line"># Redis calls an internal function to perform many background tasks, like</span><br><span class="line"># closing connections of clients in timeout, purging expired keys that are</span><br><span class="line"># never requested, and so forth.</span><br><span class="line">#</span><br><span class="line"># Not all tasks are performed with the same frequency, but Redis checks for</span><br><span class="line"># tasks to perform according to the specified &quot;hz&quot; value.</span><br><span class="line">#</span><br><span class="line"># By default &quot;hz&quot; is set to 10. Raising the value will use more CPU when</span><br><span class="line"># Redis is idle, but at the same time will make Redis more responsive when</span><br><span class="line"># there are many keys expiring at the same time, and timeouts may be</span><br><span class="line"># handled with more precision.</span><br><span class="line">#</span><br><span class="line"># The range is between 1 and 500, however a value over 100 is usually not</span><br><span class="line"># a good idea. Most users should use the default of 10 and raise this up to</span><br><span class="line"># 100 only in environments where very low latency is required.</span><br><span class="line">hz 10</span><br><span class="line"> </span><br><span class="line"># When a child rewrites the AOF file, if the following option is enabled</span><br><span class="line"># the file will be fsync-ed every 32 MB of data generated. This is useful</span><br><span class="line"># in order to commit the file to the disk more incrementally and avoid</span><br><span class="line"># big latency spikes.</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line"> </span><br><span class="line"># Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good</span><br><span class="line"># idea to start with the default settings and only change them after investigating</span><br><span class="line"># how to improve the performances and how the keys LFU change over time, which</span><br><span class="line"># is possible to inspect via the OBJECT FREQ command.</span><br><span class="line">#</span><br><span class="line"># There are two tunable parameters in the Redis LFU implementation: the</span><br><span class="line"># counter logarithm factor and the counter decay time. It is important to</span><br><span class="line"># understand what the two parameters mean before changing them.</span><br><span class="line">#</span><br><span class="line"># The LFU counter is just 8 bits per key, it&#x27;s maximum value is 255, so Redis</span><br><span class="line"># uses a probabilistic increment with logarithmic behavior. Given the value</span><br><span class="line"># of the old counter, when a key is accessed, the counter is incremented in</span><br><span class="line"># this way:</span><br><span class="line">#</span><br><span class="line"># 1. A random number R between 0 and 1 is extracted.</span><br><span class="line"># 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).</span><br><span class="line"># 3. The counter is incremented only if R &lt; P.</span><br><span class="line">#</span><br><span class="line"># The default lfu-log-factor is 10. This is a table of how the frequency</span><br><span class="line"># counter changes with a different number of accesses with different</span><br><span class="line"># logarithmic factors:</span><br><span class="line">#</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line"># | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line"># | 0      | 104        | 255        | 255        | 255        | 255        |</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line"># | 1      | 18         | 49         | 255        | 255        | 255        |</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line"># | 10     | 10         | 18         | 142        | 255        | 255        |</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line"># | 100    | 8          | 11         | 49         | 143        | 255        |</span><br><span class="line"># +--------+------------+------------+------------+------------+------------+</span><br><span class="line">#</span><br><span class="line"># NOTE: The above table was obtained by running the following commands:</span><br><span class="line">#</span><br><span class="line">#   redis-benchmark -n 1000000 incr foo</span><br><span class="line">#   redis-cli object freq foo</span><br><span class="line">#</span><br><span class="line"># NOTE 2: The counter initial value is 5 in order to give new objects a chance</span><br><span class="line"># to accumulate hits.</span><br><span class="line">#</span><br><span class="line"># The counter decay time is the time, in minutes, that must elapse in order</span><br><span class="line"># for the key counter to be divided by two (or decremented if it has a value</span><br><span class="line"># less &lt;= 10).</span><br><span class="line">#</span><br><span class="line"># The default value for the lfu-decay-time is 1. A Special value of 0 means to</span><br><span class="line"># decay the counter every time it happens to be scanned.</span><br><span class="line">#</span><br><span class="line"># lfu-log-factor 10</span><br><span class="line"># lfu-decay-time 1</span><br><span class="line"> </span><br><span class="line">########################### ACTIVE DEFRAGMENTATION #######################</span><br><span class="line">#</span><br><span class="line"># WARNING THIS FEATURE IS EXPERIMENTAL. However it was stress tested</span><br><span class="line"># even in production and manually tested by multiple engineers for some</span><br><span class="line"># time.</span><br><span class="line">#</span><br><span class="line"># What is active defragmentation?</span><br><span class="line"># -------------------------------</span><br><span class="line">#</span><br><span class="line"># Active (online) defragmentation allows a Redis server to compact the</span><br><span class="line"># spaces left between small allocations and deallocations of data in memory,</span><br><span class="line"># thus allowing to reclaim back memory.</span><br><span class="line">#</span><br><span class="line"># Fragmentation is a natural process that happens with every allocator (but</span><br><span class="line"># less so with Jemalloc, fortunately) and certain workloads. Normally a server</span><br><span class="line"># restart is needed in order to lower the fragmentation, or at least to flush</span><br><span class="line"># away all the data and create it again. However thanks to this feature</span><br><span class="line"># implemented by Oran Agra for Redis 4.0 this process can happen at runtime</span><br><span class="line"># in an &quot;hot&quot; way, while the server is running.</span><br><span class="line">#</span><br><span class="line"># Basically when the fragmentation is over a certain level (see the</span><br><span class="line"># configuration options below) Redis will start to create new copies of the</span><br><span class="line"># values in contiguous memory regions by exploiting certain specific Jemalloc</span><br><span class="line"># features (in order to understand if an allocation is causing fragmentation</span><br><span class="line"># and to allocate it in a better place), and at the same time, will release the</span><br><span class="line"># old copies of the data. This process, repeated incrementally for all the keys</span><br><span class="line"># will cause the fragmentation to drop back to normal values.</span><br><span class="line">#</span><br><span class="line"># Important things to understand:</span><br><span class="line">#</span><br><span class="line"># 1. This feature is disabled by default, and only works if you compiled Redis</span><br><span class="line">#    to use the copy of Jemalloc we ship with the source code of Redis.</span><br><span class="line">#    This is the default with Linux builds.</span><br><span class="line">#</span><br><span class="line"># 2. You never need to enable this feature if you don&#x27;t have fragmentation</span><br><span class="line">#    issues.</span><br><span class="line">#</span><br><span class="line"># 3. Once you experience fragmentation, you can enable this feature when</span><br><span class="line">#    needed with the command &quot;CONFIG SET activedefrag yes&quot;.</span><br><span class="line">#</span><br><span class="line"># The configuration parameters are able to fine tune the behavior of the</span><br><span class="line"># defragmentation process. If you are not sure about what they mean it is</span><br><span class="line"># a good idea to leave the defaults untouched.</span><br><span class="line"> </span><br><span class="line"># Enabled active defragmentation</span><br><span class="line"># activedefrag yes</span><br><span class="line"> </span><br><span class="line"># Minimum amount of fragmentation waste to start active defrag</span><br><span class="line"># active-defrag-ignore-bytes 100mb</span><br><span class="line"> </span><br><span class="line"># Minimum percentage of fragmentation to start active defrag</span><br><span class="line"># active-defrag-threshold-lower 10</span><br><span class="line"> </span><br><span class="line"># Maximum percentage of fragmentation at which we use maximum effort</span><br><span class="line"># active-defrag-threshold-upper 100</span><br><span class="line"> </span><br><span class="line"># Minimal effort for defrag in CPU percentage</span><br><span class="line"># active-defrag-cycle-min 25</span><br><span class="line"> </span><br><span class="line"># Maximal effort for defrag in CPU percentage</span><br><span class="line"># active-defrag-cycle-max 75</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="精简redis-conf"><a href="#精简redis-conf" class="headerlink" title="精简redis.conf"></a>精简redis.conf</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bind *</span><br><span class="line">protected-mode yes</span><br><span class="line">port 6379</span><br><span class="line">tcp-backlog 511</span><br><span class="line">timeout 0</span><br><span class="line">tcp-keepalive 300</span><br><span class="line">supervised no</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line">loglevel notice</span><br><span class="line">logfile &quot;/data/redis.log&quot;</span><br><span class="line">databases 16</span><br><span class="line">always-show-logo yes</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbchecksum yes</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">dir ./</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line">slave-read-only yes</span><br><span class="line">repl-diskless-sync no</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line">slave-priority 100</span><br><span class="line">requirepass 123456</span><br><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del no</span><br><span class="line">slave-lazy-flush no</span><br><span class="line">appendonly no</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line">appendfsync everysec</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line">aof-load-truncated yes</span><br><span class="line">aof-use-rdb-preamble no</span><br><span class="line">lua-time-limit 5000</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line">slowlog-max-len 128</span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line">list-compress-depth 0</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line">activerehashing yes</span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line">hz 10</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name redis --restart=always -p 6379:6379 -v ~/redis/log/redis.log:/data/redis.log -v /etc/localtime:/etc/localtime:ro -v ~/redis/conf/redis.conf:/etc/redis/redis.conf -v ~/redis/data:/data -d redis:latest redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure>

<h2 id="快速运行"><a href="#快速运行" class="headerlink" title="快速运行"></a>快速运行</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -vp /data/redis/&#123;data,conf,<span class="built_in">log</span>&#125;</span><br><span class="line"><span class="built_in">touch</span> /data/redis/conf/redis.conf</span><br><span class="line"><span class="built_in">touch</span> /data/redis/log/redis.log</span><br><span class="line"><span class="comment"># 配置</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF &gt; /data/redis/conf/data.conf</span></span><br><span class="line"><span class="string">bind *</span></span><br><span class="line"><span class="string">protected-mode yes</span></span><br><span class="line"><span class="string">port 6379</span></span><br><span class="line"><span class="string">tcp-backlog 511</span></span><br><span class="line"><span class="string">timeout 0</span></span><br><span class="line"><span class="string">tcp-keepalive 300</span></span><br><span class="line"><span class="string">supervised no</span></span><br><span class="line"><span class="string">pidfile /var/run/redis_6379.pid</span></span><br><span class="line"><span class="string">loglevel notice</span></span><br><span class="line"><span class="string">logfile &quot;/data/redis.log&quot;</span></span><br><span class="line"><span class="string">databases 16</span></span><br><span class="line"><span class="string">always-show-logo yes</span></span><br><span class="line"><span class="string">save 900 1</span></span><br><span class="line"><span class="string">save 300 10</span></span><br><span class="line"><span class="string">save 60 10000</span></span><br><span class="line"><span class="string">stop-writes-on-bgsave-error yes</span></span><br><span class="line"><span class="string">rdbcompression yes</span></span><br><span class="line"><span class="string">rdbchecksum yes</span></span><br><span class="line"><span class="string">dbfilename dump.rdb</span></span><br><span class="line"><span class="string">dir ./</span></span><br><span class="line"><span class="string">slave-serve-stale-data yes</span></span><br><span class="line"><span class="string">slave-read-only yes</span></span><br><span class="line"><span class="string">repl-diskless-sync no</span></span><br><span class="line"><span class="string">repl-diskless-sync-delay 5</span></span><br><span class="line"><span class="string">repl-disable-tcp-nodelay no</span></span><br><span class="line"><span class="string">slave-priority 100</span></span><br><span class="line"><span class="string">requirepass 123456</span></span><br><span class="line"><span class="string">lazyfree-lazy-eviction no</span></span><br><span class="line"><span class="string">lazyfree-lazy-expire no</span></span><br><span class="line"><span class="string">lazyfree-lazy-server-del no</span></span><br><span class="line"><span class="string">slave-lazy-flush no</span></span><br><span class="line"><span class="string">appendonly no</span></span><br><span class="line"><span class="string">appendfilename &quot;appendonly.aof&quot;</span></span><br><span class="line"><span class="string">appendfsync everysec</span></span><br><span class="line"><span class="string">no-appendfsync-on-rewrite no</span></span><br><span class="line"><span class="string">auto-aof-rewrite-percentage 100</span></span><br><span class="line"><span class="string">auto-aof-rewrite-min-size 64mb</span></span><br><span class="line"><span class="string">aof-load-truncated yes</span></span><br><span class="line"><span class="string">aof-use-rdb-preamble no</span></span><br><span class="line"><span class="string">lua-time-limit 5000</span></span><br><span class="line"><span class="string">slowlog-log-slower-than 10000</span></span><br><span class="line"><span class="string">slowlog-max-len 128</span></span><br><span class="line"><span class="string">latency-monitor-threshold 0</span></span><br><span class="line"><span class="string">notify-keyspace-events &quot;&quot;</span></span><br><span class="line"><span class="string">hash-max-ziplist-entries 512</span></span><br><span class="line"><span class="string">hash-max-ziplist-value 64</span></span><br><span class="line"><span class="string">list-max-ziplist-size -2</span></span><br><span class="line"><span class="string">list-compress-depth 0</span></span><br><span class="line"><span class="string">set-max-intset-entries 512</span></span><br><span class="line"><span class="string">zset-max-ziplist-entries 128</span></span><br><span class="line"><span class="string">zset-max-ziplist-value 64</span></span><br><span class="line"><span class="string">hll-sparse-max-bytes 3000</span></span><br><span class="line"><span class="string">activerehashing yes</span></span><br><span class="line"><span class="string">client-output-buffer-limit normal 0 0 0</span></span><br><span class="line"><span class="string">client-output-buffer-limit slave 256mb 64mb 60</span></span><br><span class="line"><span class="string">client-output-buffer-limit pubsub 32mb 8mb 60</span></span><br><span class="line"><span class="string">hz 10</span></span><br><span class="line"><span class="string">aof-rewrite-incremental-fsync yes</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">docker run --name redis --restart=always -p 6379:6379 -v ~/redis/log/redis.log:/data/redis.log -v /etc/localtime:/etc/localtime:ro -v ~/redis/conf/redis.conf:/etc/redis/redis.conf -v ~/redis/data:/data -d redis:latest redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker镜像代理加速</title>
    <url>/2024/06/23/docker/Docker%E9%95%9C%E5%83%8F%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F/</url>
    <content><![CDATA[<h2 id="打开大善人网站"><a href="#打开大善人网站" class="headerlink" title="打开大善人网站"></a>打开大善人网站</h2><p><a href="https://dash.cloudflare.com/">https://dash.cloudflare.com/</a></p>
<h2 id="找到-Workers-Pages"><a href="#找到-Workers-Pages" class="headerlink" title="找到 Workers &amp; Pages"></a>找到 Workers &amp; Pages</h2><img data-src="/2024/06/23/docker/Docker%E9%95%9C%E5%83%8F%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F/image.png" class="" alt="找到 Workers &amp; Pages">

<h2 id="找到-Create-按钮"><a href="#找到-Create-按钮" class="headerlink" title="找到 Create 按钮"></a>找到 Create 按钮</h2><img data-src="/2024/06/23/docker/Docker%E9%95%9C%E5%83%8F%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F/image2.png" class="" alt="找到 Create 按钮">

<h2 id="选择Workers-然后点击Create-Workers"><a href="#选择Workers-然后点击Create-Workers" class="headerlink" title="选择Workers 然后点击Create Workers"></a>选择Workers 然后点击Create Workers</h2><img data-src="/2024/06/23/docker/Docker%E9%95%9C%E5%83%8F%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F/image3.png" class="" alt="选择Workers 然后点击Create Workers">

<h2 id="输入前缀-比如：dockerproxy"><a href="#输入前缀-比如：dockerproxy" class="headerlink" title="输入前缀 比如：dockerproxy"></a>输入前缀 比如：dockerproxy</h2><img data-src="/2024/06/23/docker/Docker%E9%95%9C%E5%83%8F%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F/image4.png" class="" alt="输入前缀 比如：dockerproxy">

<h2 id="然后点击Save保存"><a href="#然后点击Save保存" class="headerlink" title="然后点击Save保存"></a>然后点击Save保存</h2><img data-src="/2024/06/23/docker/Docker%E9%95%9C%E5%83%8F%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F/image-1.png" class="" alt="Save保存">

<h2 id="保存好之后-就会出现这个页面-什么也不用管-直接finish"><a href="#保存好之后-就会出现这个页面-什么也不用管-直接finish" class="headerlink" title="保存好之后 就会出现这个页面 什么也不用管 直接finish"></a>保存好之后 就会出现这个页面 什么也不用管 直接finish</h2><img data-src="/2024/06/23/docker/Docker%E9%95%9C%E5%83%8F%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F/image-2.png" class="" alt="直接finish">

<h2 id="成功-然后点击‘Edit-code’开始编辑workers-js"><a href="#成功-然后点击‘Edit-code’开始编辑workers-js" class="headerlink" title="成功 然后点击‘Edit code’开始编辑workers.js"></a>成功 然后点击‘Edit code’开始编辑workers.js</h2><img data-src="/2024/06/23/docker/Docker%E9%95%9C%E5%83%8F%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F/image-3.png" class="" alt="workers.js">

<h2 id="把自带的内容删除掉"><a href="#把自带的内容删除掉" class="headerlink" title="把自带的内容删除掉"></a>把自带的内容删除掉</h2><img data-src="/2024/06/23/docker/Docker%E9%95%9C%E5%83%8F%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F/image-4.png" class="" alt="把自带的内容删除掉">


<h2 id="把代码粘贴进去"><a href="#把代码粘贴进去" class="headerlink" title="把代码粘贴进去"></a>把代码粘贴进去</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _worker.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Docker镜像仓库主机地址</span></span><br><span class="line"><span class="keyword">let</span> hub_host = <span class="string">&#x27;registry-1.docker.io&#x27;</span></span><br><span class="line"><span class="comment">// Docker认证服务器地址</span></span><br><span class="line"><span class="keyword">const</span> auth_url = <span class="string">&#x27;https://auth.docker.io&#x27;</span></span><br><span class="line"><span class="comment">// 自定义的工作服务器地址</span></span><br><span class="line"><span class="keyword">let</span> workers_url = <span class="string">&#x27;https://你的域名&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据主机名选择对应的上游地址</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">routeByHosts</span>(<span class="params">host</span>) &#123;</span><br><span class="line">		<span class="comment">// 定义路由表</span></span><br><span class="line">	<span class="keyword">const</span> routes = &#123;</span><br><span class="line">		<span class="comment">// 生产环境</span></span><br><span class="line">		<span class="string">&quot;quay&quot;</span>: <span class="string">&quot;quay.io&quot;</span>,</span><br><span class="line">		<span class="string">&quot;gcr&quot;</span>: <span class="string">&quot;gcr.io&quot;</span>,</span><br><span class="line">		<span class="string">&quot;k8s-gcr&quot;</span>: <span class="string">&quot;k8s.gcr.io&quot;</span>,</span><br><span class="line">		<span class="string">&quot;k8s&quot;</span>: <span class="string">&quot;registry.k8s.io&quot;</span>,</span><br><span class="line">		<span class="string">&quot;ghcr&quot;</span>: <span class="string">&quot;ghcr.io&quot;</span>,</span><br><span class="line">		<span class="string">&quot;cloudsmith&quot;</span>: <span class="string">&quot;docker.cloudsmith.io&quot;</span>,</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 测试环境</span></span><br><span class="line">		<span class="string">&quot;test&quot;</span>: <span class="string">&quot;registry-1.docker.io&quot;</span>,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (host <span class="keyword">in</span> routes) <span class="keyword">return</span> [ routes[host], <span class="literal">false</span> ];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> [ hub_host, <span class="literal">true</span> ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">RequestInit</span>&#125; */</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PREFLIGHT_INIT</span> = &#123;</span><br><span class="line">	<span class="comment">// 预检请求配置</span></span><br><span class="line">	<span class="attr">headers</span>: <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123;</span><br><span class="line">		<span class="string">&#x27;access-control-allow-origin&#x27;</span>: <span class="string">&#x27;*&#x27;</span>, <span class="comment">// 允许所有来源</span></span><br><span class="line">		<span class="string">&#x27;access-control-allow-methods&#x27;</span>: <span class="string">&#x27;GET,POST,PUT,PATCH,TRACE,DELETE,HEAD,OPTIONS&#x27;</span>, <span class="comment">// 允许的HTTP方法</span></span><br><span class="line">		<span class="string">&#x27;access-control-max-age&#x27;</span>: <span class="string">&#x27;1728000&#x27;</span>, <span class="comment">// 预检请求的缓存时间</span></span><br><span class="line">	&#125;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造响应</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">any</span>&#125; body 响应体</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; status 响应状态码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object&lt;string, string&gt;</span>&#125; headers 响应头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeRes</span>(<span class="params">body, status = <span class="number">200</span>, headers = &#123;&#125;</span>) &#123;</span><br><span class="line">	headers[<span class="string">&#x27;access-control-allow-origin&#x27;</span>] = <span class="string">&#x27;*&#x27;</span> <span class="comment">// 允许所有来源</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>(body, &#123; status, headers &#125;) <span class="comment">// 返回新构造的响应</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造新的URL对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; urlStr URL字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">newUrl</span>(<span class="params">urlStr</span>) &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">URL</span>(urlStr) <span class="comment">// 尝试构造新的URL对象</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// 构造失败返回null</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isUUID</span>(<span class="params">uuid</span>) &#123;</span><br><span class="line">	<span class="comment">// 定义一个正则表达式来匹配 UUID 格式</span></span><br><span class="line">	<span class="keyword">const</span> uuidRegex = <span class="regexp">/^[0-9a-f]&#123;8&#125;-[0-9a-f]&#123;4&#125;-[4][0-9a-f]&#123;3&#125;-[89ab][0-9a-f]&#123;3&#125;-[0-9a-f]&#123;12&#125;$/i</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 使用正则表达式测试 UUID 字符串</span></span><br><span class="line">	<span class="keyword">return</span> uuidRegex.<span class="title function_">test</span>(uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">nginx</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> text = <span class="string">`</span></span><br><span class="line"><span class="string">	&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">	&lt;html&gt;</span></span><br><span class="line"><span class="string">	&lt;head&gt;</span></span><br><span class="line"><span class="string">	&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span></span><br><span class="line"><span class="string">	&lt;style&gt;</span></span><br><span class="line"><span class="string">		body &#123;</span></span><br><span class="line"><span class="string">			width: 35em;</span></span><br><span class="line"><span class="string">			margin: 0 auto;</span></span><br><span class="line"><span class="string">			font-family: Tahoma, Verdana, Arial, sans-serif;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&lt;/style&gt;</span></span><br><span class="line"><span class="string">	&lt;/head&gt;</span></span><br><span class="line"><span class="string">	&lt;body&gt;</span></span><br><span class="line"><span class="string">	&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span></span><br><span class="line"><span class="string">	&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span></span><br><span class="line"><span class="string">	working. Further configuration is required.&lt;/p&gt;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	&lt;p&gt;For online documentation and support please refer to</span></span><br><span class="line"><span class="string">	&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span></span><br><span class="line"><span class="string">	Commercial support is available at</span></span><br><span class="line"><span class="string">	&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">	&lt;/body&gt;</span></span><br><span class="line"><span class="string">	&lt;/html&gt;</span></span><br><span class="line"><span class="string">	`</span></span><br><span class="line">	<span class="keyword">return</span> text ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">	<span class="keyword">async</span> <span class="title function_">fetch</span>(<span class="params">request, env, ctx</span>) &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="title function_">getReqHeader</span> = (<span class="params">key</span>) =&gt; request.<span class="property">headers</span>.<span class="title function_">get</span>(key); <span class="comment">// 获取请求头</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">let</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(request.<span class="property">url</span>); <span class="comment">// 解析请求URL</span></span><br><span class="line">		workers_url = <span class="string">`https://<span class="subst">$&#123;url.hostname&#125;</span>`</span>;</span><br><span class="line">		<span class="keyword">const</span> pathname = url.<span class="property">pathname</span>;</span><br><span class="line">		<span class="keyword">const</span> hostname = url.<span class="property">searchParams</span>.<span class="title function_">get</span>(<span class="string">&#x27;hubhost&#x27;</span>) || url.<span class="property">hostname</span>; </span><br><span class="line">		<span class="keyword">const</span> hostTop = hostname.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>];<span class="comment">// 获取主机名的第一部分</span></span><br><span class="line">		<span class="keyword">const</span> checkHost = <span class="title function_">routeByHosts</span>(hostTop);</span><br><span class="line">		hub_host = checkHost[<span class="number">0</span>]; <span class="comment">// 获取上游地址</span></span><br><span class="line">		<span class="keyword">const</span> fakePage = checkHost[<span class="number">1</span>];</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`域名头部: <span class="subst">$&#123;hostTop&#125;</span>\n反代地址: <span class="subst">$&#123;hub_host&#125;</span>\n伪装首页: <span class="subst">$&#123;fakePage&#125;</span>`</span>);</span><br><span class="line">		<span class="keyword">const</span> isUuid = <span class="title function_">isUUID</span>(pathname.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>)[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>)[<span class="number">0</span>]);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">const</span> conditions = [</span><br><span class="line">			isUuid,</span><br><span class="line">			pathname.<span class="title function_">includes</span>(<span class="string">&#x27;/_&#x27;</span>),</span><br><span class="line">			pathname.<span class="title function_">includes</span>(<span class="string">&#x27;/r&#x27;</span>),</span><br><span class="line">			pathname.<span class="title function_">includes</span>(<span class="string">&#x27;/v2/user&#x27;</span>),</span><br><span class="line">			pathname.<span class="title function_">includes</span>(<span class="string">&#x27;/v2/orgs&#x27;</span>),</span><br><span class="line">			pathname.<span class="title function_">includes</span>(<span class="string">&#x27;/v2/_catalog&#x27;</span>),</span><br><span class="line">			pathname.<span class="title function_">includes</span>(<span class="string">&#x27;/v2/categories&#x27;</span>),</span><br><span class="line">			pathname.<span class="title function_">includes</span>(<span class="string">&#x27;/v2/feature-flags&#x27;</span>),</span><br><span class="line">			pathname.<span class="title function_">includes</span>(<span class="string">&#x27;search&#x27;</span>),</span><br><span class="line">			pathname.<span class="title function_">includes</span>(<span class="string">&#x27;source&#x27;</span>),</span><br><span class="line">			pathname === <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">			pathname === <span class="string">&#x27;/favicon.ico&#x27;</span>,</span><br><span class="line">			pathname === <span class="string">&#x27;/auth/profile&#x27;</span>,</span><br><span class="line">		];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (conditions.<span class="title function_">some</span>(<span class="function"><span class="params">condition</span> =&gt;</span> condition) &amp;&amp; (fakePage === <span class="literal">true</span> || hostTop == <span class="string">&#x27;docker&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (env.<span class="property">URL302</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="title class_">Response</span>.<span class="title function_">redirect</span>(env.<span class="property">URL302</span>, <span class="number">302</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (env.<span class="property">URL</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span> (env.<span class="property">URL</span>.<span class="title function_">toLowerCase</span>() == <span class="string">&#x27;nginx&#x27;</span>)&#123;</span><br><span class="line">					<span class="comment">//首页改成一个nginx伪装页</span></span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="keyword">await</span> <span class="title function_">nginx</span>(), &#123;</span><br><span class="line">						<span class="attr">headers</span>: &#123;</span><br><span class="line">							<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html; charset=UTF-8&#x27;</span>,</span><br><span class="line">						&#125;,</span><br><span class="line">					&#125;);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="title function_">fetch</span>(<span class="keyword">new</span> <span class="title class_">Request</span>(env.<span class="property">URL</span>, request));</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">const</span> newUrl = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&quot;https://registry.hub.docker.com&quot;</span> + pathname + url.<span class="property">search</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 复制原始请求的标头</span></span><br><span class="line">			<span class="keyword">const</span> headers = <span class="keyword">new</span> <span class="title class_">Headers</span>(request.<span class="property">headers</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 确保 Host 头部被替换为 hub.docker.com</span></span><br><span class="line">			headers.<span class="title function_">set</span>(<span class="string">&#x27;Host&#x27;</span>, <span class="string">&#x27;registry.hub.docker.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">const</span> newRequest = <span class="keyword">new</span> <span class="title class_">Request</span>(newUrl, &#123;</span><br><span class="line">					<span class="attr">method</span>: request.<span class="property">method</span>,</span><br><span class="line">					<span class="attr">headers</span>: headers,</span><br><span class="line">					<span class="attr">body</span>: request.<span class="property">method</span> !== <span class="string">&#x27;GET&#x27;</span> &amp;&amp; request.<span class="property">method</span> !== <span class="string">&#x27;HEAD&#x27;</span> ? <span class="keyword">await</span> request.<span class="title function_">blob</span>() : <span class="literal">null</span>,</span><br><span class="line">					<span class="attr">redirect</span>: <span class="string">&#x27;follow&#x27;</span></span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="title function_">fetch</span>(newRequest);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 修改包含 %2F 和 %3A 的请求</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="regexp">/%2F/</span>.<span class="title function_">test</span>(url.<span class="property">search</span>) &amp;&amp; <span class="regexp">/%3A/</span>.<span class="title function_">test</span>(url.<span class="title function_">toString</span>())) &#123;</span><br><span class="line">			<span class="keyword">let</span> modifiedUrl = url.<span class="title function_">toString</span>().<span class="title function_">replace</span>(<span class="regexp">/%3A(?=.*?&amp;)/</span>, <span class="string">&#x27;%3Alibrary%2F&#x27;</span>);</span><br><span class="line">			url = <span class="keyword">new</span> <span class="title function_">URL</span>(modifiedUrl);</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`handle_url: <span class="subst">$&#123;url&#125;</span>`</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理token请求</span></span><br><span class="line">		<span class="keyword">if</span> (url.<span class="property">pathname</span>.<span class="title function_">includes</span>(<span class="string">&#x27;/token&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">let</span> token_parameter = &#123;</span><br><span class="line">				<span class="attr">headers</span>: &#123;</span><br><span class="line">					<span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;auth.docker.io&#x27;</span>,</span><br><span class="line">					<span class="string">&#x27;User-Agent&#x27;</span>: <span class="title function_">getReqHeader</span>(<span class="string">&quot;User-Agent&quot;</span>),</span><br><span class="line">					<span class="string">&#x27;Accept&#x27;</span>: <span class="title function_">getReqHeader</span>(<span class="string">&quot;Accept&quot;</span>),</span><br><span class="line">					<span class="string">&#x27;Accept-Language&#x27;</span>: <span class="title function_">getReqHeader</span>(<span class="string">&quot;Accept-Language&quot;</span>),</span><br><span class="line">					<span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="title function_">getReqHeader</span>(<span class="string">&quot;Accept-Encoding&quot;</span>),</span><br><span class="line">					<span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">					<span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="keyword">let</span> token_url = auth_url + url.<span class="property">pathname</span> + url.<span class="property">search</span></span><br><span class="line">			<span class="keyword">return</span> <span class="title function_">fetch</span>(<span class="keyword">new</span> <span class="title class_">Request</span>(token_url, request), token_parameter)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 修改 /v2/ 请求路径</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="regexp">/^\/v2\/[^/]+\/[^/]+\/[^/]+$/</span>.<span class="title function_">test</span>(url.<span class="property">pathname</span>) &amp;&amp; !<span class="regexp">/^\/v2\/library/</span>.<span class="title function_">test</span>(url.<span class="property">pathname</span>)) &#123;</span><br><span class="line">			url.<span class="property">pathname</span> = url.<span class="property">pathname</span>.<span class="title function_">replace</span>(<span class="regexp">/\/v2\//</span>, <span class="string">&#x27;/v2/library/&#x27;</span>);</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`modified_url: <span class="subst">$&#123;url.pathname&#125;</span>`</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更改请求的主机名</span></span><br><span class="line">		url.<span class="property">hostname</span> = hub_host;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 构造请求参数</span></span><br><span class="line">		<span class="keyword">let</span> parameter = &#123;</span><br><span class="line">			<span class="attr">headers</span>: &#123;</span><br><span class="line">				<span class="string">&#x27;Host&#x27;</span>: hub_host,</span><br><span class="line">				<span class="string">&#x27;User-Agent&#x27;</span>: <span class="title function_">getReqHeader</span>(<span class="string">&quot;User-Agent&quot;</span>),</span><br><span class="line">				<span class="string">&#x27;Accept&#x27;</span>: <span class="title function_">getReqHeader</span>(<span class="string">&quot;Accept&quot;</span>),</span><br><span class="line">				<span class="string">&#x27;Accept-Language&#x27;</span>: <span class="title function_">getReqHeader</span>(<span class="string">&quot;Accept-Language&quot;</span>),</span><br><span class="line">				<span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="title function_">getReqHeader</span>(<span class="string">&quot;Accept-Encoding&quot;</span>),</span><br><span class="line">				<span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">				<span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">cacheTtl</span>: <span class="number">3600</span> <span class="comment">// 缓存时间</span></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 添加Authorization头</span></span><br><span class="line">		<span class="keyword">if</span> (request.<span class="property">headers</span>.<span class="title function_">has</span>(<span class="string">&quot;Authorization&quot;</span>)) &#123;</span><br><span class="line">			parameter.<span class="property">headers</span>.<span class="property">Authorization</span> = <span class="title function_">getReqHeader</span>(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 发起请求并处理响应</span></span><br><span class="line">		<span class="keyword">let</span> original_response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="keyword">new</span> <span class="title class_">Request</span>(url, request), parameter)</span><br><span class="line">		<span class="keyword">let</span> original_response_clone = original_response.<span class="title function_">clone</span>();</span><br><span class="line">		<span class="keyword">let</span> original_text = original_response_clone.<span class="property">body</span>;</span><br><span class="line">		<span class="keyword">let</span> response_headers = original_response.<span class="property">headers</span>;</span><br><span class="line">		<span class="keyword">let</span> new_response_headers = <span class="keyword">new</span> <span class="title class_">Headers</span>(response_headers);</span><br><span class="line">		<span class="keyword">let</span> status = original_response.<span class="property">status</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 修改 Www-Authenticate 头</span></span><br><span class="line">		<span class="keyword">if</span> (new_response_headers.<span class="title function_">get</span>(<span class="string">&quot;Www-Authenticate&quot;</span>)) &#123;</span><br><span class="line">			<span class="keyword">let</span> auth = new_response_headers.<span class="title function_">get</span>(<span class="string">&quot;Www-Authenticate&quot;</span>);</span><br><span class="line">			<span class="keyword">let</span> re = <span class="keyword">new</span> <span class="title class_">RegExp</span>(auth_url, <span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">			new_response_headers.<span class="title function_">set</span>(<span class="string">&quot;Www-Authenticate&quot;</span>, response_headers.<span class="title function_">get</span>(<span class="string">&quot;Www-Authenticate&quot;</span>).<span class="title function_">replace</span>(re, workers_url));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理重定向</span></span><br><span class="line">		<span class="keyword">if</span> (new_response_headers.<span class="title function_">get</span>(<span class="string">&quot;Location&quot;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="title function_">httpHandler</span>(request, new_response_headers.<span class="title function_">get</span>(<span class="string">&quot;Location&quot;</span>))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回修改后的响应</span></span><br><span class="line">		<span class="keyword">let</span> response = <span class="keyword">new</span> <span class="title class_">Response</span>(original_text, &#123;</span><br><span class="line">			status,</span><br><span class="line">			<span class="attr">headers</span>: new_response_headers</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span> response;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理HTTP请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Request</span>&#125; req 请求对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; pathname 请求路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">httpHandler</span>(<span class="params">req, pathname</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> reqHdrRaw = req.<span class="property">headers</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理预检请求</span></span><br><span class="line">	<span class="keyword">if</span> (req.<span class="property">method</span> === <span class="string">&#x27;OPTIONS&#x27;</span> &amp;&amp;</span><br><span class="line">		reqHdrRaw.<span class="title function_">has</span>(<span class="string">&#x27;access-control-request-headers&#x27;</span>)</span><br><span class="line">	) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="literal">null</span>, <span class="variable constant_">PREFLIGHT_INIT</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> rawLen = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> reqHdrNew = <span class="keyword">new</span> <span class="title class_">Headers</span>(reqHdrRaw)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> refer = reqHdrNew.<span class="title function_">get</span>(<span class="string">&#x27;referer&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> urlStr = pathname</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> urlObj = <span class="title function_">newUrl</span>(urlStr)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">RequestInit</span>&#125; */</span></span><br><span class="line">	<span class="keyword">const</span> reqInit = &#123;</span><br><span class="line">		<span class="attr">method</span>: req.<span class="property">method</span>,</span><br><span class="line">		<span class="attr">headers</span>: reqHdrNew,</span><br><span class="line">		<span class="attr">redirect</span>: <span class="string">&#x27;follow&#x27;</span>,</span><br><span class="line">		<span class="attr">body</span>: req.<span class="property">body</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">proxy</span>(urlObj, reqInit, rawLen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">URL</span>&#125; urlObj URL对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">RequestInit</span>&#125; reqInit 请求初始化对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; rawLen 原始长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">proxy</span>(<span class="params">urlObj, reqInit, rawLen</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(urlObj.<span class="property">href</span>, reqInit)</span><br><span class="line">	<span class="keyword">const</span> resHdrOld = res.<span class="property">headers</span></span><br><span class="line">	<span class="keyword">const</span> resHdrNew = <span class="keyword">new</span> <span class="title class_">Headers</span>(resHdrOld)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 验证长度</span></span><br><span class="line">	<span class="keyword">if</span> (rawLen) &#123;</span><br><span class="line">		<span class="keyword">const</span> newLen = resHdrOld.<span class="title function_">get</span>(<span class="string">&#x27;content-length&#x27;</span>) || <span class="string">&#x27;&#x27;</span></span><br><span class="line">		<span class="keyword">const</span> badLen = (rawLen !== newLen)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (badLen) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="title function_">makeRes</span>(res.<span class="property">body</span>, <span class="number">400</span>, &#123;</span><br><span class="line">				<span class="string">&#x27;--error&#x27;</span>: <span class="string">`bad len: <span class="subst">$&#123;newLen&#125;</span>, except: <span class="subst">$&#123;rawLen&#125;</span>`</span>,</span><br><span class="line">				<span class="string">&#x27;access-control-expose-headers&#x27;</span>: <span class="string">&#x27;--error&#x27;</span>,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> status = res.<span class="property">status</span></span><br><span class="line">	resHdrNew.<span class="title function_">set</span>(<span class="string">&#x27;access-control-expose-headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">	resHdrNew.<span class="title function_">set</span>(<span class="string">&#x27;access-control-allow-origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">	resHdrNew.<span class="title function_">set</span>(<span class="string">&#x27;Cache-Control&#x27;</span>, <span class="string">&#x27;max-age=1500&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除不必要的头</span></span><br><span class="line">	resHdrNew.<span class="title function_">delete</span>(<span class="string">&#x27;content-security-policy&#x27;</span>)</span><br><span class="line">	resHdrNew.<span class="title function_">delete</span>(<span class="string">&#x27;content-security-policy-report-only&#x27;</span>)</span><br><span class="line">	resHdrNew.<span class="title function_">delete</span>(<span class="string">&#x27;clear-site-data&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>(res.<span class="property">body</span>, &#123;</span><br><span class="line">		status,</span><br><span class="line">		<span class="attr">headers</span>: resHdrNew</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改自定义域名-需要是托管dns在cloudflare的域名才可以"><a href="#修改自定义域名-需要是托管dns在cloudflare的域名才可以" class="headerlink" title="修改自定义域名 需要是托管dns在cloudflare的域名才可以"></a>修改自定义域名 需要是托管dns在cloudflare的域名才可以</h2><img data-src="/2024/06/23/docker/Docker%E9%95%9C%E5%83%8F%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F/image-5.png" class="" alt="需要是托管dns在cloudflare的域名才可以">

<h2 id="填写完是这样的"><a href="#填写完是这样的" class="headerlink" title="填写完是这样的"></a>填写完是这样的</h2><img data-src="/2024/06/23/docker/Docker%E9%95%9C%E5%83%8F%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F/image-6.png" class="" alt="alt text">

<h2 id="然后去右上角-deploy保存"><a href="#然后去右上角-deploy保存" class="headerlink" title="然后去右上角 deploy保存"></a>然后去右上角 deploy保存</h2><img data-src="/2024/06/23/docker/Docker%E9%95%9C%E5%83%8F%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F/image-7.png" class="" alt="alt text">

<h2 id="然后返回-回到设置"><a href="#然后返回-回到设置" class="headerlink" title="然后返回 回到设置"></a>然后返回 回到设置</h2><img data-src="/2024/06/23/docker/Docker%E9%95%9C%E5%83%8F%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F/image-8.png" class="" alt="alt text">

<h2 id="其他：添加上自定义域名"><a href="#其他：添加上自定义域名" class="headerlink" title="其他：添加上自定义域名"></a>其他：添加上自定义域名</h2><img data-src="/2024/06/23/docker/Docker%E9%95%9C%E5%83%8F%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F/image-9.png" class="" alt="alt text">

<p>保存 大功告成 现在可以用这个自定义的域名访问了<br>接下来还有可以选择开启的环境变量功能 就是伪装首页</p>
<h2 id="其他：变量说明"><a href="#其他：变量说明" class="headerlink" title="其他：变量说明"></a>其他：变量说明</h2><table>
<thead>
<tr>
<th align="left">变量名</th>
<th align="left">示例</th>
<th align="left">必填</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">URL302</td>
<td align="left"><a href="https://baidu.com/">https://baidu.com</a></td>
<td align="left">否</td>
<td align="left">主页302跳转</td>
</tr>
<tr>
<td align="left">URL</td>
<td align="left"><a href="https://dockerpull.com/">https://dockerpull.com</a></td>
<td align="left">否</td>
<td align="left">主页伪装(设为<code>nginx</code>则伪装为nginx默认页面)</td>
</tr>
</tbody></table>
<p>如果你像我的<a href="https://dockerpull.com/">dockerpull.com</a>无所畏惧 就可以不管<br>如果你想自己稳定使用 不想公开的话 可以设置伪装页面<br>找到设置 环境变量</p>
<img data-src="/2024/06/23/docker/Docker%E9%95%9C%E5%83%8F%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F/image-10.png" class="" alt="alt text">

<p>如果想别人访问域名首页的时候重定向到别的网站<br>可以加入环境变量<code>URL302</code>必须要大写的哈 然后值填写需要目标域名 我以跳转到百度为例</p>
<img data-src="/2024/06/23/docker/Docker%E9%95%9C%E5%83%8F%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F/image-13.png" class="" alt="alt text">

<p>保存之后 访问首页就会自动跳转到百度 但是拉取docker镜像的时候 不会受到影响</p>
<p>第二种 是伪装首页 可以伪装成任意的网页首页 变量名称改为<code>URL</code> 也是要大写 值输入<a href="https://dockerpull.com/">https://dockerpull.com/</a> 保存</p>
<img data-src="/2024/06/23/docker/Docker%E9%95%9C%E5%83%8F%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F/image-14.png" class="" alt="alt text">

<p>这时候访问域名 就会出现我的那个<a href="https://dockerpull.com/">镜像站</a>的页面 当然也可以用别的页面</p>
<p>全部部署完之后呢 如何使用？</p>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h3 id="官方镜像路径前面加域名"><a href="#官方镜像路径前面加域名" class="headerlink" title="官方镜像路径前面加域名"></a>官方镜像路径前面加域名</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull dockerpull.com/stilleshan/frpc:latest</span><br></pre></td></tr></table></figure>

<h3 id="一键设置镜像加速"><a href="#一键设置镜像加速" class="headerlink" title="一键设置镜像加速"></a>一键设置镜像加速</h3><p>修改文件 &#x2F;etc&#x2F;docker&#x2F;daemon.json（如果不存在则创建）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://dockerpull.com&quot;</span>]  <span class="comment"># 请替换为您自己的Worker自定义域名</span></span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
        <category>cloudflare</category>
      </categories>
      <tags>
        <tag>cloudflare</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA链接Docker</title>
    <url>/2024/04/08/docker/IDEA%E9%93%BE%E6%8E%A5docker/</url>
    <content><![CDATA[<h2 id="下载证书（非必要）"><a href="#下载证书（非必要）" class="headerlink" title="下载证书（非必要）"></a>下载证书（非必要）</h2><p>下载生成的证书</p>


<h2 id="IDEA设置证书访问"><a href="#IDEA设置证书访问" class="headerlink" title="IDEA设置证书访问"></a>IDEA设置证书访问</h2><p>目录: file -&gt; settings</p>
]]></content>
      <categories>
        <category>docker</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL安装Docker</title>
    <url>/2024/06/25/docker/WSL%E5%AE%89%E8%A3%85Docker/</url>
    <content><![CDATA[<h2 id="配置初始环境"><a href="#配置初始环境" class="headerlink" title="配置初始环境"></a>配置初始环境</h2><p>使用WSL2、Ubuntu20.04.6，其他环境不保证正确</p>
<p>在用户文件夹下创建<code>.wslconfig</code>输入内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[boot]</span><br><span class="line">systemd=<span class="literal">true</span> <span class="comment"># 启用此设置将在 WSL 实例中启用 systemd 初始化。Systemd 是大多数现代 Linux 发行版的标准 init 系统，允许更好地管理服务和依赖关系。</span></span><br><span class="line"></span><br><span class="line">[experimental]</span><br><span class="line">autoMemoryReclaim=gradual  <span class="comment"># 此选项指定在 WSL 中如何处理内存回收。gradual 表示采用渐进式内存回收，这可能更为保守和平衡。</span></span><br><span class="line">networkingMode=mirrored <span class="comment"># 此设置控制 WSL 中的网络处理方式。mirrored 模式通常会镜像主机操作系统（Windows）的网络配置，使得 WSL 可以共享相同的网络设置。</span></span><br><span class="line">dnsTunneling=<span class="literal">true</span> <span class="comment"># 启用 DNS 隧道功能允许 WSL 使用主机的 DNS 配置，简化 DNS 解析，无需在 WSL 中额外配置。</span></span><br><span class="line">firewall=<span class="literal">true</span> <span class="comment"># 此选项可能启用与 Windows 防火墙的集成，允许 WSL 遵循在主机 Windows 系统上设置的防火墙规则。</span></span><br><span class="line">autoProxy=<span class="literal">true</span> <span class="comment"># 启用 autoProxy 可能允许 WSL 自动使用在 Windows 主机上配置的系统代理设置。</span></span><br></pre></td></tr></table></figure>

<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>因为docker官网提供的脚本在疯狂的安利：Docker Desktop for Windows，所以需要把这段代码给屏蔽掉</p>
<p>官方脚本：<a href="https://get.docker.com/">https://get.docker.com</a></p>
<p>需要正常访问并把脚本拷贝一份，然后搜索<code>is_wsl</code>注释掉下面的代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#	if is_wsl; then</span></span><br><span class="line"><span class="comment">#		echo</span></span><br><span class="line"><span class="comment">#		echo &quot;WSL DETECTED: We recommend using Docker Desktop for Windows.&quot;</span></span><br><span class="line"><span class="comment">#		echo &quot;Please get Docker Desktop from https://www.docker.com/products/docker-desktop/&quot;</span></span><br><span class="line"><span class="comment">#		echo</span></span><br><span class="line"><span class="comment">#		cat &gt;&amp;2 &lt;&lt;-&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#			You may press Ctrl+C now to abort this script.</span></span><br><span class="line"><span class="comment">#		EOF</span></span><br><span class="line"><span class="comment">#		( set -x; sleep 20 )</span></span><br><span class="line"><span class="comment">#	fi</span></span><br></pre></td></tr></table></figure>

<p>然后使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim get-docker.sh</span><br><span class="line"><span class="comment"># 粘贴</span></span><br><span class="line"><span class="built_in">chmod</span> +x get-docker.sh</span><br><span class="line">sudo ./get-docker.sh</span><br><span class="line"><span class="comment"># 等待安装，因为国内已经无法下载镜像了，所以需要自己解决代理问题</span></span><br></pre></td></tr></table></figure>

<h2 id="给普通用户docker权限"><a href="#给普通用户docker权限" class="headerlink" title="给普通用户docker权限"></a>给普通用户docker权限</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为 docker 的用户组。</span></span><br><span class="line">sudo groupadd docker</span><br><span class="line"><span class="comment"># 将当前用户（$USER）添加到 docker 用户组中，使得该用户能够运行 Docker 命令而无需使用 sudo。</span></span><br><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br><span class="line"><span class="comment"># 启动一个新的 shell，将其当前用户组切换为 docker，这样该 shell 中的命令执行时将具有 docker 组的权限。 </span></span><br><span class="line">newgrp docker</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
        <category>WSL</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compose安装</title>
    <url>/2024/05/15/docker/docker-compose%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="docker-compose安装"><a href="#docker-compose安装" class="headerlink" title="docker-compose安装"></a>docker-compose安装</h2><blockquote>
<p>因为版本更新原因推荐安装前去<a href="https://github.com/docker/compose%E6%9F%A5%E8%AF%A2%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC">https://github.com/docker/compose查询最新版本</a></p>
</blockquote>
<p>运行下边的命令来安装 Compose：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/v2.23.3/docker-compose-`<span class="built_in">uname</span> -s`-`<span class="built_in">uname</span> -m` &gt; /usr/local/bin/docker-compose &amp;&amp; <span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果你在安装的时候出现了 “Permission denied” 的错误信息，这说明你的 <code>/usr/local/bin</code> 目录是不可写的，你需要使用超级用户来安装。运行 <code>sudo -i</code> , 然后运行上边的两个命令，然后 <code>exit</code> 退出。</p>
</blockquote>
<p>可选，你也可以在 shell 中使用命令行安装。</p>
<p>Compose 适用于 OS X 和 64位的Linux 。 如果你使用其他平台，你可以安装一个 Compose 的 Python 包来完成安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip install -U docker-compose</span><br></pre></td></tr></table></figure>

<p>到这里安装就结束了；Compose已经安装完成。你可以使用 <code>docker-compose --version</code> 来进行测试 。</p>
<h2 id="docker-compose附件安装"><a href="#docker-compose附件安装" class="headerlink" title="docker-compose附件安装"></a>docker-compose附件安装</h2><p>从github上下载docker-compose二进制文件安装</p>
<p>下载最新版的docker-compose文件</p>
<p>官方文档地址：Install Docker Compose | Docker Documentation <a href="https://docs.docker.com/compose/install/">https://docs.docker.com/compose/install/</a></p>
<p><a href="https://github.com/docker/compose/releases/download/v2.5.0/docker-compose-linux-x86_64">https://github.com/docker/compose/releases/download/v2.5.0/docker-compose-linux-x86_64</a></p>
<p>添加可执行权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> docker-compose-linux-x86_64 docker-compose</span><br><span class="line">docker-compose version</span><br></pre></td></tr></table></figure>

<h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install docker-compose</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker内网安装</title>
    <url>/2024/04/08/docker/%E5%86%85%E7%BD%91%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="下载二进制文件"><a href="#下载二进制文件" class="headerlink" title="下载二进制文件"></a>下载二进制文件</h2><p><a href="https://download.docker.com/">https://download.docker.com/</a></p>


<h2 id="上传到服务器"><a href="#上传到服务器" class="headerlink" title="上传到服务器"></a>上传到服务器</h2><p>略</p>
<h2 id="剪切文件"><a href="#剪切文件" class="headerlink" title="剪切文件"></a>剪切文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> /home/weihu/docker-20.10.9.tgz /home/docker</span><br></pre></td></tr></table></figure>

<h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf docker-20.10.9.tgz</span><br></pre></td></tr></table></figure>

<h2 id="将二进制文件移到可执行文件目录下"><a href="#将二进制文件移到可执行文件目录下" class="headerlink" title="将二进制文件移到可执行文件目录下"></a>将二进制文件移到可执行文件目录下</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> docker/* /usr/bin/</span><br></pre></td></tr></table></figure>

<h2 id="配置docker-service"><a href="#配置docker-service" class="headerlink" title="配置docker.service"></a>配置docker.service</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">Documentation=https://docs.docker.com</span><br><span class="line">After=network-online.target firewalld.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">ExecStart=/usr/bin/dockerd</span><br><span class="line">ExecReload=/bin/kill -s HUP <span class="variable">$MAINPID</span></span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">Delegate=<span class="built_in">yes</span></span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">StartLimitBurst=3</span><br><span class="line">StartLimitInterval=60s</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<h2 id="启动dockerd服务"><a href="#启动dockerd服务" class="headerlink" title="启动dockerd服务"></a>启动dockerd服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start docker.service</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure>

<h3 id="将docker设置为开机自启动"><a href="#将docker设置为开机自启动" class="headerlink" title="将docker设置为开机自启动"></a>将docker设置为开机自启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>

<h2 id="导出镜像或者容器"><a href="#导出镜像或者容器" class="headerlink" title="导出镜像或者容器"></a>导出镜像或者容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 容器 记得指定tag</span></span><br><span class="line">docker save -o rabbitmqmanagement.tar xxx </span><br><span class="line"><span class="comment"># 镜像</span></span><br><span class="line">docker <span class="built_in">export</span> -o SMSServer.tar CONTAINER ID</span><br><span class="line"></span><br><span class="line">docker load &lt; rabbitmqmanagement.tar </span><br><span class="line"></span><br><span class="line">docker import SMSServer.tar smsserver</span><br><span class="line"><span class="comment">#重命名</span></span><br><span class="line">docker tag [镜像<span class="built_in">id</span>] [新镜像名称]:[新镜像标签]</span><br></pre></td></tr></table></figure>

<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="Error-response-from-daemon-No-command-specified"><a href="#Error-response-from-daemon-No-command-specified" class="headerlink" title="Error response from daemon: No command specified."></a>Error response from daemon: No command specified.</h3><p>run 后缀添加 <code>/bin/ash</code> <code>/bin/bash</code> <code>/bin/sh</code></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker开发2375及生成证书</title>
    <url>/2024/05/15/docker/%E5%BC%80%E6%94%BE2375%E5%8F%8A%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<h2 id="证书生成"><a href="#证书生成" class="headerlink" title="证书生成"></a>证书生成</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim docker-tls.sh</span><br></pre></td></tr></table></figure>

<p>输入下面的脚本及修改脚本内容 </p>
<h3 id="证书生成脚本"><a href="#证书生成脚本" class="headerlink" title="证书生成脚本"></a>证书生成脚本</h3><p>需要修改 SERVER PASSWORD COUNTRY STATE CITY ORGANIZATION ORGANIZATIONAL_UNIT EMAIL</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#Docker tls script</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#settings</span></span><br><span class="line">SERVER=<span class="string">&quot;服务器ip记得写哇&quot;</span></span><br><span class="line">PASSWORD=<span class="string">&quot;1qaz2wsx3edc&quot;</span></span><br><span class="line">COUNTRY=<span class="string">&quot;CN&quot;</span></span><br><span class="line">STATE=<span class="string">&quot;sichuan&quot;</span></span><br><span class="line">CITY=<span class="string">&quot;chengdu&quot;</span></span><br><span class="line">ORGANIZATION=<span class="string">&quot;&quot;</span></span><br><span class="line">ORGANIZATIONAL_UNIT=<span class="string">&quot;Dev&quot;</span></span><br><span class="line">EMAIL=<span class="string">&quot;isguard@outlook.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###start###</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;script start&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gen ca.pem - aes256   </span></span><br><span class="line">openssl genrsa -aes256 -passout pass:<span class="variable">$PASSWORD</span> -out ca-key.pem 4096</span><br><span class="line"></span><br><span class="line">openssl req -new -x509 -passin <span class="string">&quot;pass:<span class="variable">$PASSWORD</span>&quot;</span> -days 365 -key ca-key.pem -sha256 -out ca.pem -subj <span class="string">&quot;/C=<span class="variable">$COUNTRY</span>/ST=<span class="variable">$STATE</span>/L=<span class="variable">$CITY</span>/O=<span class="variable">$ORGANIZATION</span>/OU=<span class="variable">$ORGANIZATIONAL_UNIT</span>/CN=<span class="variable">$SERVER</span>/emailAddress=<span class="variable">$EMAIL</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gen server cert</span></span><br><span class="line">openssl genrsa -out server-key.pem 4096</span><br><span class="line"></span><br><span class="line">openssl req -subj <span class="string">&quot;/CN=<span class="variable">$SERVER</span>&quot;</span> -sha256 -new -key server-key.pem -out server.csr</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> subjectAltName = IP:<span class="variable">$SERVER</span>,IP:0.0.0.0 &gt;&gt; extfile.cnf</span><br><span class="line"><span class="built_in">echo</span> extendedKeyUsage = serverAuth &gt;&gt; extfile.cnf</span><br><span class="line"></span><br><span class="line">openssl x509 -req -days 365 -sha256 -<span class="keyword">in</span> server.csr -CA ca.pem -CAkey ca-key.pem -passin <span class="string">&quot;pass:<span class="variable">$PASSWORD</span>&quot;</span> \-CAcreateserial -out server-cert.pem -extfile extfile.cnf</span><br><span class="line"></span><br><span class="line"><span class="comment">#gen client cert</span></span><br><span class="line">openssl genrsa -out key.pem 4096</span><br><span class="line"></span><br><span class="line">openssl req -subj <span class="string">&#x27;/CN=client&#x27;</span> -new -key key.pem -out client.csr</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> extendedKeyUsage = clientAuth &gt;&gt; extfile.cnf</span><br><span class="line"></span><br><span class="line">openssl x509 -req -days 365 -sha256 -<span class="keyword">in</span> client.csr -CA ca.pem -CAkey ca-key.pem -passin <span class="string">&quot;pass:<span class="variable">$PASSWORD</span>&quot;</span> \-CAcreateserial -out cert.pem -extfile extfile.cnf</span><br><span class="line"></span><br><span class="line"><span class="comment">#cert authorized</span></span><br><span class="line"><span class="built_in">chmod</span> -v 0400 ca-key.pem key.pem server-key.pem</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> -v 0444 ca.pem server-cert.pem cert.pem</span><br><span class="line"></span><br><span class="line"><span class="comment">#del useless file</span></span><br><span class="line"><span class="built_in">rm</span> client.csr server.csr</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;script done&quot;</span></span><br><span class="line"><span class="comment">###end###</span></span><br></pre></td></tr></table></figure>

<h2 id="docker服务设置使用证书远程访问"><a href="#docker服务设置使用证书远程访问" class="headerlink" title="docker服务设置使用证书远程访问"></a>docker服务设置使用证书远程访问</h2><p>以下操作在docker服务器中进行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x docker-tls.sh</span><br><span class="line">./docker-tls.sh</span><br></pre></td></tr></table></figure>



<h3 id="修改docker配置文件"><a href="#修改docker配置文件" class="headerlink" title="修改docker配置文件"></a>修改docker配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找到ExecStart前缀内容</span></span><br><span class="line"><span class="comment"># 修改内容并添加tls</span></span><br><span class="line">ExecStart=/usr/bin/dockerd  --tlsverify --tlscacert=/data/docker/ca.pem  --tlscert=/data/docker/server-cert.pem --tlskey=/data/docker/server-key.pem -H tcp://0.0.0.0:2375 -H fd:// --containerd=/run/containerd/containerd.sock</span><br><span class="line"><span class="comment"># 也可以修改端口</span></span><br><span class="line">ExecStart=/usr/bin/dockerd --tlsverify --tlscacert=/data/docker/ca.pem  --tlscert=/data/docker/server-cert.pem --tlskey=/data/docker/server-key.pem -H tcp://0.0.0.0:9999 -H fd:// --containerd=/run/containerd/containerd.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># --containerd=/run/containerd/containerd.sock可替换</span></span><br><span class="line">-H unix:///var/run/docker.sock</span><br></pre></td></tr></table></figure>

<h3 id="重启docker服务"><a href="#重启docker服务" class="headerlink" title="重启docker服务"></a>重启docker服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="连接验证"><a href="#连接验证" class="headerlink" title="连接验证"></a>连接验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl 127.0.0.1:9999/info --cert /data/docker/cert.pem --key /data/docker/key.pem --cacert /data/docker/ca.pem</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装GitLab</title>
    <url>/2024/05/15/gitLab/Docker%E5%AE%89%E8%A3%85GitLab/</url>
    <content><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --detach \</span><br><span class="line">  --hostname gitlab.example.com \</span><br><span class="line">  --publish 443:443 --publish 80:80 --publish 22:22 \</span><br><span class="line">  --name gitlab \</span><br><span class="line">  --restart always \</span><br><span class="line">  --volume <span class="variable">$GITLAB_HOME</span>/config:/etc/gitlab:Z \</span><br><span class="line">  --volume <span class="variable">$GITLAB_HOME</span>/logs:/var/log/gitlab:Z \</span><br><span class="line">  --volume <span class="variable">$GITLAB_HOME</span>/data:/var/opt/gitlab:Z \</span><br><span class="line">  --shm-size 256m \</span><br><span class="line">  gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure>

<h2 id="登录GitLab"><a href="#登录GitLab" class="headerlink" title="登录GitLab"></a>登录GitLab</h2><ol>
<li><p>获取GitLab的登录密码。</p>
<ul>
<li>Linux安装包方式：<code>sudo cat /etc/gitlab/initial_root_password</code></li>
<li>Docker Engine安装方式：<code>sudo docker exec -it gitlab grep &#39;Password:&#39; /etc/gitlab/initial_root_password</code></li>
</ul>
<p>回显信息类似如下所示，您可以在<code>Password</code>后获取GitLab的初始登录密码。</p>
<p><strong>重要</strong></p>
<p>出于安全原因，24小时后，该文件会被自动删除，建议您安装成功，首次登录之后，立即修改初始密码。</p>

</li>
<li><p>登录GitLab。</p>
<ul>
<li>Linux安装包方式：在浏览器的地址栏中，输入http:&#x2F;&#x2F;<em>ECS实例的公网IP</em>即可进入GitLab的登录界面。</li>
<li>Docker Engine安装方式：在浏览器的地址栏中，输入http:&#x2F;&#x2F;<em>ECS实例的公网IP:8080</em>即可进入GitLab的登录界面。</li>
</ul>
<p>首次登录使用用户名<code>root</code>，密码为步骤<a href="https://help.aliyun.com/zh/ecs/use-cases/deploy-and-use-gitlab#8c9d01b0880v4">1</a>获取的密码。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>gitLab</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>gitLab</tag>
      </tags>
  </entry>
  <entry>
    <title>GitLab 授权 2099年</title>
    <url>/2024/05/15/gitLab/GitLab%E4%BC%81%E4%B8%9A%E7%89%88%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="GitLab-授权-2099年"><a href="#GitLab-授权-2099年" class="headerlink" title="GitLab 授权 2099年"></a>GitLab 授权 2099年</h2><h3 id="创建文件license-rb"><a href="#创建文件license-rb" class="headerlink" title="创建文件license.rb"></a>创建文件license.rb</h3><p>license.rb文件 用来激活使用的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">require <span class="string">&quot;openssl&quot;</span></span><br><span class="line">require <span class="string">&quot;gitlab/license&quot;</span></span><br><span class="line"></span><br><span class="line">key_pair = OpenSSL::PKey::RSA.generate(2048)</span><br><span class="line">File.open(<span class="string">&quot;license_key&quot;</span>, <span class="string">&quot;w&quot;</span>) &#123; |f| f.write(key_pair.to_pem) &#125;</span><br><span class="line"></span><br><span class="line">public_key = key_pair.public_key</span><br><span class="line">File.open(<span class="string">&quot;license_key.pub&quot;</span>, <span class="string">&quot;w&quot;</span>) &#123; |f| f.write(public_key.to_pem) &#125;</span><br><span class="line"></span><br><span class="line">private_key = OpenSSL::PKey::RSA.new File.<span class="built_in">read</span>(<span class="string">&quot;license_key&quot;</span>)</span><br><span class="line">Gitlab::License.encryption_key = private_key</span><br><span class="line"></span><br><span class="line">license = Gitlab::License.new</span><br><span class="line">license.licensee = &#123;</span><br><span class="line">  <span class="string">&quot;Name&quot;</span> =&gt; <span class="string">&quot;Lemon&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Company&quot;</span> =&gt; <span class="string">&quot;Lemon&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Email&quot;</span> =&gt; <span class="string">&quot;example@test.com&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">license.starts_at = Date.new(2020, 1, 1) <span class="comment"># 开始时间</span></span><br><span class="line">license.expires_at = Date.new(2099, 1, 1) <span class="comment"># 结束时间</span></span><br><span class="line">license.notify_admins_at = Date.new(2049, 12, 1)</span><br><span class="line">license.notify_users_at = Date.new(2049, 12, 1)</span><br><span class="line">license.block_changes_at = Date.new(2099, 1, 1)</span><br><span class="line">license.restrictions = &#123;</span><br><span class="line">  active_user_count: 10000,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">puts <span class="string">&quot;License:&quot;</span></span><br><span class="line">puts license</span><br><span class="line"></span><br><span class="line">data = license.export</span><br><span class="line">puts <span class="string">&quot;Exported license:&quot;</span></span><br><span class="line">puts data</span><br><span class="line">File.open(<span class="string">&quot;GitLabBV.gitlab-license&quot;</span>, <span class="string">&quot;w&quot;</span>) &#123; |f| f.write(data) &#125;</span><br><span class="line"></span><br><span class="line">public_key = OpenSSL::PKey::RSA.new File.<span class="built_in">read</span>(<span class="string">&quot;license_key.pub&quot;</span>)</span><br><span class="line">Gitlab::License.encryption_key = public_key</span><br><span class="line"></span><br><span class="line">data = File.<span class="built_in">read</span>(<span class="string">&quot;GitLabBV.gitlab-license&quot;</span>)</span><br><span class="line"><span class="variable">$license</span> = Gitlab::License.import(data)</span><br><span class="line"></span><br><span class="line">puts <span class="string">&quot;Imported license:&quot;</span></span><br><span class="line">puts <span class="variable">$license</span></span><br><span class="line"></span><br><span class="line">unless <span class="variable">$license</span></span><br><span class="line">  raise <span class="string">&quot;The license is invalid.&quot;</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="variable">$license</span>.restricted?(:active_user_count)</span><br><span class="line">  active_user_count = 10000</span><br><span class="line">  <span class="keyword">if</span> active_user_count &gt; <span class="variable">$license</span>.restrictions[:active_user_count]</span><br><span class="line">    raise <span class="string">&quot;The active user count exceeds the allowed amount!&quot;</span></span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="variable">$license</span>.notify_admins?</span><br><span class="line">  puts <span class="string">&quot;The license is due to expire on #&#123;<span class="variable">$license</span>.expires_at&#125;.&quot;</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="variable">$license</span>.notify_users?</span><br><span class="line">  puts <span class="string">&quot;The license is due to expire on #&#123;<span class="variable">$license</span>.expires_at&#125;.&quot;</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">module Gitlab</span><br><span class="line">  class GitAccess</span><br><span class="line">    def check(cmd, changes = nil)</span><br><span class="line">      <span class="keyword">if</span> <span class="variable">$license</span>.block_changes?</span><br><span class="line">        <span class="built_in">return</span> build_status_object(<span class="literal">false</span>, <span class="string">&quot;License expired&quot;</span>)</span><br><span class="line">      end</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">puts <span class="string">&quot;This instance of GitLab Enterprise Edition is licensed to:&quot;</span></span><br><span class="line"><span class="variable">$license</span>.licensee.each <span class="keyword">do</span> |key, value|</span><br><span class="line">  puts <span class="string">&quot;#&#123;key&#125;: #&#123;value&#125;&quot;</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="variable">$license</span>.expired?</span><br><span class="line">  puts <span class="string">&quot;The license expired on #&#123;<span class="variable">$license</span>.expires_at&#125;&quot;</span></span><br><span class="line">elsif <span class="variable">$license</span>.will_expire?</span><br><span class="line">  puts <span class="string">&quot;The license will expire on #&#123;<span class="variable">$license</span>.expires_at&#125;&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  puts <span class="string">&quot;The license will never expire.&quot;</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="创建Dockerfile"><a href="#创建Dockerfile" class="headerlink" title="创建Dockerfile"></a>创建Dockerfile</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用最新的 GitLab 镜像作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> gitlab/gitlab-ee:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为我们的脚本创建一个目录</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /usr/src/lemon</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 license.rb 文件复制到新创建的目录中 </span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> license.rb /usr/src/lemon</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /usr/src/lemon</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Ruby 和必要的依赖</span></span><br><span class="line"><span class="comment">#RUN apt-get update &amp;&amp; apt-get install -y ruby ruby-dev</span></span><br><span class="line"><span class="comment">#RUN gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/</span></span><br><span class="line"><span class="comment">#RUN gem install openssl --verbose</span></span><br><span class="line"><span class="comment">#RUN gem install gitlab-license --verbose</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行脚本并产生所需的文件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> ruby license.rb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 覆盖公钥</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cp</span> license_key.pub /opt/gitlab/embedded/service/gitlab-rails/.license_encryption_key.pub</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 license.rb 文件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s/restricted_attr(:plan).presence || STARTER_PLAN/restricted_attr(:plan).presence || ULTIMATE_PLAN/g&#x27;</span> /opt/gitlab/embedded/service/gitlab-rails/ee/app/models/license.rb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名 license 文件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mv</span> GitLabBV.gitlab-license lemon.gitlab-license</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">rm</span> license.rb license_key license_key.pub</span></span><br><span class="line"><span class="comment"># 开启容器时的命令</span></span><br><span class="line"><span class="comment">#CMD [&quot;gitlab-ctl&quot;, &quot;reconfigure&quot;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 需要将license.rb Dockerfile两个文件放在一块即可</p>




<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p> 我以gitlab_license 为例 gitlab_license 你那边可以随意起名 起的名字是镜像的名字</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t gitlab_license .</span><br></pre></td></tr></table></figure>

<p>等待构建完成后 docker images  就出现对应的你创建的镜像了</p>
<p>如果有docker-compose.yml   </p>
<p>可以按着你之前的 <code>docker-compose.yml </code>  </p>
<p>只需要将你yml的镜像改成你自己创建的镜像  <code>down up -d</code></p>
<p>我以简单的例子作为演示 ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 80:80  gitlab_license</span><br></pre></td></tr></table></figure>

<p>运行容器之后 </p>
<p>等待gitlab启动  </p>
<p>gitlab的访问地址是 你设备的 ip 加端口号  80 443 可以省略不写  </p>
<p>还有启动时间根据你的机器性能有关 </p>
<p>当出现这个页面 说明一切准备就绪</p>


<h3 id="修改默认密码"><a href="#修改默认密码" class="headerlink" title="修改默认密码"></a>修改默认密码</h3><p>第一次使用需要默认的初始密码</p>
<p>进入容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it (容器<span class="built_in">id</span> 或者容器名称) /bin/bash</span><br><span class="line">docker <span class="built_in">exec</span> -it 877c606c5e53 /bin/bash </span><br><span class="line"><span class="built_in">cat</span> /etc/gitlab/initial_root_password </span><br></pre></td></tr></table></figure>



<p>mmPPA7vlzRPgdEgQXu1LnWbok6OUNgiAgoZvhYnCgrw&#x3D;是默认的初始密码</p>
<p>我们可以在&#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb配置文件中设置自己的root密码，也可以用默认的密码登陆再修改自己想要的密码。</p>
<p><strong>要注意该文件24小时后自动删除</strong>。</p>
<h3 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h3><p>网页版是激活路径</p>


<p>在右侧下滑到 添加许可证</p>


<p>进入容器</p>
<p>当前目录是&#x2F;usr&#x2F;src&#x2F;lemon 如果不是 这个目录请转移到这个目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it (容器id 或者容器名称) /bin/bash</span><br><span class="line">docker exec -it 877c606c5e53 /bin/bash </span><br><span class="line">cat /usr/src/lemon/lemon.gitlab-license</span><br></pre></td></tr></table></figure>

<p>将当前的密钥添加到许可证密钥中即可</p>
]]></content>
      <categories>
        <category>gitLab</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>gitLab</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo01</title>
    <url>/2024/06/20/hexo/Hexo01/</url>
    <content><![CDATA[<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br><span class="line">cd themes</span><br><span class="line">git clone https://github.com/theme-next/hexo-theme-next</span><br></pre></td></tr></table></figure>

<h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">hexo-theme-next</span></span><br></pre></td></tr></table></figure>

<h2 id="设置创建文件时创建目录"><a href="#设置创建文件时创建目录" class="headerlink" title="设置创建文件时创建目录"></a>设置创建文件时创建目录</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写作</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># 新帖子的文件名</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># 将标题转换为标题大小写</span></span><br><span class="line"><span class="attr">external_link:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 在新标签页中打开外部链接</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># 适用于整个网站</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span> <span class="comment"># 修改为true</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="设置目录和子目录"><a href="#设置目录和子目录" class="headerlink" title="设置目录和子目录"></a>设置目录和子目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br><span class="line">hexo new page categories</span><br><span class="line">hexo new page archives</span><br></pre></td></tr></table></figure>

<h2 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Next 主题在 Hexo 中添加GA4</title>
    <url>/2024/06/29/hexo/Next%20%E4%B8%BB%E9%A2%98%E5%9C%A8%20Hexo%20%E4%B8%AD%E6%B7%BB%E5%8A%A0GA4/</url>
    <content><![CDATA[<p>确保您的 Next 主题是7。</p>
<h2 id="1：修改-config-yml"><a href="#1：修改-config-yml" class="headerlink" title="1：修改_config.yml"></a>1：修改_config.yml</h2><p>打开 <code>&#123;HEXO_ROOT&#125;\themes\next\_config.yml</code> 文件，找到以下代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.swig</span></span><br></pre></td></tr></table></figure>

<p>删除 “#head: source&#x2F;_data&#x2F;head.swig “行中的 #。</p>
<h2 id="2：添加head-swig"><a href="#2：添加head-swig" class="headerlink" title="2：添加head.swig"></a>2：添加head.swig</h2><p>创建一个文件 <code>&#123;HEXO_ROOT&#125;\source\_data\head.swig</code> 并将 GA 代码放入该文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Global site tag (gtag.js) - Google Analytics --&gt;</span><br><span class="line">&lt;script async src=&quot;https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  window.dataLayer = window.dataLayer || [];</span><br><span class="line">  function gtag()&#123;dataLayer.push(arguments);&#125;</span><br><span class="line">  gtag(&#x27;js&#x27;, new Date());</span><br><span class="line"></span><br><span class="line">  gtag(&#x27;config&#x27;, &#x27;G-XXXXXXXXXX&#x27;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-获取代码"><a href="#3-获取代码" class="headerlink" title="3.获取代码"></a>3.获取代码</h2><ol>
<li>資料蒐集和修改 -&gt; 資料串流</li>
<li>點選你的網址</li>
<li>最下方的 查看代碼操作說明</li>
<li>選擇右邊的 手動安裝 就可以看到追蹤程式碼了</li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList类</title>
    <url>/2020/03/29/java/ArrayList%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="什么是ArrayList类"><a href="#什么是ArrayList类" class="headerlink" title="什么是ArrayList类"></a>什么是ArrayList类</h2><p><code>java.utiL.ArrayList</code>是大小可变的数组的实现，存储在内的数据称为元素。</p>
<p>此类提供一些方法来操作内部存储的元素。</p>
<p><code>ArrayList</code>中可不断添加元素，其大小也自动增长。</p>
<h2 id="ArrayList使用步骤"><a href="#ArrayList使用步骤" class="headerlink" title="ArrayList使用步骤"></a>ArrayList使用步骤</h2><ul>
<li>查看类<ul>
<li><code>java.util.ArrayList &lt;E&gt;</code>：该类需要import导入后使用<ul>
<li><code>&lt;E&gt;</code>，表示一种指定的数据类型，叫做泛型，<code>E</code>：取自Element（元素）的首字母，在出现<code>E</code>的地方，我们使用一种引用数据类型将其替换立刻，边是我们将存储那种引用类型的元素。</li>
<li>例如：<code>ArrayList&lt;String&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li>查看构造方法<ul>
<li><code>public ArrayList()</code>：构造一个内容为空的集合</li>
</ul>
</li>
<li>格式<ul>
<li><code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></li>
<li>在JDK7之后，右侧泛型的尖括号之内可以留空</li>
<li><code>ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</code></li>
</ul>
</li>
<li>查看成员方法<ul>
<li><code>public boolean add(E e)</code>：将指定的元素添加到此列表的尾部<ul>
<li>参数<code>E e</code>，在构造Arraylist对象时，<code>&lt;E&gt;</code>指定了什么数据类型，那么<code>add (E e)</code>方法中，只能添加什么数据类型的对象。</li>
</ul>
</li>
</ul>
</li>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">     list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">     list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">     list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">     System.out.println(list);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用方法和遍历"><a href="#常用方法和遍历" class="headerlink" title="常用方法和遍历"></a>常用方法和遍历</h2><p>对于元素的操作，基本体现在-一增、删、查。常用的方法有：</p>
<ul>
<li><code>public boolean add(E e)</code>：将指定的元素添加到此集合的尾部</li>
<li><code>public E remove(int index)</code>：移除此集合中指定位置上的元素。返回被删除的元素</li>
<li><code>public E get(int index)</code>：返回此集合中指定位置上的元素。返回获取的元素</li>
<li><code>public int size()</code>：返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界</li>
<li>这些都是最基本的方法，操作非常简单，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">       System.out.println(list); <span class="comment">// [a, b, c]</span></span><br><span class="line">       System.out.println(list.remove(<span class="number">1</span>)); <span class="comment">// b</span></span><br><span class="line">       System.out.println(list); <span class="comment">// [a, c]</span></span><br><span class="line">       System.out.println(list.get(<span class="number">1</span>)); <span class="comment">// c</span></span><br><span class="line">       System.out.println(list.size()); <span class="comment">// 2</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何存储基本数据类型"><a href="#如何存储基本数据类型" class="headerlink" title="如何存储基本数据类型"></a>如何存储基本数据类型</h2><p><code>ArrayList</code>对象不能存储基本类型，只能存储引用类型的数据。类似<code>&lt;int&gt;</code>不能写，但是存储基本数据类型对应的<code>包装类型</code>是可以的。所以，想要存储基本类型数据，<code>&lt;&gt;</code>中的数据类型，必须转换后才能编写，转换写法如下：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>基本类型包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       list.add(<span class="number">1</span>);</span><br><span class="line">       list.add(<span class="number">2</span>);</span><br><span class="line">       list.add(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Arrays类</title>
    <url>/2020/04/01/java/Arrays%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>java.util.Arrays</code>此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来非常简单。</p>
<h2 id="操作数组的方法"><a href="#操作数组的方法" class="headerlink" title="操作数组的方法"></a>操作数组的方法</h2><ul>
<li><p><code>public static String toString(int[] a)</code>：返回指定数组内容的字符串表示形式</p>
</li>
<li><p><code>public static void sort(int[] a)</code>：对指定的数组按数字升序进行排序</p>
<ul>
<li>数值，sort默认按照升序从小到大</li>
</ul>
</li>
<li><p>字符串，sort默认按照字母升序</p>
<ul>
<li>自定义类型，自定义类需要有Comparable或者Comparator接口的支持</li>
</ul>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] bytes = &#123;<span class="number">99</span>,<span class="number">98</span>,<span class="number">97</span>&#125;;</span><br><span class="line">    <span class="type">short</span>[] shorts = &#123;<span class="number">99</span>,<span class="number">98</span>,<span class="number">97</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] ints =&#123;<span class="number">99</span>,<span class="number">98</span>,<span class="number">97</span>&#125;;</span><br><span class="line">    <span class="type">long</span>[] longs = &#123;<span class="number">99</span>,<span class="number">98</span>,<span class="number">97</span>&#125;;</span><br><span class="line">    <span class="type">float</span>[] floats = &#123;<span class="number">99.0F</span>,<span class="number">98.0F</span>,<span class="number">97.0F</span>&#125;;</span><br><span class="line">    <span class="type">double</span>[] doubles = &#123;<span class="number">99.0</span>,<span class="number">98.0</span>,<span class="number">97.0</span>&#125;;</span><br><span class="line">    <span class="type">char</span>[] chars = &#123;<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">boolean</span>[] booleans = &#123;<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">true</span>&#125;;</span><br><span class="line">    String[] strings =  &#123;<span class="string">&quot;c&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// Arrays.toString</span></span><br><span class="line">    System.out.println(Arrays.toString(bytes));     <span class="comment">//[99, 98, 97]</span></span><br><span class="line">    System.out.println(Arrays.toString(shorts));    <span class="comment">//[99, 98, 97]</span></span><br><span class="line">    System.out.println(Arrays.toString(ints));      <span class="comment">//[99, 98, 97]</span></span><br><span class="line">    System.out.println(Arrays.toString(longs));     <span class="comment">//[99, 98, 97]</span></span><br><span class="line">    System.out.println(Arrays.toString(chars));     <span class="comment">//[c, b, a]</span></span><br><span class="line">    System.out.println(Arrays.toString(floats));    <span class="comment">//[99.0, 98.0, 97.0]</span></span><br><span class="line">    System.out.println(Arrays.toString(doubles));   <span class="comment">//[99.0, 98.0, 97.0]</span></span><br><span class="line">    System.out.println(Arrays.toString(booleans));  <span class="comment">//[true, false, true]</span></span><br><span class="line">    System.out.println(Arrays.toString(strings));   <span class="comment">//[c, b, a]</span></span><br><span class="line">    <span class="comment">// Arrays.sort</span></span><br><span class="line">    Arrays.sort(bytes);</span><br><span class="line">    Arrays.sort(shorts);</span><br><span class="line">    Arrays.sort(ints);</span><br><span class="line">    Arrays.sort(longs);</span><br><span class="line">    Arrays.sort(chars);</span><br><span class="line">    Arrays.sort(floats);</span><br><span class="line">    Arrays.sort(doubles);</span><br><span class="line">    Arrays.sort(strings);</span><br><span class="line">    System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">    System.out.println(Arrays.toString(bytes));   <span class="comment">//[97, 98, 99]</span></span><br><span class="line">    System.out.println(Arrays.toString(shorts));  <span class="comment">//[97, 98, 99]</span></span><br><span class="line">    System.out.println(Arrays.toString(ints));    <span class="comment">//[97, 98, 99]</span></span><br><span class="line">    System.out.println(Arrays.toString(longs));   <span class="comment">//[97, 98, 99]</span></span><br><span class="line">    System.out.println(Arrays.toString(chars));   <span class="comment">//[a, b, c]</span></span><br><span class="line">    System.out.println(Arrays.toString(floats));  <span class="comment">//[97.0, 98.0, 99.0]</span></span><br><span class="line">    System.out.println(Arrays.toString(doubles)); <span class="comment">//[97.0, 98.0, 99.0]</span></span><br><span class="line">    System.out.println(Arrays.toString(strings)); <span class="comment">//[a, b, c]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Collections类</title>
    <url>/2020/04/20/java/Collections%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h2><ul>
<li><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</li>
</ul>
<ul>
<li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)  </code>:往集合中添加一些元素。</li>
<li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li>
</ul>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//原来写法</span></span><br><span class="line">        <span class="comment">//list.add(12);</span></span><br><span class="line">        <span class="comment">//list.add(14);</span></span><br><span class="line">        <span class="comment">//list.add(15);</span></span><br><span class="line">        <span class="comment">//list.add(1000);</span></span><br><span class="line">        <span class="comment">//采用工具类 完成 往集合中添加元素  </span></span><br><span class="line">        Collections.addAll(list, <span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>，<span class="number">2</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//排序方法 </span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">[<span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">222</span>]</span><br></pre></td></tr></table></figure>

<p>代码演示之后 ，发现我们的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序那该怎么办呢？</p>
<p>我们发现还有个方法没有讲，<code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。接下来讲解一下指定规则的排列。</p>
<h2 id="Comparator比较器"><a href="#Comparator比较器" class="headerlink" title="Comparator比较器"></a>Comparator比较器</h2><p>我们还是先研究这个方法</p>
<p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p>
<p>不过这次存储的是字符串类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt;  list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;cba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;aba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;sba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;nba&quot;</span>);</span><br><span class="line">        <span class="comment">//排序方法</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[aba, cba, nba, sba]</span><br></pre></td></tr></table></figure>

<p>我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？</p>
<p>说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用<code>java.lang.Comparable</code>接口去实现，一种是灵活的当我需要做排序的时候在去选择的<code>java.util.Comparator</code>接口完成。</p>
<p>那么我们采用的<code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br></pre></td></tr></table></figure>

<p>String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用</p>
<p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：</p>
<ul>
<li><p><code> public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</p>
<blockquote>
<p>两个对象比较的结果有三种：大于，等于，小于。</p>
<p>如果要按照升序排序，<br>则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）<br>如果要按照降序排序<br>则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）</p>
</blockquote>
</li>
</ul>
<p>操作如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;cba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;aba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;sba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;nba&quot;</span>);</span><br><span class="line">        <span class="comment">//排序方法  按照第一个单词的降序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o2.charAt(<span class="number">0</span>) - o1.charAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[sba, nba, cba, aba]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, (i, j) -&gt; j.getAge() - i.getAge());</span><br><span class="line">可以替换成</span><br><span class="line">list.sort((i, j) -&gt; j.getAge() - i.getAge());</span><br></pre></td></tr></table></figure>

<h2 id="简述Comparable和Comparator两个接口的区别。"><a href="#简述Comparable和Comparator两个接口的区别。" class="headerlink" title="简述Comparable和Comparator两个接口的区别。"></a>简述Comparable和Comparator两个接口的区别。</h2><p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p>
<p><strong>Comparator</strong>强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>创建一个学生类，存储到ArrayList集合中完成指定排序操作。</p>
<p>Student 初始类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">               <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">               <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">               <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建四个学生对象 存储到集合中</span></span><br><span class="line">        ArrayList&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;rose&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;abc&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;ace&quot;</span>,<span class="number">17</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;mark&quot;</span>,<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          让学生 按照年龄排序 升序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        Collections.sort(list);//要求 该list中元素类型  必须实现比较器Comparable接口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现，当我们调用Collections.sort()方法的时候 程序报错了。</p>
<p>原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。</p>
<p>于是我们就完成了Student类的一个实现，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age-o.age;<span class="comment">//升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次测试，代码就OK 了效果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student&#123;name=<span class="string">&#x27;jack&#x27;</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;abc&#x27;</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;mark&#x27;</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;ace&#x27;</span>, age=<span class="number">17</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;rose&#x27;</span>, age=<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>如果在使用的时候，想要独立的定义规则去使用 可以采用Collections.sort(List list,Comparetor<T> c)方式，自己定义规则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.getAge()-o1.getAge();<span class="comment">//以学生的年龄降序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Student&#123;name=&#x27;rose&#x27;, age=18&#125;</span><br><span class="line">Student&#123;name=&#x27;ace&#x27;, age=17&#125;</span><br><span class="line">Student&#123;name=&#x27;jack&#x27;, age=16&#125;</span><br><span class="line">Student&#123;name=&#x27;abc&#x27;, age=16&#125;</span><br><span class="line">Student&#123;name=&#x27;mark&#x27;, age=16&#125;</span><br></pre></td></tr></table></figure>



<p>如果想要规则更多一些，可以参考下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">                <span class="comment">// 年龄降序</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> o2.getAge()-o1.getAge();<span class="comment">//年龄降序</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(result==<span class="number">0</span>)&#123;<span class="comment">//第一个规则判断完了 下一个规则 姓名的首字母 升序</span></span><br><span class="line">                    result = o1.getName().charAt(<span class="number">0</span>)-o2.getName().charAt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Student&#123;name=&#x27;rose&#x27;, age=18&#125;</span><br><span class="line">Student&#123;name=&#x27;ace&#x27;, age=17&#125;</span><br><span class="line">Student&#123;name=&#x27;abc&#x27;, age=16&#125;</span><br><span class="line">Student&#123;name=&#x27;jack&#x27;, age=16&#125;</span><br><span class="line">Student&#123;name=&#x27;mark&#x27;, age=16&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Collection集合</title>
    <url>/2020/04/15/java/Collection%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>集合到底是什么呢?</p>
<ul>
<li><strong>集合</strong>：集合是Java中提供的一种容器，可以用来存储多个数据。</li>
</ul>
<p>集合和数组既然都是容器，它们有啥区别呢？</p>
<ul>
<li>数组的长度是固定的。集合的长度是可变的。</li>
<li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li>
</ul>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>JavaSE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p>
<p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code>，今天我们主要学习<code>Collection</code>集合，<code>Map</code>集合。</p>
<ul>
<li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。<ul>
<li>其中，<code>List</code>的特点是元素有序、元素可重复。</li>
<li><code>Set</code>的特点是元素无序，而且不可重复。</li>
<li><code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，</li>
<li><code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</li>
</ul>
</li>
</ul>
<p>从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。</p>
<img data-src="/2020/04/15/java/Collection%E9%9B%86%E5%90%88/01_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.bmp" class="" alt="01_集合框架介绍">

<img data-src="/2020/04/15/java/Collection%E9%9B%86%E5%90%88/image-20200412180201258.png" class="" alt="image-20200412180201258">

<p>其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。</p>
<p>集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p>
<h2 id="Collection-常用功能"><a href="#Collection-常用功能" class="headerlink" title="Collection 常用功能"></a>Collection 常用功能</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p>
<ul>
<li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li>
<li><code>public void clear()</code> :清空集合中所有的元素。</li>
<li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li>
<li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li>
<li><code>public int size()</code>: 返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li>
</ul>
<p>方法演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1Collection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建集合对象 </span></span><br><span class="line">    	<span class="comment">// 使用多态形式</span></span><br><span class="line">    	Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    	<span class="comment">// 使用方法</span></span><br><span class="line">    	<span class="comment">// 添加功能  boolean  add(String s)</span></span><br><span class="line">    	coll.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line">    	System.out.println(coll);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// boolean contains(E e) 判断o是否在集合中存在</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;判断  扫地僧 是否在集合中&quot;</span>+coll.contains(<span class="string">&quot;扫地僧&quot;</span>));</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//boolean remove(E e) 删除在集合中的o元素</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;删除石破天：&quot;</span>+coll.remove(<span class="string">&quot;石破天&quot;</span>));</span><br><span class="line">    	System.out.println(<span class="string">&quot;操作之后集合中元素:&quot;</span>+coll);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// size() 集合中有几个元素</span></span><br><span class="line">		System.out.println(<span class="string">&quot;集合中有&quot;</span>+coll.size()+<span class="string">&quot;个元素&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Object[] toArray()转换成一个Object数组</span></span><br><span class="line">    	Object[] objects = coll.toArray();</span><br><span class="line">    	<span class="comment">// 遍历数组</span></span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">			System.out.println(objects[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// void  clear() 清空集合</span></span><br><span class="line">		coll.clear();</span><br><span class="line">		System.out.println(<span class="string">&quot;集合中内容为：&quot;</span>+coll);</span><br><span class="line">		<span class="comment">// boolean  isEmpty()  判断是否为空</span></span><br><span class="line">		System.out.println(coll.isEmpty());  	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>File类</title>
    <url>/2020/04/21/java/File%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul>
<li><p><code>public File(String pathname) </code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。  </p>
</li>
<li><p><code>public File(String parent, String child) </code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。</p>
</li>
<li><p><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。  </p>
</li>
<li><p>构造举例，代码如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">pathname</span> <span class="operator">=</span> <span class="string">&quot;D:\\aaa.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(pathname); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">pathname2</span> <span class="operator">=</span> <span class="string">&quot;D:\\aaa\\bbb.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(pathname2); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="string">&quot;d:\\aaa&quot;</span>;</span><br><span class="line"> <span class="type">String</span> <span class="variable">child</span> <span class="operator">=</span> <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"> <span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parent, child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line"><span class="type">File</span> <span class="variable">parentDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">child</span> <span class="operator">=</span> <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentDir, child);</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>一个File对象代表硬盘中实际存在的一个文件或者目录。</li>
<li>无论该路径下是否存在文件或者目录，都不影响File对象的创建。</li>
</ol>
</blockquote>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h3><ul>
<li><p><code>public String getAbsolutePath() </code> ：返回此File的绝对路径名字符串。</p>
</li>
<li><p><code>public String getPath()</code> ：将此File转换为路径名字符串。 </p>
</li>
<li><p><code>public String getName()</code>  ：返回由此File表示的文件或目录的名称。  </p>
</li>
<li><p><code>public long length()</code>  ：返回由此File表示的文件的长度。 </p>
<p>方法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileGet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/aaa/bbb.java&quot;</span>);     </span><br><span class="line">        System.out.println(<span class="string">&quot;文件绝对路径:&quot;</span>+f.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件构造路径:&quot;</span>+f.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件名称:&quot;</span>+f.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件长度:&quot;</span>+f.length()+<span class="string">&quot;字节&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/aaa&quot;</span>);     </span><br><span class="line">        System.out.println(<span class="string">&quot;目录绝对路径:&quot;</span>+f2.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录构造路径:&quot;</span>+f2.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录名称:&quot;</span>+f2.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录长度:&quot;</span>+f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">文件绝对路径:d:\aaa\bbb.java</span><br><span class="line">文件构造路径:d:\aaa\bbb.java</span><br><span class="line">文件名称:bbb.java</span><br><span class="line">文件长度:<span class="number">636</span>字节</span><br><span class="line"></span><br><span class="line">目录绝对路径:d:\aaa</span><br><span class="line">目录构造路径:d:\aaa</span><br><span class="line">目录名称:aaa</span><br><span class="line">目录长度:<span class="number">4096</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。</p>
</blockquote>
<h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><ul>
<li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li>
<li><strong>相对路径</strong>：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilePath</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">// D盘下的bbb.java文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">      	</span><br><span class="line">		<span class="comment">// 项目下的bbb.java文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">D:\bbb.java</span><br><span class="line">D:\idea_project_test4\bbb.java</span><br></pre></td></tr></table></figure>

<h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><ul>
<li><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</li>
<li><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</li>
<li><code>public boolean isFile()</code> ：此File表示的是否为文件。</li>
</ul>
<p>方法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileIs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\aaa\\bbb.java&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line">      	<span class="comment">// 判断是否存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa\\bbb.java 是否存在:&quot;</span>+f.exists());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 是否存在:&quot;</span>+f2.exists());</span><br><span class="line">      	<span class="comment">// 判断是文件还是目录</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 文件?:&quot;</span>+f2.isFile());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 目录?:&quot;</span>+f2.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">d:\aaa\bbb.java 是否存在:<span class="literal">true</span></span><br><span class="line">d:\aaa 是否存在:<span class="literal">true</span></span><br><span class="line">d:\aaa 文件?:<span class="literal">false</span></span><br><span class="line">d:\aaa 目录?:<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h3><ul>
<li><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </li>
<li><code>public boolean delete()</code> ：删除由此File表示的文件或目录。  </li>
<li><code>public boolean mkdir()</code> ：创建由此File表示的目录。</li>
<li><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</li>
</ul>
<p>方法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCreateDelete</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 文件的创建</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;aaa.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f.createNewFile()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// true</span></span><br><span class="line">		</span><br><span class="line">     	<span class="comment">// 目录的创建</span></span><br><span class="line">      	File f2= <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;newDir&quot;</span>);	</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f2.mkdir());	<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建多级目录</span></span><br><span class="line">      	File f3= <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdir());<span class="comment">// false</span></span><br><span class="line">        File f4= <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f4.mkdirs());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 文件的删除</span></span><br><span class="line">       	System.out.println(f.delete());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 目录的删除</span></span><br><span class="line">        System.out.println(f2.delete());<span class="comment">// true</span></span><br><span class="line">        System.out.println(f4.delete());<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。</p>
</blockquote>
<h2 id="目录的遍历"><a href="#目录的遍历" class="headerlink" title="目录的遍历"></a>目录的遍历</h2><ul>
<li><p><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</p>
</li>
<li><p><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileFor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\java_code&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">//获取当前目录下的文件以及文件夹的名称。</span></span><br><span class="line">		String[] names = dir.list();</span><br><span class="line">		<span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>HelloWorld入门程序</title>
    <url>/2020/03/03/java/HelloWorld%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="程序开发步骤说明"><a href="#程序开发步骤说明" class="headerlink" title="程序开发步骤说明"></a>程序开发步骤说明</h2><p>开发环境已经搭建完毕，可以开发我们第一个Java程序了。</p>
<p>Java程序开发三步骤：<strong>编写</strong>、<strong>编译</strong>、<strong>运行</strong></p>
<img data-src="/2020/03/03/java/HelloWorld%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/image-20200330143419255.png" class="" alt="image-20200330143419255">

<p>编译：后缀为<code>.java</code></p>
<p>编译：后缀为<code>.class</code></p>
<h2 id="编写Java源程序"><a href="#编写Java源程序" class="headerlink" title="编写Java源程序"></a>编写Java源程序</h2><ol>
<li><p>在<strong>E:\JavaSE\day1</strong>目录下新建文本文件，完整的文件名修改为<strong>HelloWorld.java</strong>，其中文件名为<strong>HelloWorld</strong>，后缀名必须为 <strong>.java</strong></p>
<img data-src="/2020/03/03/java/HelloWorld%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/image-20200330144757408.png" class="" alt="image-20200330144757408">
</li>
<li><p>用记事本打开</p>
</li>
<li><p>在文件中键入文本并保存，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;Hello Wrold!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>&#x3D;&#x3D;文件名必须是<strong>HelloWorld</strong>，保证文件名和类的名字是一致的，注意大小写&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;每个字母和符号必须与示例代码一模一样&#x3D;&#x3D;</li>
</ul>
</li>
</ol>
<h2 id="编译java源文件"><a href="#编译java源文件" class="headerlink" title="编译java源文件"></a>编译java源文件</h2><p>在DOS命令行中，进入<strong>Java源文件的目录</strong>，使用<strong>javac</strong>命令进行编译。</p>
<p>命令：<code>javac HelloWorld.java</code></p>
<img data-src="/2020/03/03/java/HelloWorld%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/image-20200330145037750.png" class="" alt="image-20200330145037750">

<p>编译成功后，命令行没有任何提示。打开<strong>E:\JavaSE\day1</strong>目录，发现产生了一个新的文件HelloWorld.class，该文件就是编译后的文件，是Java的可运行文件，称为字节码文件，有了字节码文件，就可以运行程序了。</p>
<h2 id="运行Java程序"><a href="#运行Java程序" class="headerlink" title="运行Java程序"></a>运行Java程序</h2><p>在DOS命令行中，进入<strong>Java源文件的目录</strong>，使用<strong>java</strong>命令进行运行。</p>
<p>命令：<code>java HelloWorld</code></p>
<img data-src="/2020/03/03/java/HelloWorld%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/image-20200330145407426.png" class="" alt="image-20200330145407426">

<p>&#x3D;&#x3D;一定不要写<code>.class</code>&#x3D;&#x3D;</p>
<h2 id="入门程序说明"><a href="#入门程序说明" class="headerlink" title="入门程序说明"></a>入门程序说明</h2><p>编译和运行是两回事</p>
<ul>
<li><p><strong>编译</strong>：是指将我们编写的<strong>Java</strong>源文件翻译成JVM<strong>认识</strong>的<strong>class</strong>文件，在这个过程中，j<strong>avac编译器</strong>会检查我们所写的程序是否有错误，有错误就会提示出来，如果没有错误就会编译成功。</p>
</li>
<li><p><strong>运行</strong>：是指将class文件交给JVM去运行，此时JVM就会去执行我们编写的程序了。</p>
</li>
</ul>
<h3 id="关于main方法"><a href="#关于main方法" class="headerlink" title="关于main方法"></a>关于main方法</h3><p><strong>main方法</strong>：称为主方法。写法是<strong>固定格式</strong>不可以更改。main方法是程序的入口点或起始点，无论我们编写多少程序，JVM在运行的时候，都会从main方法这里开始执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="添加注释comment"><a href="#添加注释comment" class="headerlink" title="添加注释comment"></a>添加注释comment</h2><ul>
<li>注释：就是对代码的解释和说明。其目的是让人们能够更加轻松地了解代码。为代码添加注释，是十分必须要的，它不影响程序的编译和运行。</li>
<li>Java中有单行注释和多行注释<ul>
<li>单行注释以<code>//开头 </code>换行结束</li>
<li>多行注释以<code>/*开头 以*/</code>结束</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		这是多行注释</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;Hello Wrold!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关键字keywords"><a href="#关键字keywords" class="headerlink" title="关键字keywords"></a>关键字keywords</h2><p>关键字：是指在程序中，Java已经定义好的单词，具有特殊含义。</p>
<ul>
<li><p>全部都是小写字母。</p>
</li>
<li><p>HelloWorld案例中，出现的关键字有<strong>public、class、static、void</strong>等</p>
<table>
<thead>
<tr>
<th>byte</th>
<th>基本数据类型之一，字节类型</th>
</tr>
</thead>
<tbody><tr>
<td>short</td>
<td>基本数据类型之一，短整数类型</td>
</tr>
<tr>
<td>int</td>
<td>基本数据类型之一，整数类型</td>
</tr>
<tr>
<td>long</td>
<td>基本数据类型之一，长整数类型</td>
</tr>
<tr>
<td>float</td>
<td>基本数据类型之一，单精度浮点数类型</td>
</tr>
<tr>
<td>boolean</td>
<td>基本数据类型之一，声明布尔类型的关键字</td>
</tr>
<tr>
<td>char</td>
<td>基本数据类型之一，字符类型</td>
</tr>
<tr>
<td>double</td>
<td>基本数据类型之一，双精度浮点数类型</td>
</tr>
<tr>
<td>try</td>
<td>尝试一个可能抛出异常的程序块</td>
</tr>
<tr>
<td>catch</td>
<td>用在异常处理中，用来捕捉异常</td>
</tr>
<tr>
<td>finally</td>
<td>用于处理异常情况，用来声明一个基本肯定会被执行到的语句块</td>
</tr>
<tr>
<td>throw</td>
<td>抛出一个异常</td>
</tr>
<tr>
<td>throws</td>
<td>声明在当前定义的成员方法中所有需要抛出的异常</td>
</tr>
<tr>
<td>for</td>
<td>一种循环结构的引导词</td>
</tr>
<tr>
<td>do</td>
<td>用在do-while循环结构中</td>
</tr>
<tr>
<td>while</td>
<td>用在循环结构中</td>
</tr>
<tr>
<td>break</td>
<td>提前跳出一个块</td>
</tr>
<tr>
<td>continue</td>
<td>回到一个块的开始处</td>
</tr>
<tr>
<td>switch</td>
<td>分支语句结构的引导词</td>
</tr>
<tr>
<td>case</td>
<td>用在switch语句之中，表示其中的一个分支</td>
</tr>
<tr>
<td>if</td>
<td>条件语句的引导词</td>
</tr>
<tr>
<td>else</td>
<td>用在条件语句中，表明当条件不成立时的分支</td>
</tr>
<tr>
<td>instanceof</td>
<td>用来测试一个对象是否是指定类型的实例对象</td>
</tr>
<tr>
<td>private</td>
<td>一种访问控制方式：私用模式</td>
</tr>
<tr>
<td>protected</td>
<td>一种访问控制方式：保护模式</td>
</tr>
<tr>
<td>public</td>
<td>一种访问控制方式：共用模式</td>
</tr>
<tr>
<td>super</td>
<td>表明当前对象的父类型的引用或者父类型的构造方法</td>
</tr>
<tr>
<td>this</td>
<td>指向当前实例对象的引用</td>
</tr>
<tr>
<td>package</td>
<td>包</td>
</tr>
<tr>
<td>import</td>
<td>表明要访问指定的类或包</td>
</tr>
<tr>
<td>class</td>
<td>声明一个类</td>
</tr>
<tr>
<td>enum</td>
<td>枚举</td>
</tr>
<tr>
<td>interface</td>
<td>接口</td>
</tr>
<tr>
<td>abstract</td>
<td>表明类或者成员方法具有抽象属性</td>
</tr>
<tr>
<td>extends</td>
<td>表明一个类型是另一个类型的子类型。对于类，可以是另一个类或者抽象类；对于接口，可以是另一个接口</td>
</tr>
<tr>
<td>implements</td>
<td>表明一个类实现了给定的接口</td>
</tr>
<tr>
<td>static</td>
<td>表明具有静态属性</td>
</tr>
<tr>
<td>final</td>
<td>用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量</td>
</tr>
<tr>
<td>void</td>
<td>声明当前成员方法没有返回值</td>
</tr>
<tr>
<td>return</td>
<td>从成员方法中返回数据</td>
</tr>
<tr>
<td>default</td>
<td>默认，例如，用在switch语句中，表明一个默认的分支。Java8 中也作用于声明接口函数的默认实现</td>
</tr>
<tr>
<td>new</td>
<td>用来创建新实例对象</td>
</tr>
<tr>
<td>synchronized</td>
<td>表明一段代码需要同步执行</td>
</tr>
<tr>
<td>native</td>
<td>用来声明一个方法是由与计算机相关的语言（如C&#x2F;C++&#x2F;FORTRAN语言）实现的</td>
</tr>
<tr>
<td>strictfp</td>
<td>用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范</td>
</tr>
<tr>
<td>assert</td>
<td>断言，用来进行程序调试</td>
</tr>
<tr>
<td>transient</td>
<td>声明不用序列化的成员域</td>
</tr>
<tr>
<td>volatile</td>
<td>表明两个或者多个变量必须同步地发生变化</td>
</tr>
<tr>
<td>goto</td>
<td>保留关键字，没有具体含义</td>
</tr>
<tr>
<td>const</td>
<td>保留关键字，没有具体含义</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符：是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。</p>
<ul>
<li>HelloWorld案例中，出现的标识符有类名字<code>HelloWorld</code></li>
<li>命名规则：硬性要求<ul>
<li>标识符可以包含英文字母<code>26个（区分大小写）</code>、<code>0-9数字</code>、<code>$（美元符号）</code>和<code>_（下划线）</code></li>
<li>标识符不能以数字开头。</li>
<li>标识符不能是关键字。</li>
</ul>
</li>
<li>命名规范：软性建议<ul>
<li>类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）</li>
<li>方法名规范：首字母小写，后面每个单词首字母大写（小驼峰式）</li>
<li>变量名规范：全部小写。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Iterator迭代器</title>
    <url>/2020/04/16/java/Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h2 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h2><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p>
<p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p>
<ul>
<li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li>
</ul>
<p>下面介绍一下迭代的概念：</p>
<ul>
<li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li>
</ul>
<p>Iterator接口的常用方法如下：</p>
<ul>
<li><code>public E next()</code>:返回迭代的下一个元素。</li>
<li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li>
</ul>
<p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorDemo</span> &#123;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用多态方式 创建对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        coll.add(<span class="string">&quot;串串星人&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;吐槽星人&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;汪星人&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//使用迭代器 遍历   每个集合对象都有自己的迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="comment">//  泛型指的是 迭代出 元素的数据类型</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p>
</blockquote>
<h2 id="迭代器的实现原理"><a href="#迭代器的实现原理" class="headerlink" title="迭代器的实现原理"></a>迭代器的实现原理</h2><p>我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p>
<p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p>
<img data-src="/2020/04/16/java/Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/02_%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86(1).bmp" class="">

<p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p>
<h2 id="2-3-增强for"><a href="#2-3-增强for" class="headerlink" title="2.3 增强for"></a>2.3 增强for</h2><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; </span><br><span class="line">  	<span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p>
<h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NBForDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">87</span>&#125;;</span><br><span class="line">       	<span class="comment">//使用增强for遍历数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> a : arr)&#123;<span class="comment">//a代表数组中的每个元素</span></span><br><span class="line">			System.out.println(a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NBFor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        </span><br><span class="line">    	Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    	coll.add(<span class="string">&quot;小河神&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;老河神&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;神婆&quot;</span>);</span><br><span class="line">    	<span class="comment">//使用增强for遍历</span></span><br><span class="line">    	<span class="keyword">for</span>(String s :coll)&#123;<span class="comment">//接收变量s代表 代表被遍历到的集合元素</span></span><br><span class="line">    		System.out.println(s);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JShell脚本工具</title>
    <url>/2020/03/09/java/JShell%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="JShell脚本工具"><a href="#JShell脚本工具" class="headerlink" title="JShell脚本工具"></a>JShell脚本工具</h1><p>JShell脚本工具是JDK9的新特性</p>
<p>从java9开始，java开始引入了类似于python的交互式 REPL（Read-Eval-Print Loop，读取-求值-输出 循环）工具。官方的表述如下：</p>
<blockquote>
<p>The Java Shell tool (JShell) is an interactive tool for learning the Java programming language and prototyping Java code. JShell is a Read-Evaluate-Print Loop (REPL), which evaluates declarations, statements, and expressions as they are entered and immediately shows the results. The tool is run from the command line.</p>
</blockquote>
<p>简而言之，使用 JShell，你可以输入代码片段并马上看到运行结果，然后就可以根据需要作出调整。官方的表述如下：</p>
<blockquote>
<p>JShell helps you try out code and easily explore options as you develop your program. You can test individual statements, try out different variations of a method, and experiment with unfamiliar APIs within the JShell session. JShell doesn’t replace an IDE. As you develop your program, paste code into JShell to try it out, and then paste working code from JShell into your program editor or IDE.</p>
</blockquote>
<p>什么时候会用到<code>JShell</code>工具呢，当我们编写的代码非常少的时候，而又不愿意编写类，main方法，也不愿意去编译和运行，这个时候可以使用Shell工具。</p>
<p>启动Shell工具，在DOS命令行直接输入JShell命令。</p>
<img data-src="/2020/03/09/java/JShell%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/image-20200401173052296.png" class="" alt="image-20200401173052296">

<p>接下来可以编写Java代码，无需写类和方法，直接写方法中的代码即可，同时无需编译和运行，直接回车即可</p>
<img data-src="/2020/03/09/java/JShell%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/image-20200401173119744.png" class="" alt="image-20200401173119744">

<p>当然我门也可以在JShell里定义函数方法</p>
<img data-src="/2020/03/09/java/JShell%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/2726392-c425eceb3af74ae9.webp" class="" alt="img">

<p>这样我们就创建了一个方法。接下来使用我们的方法。</p>
<img data-src="/2020/03/09/java/JShell%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/2726392-d0942ddba42c8889.webp" class="" alt="img">

<p>那么从上面的这些例子我们可以看出，Jshell是可以执行我们的任何代码片段。但有个问题，就是加入我声明多个函数之后，我忘了那个是哪个，怎么办呢？所以我们需要学习Jshell提供给我们的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jshell&gt; /help</span><br><span class="line">|  键入 Java 语言表达式, 语句或声明。</span><br><span class="line">|  或者键入以下命令之一:</span><br><span class="line">|  /list [&lt;名称或 <span class="built_in">id</span>&gt;|-all|-start]</span><br><span class="line">|       列出您键入的源</span><br><span class="line">|  /edit &lt;名称或 <span class="built_in">id</span>&gt;</span><br><span class="line">|       编辑源条目</span><br><span class="line">|  /drop &lt;名称或 <span class="built_in">id</span>&gt;</span><br><span class="line">|       删除源条目</span><br><span class="line">|  /save [-all|-<span class="built_in">history</span>|-start] &lt;文件&gt;</span><br><span class="line">|       将片段源保存到文件</span><br><span class="line">|  /open &lt;file&gt;</span><br><span class="line">|       打开文件作为源输入</span><br><span class="line">|  /vars [&lt;名称或 <span class="built_in">id</span>&gt;|-all|-start]</span><br><span class="line">|       列出已声明变量及其值</span><br><span class="line">|  /methods [&lt;名称或 <span class="built_in">id</span>&gt;|-all|-start]</span><br><span class="line">|       列出已声明方法及其签名</span><br><span class="line">|  /types [&lt;名称或 <span class="built_in">id</span>&gt;|-all|-start]</span><br><span class="line">|       列出类型声明</span><br><span class="line">|  /imports</span><br><span class="line">|       列出导入的项</span><br><span class="line">|  /exit [&lt;integer-expression-snippet&gt;]</span><br><span class="line">|       退出 jshell 工具</span><br><span class="line">|  /env [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;] [-add-modules &lt;模块&gt;] ...</span><br><span class="line">|       查看或更改评估上下文</span><br><span class="line">|  /reset [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;] [-add-modules &lt;模块&gt;]...</span><br><span class="line">|       重置 jshell 工具</span><br><span class="line">|  /reload [-restore] [-quiet] [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;]...</span><br><span class="line">|       重置和重放相关历史记录 -- 当前历史记录或上一个历史记录 (-restore)</span><br><span class="line">|  /history</span><br><span class="line">|       您键入的内容的历史记录</span><br><span class="line">|  /help [&lt;<span class="built_in">command</span>&gt;|&lt;subject&gt;]</span><br><span class="line">|       获取有关使用 jshell 工具的信息</span><br><span class="line">|  /set editor|start|feedback|mode|prompt|truncation|format ...</span><br><span class="line">|       设置配置信息</span><br><span class="line">|  /? [&lt;<span class="built_in">command</span>&gt;|&lt;subject&gt;]</span><br><span class="line">|       获取有关使用 jshell 工具的信息</span><br><span class="line">|  /!</span><br><span class="line">|       重新运行上一个片段 -- 请参阅 /help rerun</span><br><span class="line">|  /&lt;<span class="built_in">id</span>&gt;</span><br><span class="line">|       按 ID 或 ID 范围重新运行片段 -- 参见 /help rerun</span><br><span class="line">|  /-&lt;n&gt;</span><br><span class="line">|       重新运行以前的第 n 个片段 -- 请参阅 /help rerun</span><br><span class="line">|</span><br><span class="line">|  有关详细信息, 请键入 <span class="string">&#x27;/help&#x27;</span>, 后跟</span><br><span class="line">|  命令或主题的名称。</span><br><span class="line">|  例如 <span class="string">&#x27;/help /list&#x27;</span> 或 <span class="string">&#x27;/help intro&#x27;</span>。主题:</span><br><span class="line">|</span><br><span class="line">|  intro</span><br><span class="line">|       jshell 工具的简介</span><br><span class="line">|  <span class="built_in">id</span></span><br><span class="line">|       片段 ID 以及如何使用它们的说明</span><br><span class="line">|  shortcuts</span><br><span class="line">|       片段和命令输入提示, 信息访问以及</span><br><span class="line">|       自动代码生成的按键说明</span><br><span class="line">|  context</span><br><span class="line">|       /env /reload 和 /reset 的评估上下文选项的说明</span><br><span class="line">|  rerun</span><br><span class="line">|       重新评估以前输入片段的方法的说明</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-8函数式编程1</title>
    <url>/2019/02/01/java/Java-8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B1/</url>
    <content><![CDATA[<blockquote>
<p>前言</p>
<p>Java 8 Lambdas，Richard Warburton 著（O’Reilly，2014）。版权所有， 978-1-449-37077-0</p>
<ul>
<li>如何编写出简单、干净、易读的代码 —— 尤其是对于集合的操作？</li>
<li>如何简单地使用并行计算提高性能？</li>
<li>如何准确地为问题建模，并且开发出更好的领域特定语言？</li>
<li>如何写出不易出错，并且更简单的并发代码？</li>
<li>如何测试和调试 Lambda 表达式？</li>
</ul>
<p>将<strong>Lambda 表达式</strong>加入 Java，并不只是为了提高开发人员的生产效率，业界也对这一特性有根本性的需求。</p>
</blockquote>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在开始探索 Lambda 表达式之前，首先我们要知道它因何而生。</p>
<h2 id="为什么需要再次修改Java"><a href="#为什么需要再次修改Java" class="headerlink" title="为什么需要再次修改Java"></a>为什么需要再次修改Java</h2><p>Java还欠缺高效的并行操作</p>
<p>面向对象编程是对数据进行抽象，函数式编程是对行为进行抽象</p>
<h2 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h2><p>在思考问题时，使用不可变值和函数，函数对一个值进行处理，映射成另一个值</p>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>Java 8 的最大变化是引入了 Lambda 表达式</p>
<h2 id="第一个Lambda表达式"><a href="#第一个Lambda表达式" class="headerlink" title="第一个Lambda表达式"></a>第一个Lambda表达式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">button.addActionListener(new ActionListener() &#123; </span><br><span class="line">    public void actionPerformed(ActionEvent event) &#123; </span><br><span class="line">        System.out.println(&quot;button clicked&quot;); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">==</span><br><span class="line"></span><br><span class="line">button.addActionListener(event -&gt; System.out.println(&quot;button clicked&quot;));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>和传入一个实现某接口的对象不同，我们传入了一段代码块——一个没有名字的函数。event 是参数名，和上面匿名内部类示例中的是同一个参数。-&gt; 将参数和 Lambda 表达式的主体分开，而主体是用户点击按钮时会运行的一些代码。</p>
<p>和使用匿名内部类的另一处不同在于声明 event 参数的方式。使用匿名内部类时需要显式地声明参数类型 ActionEvent  event，而在 Lambda 表达式中无需指定类型，程序依然可以编译。这是因为 javac 根据程序的上下文（addActionListener 方法的签名）在后台推断出了参数 event 的类型。这意味着如果参数类型不言而明，则无需显式指定。</p>
<blockquote>
<p>尽管与之前相比，Lambda 表达式中的参数需要的样板代码很少，但是 Java 8仍然是一种静态类型语言。为了增加可读性并迁就我们的习惯，声明参数时也可以包括类型信息，而且有时编译器不一定能根据上下文推断出参数的类型！</p>
</blockquote>
<h2 id="如何辨别Lambda表达式"><a href="#如何辨别Lambda表达式" class="headerlink" title="如何辨别Lambda表达式"></a>如何辨别Lambda表达式</h2><p>编写 Lambda 表达式的不同形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Runnable noArguments = () -&gt; System.out.println(&quot;Hello World&quot;); </span><br><span class="line"></span><br><span class="line">Lambda 表达式不包含参数，使用空括号 () 表示没有参数。</span><br><span class="line">该 Lambda 表达式实现了 Runnable 接口，该接口也只有一个 run 方法，没有参数，且返回类型为 void</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ActionListener oneArgument = event -&gt; System.out.println(&quot;button clicked&quot;);</span><br><span class="line"> </span><br><span class="line">Lambda 表达式包含且只包含一个参数，可省略参数的括号。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Runnable multiStatement = () -&gt; &#123;</span><br><span class="line">	System.out.print(&quot;Hello&quot;); </span><br><span class="line">	System.out.println(&quot; World&quot;); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Lambda 表达式的主体不仅可以是一个表达式，而且也可以是一段代码块，使用大括号（&#123;&#125;）将代码块括起来。</span><br><span class="line">该代码块和普通方法遵循的规则别无二致，可以用返回或抛出异常来退出。</span><br><span class="line">只有一行代码的 Lambda 表达式也可使用大括号，用以明确 Lambda表达式从何处开始、到哪里结束。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; add = (x, y) -&gt; x + y;</span><br><span class="line"></span><br><span class="line">Lambda 表达式也可以表示包含多个参数的方法。</span><br><span class="line">这时就有必要思考怎样去阅读该 Lambda 表达式。</span><br><span class="line">这行代码并不是将两个数字相加，而是创建了一个函数，用来计算两个数字相加的结果。</span><br><span class="line">变量 add 的类型是 BinaryOperator&lt;Long&gt;，它不是两个数字的和，而是将两个数字相加的那行代码。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; addExplicit = (Long x, Long y) -&gt; x + y; </span><br><span class="line"></span><br><span class="line">显式声明参数类型</span><br></pre></td></tr></table></figure>

<blockquote>
<p>目标类型是指 Lambda 表达式所在上下文环境的类型。<br>比如，将 Lambda 表达式赋值给一个局部变量，或传递给一个方法作为参数，局部变量或方法参数的类型就是 Lambda 表达式的目标类型。</p>
</blockquote>
<p>Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。</p>
<p>Java 中初始化数组时，数组的类型就是根据上下文推断出来的。另一个常见的例子是 null，只有将 null 赋值给一个变量，才能知道它的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final String[] array = &#123; &quot;hello&quot;, &quot;world&quot; &#125;;</span><br><span class="line">等号右边的代码并没有声明类型，系统根据上下文推断出类型信息</span><br></pre></td></tr></table></figure>

<h2 id="引用值，而不是变量"><a href="#引用值，而不是变量" class="headerlink" title="引用值，而不是变量"></a>引用值，而不是变量</h2><p>需要引用它所在方法里的变量。这时，需要将变量声明为 final</p>
<p>将变量声明为 final，意味着不能为其重复赋值。同时也意味着在使用 final 变量时，实际上是在使用赋给该变量的一个特定的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">匿名内部类中使用 final 局部变量</span><br><span class="line"></span><br><span class="line">final String name = getUserName(); </span><br><span class="line">button.addActionListener(new ActionListener() &#123; </span><br><span class="line">    public void actionPerformed(ActionEvent event) &#123; </span><br><span class="line">        System.out.println(&quot;hi &quot; + name); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Java 8 虽然放松了这一限制，可以引用非 final 变量，但是该变量在既成事实上必须是final。</p>
<p>虽然无需将变量声明为 final，但在 Lambda 表达式中，也无法用作非终态变量。</p>
<p>如果坚持用作非终态变量，编译器就会报错。</p>
<p>既成事实上的 final 是指只能给该变量赋值一次。</p>
<p>换句话说，Lambda 表达式引用的是值，而不是变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lambda 表达式中引用既成事实上的 final 变量</span><br><span class="line">name 就是一个既成事实上的 final 变量</span><br><span class="line"></span><br><span class="line">String name = getUserName(); </span><br><span class="line">button.addActionListener(event -&gt; System.out.println(&quot;hi &quot; + name));</span><br></pre></td></tr></table></figure>

<p>final 就像代码中的线路噪声，省去之后代码更易读。</p>
<p>当然，有些情况下，显式地使用 final代码更易懂。</p>
<p>是否使用这种既成事实上的 final 变量，完全取决于个人喜好。</p>
<p>如果你试图给该变量多次赋值，然后在 Lambda 表达式中引用它，编译器就会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">未使用既成事实上的 final 变量，导致无法通过编译（ Lambda 表达式中引用的局部变量必须是 final 或既成事实上的 final 变量）</span><br><span class="line"></span><br><span class="line">String name = getUserName(); </span><br><span class="line">name = formatUserName(name); </span><br><span class="line">button.addActionListener(event -&gt; System.out.println(&quot;hi &quot; + name));</span><br><span class="line"></span><br><span class="line">显示出错信息：local variables referenced from a Lambda expression must be final or effectively final</span><br></pre></td></tr></table></figure>

<h2 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h2><blockquote>
<p>函数接口是只有一个抽象方法的接口，用作 Lambda 表达式的类型。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ActionListener 接口：接受 ActionEvent 类型的参数，返回空</span><br><span class="line"></span><br><span class="line">public interface ActionListener extends EventListener &#123; </span><br><span class="line">    public void actionPerformed(ActionEvent event); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ActionListener 只有一个抽象方法：actionPerformed，被用来表示行为：接受一个参数，返回空。</span><br><span class="line">记住，由于 actionPerformed 定义在一个接口里，因此 abstract 关键字不是必需的。</span><br><span class="line">该接口也继承自一个不具有任何方法的父接口：EventListener。</span><br></pre></td></tr></table></figure>

<p>这就是函数接口，接口中单一方法的命名并不重要，只要方法签名和 Lambda 表达式的类型匹配即可。</p>
<p>可在函数接口中为参数起一个有意义的名字，增加代码易读性，便于更透彻地理解参数的用途。</p>
<p>Java一些重要的函数接口</p>
<table>
<thead>
<tr>
<th align="center">接口</th>
<th align="center">参数</th>
<th align="center">返回类型</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Predicate<T></td>
<td align="center">T</td>
<td align="center">boolean</td>
<td align="center">用来判断真假</td>
</tr>
<tr>
<td align="center">Consumer<T></td>
<td align="center">T</td>
<td align="center">void</td>
<td align="center">输出一个值</td>
</tr>
<tr>
<td align="center">Function&lt;T,R&gt;</td>
<td align="center">T</td>
<td align="center">R</td>
<td align="center">获取Artist对象的名字</td>
</tr>
<tr>
<td align="center">Supplier<T></td>
<td align="center">None</td>
<td align="center">T</td>
<td align="center">工厂方法</td>
</tr>
<tr>
<td align="center">UnaryOperator<T></td>
<td align="center">T</td>
<td align="center">T</td>
<td align="center">逻辑非(!)</td>
</tr>
<tr>
<td align="center">BinaryOperator<T></td>
<td align="center">(T,T)</td>
<td align="center">T</td>
<td align="center">求两个数的乘积(*)</td>
</tr>
</tbody></table>
<h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><p>Lambda 表达式中的类型推断，实际上是 Java 7 就引入的目标类型推断的扩展。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; oldWordCounts = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">Map&lt;String, Integer&gt; diamondWordCounts = new HashMap&lt;&gt;(); </span><br></pre></td></tr></table></figure>
<p>javac 根据 Lambda 表达式上下文信息就能推断出参数的正确类型。</p>
<p>程序依然要经过类型检查来保证运行的安全性，但不用再显式声明类型罢了。这就是所谓的类型推断。</p>
<p>用 Lambda 表达式检测一个 Integer 是否大于 5。这实际上是一个 Predicate——用来判断真假的函数接口</p>
<p><code>Predicate&lt;Integer&gt; atLeast5 = x -&gt; x &gt; 5;</code></p>
<p>Predicate 也是一个 Lambda 表达式，和前文中 ActionListener 不同的是，它还返回一个值。</p>
<p>表达式 x  &gt;  5 是 Lambda 表达式的主体。</p>
<p>这样的情况下，返回值就是Lambda 表达式主体的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Predicate 接口的源码，接受一个对象，返回一个布尔值</span><br><span class="line"></span><br><span class="line">public interface Predicate&lt;T&gt; &#123; </span><br><span class="line">    boolean test(T t); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Predicate 只有一个泛型类型的参数，Integer 用于其中。</span><br><span class="line">Lambda表达式实现了 Predicate 接口，因此它的单一参数被推断为 Integer 类型。</span><br><span class="line">javac 还可检查Lambda 表达式的返回值是不是 boolean，这正是 Predicate 方法的返回类型。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">略显复杂的类型推断</span><br><span class="line"></span><br><span class="line">BinaryOperator&lt;Long&gt; addLongs = (x, y) -&gt; x + y;</span><br><span class="line"></span><br><span class="line">一个略显复杂的函数接口：BinaryOperator。</span><br><span class="line">该接口接受两个参数，返回一个值，参数和值的类型均相同。</span><br><span class="line">实例中所用的类型是 Long。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">没有泛型，代码则通不过编译</span><br><span class="line"></span><br><span class="line">BinaryOperator add = (x, y) -&gt; x + y;</span><br><span class="line"></span><br><span class="line">编译器给出的报错信息如下：</span><br><span class="line">Operator &#x27;&amp; #x002B;&#x27; cannot be applied to java.lang.Object, java.lang.Object.</span><br></pre></td></tr></table></figure>

<p>BinaryOperator 毕竟是一个具有泛型参数的函数接口，该类型既是参数 x 和 y 的类型，也是返回值的类型。<br>上面的例子中并没有给出变量add 的任何泛型信息，给出的正是原始类型的定义。<br>因此，编译器认为参数和返回值都是java.lang.Object 实例。</p>
<h2 id="要点回顾"><a href="#要点回顾" class="headerlink" title="要点回顾"></a>要点回顾</h2><ul>
<li>Lambda 表达式是一个匿名方法，将行为像数据一样进行传递。</li>
<li>Lambda 表达式的常见结构：BinaryOperator<Integer> add &#x3D; (x, y) → x + y。</li>
<li>函数接口指仅具有单个抽象方法的接口，用来表示 Lambda 表达式的类型。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-8函数式编程2</title>
    <url>/2019/02/03/java/Java-8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B2/</url>
    <content><![CDATA[<blockquote>
<p>前言</p>
<p>Java 8 Lambdas，Richard Warburton 著（O’Reilly，2014）。版权所有， 978-1-449-37077-0</p>
<ul>
<li>如何编写出简单、干净、易读的代码 —— 尤其是对于集合的操作？</li>
<li>如何简单地使用并行计算提高性能？</li>
<li>如何准确地为问题建模，并且开发出更好的领域特定语言？</li>
<li>如何写出不易出错，并且更简单的并发代码？</li>
<li>如何测试和调试 Lambda 表达式？</li>
</ul>
<p>将<strong>Lambda 表达式</strong>加入 Java，并不只是为了提高开发人员的生产效率，业界也对这一特性有根本性的需求。</p>
</blockquote>
<h1 id="流"><a href="#流" class="headerlink" title="流"></a>流</h1><p>Java 8 中新增的特性旨在帮助程序员写出更好的代码，其中对核心类库的改进是很关键的一部分。</p>
<p>对核心类库的改进主要包括集合类的 API 和新引入的流（Stream）。</p>
<p>流使程序员得以站在更高的抽象层次上对集合进行操作。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul>
<li>Artist : 创作音乐的个人或团队<ul>
<li>name ：艺术家的名字</li>
<li>members ：乐队成员</li>
<li>origin ：乐队来自哪里</li>
<li>Track : 专辑中的一支曲目<ul>
<li>name : 曲目名称</li>
</ul>
</li>
<li>Album ： 专辑，若干曲目组成<ul>
<li>name ：专辑名</li>
<li>tracks ： 专辑上所有曲目的列表</li>
<li>musicians ：参与创作本专辑的艺术家列表</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="从外部迭代到内部迭代"><a href="#从外部迭代到内部迭代" class="headerlink" title="从外部迭代到内部迭代"></a>从外部迭代到内部迭代</h2><p>Java 程序员在使用集合类时，一个通用的模式是在集合上进行迭代，然后处理返回的每一个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用 for 循环计算来自伦敦的艺术家人数</span><br><span class="line"></span><br><span class="line">int count = 0; </span><br><span class="line">for (Artist artist : allArtists) &#123; </span><br><span class="line">    if (artist.isFrom(&quot;London&quot;)) &#123; </span><br><span class="line">        count++; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">尽管这样的操作可行，但存在几个问题</span><br><span class="line">1.每次迭代集合类时，都需要写很多样板代码。</span><br><span class="line">2.将for 循环改造成并行方式运行也很麻烦，需要修改每个 for 循环才能实现。</span><br><span class="line">3.上述代码无法流畅传达程序员的意图。</span><br><span class="line">	for 循环的样板代码模糊了代码的本意，程序员必须阅读整个循环体才能理解。</span><br><span class="line">	若是单一的 for 循环，倒也问题不大，但面对一个满是循环（尤其是嵌套循环）的庞大代码库时，负担就重了。</span><br></pre></td></tr></table></figure>

<p>for 循环其实是一个封装了迭代的语法糖，看看它的工作原理。</p>
<p>首先调用 iterator 方法，产生一个新的 Iterator 对象，进而控制整个迭代过程，这就是<strong>外部迭代</strong>。</p>
<p>迭代过程通过显式调用 Iterator 对象的 hasNext 和 next 方法完成迭代。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用迭代器计算来自伦敦的艺术家人数</span><br><span class="line"></span><br><span class="line">int count = 0; </span><br><span class="line">Iterator&lt;Artist&gt; iterator = allArtists.iterator(); </span><br><span class="line">while(iterator.hasNext()) &#123; </span><br><span class="line">    Artist artist = iterator.next(); </span><br><span class="line">    if (artist.isFrom(&quot;London&quot;)) &#123; </span><br><span class="line">        count++; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内部迭代</strong></p>
<p>首先要注意 stream() 方法的调用，它和调用 iterator() 的作用一样。</p>
<p>该方法不是返回一个控制迭代的 Iterator 对象，而是返回内部迭代中的相应接口：Stream。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用内部迭代计算来自伦敦的艺术家人数</span><br><span class="line"></span><br><span class="line">long count = allArtists.stream()</span><br><span class="line">			.filter(artist -&gt; artist.isFrom(&quot;London&quot;))</span><br><span class="line">			.count();</span><br><span class="line"></span><br><span class="line">被分解为两步更简单的操作：</span><br><span class="line">	找出所有来自伦敦的艺术家</span><br><span class="line">	计算他们的人数</span><br></pre></td></tr></table></figure>

<p>每种操作都对应 Stream 接口的一个方法。<br>为了找出来自伦敦的艺术家，需要对 Stream 对象进行过滤：filter。过滤在这里是指“只保留通过某项测试的对象”。<br>测试由一个函数完成，根据艺术家是否来自伦敦，该函数返回 true 或者 false。<br>由于 Stream API 的函数式编程风格，我们并没有改变集合的内容，而是描述出 Stream 里的内容。<br>count() 方法计算给定 Stream 里包含多少个对象。</p>
<blockquote>
<p>Stream 是用函数式编程方式在集合类上进行复杂操作的工具。</p>
</blockquote>
<h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p>整个过程被分解为两种更简单的操作：过滤和计数，看似有化简为繁之嫌<br>但 迭代只有一个for循环 ，两种操作是否以为着需要两次循环？ 答案并不是，只需要对列表迭代一次。</p>
<p>通常，在Java中调用一个方法，计算机会随机执行操作：比如，System.out.println(“Hello World”);会在终端上输出一条信息。<br>Streatm里的一些方法却略有不同，他们虽是普通Java方法，但返回的Stream对象却不是一个新集合，而是<strong>创建新集合的配方</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只过滤，不计数</span><br><span class="line"></span><br><span class="line">allArtists.stream().filter(artist -&gt; artist.isFrom(&quot;London&quot;));</span><br></pre></td></tr></table></figure>

<p>这行代码并未做什么实际性的工作，filter 只刻画出了 Stream，但没有产生新的集合。<br>像filter 这样只描述 Stream，最终不产生新集合的方法叫<strong>作惰性求值方法</strong>；<br>而像 count 这样最终会从 Stream 产生值的方法叫作<strong>及早求值方法</strong>。</p>
<p>在过滤器中加入一条 println 语句，来输出艺术家的名字，就能轻而易举地看出其中的不同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于使用了惰性求值，没有输出艺术家的名字</span><br><span class="line"></span><br><span class="line">allArtists.stream() </span><br><span class="line">          .filter(artist -&gt; &#123; </span><br><span class="line">              System.out.println(artist.getName()); </span><br><span class="line">              return artist.isFrom(&quot;London&quot;); </span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">运行这段代码，程序不会输出任何信息！</span><br></pre></td></tr></table></figure>

<p>如果将同样的输出语句加入一个拥有终止操作的流,艺术家的名字就会被输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long count = allArtists.stream() </span><br><span class="line">                       .filter(artist -&gt; &#123; </span><br><span class="line">                           System.out.println(artist.getName()); </span><br><span class="line">                           return artist.isFrom(&quot;London&quot;); </span><br><span class="line">                       &#125;) </span><br><span class="line">                       .count();</span><br></pre></td></tr></table></figure>

<p>判断一个操作是惰性求值还是及早求值很简单：只需看它的返回值。<br>如果返回值是 Stream，那么是惰性求值；如果返回值是另一个值或为空，那么就是及早求值。<br>使用这些操作的理想方式就是形成一个惰性求值的链，最后用一个及早求值的操作返回想要的结果，这正是它的合理之处。</p>
<h2 id="常用的流操作"><a href="#常用的流操作" class="headerlink" title="常用的流操作"></a>常用的流操作</h2><p>为了更好地理解 Stream API，掌握一些常用的 Stream 操作十分必要。除此处讲述的几种重要操作之外，该 API 的 Javadoc 中还有更多信息。</p>
<h3 id="collect-toList"><a href="#collect-toList" class="headerlink" title="collect(toList())"></a>collect(toList())</h3><blockquote>
<p>collect(toList()) 方法由 Stream 里的值生成一个列表，是一个及早求值操作。</p>
</blockquote>
<p>Stream 的 of 方法使用一组初始值生成新的 Stream。<br>事实上，collect 的用法不仅限于此，它是一个非常通用的强大结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; collected = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</span><br><span class="line">                               .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这段程序展示了如何使用 collect(toList()) 方法从 Stream 中生成一个列表。</span><br><span class="line">由于很多 Stream 操作都是惰性求值，因此调用 Stream 上一系列方法之后，还需要最后再调用一个类似 collect 的及早求值方法。</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础1</title>
    <url>/2019/01/24/java/Java%E5%9F%BA%E7%A1%801/</url>
    <content><![CDATA[<h1 id="Java的加载与执行"><a href="#Java的加载与执行" class="headerlink" title="Java的加载与执行"></a>Java的加载与执行</h1><img data-src="/2019/01/24/java/Java%E5%9F%BA%E7%A1%801/1.png" class="">


<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><ul>
<li>btye：Java中最小的数据类型，在内存中占8位(bit)，即1个字节，取值范围-128~127，默认值0</li>
<li>short：短整型，在内存中占16位，即2个字节，取值范围-32768~32717，默认值0</li>
<li>int：整型，用于存储整数，在内在中占32位，即4个字节，取值范围-2147483648~2147483647，默认值0</li>
<li>long：长整型，在内存中占64位，即8个字节-2^63~2^63-1，默认值0L</li>
<li>float：浮点型，在内存中占32位，即4个字节，用于存储带小数点的数字（与double的区别在于float类型有效小数点只有6~7位），默认值0</li>
<li>double：双精度浮点型，用于存储带有小数点的数字，在内存中占64位，即8个字节，默认值0</li>
<li>char：字符型，用于存储单个字符，占16位，即2个字节，取值范围0~65535，默认值为空</li>
<li>boolean：布尔类型，占1个字节，用于判断真或假（仅有两个值，即true、false），默认值false</li>
</ul>
<h1 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h1><ul>
<li>\n：表示换一行</li>
<li>\t：表示制表符</li>
<li>\\：表示输出一个\</li>
<li>&quot;:表示输出一个”</li>
<li>&#39;:表示输出一个’</li>
<li>\u0000：表示unicode转义序列符，输出一个空格</li>
</ul>
<h1 id="变量的内存分析"><a href="#变量的内存分析" class="headerlink" title="变量的内存分析"></a>变量的内存分析</h1><ol>
<li>当运行程序时，在内存中JVM会自动分配空间</li>
<li>内存中包含：<ul>
<li>栈：存放方法及方法中的局部变量</li>
<li>堆：存方法对象</li>
<li>方法区：代码片段、常量池（常量池中存放的时字符串的值）、静态属性</li>
</ul>
</li>
<li>基本数据类型内存中存放真正的值、引用数据类型内存中存放地址</li>
</ol>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ol>
<li>算术运算符：+、-、*、&#x2F;、%、++、–</li>
<li>链接运算符：+</li>
<li>赋值运算符：&#x3D;、+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;</li>
<li>关系运算符：&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;、&#x3D;&#x3D;</li>
<li>逻辑运算符：&amp;、|、^、！、&amp;&amp;、||</li>
<li>三目运算符：条件 ？代码1 ：代码2</li>
</ol>
<h1 id="控制台输入"><a href="#控制台输入" class="headerlink" title="控制台输入"></a>控制台输入</h1><p><code>Scanner input = new Scanner(System.in);</code></p>
<h1 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(代码1）&#123;</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">if(代码1）&#123;</span><br><span class="line"></span><br><span class="line">&#125;else if(代码2)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">if(代码1）&#123;</span><br><span class="line"></span><br><span class="line">&#125;else if(代码2)&#123;</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java中，字符串比较，使用&#x3D;&#x3D;比较的时地址是否一致，equals()比较内容</p>
<h1 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h1><p>表达式 &#x3D; byte、short、int、char、String（JDK7.0）、枚举</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switsh(表达式)&#123;</span><br><span class="line">case 常量1：	break；</span><br><span class="line">case 常量2： break；</span><br><span class="line">default：</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i=0;i&lt;=100;i++)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(条件)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do&#123;</span><br><span class="line"></span><br><span class="line">&#125;while(条件)</span><br></pre></td></tr></table></figure>

<h2 id="跳过及中断"><a href="#跳过及中断" class="headerlink" title="跳过及中断"></a>跳过及中断</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break；中断</span><br><span class="line">continue；跳过</span><br></pre></td></tr></table></figure>
<h1 id="方法的内存分析"><a href="#方法的内存分析" class="headerlink" title="方法的内存分析"></a>方法的内存分析</h1><ul>
<li>当执行该方法时，则方法进栈（压栈）</li>
<li>当方法执行完毕，则该方法出栈（弹栈），局部变量也随之释放</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础2</title>
    <url>/2019/01/26/java/Java%E5%9F%BA%E7%A1%802/</url>
    <content><![CDATA[<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>Object类是Java中所有类的根父类，Java中的类要么直接继承Object，要么间接继承Object类</p>
<p>Java中类的继承是可传递的，Object类中定义的方法，所有的类都能继承到</p>
<table>
<thead>
<tr>
<th align="center">Object</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">clone</td>
<td align="center">对象克隆</td>
</tr>
<tr>
<td align="center">equals</td>
<td align="center">用于判断两个对象的内容是否一样</td>
</tr>
<tr>
<td align="center">finalize</td>
<td align="center">当对象被垃圾回收器回收时，会执行对象的finalize()方法，但是垃圾回收器在什么时候回收这个对象不确定，即这个方法的执行时间不确定，一般不用</td>
</tr>
<tr>
<td align="center">getClass</td>
<td align="center">返回对象的运行时类对象，可以简单的理解为返回对象的类的字节码文件</td>
</tr>
<tr>
<td align="center">hashCode</td>
<td align="center">返回对象的哈希码</td>
</tr>
<tr>
<td align="center">notify</td>
<td align="center">在线程中用于唤醒等待中的线程</td>
</tr>
<tr>
<td align="center">notifyAll</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">toString</td>
<td align="center">把对象转换为字符串</td>
</tr>
<tr>
<td align="center">wait</td>
<td align="center">在多线程中，让线程等待</td>
</tr>
</tbody></table>
<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>Collection存储数据时是单个存储的，只能存储引用类型数据</p>
<p><code>add(),remove(),contains(),iterator()</code></p>
<ul>
<li>list集合<ul>
<li>有序，可重复</li>
<li>为每个元素指定了一个索引值</li>
<li>add(index,0),remove(index),get(index),sort(Comparator)</li>
<li>ArrayList</li>
<li>Vector<ul>
<li>底层是数组，访问快，添加&#x2F;删除慢</li>
<li>初始化容量：10</li>
<li>扩容：ArrayList是1.5倍，Vector是2倍</li>
<li>Vector是线程安全的，ArrayList不是线程安全的</li>
</ul>
</li>
<li>LinkedList<ul>
<li>底层是双向链表，添加&#x2F;删除效率高，访问慢</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>ArrayList应用于以查询访问为主，很少进行添加&#x2F;删除操作<br>LinkedList应用于频繁的进行添加&#x2F;删除操作的情况</p>
<ul>
<li>Set集合<ul>
<li>无序，不可重复</li>
<li>HashSet<ul>
<li>底层是HashMap</li>
<li>HashSet就是HashMap键的集合</li>
</ul>
</li>
<li>TreeSet<ul>
<li>底层是TreeMap</li>
<li>TreeSet就是TreeMap键的集合</li>
<li>TreeSet实现了SortedSet接口，可以对元素自然排序，要求元素必须是可比较的<ul>
<li>创建TreeSet时指定Comparator比较器</li>
<li>如果没有指定Comparator比较器，元素类需要实现Comparable接口</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>List集合与HashSet集合中判断是否同一个元素，需要调用对象的equals()方法，元素的类需要重写equals()方法</p>
<p>TreeSet集合判断是否同一个元素，根据Comparator&#x2F;Comparable的比较结果是否为0判断，如果比较结果为0就认为是同一个元素</p>
<img data-src="/2019/01/26/java/Java%E5%9F%BA%E7%A1%802/1.png" class="">

<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><ul>
<li>HashSet底层是HashMap<ul>
<li>向HashSet中添加元素，实际上是把元素作为键添加到底层的HashMap中</li>
<li>HashSet就是HashMap键的集合</li>
</ul>
</li>
</ul>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><ul>
<li>TreeSet实现了SortedSet接口，可以对元素自然排序，要求集合中的元素必须是可比较的<ul>
<li>在创建TreeSet时，可以指定Comparator比较器</li>
<li>没有指定Comparator比较器，要求元素的类实现Comparable接口</li>
</ul>
</li>
<li>TreeSet底层是TreeMap<ul>
<li>向TreeSett中添加元素，实际上是把元素作为键添加到底层的TreeMap中</li>
<li>TreeSet就是TreeMap键的集合</li>
</ul>
</li>
</ul>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map是按&lt;键,值&gt;对的形式存储数据的</p>
<img data-src="/2019/01/26/java/Java%E5%9F%BA%E7%A1%802/2.png" class="">

<table>
<thead>
<tr>
<th align="center">Map</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">clear</td>
<td align="center">清除所有的&lt;键,值&gt;对</td>
</tr>
<tr>
<td align="center">containsKey</td>
<td align="center">判断是否包含指定的键</td>
</tr>
<tr>
<td align="center">containsValue</td>
<td align="center">判断是否包含指定的值</td>
</tr>
<tr>
<td align="center">entrySet</td>
<td align="center">返回Entry的集合，一个&lt;键,值&gt;对就是一个entry</td>
</tr>
<tr>
<td align="center">equals</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">get</td>
<td align="center">返回Key对应的值</td>
</tr>
<tr>
<td align="center">isEmpty</td>
<td align="center">判断是否为空</td>
</tr>
<tr>
<td align="center">ketSet</td>
<td align="center">返回键的集合</td>
</tr>
<tr>
<td align="center">put</td>
<td align="center">向Map中添加&lt;键,值&gt;对，如果这个键Key已存在，使用value替换原来的值，Map中的键是不重复的</td>
</tr>
<tr>
<td align="center">putAll</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">remove</td>
<td align="center">只要key匹配就删除对应的&lt;键,值&gt;对</td>
</tr>
<tr>
<td align="center">remove</td>
<td align="center">要求&lt;键,值&gt;都匹配才会删除</td>
</tr>
<tr>
<td align="center">replace</td>
<td align="center">替换</td>
</tr>
<tr>
<td align="center">size</td>
<td align="center">返回&lt;键,值&gt;对的数量</td>
</tr>
<tr>
<td align="center">values</td>
<td align="center">返回值的集合</td>
</tr>
</tbody></table>
<img data-src="/2019/01/26/java/Java%E5%9F%BA%E7%A1%802/3.png" class="">

<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><ul>
<li>底层都是哈希表（散列表），但是HashTable事线程安全的，HashMap不是线程安全的</li>
<li>HashMap的父类是AbstractMap,HashTable的父类是Dictionary</li>
<li>HashMap默认的初始化容量：16，HashTable默认的初始化容量：11</li>
<li>加载因子：0.75，当&lt;键,值&gt;对的数量大于数组的容量（哈希桶的容量）*加载因子时，数组要扩容</li>
<li>HashMap扩容默认：2倍大小，HashTable扩容默认：2倍+1</li>
<li>HashMap的键与值都可以为null，HashTable的键与值都不可以为null</li>
<li>HashMap在创建时，可以指定一个初始化容量，系统会调整为2的幂次方，为了快速计算出数组的下标</li>
<li>HashTable也可以指定初始化容量，系统不调整</li>
</ul>
<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><ul>
<li>继承了HashTable</li>
<li>他的键与值都是String字符串</li>
<li>常用于设置读取系统属性值</li>
</ul>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><ul>
<li>TreeMap实现了SortedMap，可以根据键自然排序，排序原理是二叉树原理</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础3</title>
    <url>/2019/01/28/java/Java%E5%9F%BA%E7%A1%803/</url>
    <content><![CDATA[<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p>流是有起点和终点的有序字节序列</p>
<p>流的分类</p>
<ul>
<li>输入流&#x2F;输出流：是当前程序为参照点，程序从外面读取数据这是输入流，把程序的数据保存到外面是输出流</li>
<li>字节流&#x2F;字符流：如果是以字节为单位处理流中的数据就是字节流，如果是以字符为单位处理流中的数据就是字符流</li>
<li>节点流&#x2F;处理流：如果直接从设备（数据源）上读写数据就是节点流，处理流是对节点流的包装</li>
</ul>
<p>在程序中从文件里读写数据需要使用IO流.Java定义了相关的流类，在java.io包中，如果这个类是以Stream单词结尾就是流类，如果是以Reader结尾就是字符输入流，以Writer单词结尾就是字符输出流。</p>
<ul>
<li>FileInputStream&#x2F;FileOutputStream<ul>
<li>以节为单位读写文件内容</li>
</ul>
</li>
<li>FileReader&#x2F;FileWriter<ul>
<li>FileReader&#x2F;FileWriter只能读写与当前环境编码兼容的文本文件</li>
</ul>
</li>
<li>InputStreamReader&#x2F;OutputStreamwriter<ul>
<li>如果文本文件与当前环境编码不兼容，使用InputStreamReader&#x2F;OutputStreamwriter转换流读写</li>
</ul>
</li>
<li>BufferedReader&#x2F;Bufferedwriter<ul>
<li>字符缓冲流BufferedReader&#x2F;Bufferedwriter也是一种处理流，包装流</li>
</ul>
</li>
<li>ObjectinputStream&#x2F;ObjectOutputStream<ul>
<li>对象序列化：把对象转换为01二进制序列就是对象序列化</li>
<li>对象反序列化：把一组01二进制序列转换为对象</li>
<li>注意：对象序列化&#x2F;反序列化前提是对象的类要实现Serializable接口，该接口是一个标志性接口，没有任何方法</li>
</ul>
</li>
<li>PrintStream&#x2F;PrintWriter</li>
<li>File类<ul>
<li>读取文件内容使用IO流，操作文件&#x2F;文件来使用File类，如创建&#x2F;遍历&#x2F;删除文件来，查看文件的相关属性等操作</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">File</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">getAbsolutePath</td>
<td align="center">返回绝对路径（从根目录开始的路径）</td>
</tr>
<tr>
<td align="center">getPath</td>
<td align="center">返回路径</td>
</tr>
<tr>
<td align="center">getParent</td>
<td align="center">返回上一级文件夹</td>
</tr>
<tr>
<td align="center">getName</td>
<td align="center">对象名</td>
</tr>
<tr>
<td align="center">length</td>
<td align="center">文件大小</td>
</tr>
<tr>
<td align="center">exists</td>
<td align="center">是否存在</td>
</tr>
<tr>
<td align="center">isFile</td>
<td align="center">是否为文件</td>
</tr>
<tr>
<td align="center">isAbsolute</td>
<td align="center">是否绝对路径</td>
</tr>
<tr>
<td align="center">lastModified</td>
<td align="center">最后一次修改的时间</td>
</tr>
</tbody></table>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>进程：进程就是操作系统运行的一个程序。</p>
<p>线程：线程就是进程的一个执行单元，一个进程至少有一个线程，如果进程有多个线程，则它就是多线程应用程序。每个线程都有独立的栈空间。</p>
<p>主线程：JVM启动主线程，主线程运行main方法</p>
<p>用户线程：开启的新的线程，也称子线程。</p>
<p>守护线程：守护线程是为其他线程提供服务的线程，不能独立运行，当JVM中只有守护线程时，JVM会退出。（垃圾回收器就是一个守护线程）</p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ul>
<li><p>继承Thread</p>
</li>
<li><p>实现Runnable接口</p>
</li>
<li><p>实现Callable接口</p>
</li>
</ul>
<h2 id="线程常用操作"><a href="#线程常用操作" class="headerlink" title="线程常用操作"></a>线程常用操作</h2><table>
<thead>
<tr>
<th align="center">Thread</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">activeCount</td>
<td align="center">当前活动线程的数量</td>
</tr>
<tr>
<td align="center">currentThread</td>
<td align="center">返回当前线程</td>
</tr>
<tr>
<td align="center">getContextClassLoader</td>
<td align="center">线程的上下文类加载器</td>
</tr>
<tr>
<td align="center">getId</td>
<td align="center">返回线程的ID，每个线程都有唯一的id</td>
</tr>
<tr>
<td align="center">getName</td>
<td align="center">返回线程名称</td>
</tr>
<tr>
<td align="center">getPriority</td>
<td align="center">返回线程优先级</td>
</tr>
<tr>
<td align="center">getState</td>
<td align="center">返回线程状态</td>
</tr>
<tr>
<td align="center">interrupt</td>
<td align="center">中断线程</td>
</tr>
<tr>
<td align="center">interrupted</td>
<td align="center">测试线程是否被中断</td>
</tr>
<tr>
<td align="center">isAlive</td>
<td align="center">测试线程是否结束</td>
</tr>
<tr>
<td align="center">isDaemon</td>
<td align="center">是否守护线程</td>
</tr>
<tr>
<td align="center">isInterrupted</td>
<td align="center">测试线程是否被中断</td>
</tr>
<tr>
<td align="center">join</td>
<td align="center">合并线程（加入）</td>
</tr>
<tr>
<td align="center">run</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">setDaemon</td>
<td align="center">设置线程为守护线程</td>
</tr>
<tr>
<td align="center">setName</td>
<td align="center">设置线程名称</td>
</tr>
<tr>
<td align="center">setPriority</td>
<td align="center">设置优先级</td>
</tr>
<tr>
<td align="center">sleep</td>
<td align="center">线程休眠</td>
</tr>
<tr>
<td align="center">start</td>
<td align="center">开启线程</td>
</tr>
<tr>
<td align="center">stop</td>
<td align="center">终止线程</td>
</tr>
<tr>
<td align="center">toString</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">yield</td>
<td align="center">线程让步</td>
</tr>
</tbody></table>
<h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><img data-src="/2019/01/28/java/Java%E5%9F%BA%E7%A1%803/1.png" class="">

<p>线程优先级</p>
<ul>
<li>每个线程都有一个优先级，取值范围：1~10</li>
<li>所有线程默认的优先级为：5</li>
<li>优先级越高，获得CPU执行权的记录越大</li>
</ul>
<p>线程休眠（Thread.sleep(2000)）</p>
<ul>
<li>静态方法，通过类名直接调用</li>
<li>睡眠的单位是毫秒</li>
<li>sleep()有受检异常需要预处理</li>
<li>sleep()方法所在的线程睡眠</li>
</ul>
<p>线程中断（t1.interrupt()）</p>
<ul>
<li>一般情况下，是把处于睡眠&#x2F;等待中的线程给中断</li>
</ul>
<p>线程让步（Thread.yield()）</p>
<ul>
<li>把线程转换为就绪状态，重新争抢CPU执行权</li>
</ul>
<p>线程加入（合并，t1.join()）</p>
<p>终止线程</p>
<ul>
<li>想办法让run()</li>
<li>在线程中设置一个标志，定期判断这个标志是否发生变化，标志发生变化就退出run()方法</li>
</ul>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul>
<li>线程安全问题。<ul>
<li>当多个线程同时操作堆区或者方法区的某个数据时，可能会出现数据不一致的现象，称为线程安全问题。</li>
</ul>
</li>
<li>出现线程安全问题怎么办？<ul>
<li>每个线程都访问自己的局部变量。</li>
<li>如果多个线程必须同时操作实例变量&#x2F;静态变量时，可以采用线程同步技术</li>
</ul>
</li>
<li>线程同步技术解决什么问题？<ul>
<li>当一个线程在操作期间，不允许其他的线程加入。</li>
<li>某一段代码在某一时刻只能由一个线程执行</li>
</ul>
</li>
</ul>
<p>同步</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronized（锁对象）&#123;</span><br><span class="line">	同步代码块</span><br><span class="line">&#125;</span><br><span class="line">工作原理：</span><br><span class="line">	1）任意对象都可以作为锁对象，每个对象有一个内置锁</span><br><span class="line">	2）某一时刻，锁对象最多只能被一个线程持有。</span><br><span class="line">	3）如果线程获得了锁对象后，会一直持有，直到执行完同步代码块后才释放</span><br><span class="line">	4）线程要执行同步代码块，必须先获得锁对象。</span><br><span class="line">场景描述：假设有线程A和线程B两个线程都想要执行同步代码块。</span><br><span class="line">	1）线程A获得CPU执行权，获得了锁对象后，开始执行同步代码块</span><br><span class="line">	2）线程A在执行同步代码块期间，CPU执行权被线程B抢走了，线程A转为就绪状态</span><br><span class="line">	3）线程B获得CPU执行权，也想要执行同步代码块，必须先获得锁对象，现在锁对象被线程A持有，线程B转到等待锁对象池中进行阻塞</span><br><span class="line">	4）线程A重新获得CPU执行权，执行完同步代码块后释放锁对象。</span><br><span class="line">	5）等待锁对象池中的线程B获得了锁对象，转为就绪状态。</span><br></pre></td></tr></table></figure>

<p>死锁</p>
<p>当多个线程同步时，获得锁的顺序不一致，导致线程相互等待的情况，称为死锁现象</p>
<p>如何避免</p>
<p>保证锁的顺序都一直</p>
<img data-src="/2019/01/28/java/Java%E5%9F%BA%E7%A1%803/2.png" class="">

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java开发环境搭建</title>
    <url>/2020/03/02/java/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="Java虚拟机–JVM"><a href="#Java虚拟机–JVM" class="headerlink" title="Java虚拟机–JVM"></a>Java虚拟机–JVM</h2><ul>
<li><strong>JVM</strong> （Java Virtual Machine）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的运行环境，是Java最具吸引力的特性之一。我们编写的Java代码，都运行在JVM之上。</li>
<li><strong>跨平台</strong>：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系统上，这个特性称为<strong>Java语言的跨平台特性</strong>。该特性是由JVM实的，我们编写程序运行在JVM上，而JVM运行在操作系统上。</li>
</ul>
<img data-src="/2020/03/02/java/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20200330135909560.png" class="" alt="image-20200330135909560">

<p>如图所示，Java的虚拟机本身不具备跨平台功能的，每个操作系统下都有不同版本的虚拟机。</p>
<h2 id="JRE和JDK"><a href="#JRE和JDK" class="headerlink" title="JRE和JDK"></a>JRE和JDK</h2><ul>
<li>JRE （Java Runtime Environment）：是Java程序的运行时环境，包含<strong>JVM</strong>和运行时所需要的<strong>核心类库</strong>。</li>
<li>JDK（Java Development Kit）：是Java程序开发工具包，包含JRE和开发人员使用的工具。</li>
</ul>
<p>我们想要运行一个已有的Java程序，那么只需安装<strong>JRE</strong>即可。</p>
<p>我们想要开发一个全新的Java程序，那么必须安装<strong>JDK</strong></p>
<img data-src="/2020/03/02/java/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20200330140526466.png" class="" alt="image-20200330140526466">

<img data-src="/2020/03/02/java/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/006tNbRwly1gbmnj3i2fyj315m0rc0z8.jpg" class="" alt="img">

<h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>JDK下载地址： <a href="https://www.oracle.com/cn/java/technologies/javase-downloads.html">https://www.oracle.com/cn/java/technologies/javase-downloads.html</a></p>
<img data-src="/2020/03/02/java/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20200330140937480.png" class="" alt="image-20200330140937480">

<p>根据自己的需要安装对应的版本注意：</p>
<img data-src="/2020/03/02/java/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20200330141046227.png" class="" alt="image-20200330141046227">

<p>安装自己操作系统适配的安装包</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>注意事项：</p>
<ul>
<li>目录最好不要为中文，也不要有空格</li>
</ul>
<p>下载下来后双击进入安装页面：</p>
<img data-src="/2020/03/02/java/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20170618230136472.png" class="" alt="这里写图片描述">

<p>最好自己指定一个安装路径（注意这是JDK的路径）</p>
<p><strong>注：可以不勾选公共JRE这样也不用再安装JRE了</strong></p>
<img data-src="/2020/03/02/java/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20170618230149347.png" class="" alt="这里写图片描述">

<p>接下来是JRE（最好把JDK和JER安装到一个目录下）</p>
<img data-src="/2020/03/02/java/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/20170618230200082.png" class="" alt="这里写图片描述">

<p>之后就是下一步下一步</p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><ul>
<li><p>打开环境变量配置。计算机→属性→高级系统设置→高级→环境变量，在系统变量中配置。</p>
</li>
<li><p>配置<strong>JAVA_HOME</strong></p>
<p>新建，变量名<code>JAVA_HOME</code>，变量值，jdk路径，我的路径是<code>E:\Java\jdk1.8.0_181</code>，保存</p>
</li>
</ul>
<img data-src="/2020/03/02/java/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20200330142153915.png" class="" alt="image-20200330142153915">

<ul>
<li><p>配置<strong>Path</strong></p>
<p>打开Path变量，在变量值最前加入<code>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</code></p>
<p>Win10可能是图形界面<code>;分号为分隔符道理一样</code></p>
</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ul>
<li>运行cmd</li>
<li>测试代码<ul>
<li><code>java</code></li>
<li><code>javac</code></li>
<li><code>java -version</code></li>
</ul>
</li>
<li>都正常显示就成功了</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数组</title>
    <url>/2024/06/30/java/Java%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		 // 这样拷贝数组没有隔离性</span><br><span class="line">		 String[] ss1 = &#123; &quot;1&quot;, &quot;2&quot;, &quot;3&quot; &#125;;</span><br><span class="line">		 // 把ss1对数组的引用传递给变量ss2,两个变量指向的是用一个数组</span><br><span class="line">		 String[] ss2 = ss1;</span><br><span class="line">		 ss2[0] = &quot;4&quot;;</span><br><span class="line">		 System.out.println(Arrays.toString(ss1));</span><br><span class="line">	&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		// 方法1</span><br><span class="line">		// 推荐</span><br><span class="line">		String[] ss1 = &#123; &quot;1&quot;, &quot;2&quot;, &quot;3&quot; &#125;;</span><br><span class="line">		// 通过new关键字再内存中开辟一块空间，ss2指向的是新的数组对象</span><br><span class="line">		String[] ss2 = new String[ss1.length];</span><br><span class="line">		for (int i = 0; i &lt; ss2.length; i++) &#123;</span><br><span class="line">			ss2[i] = ss1[i];</span><br><span class="line">		&#125;</span><br><span class="line">		ss2[0] = &quot;张三&quot;;</span><br><span class="line">		System.out.println(Arrays.toString(ss1));</span><br><span class="line">	&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		// 方法2</span><br><span class="line">		// API提供的方式，底层用C++写的，所以速度很快，比for循环的效率高</span><br><span class="line">		String[] ss1 = &#123; &quot;1&quot;, &quot;2&quot;, &quot;3&quot; &#125;;</span><br><span class="line">		String[] ss2 = new String[ss1.length];</span><br><span class="line">		System.arraycopy(ss1, 0, ss2, 0, ss1.length);</span><br><span class="line">		/**</span><br><span class="line">		 * (Object src,int srcPos,Object dest,int destPos,int length)</span><br><span class="line">		 * src:源数组,srcPos:源数组要复制的起始位置;dest:目的数组;destPos:目的数组放置的起始位置;length:复制的长度</span><br><span class="line">		 * 注意：src and dest都必须是同类型或者可以进行转换类型的数组．</span><br><span class="line">		 * 有趣的是这个函数可以实现自己到自己复制，比如：</span><br><span class="line">		 * int[] fun =&#123;0,1,2,3,4,5,6&#125;; </span><br><span class="line">		 * System.arraycopy(fun,0,fun,3,3);</span><br><span class="line">		 * 则结果为：&#123;0,1,2,0,1,2,6&#125;;</span><br><span class="line">		 */</span><br><span class="line">		System.out.println(Arrays.toString(ss2));</span><br><span class="line">	&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		//方法3</span><br><span class="line">		String[] ss1 = &#123; &quot;1&quot;, &quot;2&quot;, &quot;3&quot; &#125;;</span><br><span class="line">		String[] ss2 = Arrays.copyOf(ss1, ss1.length);</span><br><span class="line">		/**</span><br><span class="line">		 *该方法对应不同的数据类型都有各自的重载方法</span><br><span class="line">		 *original - 要复制的数组</span><br><span class="line">		 *newLength - 要返回的副本的长度</span><br><span class="line">		 *newType - 要返回的副本的类型</span><br><span class="line">		 *仔细观察发现，copyOf()内部调用了System.arraycopy()方法</span><br><span class="line">		 *区别在于：</span><br><span class="line">		 *arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置</span><br><span class="line">		 *copyOf()是系统自动在内部新建一个数组，调用arraycopy()将original内容复制到copy中去，并且长度为newLength。返回copy; 即将原数组拷贝到一个长度为newLength的新数组中，并返回该数组。</span><br><span class="line">		 *总结</span><br><span class="line">		 *Array.copyOf()可以看作是受限的System.arraycopy()，它主要是用来将原数组全部拷贝到一个新长度的数组，适用于数组扩容。</span><br><span class="line">		 */</span><br><span class="line">		System.out.println(Arrays.toString(ss2));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		String[] ss1 = &#123; &quot;1&quot;, &quot;2&quot;, &quot;3&quot; &#125;;</span><br><span class="line">		ss1 = Arrays.copyOf(ss1, ss1.length + 2);</span><br><span class="line">		System.out.println(ss1.length);</span><br><span class="line">		System.out.println(Arrays.toString(ss1));</span><br><span class="line">		// 5</span><br><span class="line">		// [1, 2, 3, null, null]</span><br><span class="line">	&#125;</span><br><span class="line">常见面试题: 统计字符的位置</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String str = &quot;统计一个字符再字符串中的所有位置&quot;;</span><br><span class="line">		int[] arry = countAll(str, &#x27;字&#x27;);</span><br><span class="line">		System.out.println(Arrays.toString(arry));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static int[] countAll(String str, char ch) &#123;</span><br><span class="line">		int[] array = &#123;&#125;;// 创建一个空数组</span><br><span class="line">		for (int i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">			if (ch == str.charAt(i)) &#123;</span><br><span class="line">				// charAt(i)遍历String每个字符</span><br><span class="line">				array = Arrays.copyOf(array, array.length + 1);</span><br><span class="line">				// 扩容</span><br><span class="line">				array[array.length - 1] = i;</span><br><span class="line">				// 刚扩容的位置</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return array;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//Java提供排序方法</span><br><span class="line">		int[] ss1= &#123;2,3,1&#125;;</span><br><span class="line">		Arrays.sort(ss1);</span><br><span class="line">		System.out.println(Arrays.toString(ss1));</span><br><span class="line">	&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		// 方法1</span><br><span class="line">		// 冒泡排序，前一个数与后一个数进行比较</span><br><span class="line">		int[] ss1 = &#123; 2, 3, 1 &#125;;</span><br><span class="line">		int temp = 0;</span><br><span class="line">		for (int i = 0; i &lt; ss1.length - 1; i++) &#123;</span><br><span class="line">			for (int j = i + 1; j &lt; ss1.length; j++) &#123;</span><br><span class="line">				if (ss1[j] &lt; ss1[i]) &#123;</span><br><span class="line">					temp = ss1[i];</span><br><span class="line">					ss1[i] = ss1[j];</span><br><span class="line">					ss1[j] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Arrays.toString(ss1));</span><br><span class="line">	&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		// 方法2</span><br><span class="line">		// 选择排序</span><br><span class="line">		int[] ss1 = &#123; 2, 3, 1 &#125;;</span><br><span class="line">		int temp = 0;</span><br><span class="line">		for (int i = 0; i &lt; ss1.length - 1; i++) &#123;</span><br><span class="line">			int min = i;</span><br><span class="line">			for (int j = i + 1; j &lt; ss1.length; j++) &#123;</span><br><span class="line">				if (ss1[min] &gt; ss1[j]) &#123;</span><br><span class="line">					// 找到比选定下标小的数</span><br><span class="line">					min = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if (min != i) &#123;</span><br><span class="line">				// 交换位置</span><br><span class="line">				temp = ss1[i];</span><br><span class="line">				ss1[i] = ss1[min];</span><br><span class="line">				ss1[min] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Arrays.toString(ss1));</span><br><span class="line">	&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		// 方法3</span><br><span class="line">		// 插入排序</span><br><span class="line">		int[] ss1 = &#123; 2, 3, 1 &#125;;</span><br><span class="line">		int temp = 0;</span><br><span class="line">		for (int i = 1; i &lt; ss1.length; i++) &#123;</span><br><span class="line">			for (int j = i; j &gt; 0; j--) &#123;</span><br><span class="line">				if (ss1[j] &lt; ss1[j - 1]) &#123;</span><br><span class="line">					temp = ss1[j];</span><br><span class="line">					ss1[j] = ss1[j - 1];</span><br><span class="line">					ss1[j - 1] = temp;</span><br><span class="line">				&#125; else</span><br><span class="line">					break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Arrays.toString(ss1));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 有序数组,二分查找</span><br><span class="line">	static int bingarySerarch(int[] array, int num) &#123;</span><br><span class="line">		int low = 0;</span><br><span class="line">		int high = array.length - 1;</span><br><span class="line">		while (low &lt;= high) &#123;</span><br><span class="line">			int mid = (low + high) / 2;</span><br><span class="line">			if (num &gt; array[mid]) &#123;</span><br><span class="line">				low = mid + 1;</span><br><span class="line">			&#125; else if (num &lt; array[mid]) &#123;</span><br><span class="line">				high = mid - 1;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return mid;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">// 无序数组，采用遍历，也可以先排序，后采用二分查找</span><br><span class="line">	static int search(int[] array, int num) &#123;</span><br><span class="line">		int index = -1;</span><br><span class="line">		for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">			if (num == array[i]) &#123;</span><br><span class="line">				index = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return index;</span><br><span class="line">	&#125;</span><br><span class="line">// Java 提供的查找方式。查看源码，它的本质就是二分查找</span><br><span class="line">	static void test(int[] array, int num) &#123;</span><br><span class="line">		/**</span><br><span class="line">		 * binarySearch(Object[], Object key) a: 要搜索的数组 key：要搜索的值</span><br><span class="line">		 * 如果key在数组中，则返回搜索值的索引；否则返回-1或“-”（插入点）。插入点是索引键将要插入数组的那一点，即第一个大于该键的元素的索引。 技巧： [1]</span><br><span class="line">		 * 搜索值不是数组元素，且在数组范围内，从1开始计数，得“ - 插入点索引值”； [2] 搜索值是数组元素，从0开始计数，得搜索值的索引值； [3]</span><br><span class="line">		 * 搜索值不是数组元素，且大于数组内元素，索引值为 – (length + 1); [4] 搜索值不是数组元素，且小于数组内元素，索引值为 – 1。</span><br><span class="line">		 */</span><br><span class="line">		int index = Arrays.binarySearch(array, 8);</span><br><span class="line">		System.out.println(index);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心数据结构(List、Map、Set)原理与使用技巧</title>
    <url>/2019/04/06/java/Java%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(List%E3%80%81Map%E3%80%81Set)%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<blockquote>
<p>JDK提供了一组主要的数据结构实现，如List、Map、Set等常用数据结构。这些数据都继承自java.util.Collection接口，并位于java.util包内</p>
</blockquote>
<h1 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h1><p>最重要的三种List接口实现：ArrayList、Vector、LinkedList。它们的类图如下：</p>
<img data-src="/2019/04/06/java/Java%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(List%E3%80%81Map%E3%80%81Set)%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/1.png" class="">

<p>可以看到，3种List均来自AbstratList的实现。</p>
<p>而AbstratList直接实现了List接口，并扩展自AbstratCollection。</p>
<p>ArrayList和Vector使用了数组实现，可以认为，ArrayList封装了对内部数组的操作。比如向数组中添加、删除、插入新的元素或数组的扩展和重定义。对ArrayList或者Vector的操作，等价于对内部对象数组的操作。</p>
<p>ArrayList和Vector几乎使用了相同的算法，它们的唯一区别可以认为是对多线程的支持。ArrayList没有对一个方法做线程同步，因此不是线程安全的。Vector中绝大多数方法都做了线程同步，是一种线程安全的实现。因此ArrayList和Vector的性能特性相差无几。</p>
<p>LinkedList使用了循环双向链表数据结构。LinkedList由一系列表项连接而成。一个表项总是包含3个部分：元素内容、前驱表项和后驱表项。如图所示：</p>
<img data-src="/2019/04/06/java/Java%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(List%E3%80%81Map%E3%80%81Set)%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2.png" class="">

<p>LinkedList的表项源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item = element;</span><br><span class="line">        this.next = next;</span><br><span class="line">        this.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论LinkedList是否为空，链表都有一个header表项，它既是链表的开始，也表示链表的结尾。它的后驱表项便是链表的第一个元素，前驱表项便是链表的最后一个元素。如图所示：</p>
<img data-src="/2019/04/06/java/Java%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(List%E3%80%81Map%E3%80%81Set)%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/3.png" class="">

<p>下面比较下ArrayList和LinkedList的不同。</p>
<h2 id="增加元素到列表尾端"><a href="#增加元素到列表尾端" class="headerlink" title="增加元素到列表尾端"></a>增加元素到列表尾端</h2><p>对于ArrayList来说，只要当前容量足够大，add()操作的效率是非常高的。</p>
<p>只有当ArrayList对容量的需求超过当前数组的大小时，才需要进行扩容。扩容会进行大量的数组复制操作。而复制时最终调用的是System.arraycopy()方法，因此，add()效率还是相当高的。</p>
<p>LinkedList由于使用了链表的结构，因此不需要维护容量的大小。这点比ArrayList有优势，不过，由于每次元素增加都需要新建Node对象，并进行更多的赋值操作。在频繁的系统调用中，对性能会产生一定影响。</p>
<h2 id="插入元素到列表任意位置"><a href="#插入元素到列表任意位置" class="headerlink" title="插入元素到列表任意位置"></a>插入元素到列表任意位置</h2><p>ArrayList是基于数组实现的，而数组是一块连续的内存空间，每次插入操作，都会进行一次数组复制。大量的数组复制会导致系统性能低下。</p>
<p>LinkedList是基于链表实现的，在任意位置插入和在尾端增加是一样的。所以，如果系统应用需要对List对象在任意位置进行频繁的插入操作，可以考虑用LinkedList替代ArrayList。</p>
<h2 id="容量参数"><a href="#容量参数" class="headerlink" title="容量参数"></a>容量参数</h2><p>容量参数是ArrayList 和 Vector等基于数组的List的特有性能参数，它表示初始数组的大小。</p>
<p>合理的设置容量参数，可以减少数组扩容，提升系统性能。</p>
<p>默认ArrayList的数组初始大小为10。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br></pre></td></tr></table></figure>

<h2 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h2><p>常用的三种列表遍历方式：ForEach操作、迭代器和for循环。</p>
<p>对于ForEach操作，反编译可知实际上是将ForEach循环体作为迭代器处理。不过ForEach比自定义的迭代器多了一步赋值操作，性能不如直接使用迭代器的方式。</p>
<p>使用For循环通过随机访问遍历列表，ArrayList表现很好，速度最快；但是LinkedList的表现非常差，应避免使用，这是因为对LinkedList的随机访问时，总会进行一次列表的遍历操作。</p>
<h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><p>Map是一种非常常用的数据结构。围绕着Map接口，最主要的实现类有Hashtable, HashMap, LinkedHashMap 和 TreeMap，在Hashtable中，还有Properties 类的实现。</p>
<img data-src="/2019/04/06/java/Java%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(List%E3%80%81Map%E3%80%81Set)%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/4.png" class="">

<p>Hashtable和hashMap的区别在于Hashtable的大部分方法都做了线程同步，而HashMap没有，</p>
<p>因此，Hashtable是线程安全的，HashMap不是。</p>
<p>其次，Hashtable 不允许key或value使用null值，而HashMap可以。</p>
<p>第三，它们在内部对key的hash算法和hash值到内存索引的映射算法不同。</p>
<p>由于HashMap使用广泛，本文以HashMap为例，阐述它的实现原理。</p>
<h2 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h2><p>简单来说，HashMap就是将key做hash算法，然后将hash值映射到内存地址，直接取得key所对应的数据。</p>
<p>在HashMap中，底层数据结构使用的是数组。所谓的内存地址，就是数组的下标索引。</p>
<p>用代码简单表示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object[key_hash] = value;</span><br></pre></td></tr></table></figure>

<h2 id="Hash冲突"><a href="#Hash冲突" class="headerlink" title="Hash冲突"></a>Hash冲突</h2><p>当需要存放的两个元素1和2经hash计算后，发现对应在内存中的同一个地址。此时HashMap又会如何处理以保证数据的完整存放？</p>
<p>在HashMap的底层使用数组，但数组内的元素不是简单的值，而是一个Entity类的对象。每一个Entity表项包括key，value，next，hash几项。注意这里的next部分，它指向另外一个Entity。</p>
<p>当put()操作有冲突时，新的Entity会替换原有的值，为了保证旧值不丢失，会将next指向旧值。这便实现了在一个数组空间内存放多个值项。因此，HashMap实际上是一个链表的数组。</p>
<p>而在进行get()操作时，如果定位到的数组元素不含链表（当前entry的next指向null），则直接返回；如果定位到的数组元素包含链表，则需要遍历链表，通过key对象的equals方法逐一比对查找。</p>
<h2 id="容量参数-1"><a href="#容量参数-1" class="headerlink" title="容量参数"></a>容量参数</h2><p>和ArrayList一样，基于数组的结构，不可避免的需要在数组空间不足时，进行扩展。而数组的重组比较耗时，因此对其做一定的优化很有必要了。</p>
<p>HashMap提供了两个可以指定初始化大小的构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashMap(int initialCapacity) </span><br><span class="line">          构造一个带指定初始容量和默认负载因子 (0.75) 的空 HashMap。</span><br><span class="line"></span><br><span class="line">HashMap(int initialCapacity, float loadFactor) </span><br><span class="line">          构造一个带指定初始容量和负载因子的空 HashMap。</span><br></pre></td></tr></table></figure>

<p>其中，HashMap会使用大于等于initialCapacity并且是2的指数次幂的最小的整数作为内置数组的大小。</p>
<p>负载因子又叫做填充比，它是介于0和1之间的浮点数。</p>
<p>负载因子 &#x3D; 实际元素个数 &#x2F; 内部数组总大小</p>
<p>负载因子的作用就是决定HashMap的阈值（threshold）。</p>
<p>阈值 &#x3D; 数组总容量 × 负载因子</p>
<p>当HashMap的实际容量超过阈值便会进行扩容，每次扩容将新的数组大小设置为原大小的1.5倍。</p>
<p>默认情况下，HashMap的初始大小是16，负载因子为0.75。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br></pre></td></tr></table></figure>

<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>LinkedHashMap继承自HashMap，因此，它具备了HashMap的优良特性，并在此基础上，LinkedHashMap又在内部增加了一个链表，用以存放元素的顺序。</p>
<p>因此，LinkedHashMap可以简单理解为一个维护了元素次序表的HashMap.</p>
<p>LinkedHashMap提供两种类型的顺序：一是元素插入时的顺序；二是最近访问的顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) </span><br><span class="line">          构造一个带指定初始容量、负载因子和排序模式的空 LinkedHashMap 实例</span><br></pre></td></tr></table></figure>

<p>其中accessOrder为true时，按照元素最后访问时间排序；当accessOrder为false 时，按照插入顺序排序。默认为 false 。</p>
<p>在内部实现中，LinkedHashMap通过继承HashMap.Entity类，实现LinkedHashMap.Entity，为HashMap.Entity增加了before和after属性用以记录某一表项的前驱和后继，并构成循环链表。</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap可以简单理解为一种可以进行排序的Map实现。与LinkedHashMap不同，LinkedHashMap是根据元素增加或者访问的先后顺序进行排序，而TreeMap则根据元素的Key进行排序。为了确定Key的排序算法，可以使用两种方式指定：</p>
<ul>
<li>在TreeMap的构造函数中注入一个Comparator：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TreeMap(Comparator&lt;? super K&gt; comparator) </span><br></pre></td></tr></table></figure>
<ul>
<li>使用一个实现了 Comparable 接口的 Key。</li>
</ul>
<p>TreeMap的内部实现是基于红黑树的。红黑树是一种平衡查找树，这里不做过多介绍。</p>
<p>TreeMap 其它排序接口如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subMap(K fromKey, K toKey) </span><br><span class="line">          返回此映射的部分视图，其键值的范围从 fromKey（包括）到 toKey（不包括）。</span><br><span class="line"></span><br><span class="line">tailMap(K fromKey) </span><br><span class="line">          返回此映射的部分视图，其键大于等于 fromKey。</span><br><span class="line"></span><br><span class="line">firstKey() </span><br><span class="line">          返回此映射中当前第一个（最低）键。</span><br><span class="line"></span><br><span class="line">headMap(K toKey) </span><br><span class="line">          返回此映射的部分视图，其键值严格小于 toKey。</span><br><span class="line"></span><br><span class="line">一个简单示例如下：</span><br><span class="line">public class MyKey implements Comparable&lt;MyKey&gt; &#123;</span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    public MyKey(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(MyKey o) &#123;</span><br><span class="line">        if (o.id &lt; this.id)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else if (o.id &gt; this.id)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyKey myKey1 = new MyKey(1);</span><br><span class="line">        MyKey myKey2 = new MyKey(2);</span><br><span class="line">        MyKey myKey3 = new MyKey(3);</span><br><span class="line">        Map&lt;MyKey,Object&gt; map = new TreeMap&lt;&gt;();</span><br><span class="line">        map.put(myKey1,&quot;一号&quot;);</span><br><span class="line">        map.put(myKey3,&quot;三号&quot;);</span><br><span class="line">        map.put(myKey2,&quot;二号&quot;);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;MyKey&gt; iterator = map.keySet().iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(map.get(iterator.next()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h1><p>Set并没有在Collection接口之上增加额外的操作，Set集合中的元素是不能重复的。<br>其中最为重要的是HashSet、LinkedHashSet、TreeSet 的实现。这里不再一一赘述，因为所有的这些Set实现都只是对应的Map的一种封装而已。</p>
<h1 id="优化集合访问代码"><a href="#优化集合访问代码" class="headerlink" title="优化集合访问代码"></a>优化集合访问代码</h1><h2 id="分离循环中被重复调用的代码"><a href="#分离循环中被重复调用的代码" class="headerlink" title="分离循环中被重复调用的代码"></a>分离循环中被重复调用的代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">举个例子，当我们要使用for循环遍历集合时</span><br><span class="line">for (int i =0;i&lt;collection.size();i++)&#123;</span><br><span class="line">    //.....</span><br><span class="line">&#125;</span><br><span class="line">很明显，每次循环都会调用size()方法，并且每次都会返回相同的数值。分离所有类似的代码对提升循环性能有着积极地意义。因此，可以将上段代码改造成</span><br><span class="line">int size= collection.size();</span><br><span class="line">for (int i =0;i&lt;size;i++)&#123;</span><br><span class="line">    //.....</span><br><span class="line">&#125;</span><br><span class="line">当元素的数量越多时，这样的处理就越有意义。</span><br></pre></td></tr></table></figure>

<h2 id="省略相同的操作"><a href="#省略相同的操作" class="headerlink" title="省略相同的操作"></a>省略相同的操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设我们有一段类似的操作如下</span><br><span class="line">int size= collection.size();</span><br><span class="line">for (int i =0;i&lt;size;i++)&#123;</span><br><span class="line">    if (list.get(i)==1||list.get(i)==2||list.get(i)==3)&#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">虽然每次循环调用get(i)的返回值不同，但在同一次调用中，结果是相同的，因此可以提取这些相同的操作。</span><br><span class="line">int size= collection.size();</span><br><span class="line">int k=0;</span><br><span class="line">for (int i =0;i&lt;size;i++)&#123;</span><br><span class="line">    if ((k = list.get(i))==1||k==2||k==3)&#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="减少方法调用"><a href="#减少方法调用" class="headerlink" title="减少方法调用"></a>减少方法调用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法调用是需要消耗系统堆栈的，如果可以，则尽量访问内部元素，而不要调用对应的接口，函数调用是需要消耗系统资源的，直接访问元素会更高效。</span><br><span class="line">假设上面的代码是Vector.class的子类的部分代码，那么可以这么改写</span><br><span class="line">int size = this.elementCount;</span><br><span class="line">Object k=null;</span><br><span class="line">for (int i =0;i&lt;size;i++)&#123;</span><br><span class="line">    if ((k = elementData[i])==&quot;1&quot;||k==&quot;2&quot;||k==&quot;3&quot;)&#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">可以看到，原本的 size() 和 get() 方法被直接替代为访问原始变量，这对系统性能的提升是非常有用的。</span><br></pre></td></tr></table></figure>

<h1 id="RandomAccess接口"><a href="#RandomAccess接口" class="headerlink" title="RandomAccess接口"></a>RandomAccess接口</h1><p>RandomAccess接口是一个标志接口，本身并没有提供任何方法，任何实现RandomAccess接口的对象都可以认为是支持快速随机访问的对象。此接口的主要目的是标识那些可以支持快速随机访问的List实现。</p>
<p>在JDK中，任何一个基于数组的List实现都实现了RandomAccess接口，而基于链表的实现则没有。这很好理解，只有数组能够快速随机访问，（比如：通过 object[5]，object[6]可以直接查找并返回对象），而对链表的随机访问需要进行链表的遍历。</p>
<p>在实际操作中，可以根据list instanceof RandomAccess来判断对象是否实现 RandomAccess接口，从而选择是使用随机访问还是iterator迭代器进行访问。</p>
<p>在应用程序中，如果需要通过索引下标对 List 做随机访问，尽量不要使用 LinkedList，ArrayList和Vector都是不错的选择。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式</title>
    <url>/2020/04/21/java/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="函数式编程思想概述"><a href="#函数式编程思想概述" class="headerlink" title="函数式编程思想概述"></a>函数式编程思想概述</h2><img data-src="/2020/04/21/java/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/03-Overview.png" class="">

<p>在数学中，<strong>函数</strong>就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong>。</p>
<p>面向对象的思想:</p>
<p>​	做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</p>
<p>函数式编程思想:</p>
<p>​	只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p>
<h2 id="冗余的Runnable代码"><a href="#冗余的Runnable代码" class="headerlink" title="冗余的Runnable代码"></a>冗余的Runnable代码</h2><h3 id="传统写法"><a href="#传统写法" class="headerlink" title="传统写法"></a>传统写法</h3><p>当需要启动一个线程去完成任务时，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使用<code>java.lang.Thread</code>类来启动该线程。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Runnable</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	<span class="comment">// 匿名内部类</span></span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">// 覆盖重写抽象方法</span></span><br><span class="line">				System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(task).start(); <span class="comment">// 启动线程</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p>
<ul>
<li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li>
<li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li>
<li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li>
</ul>
<h2 id="编程思想转换"><a href="#编程思想转换" class="headerlink" title="编程思想转换"></a>编程思想转换</h2><h3 id="做什么，而不是怎么做"><a href="#做什么，而不是怎么做" class="headerlink" title="做什么，而不是怎么做"></a>做什么，而不是怎么做</h3><p>我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而<strong>不得不</strong>创建一个对象。我们真正希望做的事情是：将<code>run</code>方法体内的代码传递给<code>Thread</code>类知晓。</p>
<p><strong>传递一段代码</strong>——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。</p>
<h3 id="生活举例"><a href="#生活举例" class="headerlink" title="生活举例"></a>生活举例</h3><img data-src="/2020/04/21/java/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/01-%E4%BA%A4%E9%80%9A%E6%96%B9%E5%BC%8F.png" class="">

<p>当我们需要从北京到上海时，可以选择高铁、汽车、骑行或是徒步。我们的真正目的是到达上海，而如何才能到达上海的形式并不重要，所以我们一直在探索有没有比高铁更好的方式——搭乘飞机。</p>
<img data-src="/2020/04/21/java/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/02-Lambda.png" class="">

<p>而现在这种飞机（甚至是飞船）已经诞生：2014年3月Oracle所发布的Java 8（JDK 1.8）中，加入了<strong>Lambda表达式</strong>的重量级新特性，为我们打开了新世界的大门。</p>
<h2 id="体验Lambda的更优写法"><a href="#体验Lambda的更优写法" class="headerlink" title="体验Lambda的更优写法"></a>体验Lambda的更优写法</h2><p>借助Java 8的全新语法，上述<code>Runnable</code>接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02LambdaRunnable</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>)).start(); <span class="comment">// 启动线程</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。</p>
<p>不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！</p>
<h2 id="回顾匿名内部类"><a href="#回顾匿名内部类" class="headerlink" title="回顾匿名内部类"></a>回顾匿名内部类</h2><p>Lambda是怎样击败面向对象的？在上例中，核心代码其实只是如下所示的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>为了理解Lambda的语义，我们需要从传统的代码起步。</p>
<h3 id="使用实现类"><a href="#使用实现类" class="headerlink" title="使用实现类"></a>使用实现类</h3><p>要启动一个线程，需要创建一个<code>Thread</code>类的对象并调用<code>start</code>方法。而为了指定线程执行的内容，需要调用<code>Thread</code>类的构造方法：</p>
<ul>
<li><code>public Thread(Runnable target)</code></li>
</ul>
<p>为了获取<code>Runnable</code>接口的实现对象，可以为该接口定义一个实现类<code>RunnableImpl</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建该实现类的对象作为<code>Thread</code>类的构造参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03ThreadInitParam</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableImpl</span>();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用匿名内部类"><a href="#使用匿名内部类" class="headerlink" title="使用匿名内部类"></a>使用匿名内部类</h3><p>这个<code>RunnableImpl</code>类只是为了实现<code>Runnable</code>接口而存在的，而且仅被使用了唯一一次，所以使用匿名内部类的语法即可省去该类的单独定义，即匿名内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04ThreadNameless</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名内部类的好处与弊端"><a href="#匿名内部类的好处与弊端" class="headerlink" title="匿名内部类的好处与弊端"></a>匿名内部类的好处与弊端</h3><p>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>；另一方面，匿名内部类的语法——<strong>确实太复杂了！</strong></p>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>仔细分析该代码中的语义，<code>Runnable</code>接口只有一个<code>run</code>方法的定义：</p>
<ul>
<li><code>public abstract void run();</code></li>
</ul>
<p>即制定了一种做事情的方案（其实就是一个函数）：</p>
<ul>
<li><strong>无参数</strong>：不需要任何条件即可执行该方案。</li>
<li><strong>无返回值</strong>：该方案不产生任何结果。</li>
<li><strong>代码块</strong>（方法体）：该方案的具体执行步骤。</li>
</ul>
<p>同样的语义体现在<code>Lambda</code>语法中，要更加简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>前面的一对小括号即<code>run</code>方法的参数（无），代表不需要任何条件；</li>
<li>中间的一个箭头代表将前面的参数传递给后面的代码；</li>
<li>后面的输出语句即业务逻辑代码。</li>
</ul>
<h2 id="Lambda标准格式"><a href="#Lambda标准格式" class="headerlink" title="Lambda标准格式"></a>Lambda标准格式</h2><p>Lambda省去面向对象的条条框框，格式由<strong>3个部分</strong>组成：</p>
<ul>
<li>一些参数</li>
<li>一个箭头</li>
<li>一段代码</li>
</ul>
<p>Lambda表达式的<strong>标准格式</strong>为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(参数类型 参数名称) -&gt; &#123; 代码语句 &#125;</span><br></pre></td></tr></table></figure>

<p>格式说明：</p>
<ul>
<li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li>
<li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li>
<li>大括号内的语法与传统方法体要求基本一致。</li>
</ul>
<h2 id="练习：使用Lambda标准格式（无参无返回）"><a href="#练习：使用Lambda标准格式（无参无返回）" class="headerlink" title="练习：使用Lambda标准格式（无参无返回）"></a>练习：使用Lambda标准格式（无参无返回）</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个厨子<code>Cook</code>接口，内含唯一的抽象方法<code>makeFood</code>，且无参数、无返回值。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cook</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeFood</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code>invokeCook</code>方法，打印输出“吃饭啦！”字样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05InvokeCook</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 请在此使用Lambda【标准格式】调用invokeCook方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeCook</span><span class="params">(Cook cook)</span> &#123;</span><br><span class="line">        cook.makeFood();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    invokeCook(() -&gt; &#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;吃饭啦！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：小括号代表<code>Cook</code>接口<code>makeFood</code>抽象方法的参数为空，大括号代表<code>makeFood</code>的方法体。</p>
</blockquote>
<h2 id="Lambda的参数和返回值"><a href="#Lambda的参数和返回值" class="headerlink" title="Lambda的参数和返回值"></a>Lambda的参数和返回值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需求:</span><br><span class="line">    使用数组存储多个Person对象</span><br><span class="line">    对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序</span><br></pre></td></tr></table></figure>

<p>下面举例演示<code>java.util.Comparator&lt;T&gt;</code>接口的使用场景代码，其中的抽象方法定义为：</p>
<ul>
<li><code>public abstract int compare(T o1, T o2);</code></li>
</ul>
<p>当需要对一个对象数组进行排序时，<code>Arrays.sort</code>方法需要一个<code>Comparator</code>接口实例来指定排序的规则。假设有一个<code>Person</code>类，含有<code>String name</code>和<code>int age</code>两个成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略构造器、toString方法与Getter Setter </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="传统写法-1"><a href="#传统写法-1" class="headerlink" title="传统写法"></a>传统写法</h3><p>如果使用传统的代码对<code>Person[]</code>数组进行排序，写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06Comparator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">// 本来年龄乱序的对象数组</span></span><br><span class="line">        Person[] array = &#123;</span><br><span class="line">        	<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;古力娜扎&quot;</span>, <span class="number">19</span>),</span><br><span class="line">        	<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">18</span>),</span><br><span class="line">       		<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;马尔扎哈&quot;</span>, <span class="number">20</span>) &#125;;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 匿名内部类</span></span><br><span class="line">        Comparator&lt;Person&gt; comp = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(array, comp); <span class="comment">// 第二个参数为排序规则，即Comparator接口实例</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : array) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法在面向对象的思想中，似乎也是“理所当然”的。其中<code>Comparator</code>接口的实例（使用了匿名内部类）代表了“按照年龄从小到大”的排序规则。</p>
<h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><p>下面我们来搞清楚上述代码真正要做什么事情。</p>
<ul>
<li>为了排序，<code>Arrays.sort</code>方法需要排序规则，即<code>Comparator</code>接口的实例，抽象方法<code>compare</code>是关键；</li>
<li>为了指定<code>compare</code>的方法体，<strong>不得不</strong>需要<code>Comparator</code>接口的实现类；</li>
<li>为了省去定义一个<code>ComparatorImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>compare</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>实际上，<strong>只有参数和方法体才是关键</strong>。</li>
</ul>
<h3 id="Lambda写法"><a href="#Lambda写法" class="headerlink" title="Lambda写法"></a>Lambda写法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07ComparatorLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Person[] array = &#123;</span><br><span class="line">          	<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;古力娜扎&quot;</span>, <span class="number">19</span>),</span><br><span class="line">          	<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">18</span>),</span><br><span class="line">          	<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;马尔扎哈&quot;</span>, <span class="number">20</span>) &#125;;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(array, (Person a, Person b) -&gt; &#123;</span><br><span class="line">          	<span class="keyword">return</span> a.getAge() - b.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : array) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="练习：使用Lambda标准格式（有参有返回）"><a href="#练习：使用Lambda标准格式（有参有返回）" class="headerlink" title="练习：使用Lambda标准格式（有参有返回）"></a>练习：使用Lambda标准格式（有参有返回）</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个计算器<code>Calculator</code>接口，内含抽象方法<code>calc</code>可以将两个int数字相加得到和值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code>invokeCalc</code>方法，完成120和130的相加计算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08InvokeCalc</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 请在此使用Lambda【标准格式】调用invokeCalc方法来计算120+130的结果ß</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeCalc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, Calculator calculator)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> calculator.calc(a, b);</span><br><span class="line">        System.out.println(<span class="string">&quot;结果是：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    invokeCalc(<span class="number">120</span>, <span class="number">130</span>, (<span class="type">int</span> a, <span class="type">int</span> b) -&gt; &#123;</span><br><span class="line">      	<span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：小括号代表<code>Calculator</code>接口<code>calc</code>抽象方法的参数，大括号代表<code>calc</code>的方法体。</p>
</blockquote>
<h2 id="Lambda省略格式"><a href="#Lambda省略格式" class="headerlink" title="Lambda省略格式"></a>Lambda省略格式</h2><h3 id="可推导即可省略"><a href="#可推导即可省略" class="headerlink" title="可推导即可省略"></a>可推导即可省略</h3><p>Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用Lambda的省略写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  	invokeCalc(<span class="number">120</span>, <span class="number">130</span>, (a, b) -&gt; a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h3><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p>
<ol>
<li>小括号内参数的类型可以省略；</li>
<li>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</li>
<li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li>
</ol>
<blockquote>
<p>备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。</p>
</blockquote>
<h2 id="练习：使用Lambda省略格式"><a href="#练习：使用Lambda省略格式" class="headerlink" title="练习：使用Lambda省略格式"></a>练习：使用Lambda省略格式</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>仍然使用前文含有唯一<code>makeFood</code>抽象方法的厨子<code>Cook</code>接口，在下面的代码中，请使用Lambda的<strong>省略格式</strong>调用<code>invokeCook</code>方法，打印输出“吃饭啦！”字样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo09InvokeCook</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 请在此使用Lambda【省略格式】调用invokeCook方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeCook</span><span class="params">(Cook cook)</span> &#123;</span><br><span class="line">        cook.makeFood();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  	invokeCook(() -&gt; System.out.println(<span class="string">&quot;吃饭啦！&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lambda的使用前提"><a href="#Lambda的使用前提" class="headerlink" title="Lambda的使用前提"></a>Lambda的使用前提</h2><p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p>
<ol>
<li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li>
<li>使用Lambda必须具有<strong>上下文推断</strong>。<br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li>
</ol>
<blockquote>
<p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>List的子类</title>
    <url>/2020/04/20/java/List%E7%9A%84%E5%AD%90%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h2><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p>
<p>许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。</p>
<h2 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h2><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p>
<blockquote>
<p>LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下</p>
</blockquote>
<img data-src="/2020/04/20/java/List%E7%9A%84%E5%AD%90%E7%B1%BB/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" class="">

<p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：</p>
<ul>
<li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li>
<li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li>
<li><code>public E getFirst()</code>:返回此列表的第一个元素。</li>
<li><code>public E getLast()</code>:返回此列表的最后一个元素。</li>
<li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li>
<li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li>
<li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li>
<li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li>
<li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li>
</ul>
<p>LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可）</p>
<p>方法演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LinkedList&lt;String&gt; link = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        link.addFirst(<span class="string">&quot;abc1&quot;</span>);</span><br><span class="line">        link.addFirst(<span class="string">&quot;abc2&quot;</span>);</span><br><span class="line">        link.addFirst(<span class="string">&quot;abc3&quot;</span>);</span><br><span class="line">        System.out.println(link);</span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        System.out.println(link.getFirst());</span><br><span class="line">        System.out.println(link.getLast());</span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line">        System.out.println(link.removeFirst());</span><br><span class="line">        System.out.println(link.removeLast());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!link.isEmpty()) &#123; <span class="comment">//判断集合是否为空</span></span><br><span class="line">            System.out.println(link.pop()); <span class="comment">//弹出集合中的栈顶元素</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(link);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vector集合"><a href="#Vector集合" class="headerlink" title="Vector集合"></a>Vector集合</h2><p>Vector类可以实现可增长的对象数组,与数组一样，它包含可以使用整数索引进行访问的组件。但是，Vector的大小可以根据需要增大或缩小，以适应创建Vector后进行添加或移除项的操作。</p>
<p>Vector是同步方法</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>List集合</title>
    <url>/2020/04/19/java/List%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>Collection中的常用几个子类（<code>java.util.List</code>集合、<code>java.util.Set</code>集合）。</p>
<h2 id="List接口介绍"><a href="#List接口介绍" class="headerlink" title="List接口介绍"></a>List接口介绍</h2><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p>
<p>看完API，我们总结一下：</p>
<p>List接口特点：</p>
<ol>
<li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li>
<li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li>
<li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li>
</ol>
<h2 id="List接口中常用方法"><a href="#List接口中常用方法" class="headerlink" title="List接口中常用方法"></a>List接口中常用方法</h2><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p>
<ul>
<li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li>
<li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li>
<li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li>
<li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li>
</ul>
<p>List集合特有的方法都是跟索引相关，我们在基础班都学习过，那么我们再来复习一遍吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建List集合对象</span></span><br><span class="line">    	List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 往 尾部添加 指定元素</span></span><br><span class="line">    	list.add(<span class="string">&quot;图图&quot;</span>);</span><br><span class="line">    	list.add(<span class="string">&quot;小美&quot;</span>);</span><br><span class="line">    	list.add(<span class="string">&quot;不高兴&quot;</span>);</span><br><span class="line">    	</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	<span class="comment">// add(int index,String s) 往指定位置添加</span></span><br><span class="line">    	list.add(<span class="number">1</span>,<span class="string">&quot;没头脑&quot;</span>);</span><br><span class="line">    	</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	<span class="comment">// String remove(int index) 删除指定位置元素  返回被删除元素</span></span><br><span class="line">    	<span class="comment">// 删除索引位置为2的元素 </span></span><br><span class="line">    	System.out.println(<span class="string">&quot;删除索引位置为2的元素&quot;</span>);</span><br><span class="line">    	System.out.println(list.remove(<span class="number">2</span>));</span><br><span class="line">    	</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// String set(int index,String s)</span></span><br><span class="line">    	<span class="comment">// 在指定位置 进行 元素替代（改） </span></span><br><span class="line">    	<span class="comment">// 修改指定位置元素</span></span><br><span class="line">    	list.set(<span class="number">0</span>, <span class="string">&quot;三毛&quot;</span>);</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// String get(int index)  获取指定位置元素</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 跟size() 方法一起用  来 遍历的 </span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">    		System.out.println(list.get(i));</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//还可以使用增强for</span></span><br><span class="line">    	<span class="keyword">for</span> (String string : list) &#123;</span><br><span class="line">			System.out.println(string);</span><br><span class="line">		&#125;  	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>操作素引的时候，一定要防止素引越界异常</p>
<ul>
<li>IndexoutofBoundsExceptfon：索引越界异常,集合会报</li>
<li>ArrayIndexoutofBoundsExcept ion：数组索引越界异常</li>
<li>StringIndexoutofBoundsException：字行串索引越界异常</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Map集合</title>
    <url>/2020/04/20/java/Map%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p>
<p>我们通过查看<code>Map</code>接口描述，发现<code>Map</code>接口下的集合与<code>Collection</code>接口下的集合，它们存储数据的形式不同，如下图。</p>
<img data-src="/2020/04/20/java/Map%E9%9B%86%E5%90%88/Collection%E4%B8%8EMap.bmp" class="">

<ul>
<li><code>Collection</code>中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li>
<li><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li>
<li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li>
<li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li>
</ul>
<h2 id="Map常用子类"><a href="#Map常用子类" class="headerlink" title="Map常用子类"></a>Map常用子类</h2><p>通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。</p>
<ul>
<li>**HashMap&lt;K,V&gt;**：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。<ul>
<li><strong>HashMap集合底层是哈希表：查询的速度特别的快</strong></li>
<li><strong>JDK1.8之前：数组+单向链表</strong></li>
<li><strong>JDK1.8之后：数组+单向链表&#x2F;红黑树（链表的长度超过8）：提高查询的速度</strong></li>
<li><strong>HashMap集合是一个无序的集合，存储元素和取出元素的顺序有可能一致</strong></li>
</ul>
</li>
<li>**LinkedHashMap&lt;K,V&gt;**：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。<ul>
<li><strong>LinkedHashMap集合底层是哈希表+链表（报增迭代的顺序）</strong></li>
<li><strong>LinkedHashMap去和是一个有序的集合，存储元素和取出元素的顺序一致的</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。</p>
</blockquote>
<h2 id="Map接口中的常用方法"><a href="#Map接口中的常用方法" class="headerlink" title="Map接口中的常用方法"></a>Map接口中的常用方法</h2><p>Map接口中定义了很多方法，常用的如下：</p>
<ul>
<li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li>
<li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li>
<li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li>
<li><code>boolean containsKey(Object key)  </code> 判断集合中是否包含指定的键。</li>
<li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li>
</ul>
<p>Map接口的方法演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建 map对象</span></span><br><span class="line">        HashMap&lt;String, String&gt;  map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素到集合</span></span><br><span class="line">        map.put(<span class="string">&quot;黄晓明&quot;</span>, <span class="string">&quot;杨颖&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;文章&quot;</span>, <span class="string">&quot;马伊琍&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;邓超&quot;</span>, <span class="string">&quot;孙俪&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String remove(String key)</span></span><br><span class="line">        System.out.println(map.remove(<span class="string">&quot;邓超&quot;</span>));</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 想要查看 黄晓明的媳妇 是谁</span></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;黄晓明&quot;</span>));</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;邓超&quot;</span>));    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </p>
<p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 </p>
</blockquote>
<h2 id="Map集合遍历键找值方式"><a href="#Map集合遍历键找值方式" class="headerlink" title="Map集合遍历键找值方式"></a>Map集合遍历键找值方式</h2><p>键找值方式：即通过元素中的键，获取键所对应的值</p>
<p>分析步骤：</p>
<ol>
<li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:<code>keyset()</code></li>
<li>遍历键的Set集合，得到每一个键。</li>
<li>根据键，获取键所对应的值。方法提示:<code>get(K key)</code></li>
</ol>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象 </span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">//添加元素到集合 </span></span><br><span class="line">        map.put(<span class="string">&quot;胡歌&quot;</span>, <span class="string">&quot;霍建华&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;郭德纲&quot;</span>, <span class="string">&quot;于谦&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;薛之谦&quot;</span>, <span class="string">&quot;大张伟&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有的键  获取键集</span></span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="comment">// 遍历键集 得到 每一个键</span></span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">          	<span class="comment">//key  就是键</span></span><br><span class="line">            <span class="comment">//获取对应值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(key+<span class="string">&quot;的CP是：&quot;</span>+value);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历图解：</p>
<img data-src="/2020/04/20/java/Map%E9%9B%86%E5%90%88/Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%B8%80.bmp" class="">

<h2 id="Entry键值对对象"><a href="#Entry键值对对象" class="headerlink" title="Entry键值对对象"></a>Entry键值对对象</h2><p>我们已经知道，<code>Map</code>中存放的是两种对象，一种称为<strong>key</strong>(键)，一种称为<strong>value</strong>(值)，它们在在<code>Map</code>中是一一对应关系，这一对对象又称做<code>Map</code>中的一个<code>Entry(项)</code>。<code>Entry</code>将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历<code>Map</code>集合时，就可以从每一个键值对（<code>Entry</code>）对象中获取对应的键与对应的值。</p>
<p> 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</p>
<ul>
<li><code>public K getKey()</code>：获取Entry对象中的键。</li>
<li><code>public V getValue()</code>：获取Entry对象中的值。</li>
</ul>
<p>在Map集合中也提供了获取所有Entry对象的方法：</p>
<ul>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li>
</ul>
<h2 id="Map集合遍历键值对方式"><a href="#Map集合遍历键值对方式" class="headerlink" title="Map集合遍历键值对方式"></a>Map集合遍历键值对方式</h2><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p>
<p>操作步骤与图解：</p>
<ol>
<li><p>获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</p>
</li>
<li><p>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</p>
</li>
<li><p>通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Map集合对象 </span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">// 添加元素到集合 </span></span><br><span class="line">        map.put(<span class="string">&quot;胡歌&quot;</span>, <span class="string">&quot;霍建华&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;郭德纲&quot;</span>, <span class="string">&quot;于谦&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;薛之谦&quot;</span>, <span class="string">&quot;大张伟&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 所有的 entry对象  entrySet</span></span><br><span class="line">        Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历得到每一个entry对象</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">           	<span class="comment">// 解析 </span></span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();  </span><br><span class="line">            System.out.println(key+<span class="string">&quot;的CP是:&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历图解：</p>
<img data-src="/2020/04/20/java/Map%E9%9B%86%E5%90%88/Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%BA%8C.bmp" class="">

<blockquote>
<p>Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</p>
</blockquote>
<h2 id="HashMap存储自定义类型键值"><a href="#HashMap存储自定义类型键值" class="headerlink" title="HashMap存储自定义类型键值"></a>HashMap存储自定义类型键值</h2><p>练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。</p>
<blockquote>
<p>注意，学生姓名相同并且年龄相同视为同一名学生。</p>
</blockquote>
<p>编写学生类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp; Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1,创建Hashmap集合对象。</span></span><br><span class="line">        Map&lt;Student,String&gt;map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Student,String&gt;();</span><br><span class="line">        <span class="comment">//2,添加元素。</span></span><br><span class="line">        map.put(newStudent(<span class="string">&quot;lisi&quot;</span>,<span class="number">28</span>), <span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;wangwu&quot;</span>,<span class="number">22</span>), <span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;zhaoliu&quot;</span>,<span class="number">24</span>), <span class="string">&quot;成都&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;zhouqi&quot;</span>,<span class="number">25</span>), <span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;wangwu&quot;</span>,<span class="number">22</span>), <span class="string">&quot;南京&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3,取出元素。键找值方式</span></span><br><span class="line">        Set&lt;Student&gt;keySet = map.keySet();</span><br><span class="line">        <span class="keyword">for</span>(Student key: keySet)&#123;</span><br><span class="line">            Stringvalue = map.get(key);</span><br><span class="line">            System.out.println(key.toString()+<span class="string">&quot;.....&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。</li>
<li>如果要保证map中存放的key和取出的顺序一致，可以使用<code>java.util.LinkedHashMap</code>集合来存放。</li>
</ul>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？</p>
<p>在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LinkedHashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;邓超&quot;</span>, <span class="string">&quot;孙俪&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;李晨&quot;</span>, <span class="string">&quot;范冰冰&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;刘德华&quot;</span>, <span class="string">&quot;朱丽倩&quot;</span>);</span><br><span class="line">        Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;  &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">邓超  孙俪</span><br><span class="line">李晨  范冰冰</span><br><span class="line">刘德华  朱丽倩</span><br></pre></td></tr></table></figure>

<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>底层也是一个哈希表</p>
<p>线程安全</p>
<p>不能存储null值</p>
<p>但是HashTable的子类Properties一样很常用</p>
<p>Properties是唯一和IO流结合的集合</p>
<h2 id="Map集合练习"><a href="#Map集合练习" class="headerlink" title="Map集合练习"></a>Map集合练习</h2><p><strong>需求：</strong></p>
<p>计算一个字符串中每个字符出现次数。</p>
<p><strong>分析：</strong></p>
<ol>
<li>获取一个字符串对象</li>
<li>创建一个Map集合，键代表字符，值代表次数。</li>
<li>遍历字符串得到每个字符。</li>
<li>判断Map中是否有该键。</li>
<li>如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。     </li>
<li>打印最终结果</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//友情提示</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请录入一个字符串:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).nextLine();</span><br><span class="line">        <span class="comment">// 定义 每个字符出现次数的方法</span></span><br><span class="line">        findChar(line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findChar</span><span class="params">(String line)</span> &#123;</span><br><span class="line">        <span class="comment">//1:创建一个集合 存储  字符 以及其出现的次数</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="comment">//2:遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; line.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> line.charAt(i);</span><br><span class="line">            <span class="comment">//判断 该字符 是否在键集中</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(c)) &#123;<span class="comment">//说明这个字符没有出现过</span></span><br><span class="line">                <span class="comment">//那就是第一次</span></span><br><span class="line">                map.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//先获取之前的次数</span></span><br><span class="line">                <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> map.get(c);</span><br><span class="line">                <span class="comment">//count++;</span></span><br><span class="line">                <span class="comment">//再次存入  更新</span></span><br><span class="line">                map.put(c, ++count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Math类</title>
    <url>/2020/04/02/java/Math%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>java.lang.Math</code>类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。</p>
<h2 id="基本运算的方法"><a href="#基本运算的方法" class="headerlink" title="基本运算的方法"></a>基本运算的方法</h2><ul>
<li><code>public static double abs(double a)</code>：返回 double 值的绝对值。<ul>
<li>如果参数为非负数，则返回该参数。如果参数为负数，则返回该参数的相反数。</li>
<li>如果参数为 NaN，那么结果为 NaN。</li>
</ul>
</li>
<li><code>public static double ceil(double a)</code>：向上取整<ul>
<li>返回最小的（最接近负无穷大）<code>double</code> 值，该值大于等于参数，并等于某个整数。</li>
</ul>
</li>
<li><code>public static double floor(double a)</code>：向下取整<ul>
<li>返回最大的（最接近正无穷大）double 值，该值小于等于参数，并等于某个整数。</li>
</ul>
</li>
<li><code>public static long round(double a)</code>：四舍五入    <ul>
<li>返回最接近参数的 long</li>
</ul>
</li>
<li>结果将舍入为整数：加上 1&#x2F;2，对结果调用 floor 并将所得结果强制转换为 long 类型</li>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">10.1</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> -<span class="number">10.1</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="number">10.5</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d4</span> <span class="operator">=</span> -<span class="number">10.5</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======Math.abs=======&quot;</span>);</span><br><span class="line">        System.out.println(Math.abs(d1)); <span class="comment">//10.1</span></span><br><span class="line">        System.out.println(Math.abs(d2)); <span class="comment">//10.1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=======Math.ceil======&quot;</span>);</span><br><span class="line">        System.out.println(Math.ceil(d1)); <span class="comment">//11.0</span></span><br><span class="line">        System.out.println(Math.ceil(d2)); <span class="comment">//-10.0</span></span><br><span class="line">        System.out.println(Math.ceil(d3)); <span class="comment">//11.0</span></span><br><span class="line">        System.out.println(Math.ceil(d4)); <span class="comment">//-10.0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=======Math.floor=====&quot;</span>);</span><br><span class="line">        System.out.println(Math.floor(d1)); <span class="comment">//10.0</span></span><br><span class="line">        System.out.println(Math.floor(d2)); <span class="comment">//-11.0</span></span><br><span class="line">        System.out.println(Math.floor(d3)); <span class="comment">//10.0</span></span><br><span class="line">        System.out.println(Math.floor(d4)); <span class="comment">//-11.0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=======Math.round=====&quot;</span>);</span><br><span class="line">        System.out.println(Math.round(d1));  <span class="comment">//10</span></span><br><span class="line">        System.out.println(Math.round(d2));  <span class="comment">//-10</span></span><br><span class="line">        System.out.println(Math.round(d3));  <span class="comment">//11</span></span><br><span class="line">        System.out.println(Math.round(d4));  <span class="comment">//-10</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Object类</title>
    <url>/2020/04/10/java/Object%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>java.lang.Object</code>类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。</p>
<p>如果一个类没有特别指定父类，那么默认则继承自Object类。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="comment">/*extends Object*/</span> &#123;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h2><h3 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul>
<li><code>public String toString()</code>：返回该对象的字符串表示。</li>
</ul>
<p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</p>
<p>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p>
<h3 id="覆盖重写"><a href="#覆盖重写" class="headerlink" title="覆盖重写"></a>覆盖重写</h3><p>如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略构造器与Getter Setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。</p>
</blockquote>
<h2 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h2><h3 id="方法摘要-1"><a href="#方法摘要-1" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul>
<li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li>
</ul>
<p>调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。</p>
<h3 id="默认地址比较"><a href="#默认地址比较" class="headerlink" title="默认地址比较"></a>默认地址比较</h3><p>如果没有覆盖重写equals方法，那么Object类中默认进行<code>==</code>运算符的对象<strong>地址比较</strong>，只要不是同一个对象，结果必然为false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而且隐含着一个多态</p>
<p><code>Object obj = new 对象类();</code></p>
<p>多态的弊端：无法受用子类特有的内容</p>
<p>解决：向下转型</p>
<h3 id="对象内容比较"><a href="#对象内容比较" class="headerlink" title="对象内容比较"></a>对象内容比较</h3><p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果对象地址一样，则认为相同</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 如果参数为空，或者类型信息不一样，则认为不同</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 转换为当前类型</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        <span class="comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span></span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。 </p>
<h2 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h2><p>自动重写equals代码中，使用到了<code>java.util.Objects</code>类</p>
<p>在<strong>JDK7</strong>添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是<strong>null-save</strong>（空指针安全的）或<strong>null-tolerant</strong>（容忍空指针的），用于计算对象的hashCode、返回对象的字符串表示形式、比较两个对象。</p>
<p>在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：</p>
<ul>
<li><code>public static boolean equals(Object a, Object b)</code>:判断两个对象是否相等。</li>
</ul>
<p>我们可以查看一下源码，学习一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="literal">null</span> &amp;&amp; a.equals(b));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Random类</title>
    <url>/2020/03/28/java/Random%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="什么是Random类"><a href="#什么是Random类" class="headerlink" title="什么是Random类"></a>什么是Random类</h2><p>此类的实例用于生成伪随机数</p>
<p>例如：获取一个随机数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> random.nextInt();</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Random使用步骤"><a href="#Random使用步骤" class="headerlink" title="Random使用步骤"></a>Random使用步骤</h2><ul>
<li>查看类<ul>
<li><code>java.util.Random</code>：该类需要import导入后使用</li>
</ul>
</li>
<li>查看构造方法<ul>
<li><code>public Random()</code>：创建一个新的随机数生成器</li>
</ul>
</li>
<li>查看成员方法<ul>
<li><code>public int nextInt(int n)</code>：返回一个伪随机数，范围在0（包括）和n（不包括）之间的<code>int</code>值</li>
</ul>
</li>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> random.nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(i+<span class="string">&quot;--------&gt;&quot;</span>+y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建一个Random对象，每次调用nextInt()方法，都会生成一个随机数</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Scanner类</title>
    <url>/2020/03/27/java/Scanner%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="什么是Scanner类"><a href="#什么是Scanner类" class="headerlink" title="什么是Scanner类"></a>什么是Scanner类</h2><p>一个可以解析基本类型和字符串的简单文本扫描器。</p>
<p>例如：读取用户键盘输入的一个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> scanner.nextInt();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>System.in系统输入指的是通过键盘录入数据</p>
</blockquote>
<h2 id="引用类型一般使用步骤"><a href="#引用类型一般使用步骤" class="headerlink" title="引用类型一般使用步骤"></a>引用类型一般使用步骤</h2><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><p>使用<code>import</code>关键字导包，在类的所有代码之前导包，引入要使用的类型，java.lang包下的所有类无需导入</p>
<ul>
<li>格式：</li>
</ul>
<p><code>import 包名.类名</code></p>
<ul>
<li>实现：</li>
</ul>
<p><code>import java.util.Scanner</code></p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>使用该类的构造方法，创建一个该类的对象</p>
<ul>
<li>格式：</li>
</ul>
<p><code>数据类型 变量名 = new 数据类型(参数列表)</code></p>
<ul>
<li>实现：</li>
</ul>
<p><code>Scanner scanner = new Scanner(System.in);</code></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>调用该类的成员方法，完成指定功能</p>
<ul>
<li>格式：</li>
</ul>
<p><code>变量名.方法名();</code></p>
<ul>
<li>实现：</li>
</ul>
<p><code>int i = scanner.nextInt();</code></p>
<h2 id="Scanner使用步骤"><a href="#Scanner使用步骤" class="headerlink" title="Scanner使用步骤"></a>Scanner使用步骤</h2><ul>
<li>查看类<ul>
<li><code>java.util.Scanner</code>：该类需要import导入后使用</li>
</ul>
</li>
<li>查看构造方法<ul>
<li><code>public Scanner(InputStream source)</code>：构造一个新的<code>Scanner</code>，它生成的值从指定的输入流扫描</li>
</ul>
</li>
<li>查看成员方法<ul>
<li><code>public int nextInt()</code>：将输入信息的下一个标记扫描为一个<code>int</code>值</li>
</ul>
</li>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。虽然是创建对象的简化写法，但是应用场景非常有限。</p>
<ul>
<li>匿名对象：没有变量名的对象</li>
<li>格式：<ul>
<li><code>new 类名(参数列表);</code></li>
</ul>
</li>
<li>实现：<ul>
<li><code>new Scanner(System.in);</code></li>
</ul>
</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>创建匿名对象直接调用方法，没有变量名</p>
</li>
<li><p><code>new Scanner(System.in).nextInt();</code></p>
</li>
<li><p>但是一旦调用两次方法，就是创建了两个对象，造成浪费</p>
<ul>
<li><pre><code class="java">new Scanner(System.in).nextInt();
new Scanner(System.in).nextInt();
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 匿名对象可以作为方法的参数和返回值</span><br><span class="line"></span><br><span class="line">  - 作为参数</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  public class Test &#123;</span><br><span class="line">      public static void main(String[] args)&#123;</span><br><span class="line">        input(new Scanner(System.in));</span><br><span class="line">  </span><br><span class="line">      &#125;</span><br><span class="line">      public static void input(Scanner scanner)&#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

- 作为返回值
</code></pre>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> input();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Scanner <span class="title function_">input</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Set接口</title>
    <url>/2020/04/20/java/Set%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p><code>java.util.Set</code>接口和<code>java.util.List</code>接口一样，同样继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p>
<p><code>Set</code>集合有多个子类，这里我们介绍其中的<code>java.util.HashSet</code>、<code>java.util.LinkedHashSet</code>这两个集合</p>
<p>Set接口的特点：</p>
<ul>
<li>不允许存储重复的元素</li>
<li>没有索引，没有带索引的方法，也不能使用普通的for循环遍历</li>
</ul>
<blockquote>
<p>Set集合取出元素的方式可以采用：迭代器、增强for。</p>
</blockquote>
<h2 id="HashSet集合介绍"><a href="#HashSet集合介绍" class="headerlink" title="HashSet集合介绍"></a>HashSet集合介绍</h2><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持。</p>
<p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p>
<p>HashSet特点：</p>
<ul>
<li>不允许存储重复的元素</li>
<li>没有索引，没有带索引的方法，也不能使用普通的for循环遍历</li>
<li>是一个无序的集合，存储元素和取出元素的顺序有可能不一致</li>
<li>底层是一个哈希表结构（查询的速度非常的快）</li>
</ul>
<p>我们先来使用一下Set集合存储，看下现象，再进行原理的讲解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建 Set集合</span></span><br><span class="line">        HashSet&lt;String&gt;  set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;cba&quot;</span>));</span><br><span class="line">        set.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;bac&quot;</span>); </span><br><span class="line">        set.add(<span class="string">&quot;cba&quot;</span>);  </span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (String name : set) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下，说明集合中不能存储重复元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cba</span><br><span class="line">abc</span><br><span class="line">bac</span><br></pre></td></tr></table></figure>

<blockquote>
<p>根据结果我们发现字符串”cba”只存储了一个，也就是说重复的元素set集合不存储。</p>
</blockquote>
<h2 id="HashSet集合存储数据的结构（哈希表）"><a href="#HashSet集合存储数据的结构（哈希表）" class="headerlink" title="HashSet集合存储数据的结构（哈希表）"></a>HashSet集合存储数据的结构（哈希表）</h2><p>哈希值：是一个十进制的整数，由系统随机给出（就是对象的地址值，是一个逻辑地址，是模拟出来的地址，不是数据实际存储的物理地址）</p>
<p>在<code>Object</code>类有一个方法，可以获取对象的哈希值</p>
<p><code>int hashCode() 返回该对象的哈希码值</code></p>
<p>hashCode方法的源码：</p>
<ul>
<li><code>public native int hashCode();</code></li>
<li><code>native</code>：表示用的是其他语言编写的代码</li>
</ul>
<p>什么是哈希表呢？</p>
<p>在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p>
<p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。<img data-src="/2020/04/20/java/Set%E6%8E%A5%E5%8F%A3/%E5%93%88%E5%B8%8C%E8%A1%A8.png" class=""></p>
<p>看到这张图就有人要问了，这个是怎么存储的呢？</p>
<p>为了方便大家的理解我们结合一个存储流程图来说明一下：</p>
<img data-src="/2020/04/20/java/Set%E6%8E%A5%E5%8F%A3/%E5%93%88%E5%B8%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="">

<p>总而言之，<strong>JDK1.8</strong>引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</p>
<h2 id="HashSet存储自定义类型元素"><a href="#HashSet存储自定义类型元素" class="headerlink" title="HashSet存储自定义类型元素"></a>HashSet存储自定义类型元素</h2><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一</p>
<p>创建自定义Student类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp;</span><br><span class="line">               Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象   该集合中存储 Student类型对象</span></span><br><span class="line">        HashSet&lt;Student&gt; stuSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Student&gt;();</span><br><span class="line">        <span class="comment">//存储 </span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;于谦&quot;</span>, <span class="number">43</span>);</span><br><span class="line">        stuSet.add(stu);</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;郭德纲&quot;</span>, <span class="number">44</span>));</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;于谦&quot;</span>, <span class="number">43</span>));</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;郭麒麟&quot;</span>, <span class="number">23</span>));</span><br><span class="line">        stuSet.add(stu);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Student stu2 : stuSet) &#123;</span><br><span class="line">            System.out.println(stu2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">Student [name=郭德纲, age=<span class="number">44</span>]</span><br><span class="line">Student [name=于谦, age=<span class="number">43</span>]</span><br><span class="line">Student [name=郭麒麟, age=<span class="number">23</span>]</span><br></pre></td></tr></table></figure>

<h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？</p>
<p>在HashSet下面有一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。</p>
<p>演示代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSetDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;String&gt;();</span><br><span class="line">		set.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;bbc&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			System.out.println(it.next());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">  bbb</span><br><span class="line">  aaa</span><br><span class="line">  abc</span><br><span class="line">  bbc</span><br></pre></td></tr></table></figure>

<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>其实这个书写完全等价与</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型[] 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。</p>
<p><strong>JDK1.5</strong>以后。出现了简化操作。**…** 用在参数上，称之为可变参数。</p>
<p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p>
<p>代码演示：    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeArgs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">62</span>, <span class="number">431</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> getSum(arr);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        <span class="comment">//  6  7  2 12 2121</span></span><br><span class="line">        <span class="comment">// 求 这几个元素和 6  7  2 12 2121</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum2</span> <span class="operator">=</span> getSum(<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">2121</span>);</span><br><span class="line">        System.out.println(sum2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 完成数组  所有元素的求和 原始写法</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">      public static int getSum(int[] arr)&#123;</span></span><br><span class="line"><span class="comment">        int sum = 0;</span></span><br><span class="line"><span class="comment">        for(int a : arr)&#123;</span></span><br><span class="line"><span class="comment">            sum += a;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        return sum;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//可变参数写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span>... arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : arr) &#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性</p>
<p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>StringBuilder类</title>
    <url>/2020/04/13/java/StringBuilder%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="字符串拼接问题"><a href="#字符串拼接问题" class="headerlink" title="字符串拼接问题"></a>字符串拼接问题</h2><p>由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        s += <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。</p>
<p>根据这句话分析我们的代码，其实总共产生了三个字符串，即<code>&quot;Hello&quot;</code>、<code>&quot;World&quot;</code>和<code>&quot;HelloWorld&quot;</code>。引用变量s首先指向<code>Hello</code>对象，最终指向拼接出来的新字符串对象，即<code>HelloWord</code> 。</p>
<p>由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用<code>java.lang.StringBuilder</code>类。</p>
<h2 id="StringBuilder概述"><a href="#StringBuilder概述" class="headerlink" title="StringBuilder概述"></a>StringBuilder概述</h2><p>查阅<code>java.lang.StringBuilder</code>的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p>
<p>原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p>
<p>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)</p>
<img data-src="/2020/04/13/java/StringBuilder%E7%B1%BB/01_StringBuilder%E7%9A%84%E5%8E%9F%E7%90%86.bmp" class="" alt="01_StringBuilder的原理">

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>根据StringBuilder的API文档，常用构造方法有2个：</p>
<ul>
<li><code>public StringBuilder()</code>：构造一个空的StringBuilder容器。</li>
<li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        System.out.println(sb1); <span class="comment">// (空白)</span></span><br><span class="line">        <span class="comment">// 使用带参构造</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        System.out.println(sb2); <span class="comment">// itcast</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>StringBuilder常用的方法有2个：</p>
<ul>
<li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</li>
<li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</li>
</ul>
<h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><p>append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02StringBuilder</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建对象</span></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		<span class="comment">//public StringBuilder append(任意类型)</span></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">builder2</span> <span class="operator">=</span> builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		<span class="comment">//对比一下</span></span><br><span class="line">		System.out.println(<span class="string">&quot;builder:&quot;</span>+builder);</span><br><span class="line">		System.out.println(<span class="string">&quot;builder2:&quot;</span>+builder2);</span><br><span class="line">		System.out.println(builder == builder2); <span class="comment">//true</span></span><br><span class="line">	    <span class="comment">// 可以添加 任何类型</span></span><br><span class="line">		builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		builder.append(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		builder.append(<span class="literal">true</span>);</span><br><span class="line">		builder.append(<span class="number">100</span>);</span><br><span class="line">		<span class="comment">// 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。</span></span><br><span class="line">        <span class="comment">// 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下</span></span><br><span class="line">		<span class="comment">//链式编程</span></span><br><span class="line">		builder.append(<span class="string">&quot;hello&quot;</span>).append(<span class="string">&quot;world&quot;</span>).append(<span class="literal">true</span>).append(<span class="number">100</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;builder:&quot;</span>+builder);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>StringBuilder已经覆盖重写了Object当中的toString方法。</p>
</blockquote>
<h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo16StringBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 链式创建</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Hello&quot;</span>).append(<span class="string">&quot;World&quot;</span>).append(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        System.out.println(str); <span class="comment">// HelloWorldJava</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>String类</title>
    <url>/2020/03/30/java/String%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>java.lang.String</code>类代表字符串。Java程序中所有的字符串文字（例如<code>&quot;abc&quot;</code>）都可以被看作是实现此类的实例。</p>
<p>类<code>String</code>中包括用于检查各个字符串的方法，比如用于<strong>比较</strong>字符串，<strong>搜索</strong>字符串，<strong>提取</strong>子字符串以及创建具有翻译为<strong>大写或小写</strong>的所有字符的字符串的副本。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>字符串不变：<strong>字符串的值在创建后不能被更改</strong></li>
<li>因为String对象不是可变的，所以他们可以被共享</li>
<li>字符串效果上相当于char[]字符数组，但是底层原理是byte[]字节数组</li>
<li><code>&quot;abc&quot;</code>等效于<code>char[] data = &#123; &#39;a&#39; , &#39;b&#39; , &#39;c&#39; &#125;</code></li>
</ol>
<img data-src="/2020/03/30/java/String%E7%B1%BB/image-20200405165653102.png" class="" alt="image-20200405165653102">

<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ul>
<li><p>查看类</p>
<ul>
<li><code>java.lang.String</code>：此类不需要导入。</li>
</ul>
</li>
<li><p>查看构造方法</p>
<ul>
<li><code>public string()</code>：初始化新创建的String对象，以使其表示空字符序列。</li>
<li><code>public string(char[] value)</code>：通过当前参数中的字符数组来构造新的String.</li>
<li><code>public String(byte[] bytes)</code>：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的String.</li>
</ul>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">    System.out.println(str);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] chars = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">    System.out.println(str2); <span class="comment">// abc</span></span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] bytes = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);</span><br><span class="line">    System.out.println(str3); <span class="comment">// abc</span></span><br><span class="line">  	<span class="comment">// 直接创建</span></span><br><span class="line">  	<span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">  	System.out.println(str4); <span class="comment">// abc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>程序中直接写上的双引号字符串，就在字符串常量池中</p>
<ul>
<li>对于基本类型来说：&#x3D;&#x3D;是进行数值比较</li>
<li>对于引用类型来说：&#x3D;&#x3D;是进行【地址值的比较】</li>
</ul>
<img data-src="/2020/03/30/java/String%E7%B1%BB/01-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0.png" class="" alt="01-字符串的常量池">

<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><ul>
<li><code>public boolean equals(Object anObject)</code>：将此字符串与指定的对象比较。当且仅当该参数不为 null，并且是与此对象表示相同字符序列的 String 对象时，结果才为 true。 <ul>
<li>任何对象都能用<code>Object</code>进行接受</li>
<li><code>equals</code>方法具有对称性，也就是<code>a.equals(b)</code>和<code>b.equals(a)</code>效果一样</li>
<li>如果比较双方一个常量一个变量，推荐把常量字符串写在前面</li>
</ul>
</li>
<li><code>public boolean equalsIgnoreCase(String anotherString)</code>：将此 String 与另一个 String 比较，不考虑大小写。如果两个字符串的长度相同，并且其中的相应字符都相等（忽略大小写），则认为这两个字符串是相等的。 </li>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line">    <span class="comment">// equals</span></span><br><span class="line">    System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br><span class="line">    System.out.println(s1.equals(s3)); <span class="comment">// false</span></span><br><span class="line">    <span class="comment">// equalsIgnoreCase</span></span><br><span class="line">    System.out.println(s1.equalsIgnoreCase(s2)); <span class="comment">// true</span></span><br><span class="line">    System.out.println(s1.equalsIgnoreCase(s3)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Object是”对象”的意思，也是一种引用类型。作为参数类型，表示任意对象都可以传递到方法中。</p>
</blockquote>
<h3 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h3><ul>
<li><p><code>public boolean isEmpty()</code>：返回此字符串的长度。长度等于字符串中 Unicode 代码单元的数量。 </p>
</li>
<li><p><code>public String concat(String str)</code>：将指定字符串连接到此字符串的结尾。 </p>
<ul>
<li>如果参数字符串的长度为 0，则返回此 String 对象。否则，创建一个新的 String 对象，用来表示由此 String 对象表示的字符序列和参数字符串表示的字符序列连接而成的字符序列。</li>
</ul>
</li>
<li><p><code>public char charAt(int index)</code>：返回指定索引处的 char 值。索引范围为从 0 到 length() - 1。序列的第一个 char 值位于索引 0 处，第二个位于索引 1 处，依此类推，这类似于数组索引。 </p>
</li>
<li><p><code>public int indexOf(int ch)</code>：返回指定字符在此字符串中第一次出现处的索引。</p>
</li>
<li><p><code>public String substring(int beginIndex)</code>：返回一个新的字符串，它是此字符串的一个子字符串。该子字符串从指定索引处的字符开始，直到此字符串末尾。</p>
</li>
<li><p><code>public String substring(int beginIndex,int endIndex)</code>：返回一个新字符串，它是此字符串的一个子字符串。该子字符串从指定的 <code>beginIndex </code>处开始，直到索引 <code>endIndex - 1</code> 处的字符。因此，该子字符串的长度为 <code>endIndex-beginIndex</code>。 </p>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// length</span></span><br><span class="line">    System.out.println(str.length()); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// concat</span></span><br><span class="line">    System.out.println(str.concat(<span class="string">&quot;---&gt;d&quot;</span>));  <span class="comment">// abc---&gt;d</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// charAt</span></span><br><span class="line">    System.out.println(str.charAt(<span class="number">0</span>)); <span class="comment">// a</span></span><br><span class="line">    System.out.println(str.charAt(str.length() - <span class="number">1</span>));<span class="comment">// c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// indexOf</span></span><br><span class="line">    System.out.println(str.indexOf(<span class="number">1</span>)); <span class="comment">// -1</span></span><br><span class="line">    System.out.println(str.indexOf(<span class="string">&quot;a&quot;</span>)); <span class="comment">// 0</span></span><br><span class="line">    System.out.println(str.indexOf(<span class="string">&quot;bcd&quot;</span>)); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// substring</span></span><br><span class="line">    System.out.println(str.substring(<span class="number">0</span>)); <span class="comment">// abc</span></span><br><span class="line">    System.out.println(str.substring(<span class="number">1</span>)); <span class="comment">// bc</span></span><br><span class="line">    System.out.println(str.substring(<span class="number">0</span>,str.length())); <span class="comment">// abc</span></span><br><span class="line">    System.out.println(str.substring(<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">// b</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转换功能的方法"><a href="#转换功能的方法" class="headerlink" title="转换功能的方法"></a>转换功能的方法</h3><ul>
<li><p><code>public char[] toCharArray()</code>：将此字符串转换为一个新的字符数组。 </p>
</li>
<li><p><code>public byte[] getBytes()</code>：使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 </p>
</li>
<li><p><code>public String replace(CharSequence target, CharSequence replacement)</code>：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。</p>
<ul>
<li>该替换从字符串的开头朝末尾执行，例如，用 “b” 替换字符串 “aaa” 中的 “aa” 将生成 “ba” 而不是 “ab”。</li>
</ul>
</li>
<li><p>CharSequence 是一个接口，意思就是说可以接受字符串类型</p>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="comment">// toCharArray</span></span><br><span class="line">    <span class="type">char</span>[] chars =str.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        System.out.print(chars[i]+<span class="string">&quot;\t&quot;</span>); <span class="comment">// a	b	c</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getBytes</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = str.getBytes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">        System.out.print(bytes[i]+<span class="string">&quot;\t&quot;</span>);<span class="comment">// 97	98	99</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// replace</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">replace</span> <span class="operator">=</span> str.replace(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">    System.out.println(str+<span class="string">&quot;---&gt;&quot;</span>+replace); <span class="comment">// abc---&gt;Abc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>CharSequence是一个接口，也是一种引用类型。作为参数类型，可以把String对象传递到方法中</p>
</blockquote>
<h3 id="分割功能的方法"><a href="#分割功能的方法" class="headerlink" title="分割功能的方法"></a>分割功能的方法</h3><ul>
<li><code>public String[] split(String regex,int limit)</code>：根据匹配给定的正则表达式来拆分此字符串。 <ul>
<li>split的参数是一个正则表达式</li>
<li>如果要按照英文句点<code>.</code>惊醒切分，必须写两个反斜杠<code>&quot;\\.&quot;</code></li>
</ul>
</li>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;a,b,c&quot;</span>;</span><br><span class="line">    String[] split = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; split.length; i++) &#123;</span><br><span class="line">        System.out.print(split[i] + <span class="string">&quot;\t&quot;</span>); <span class="comment">// a	b	c	</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>System类</title>
    <url>/2020/04/12/java/System%E7%B1%BB/</url>
    <content><![CDATA[<p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：</p>
<ul>
<li><code>public static long currentTimeMillis()</code>：返回以毫秒为单位的当前时间。</li>
<li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li>
</ul>
<h2 id="currentTimeMillis方法"><a href="#currentTimeMillis方法" class="headerlink" title="currentTimeMillis方法"></a>currentTimeMillis方法</h2><p>实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       	<span class="comment">//获取当前时间毫秒值</span></span><br><span class="line">        System.out.println(System.currentTimeMillis()); <span class="comment">// 1516090531144</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>验证for循环打印数字1-9999所需要使用的时间（毫秒）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;共耗时毫秒：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="arraycopy方法"><a href="#arraycopy方法" class="headerlink" title="arraycopy方法"></a>arraycopy方法</h2><ul>
<li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li>
</ul>
<p>数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：</p>
<table>
<thead>
<tr>
<th>参数序号</th>
<th>参数名称</th>
<th>参数类型</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>src</td>
<td>Object</td>
<td>源数组</td>
</tr>
<tr>
<td>2</td>
<td>srcPos</td>
<td>int</td>
<td>源数组索引起始位置</td>
</tr>
<tr>
<td>3</td>
<td>dest</td>
<td>Object</td>
<td>目标数组</td>
</tr>
<tr>
<td>4</td>
<td>destPos</td>
<td>int</td>
<td>目标数组索引起始位置</td>
</tr>
<tr>
<td>5</td>
<td>length</td>
<td>int</td>
<td>复制元素个数</td>
</tr>
</tbody></table>
<h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo11SystemArrayCopy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] src = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] dest = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        System.arraycopy( src, <span class="number">0</span>, dest, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">/*代码运行后：两个数组中的元素发生了变化</span></span><br><span class="line"><span class="comment">         src数组元素[1,2,3,4,5]</span></span><br><span class="line"><span class="comment">         dest数组元素[1,2,3,9,10]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread Local</title>
    <url>/2019/04/06/java/Thread%20Local/</url>
    <content><![CDATA[<blockquote>
<p>高并发处理 : 在当前进程取出对象，不会冲突<br>放入的东西<br>各个线程保存的东西是分开只与进程有关系<br>每个进程会处理自己的内容</p>
</blockquote>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLocal的是一个本地线程副本变量工具类。</p>
<p>主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。</p>
<p>原理大佬说的很清楚了》<a href="https://www.jianshu.com/p/98b68c97df9b">https://www.jianshu.com/p/98b68c97df9b</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">   private static final ThreadLocal&lt;SysUser&gt; userHolder = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   private static final ThreadLocal&lt;HttpServletRequest&gt; requestHolder = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   public static void add(SysUser sysUser)&#123;</span><br><span class="line">       userHolder.set(sysUser);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void add(HttpServletRequest request)&#123;</span><br><span class="line">       requestHolder.set(request);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static SysUser getCurrentUser()&#123;</span><br><span class="line">       return userHolder.get();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static HttpServletRequest getCurrentRequest()&#123;</span><br><span class="line">       return requestHolder.get();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void remove()&#123;</span><br><span class="line">       userHolder.remove();</span><br><span class="line">       requestHolder.remove();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>final关键字</title>
    <url>/2020/04/07/java/final%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>为了避免随意改写的情况，Java提供了<code>final</code>关键字，用于修饰<strong>不可变内容</strong></p>
<ul>
<li>final：不可以改变，可以用于修饰类、方法和变量<ul>
<li>类：被修饰的类，不能被继承</li>
<li>方法：被修饰的方法，不能被重写</li>
<li>变量：被修饰的变量，不能被重新赋值</li>
</ul>
</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul>
<li>修饰类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> class 类名&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修饰方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">final</span> 返回值类型 方法名(参数列表)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于类、方法来说，abstract和final关键字不能同时使用</p>
<ul>
<li><p>修饰变量</p>
<ul>
<li><p>局部变量：基本类型</p>
<ul>
<li><p>只能赋值一次，第二次赋值就会报错</p>
</li>
<li><pre><code class="java">final 基本类型 名称;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 局部变量：引用类型</span><br><span class="line"></span><br><span class="line">  - 不能修改引用对象的地址，但是可以修改对象内部的成员变量</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    final 类名 对象名 = new 类名();</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>成员变量</p>
<ul>
<li>因为成员变量具有默认值，所以使用final关键字之后必须手动赋值，不会再给默认值了</li>
<li>对于final的成员变量，只能初始化完成<ul>
<li>显示初始化</li>
<li>构造方法初始化</li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>被final修饰的常量名称，一般都有书写规范，所有字母都大写</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>static关键字</title>
    <url>/2020/03/31/java/static%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>关于<code>static</code>关键字的使用，它可以用来修饰的成员变量和成员方法，<strong>被修饰的成员是属于类的，而不是单单是属于某个对象的</strong>。也就是说，既然属于类，就可以不靠创建对象来调用了.</p>
<h2 id="定义和使用格式"><a href="#定义和使用格式" class="headerlink" title="定义和使用格式"></a>定义和使用格式</h2><h3 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h3><p>当<code>static</code>修饰成员变量时，该变量称为<strong>类变量</strong>。该类的每个对象都<strong>共享</strong>同一个类变量的值。任何对象都可以更改该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。</p>
<ul>
<li><strong>类变量</strong>：使用static关键字修饰的成员变量</li>
<li>格式：<ul>
<li><code>static 数据类型 变量名;</code></li>
</ul>
</li>
<li>实现：<ul>
<li><code>static int number</code></li>
</ul>
</li>
</ul>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>当<code>static</code>修饰成员方法时，该方法称为类方法。静态方法在声明中有<code>static</code>，建议使用类名来调用，而不需要创建类的对象。调用方式非常简单。</p>
<ul>
<li><p><strong>类方法</strong>：使用static关键字修饰的成员方法，习惯称为<strong>静态方法</strong>。</p>
</li>
<li><p>格式：</p>
</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">static</span> 返回值类型 方法名(参数列表)&#123;</span><br><span class="line">	<span class="comment">//执行语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>静态方法调用的注意事项</strong>：<ul>
<li>静态方法可以直接访问类变量和静态方法。</li>
<li><strong>静态方法不能直接访问普通成员变量或成员方法</strong>。反之，成员方法可以直接访问类变量或静态方法。</li>
<li>静态方法中，不能使用<strong>this</strong>关键字。</li>
</ul>
</li>
</ul>
<blockquote>
<p>静态方法只能访问静态成员</p>
</blockquote>
<h3 id="调用格式"><a href="#调用格式" class="headerlink" title="调用格式"></a>调用格式</h3><p>被<code>static</code>修饰的成员可以并且建议通过类名直接访问。虽然也可以通过对象名访问静态成员，原因即多个对象均属于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息。</p>
<ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问类变量</span></span><br><span class="line">类名.类变量名;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用静态方法</span></span><br><span class="line">类名.静态方法名(参数);</span><br></pre></td></tr></table></figure>

<ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Test.show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="静态原理图解"><a href="#静态原理图解" class="headerlink" title="静态原理图解"></a>静态原理图解</h2><p><code>static</code>修饰的内容：</p>
<ul>
<li>是随着类的加载而加载的，且只加载一次</li>
<li>存储于一块固定的内存区域（静态区），所以，可以直接被类名调用</li>
<li>它优先于对象存在，所以，可以被所有对象共享</li>
</ul>
<img data-src="/2020/03/31/java/static%E5%85%B3%E9%94%AE%E5%AD%97/03-%E9%9D%99%E6%80%81%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png" class="" alt="03-静态的内存图">

<h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><ul>
<li><p><strong>静态代码块</strong>：定义在成员位置，使用static修饰的代码块{}。</p>
<ul>
<li>位置：类中方法外。</li>
<li>执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。</li>
</ul>
</li>
<li><p>格式</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">    <span class="comment">//执行语句</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(i); <span class="comment">// 20</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/2020/04/09/java/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>内部类：将一个类A定义再另外一个类B里面，里面的那个类A就称为内部类，B则程为外部类</p>
<h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><ul>
<li>成员内部类：定义再类中方法外的类</li>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 外部类&#123;</span><br><span class="line"> 修饰符 class 内部类&#123;</span><br><span class="line">   </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>访问特点<ul>
<li>内部类可以直接访问外部类的成员，包括私有成员</li>
<li>外部类要访问内部类的成员，必须要简历内部类的对象</li>
<li>格式：<code>外部类名.内部类名 对象名 = new 外部类型().new 内部类型();</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>内部类依然是一个独立的类，再编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号</p>
</blockquote>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ul>
<li>局部内部类：只有当前所属的方法才能使用它，除了这个方法外面就不能用了</li>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 外部类名称&#123;</span><br><span class="line"> 修饰符 返回值类型 外部类方法名称(参数列表)&#123;</span><br><span class="line">   class 局部内部类名称&#123;</span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>访问<ul>
<li>在局部内部类中实现类的初始化</li>
</ul>
</li>
</ul>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><ul>
<li>匿名内部类：是内部类的简化写法。它的本质是一个<code>带具体实现的</code> <code>父类或者父接口的</code> <code>匿名的</code>子类对象。</li>
<li>前提<ul>
<li>匿名内部类必须继承一个父类或者实现一个父接口</li>
</ul>
</li>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类名或者接口名()&#123;</span><br><span class="line">  <span class="comment">// 方法重写</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 执行语句</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>格式解析<ul>
<li>new代表创建对象的动作</li>
<li>接口名称就是匿名内部类需要实现那些接口</li>
<li>{…}这才是匿名内部类的内容</li>
</ul>
</li>
<li>注意<ul>
<li>匿名内部类，在创建对象的时候，只能使用唯一一次</li>
<li>如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类</li>
<li>匿名对象，在调用方法的时候，只能调用唯一一次</li>
<li>如果希望同一个对象，调用多次方法，那么必须给对象起个名字</li>
<li>匿名内部类是省略了实现类、子类名称，但是匿名对象是省略了对象名称<ul>
<li>匿名内部类和匿名对象不是一回事</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="类的特点"><a href="#类的特点" class="headerlink" title="类的特点"></a>类的特点</h2><ul>
<li>权限修饰符<ul>
<li>外部类：public、default</li>
<li>成员内部类：public、protected、default、private</li>
<li>局部内部类：上面都不能写</li>
</ul>
</li>
<li>局部内部类：如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】<ul>
<li>从Java 8+开始，只要局部变量事实不变，那么final关键字可以忽略</li>
<li>原因<ul>
<li>new出来的对象在堆内存当中</li>
<li>局部变量是跟着方法走的，在栈内存当中</li>
<li>方法运行结束之后，立刻出栈，局部变量就会立刻消失</li>
<li>但是new出来的对象会在对当中持续存在，知道垃圾回收消失</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Outer&#123;</span><br><span class="line">  <span class="comment">// 外部类的成员变量</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">    <span class="comment">// 内部类的成员变量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">// 内部类方法的局部变量</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">      <span class="comment">// 局部变量，就近原则</span></span><br><span class="line">      System.out.print(num);</span><br><span class="line">      <span class="comment">// 内部类的成员变量</span></span><br><span class="line">      System.out.print(<span class="built_in">this</span>.num);</span><br><span class="line">      <span class="comment">// 外部类的成员变量</span></span><br><span class="line">      System.out.print(Outer.<span class="built_in">this</span>.num);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>判断语句</title>
    <url>/2020/03/11/java/%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><ul>
<li><strong>if语句的第一种格式</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)&#123;</span><br><span class="line"> 语句体; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JudgmentStatementIf</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span> (a == <span class="number">10</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;a等于10&quot;</span>); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>( a == <span class="number">20</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;a等于20&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 只显示了:a等于10</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="if的流程图"><a href="#if的流程图" class="headerlink" title="if的流程图"></a>if的流程图</h3><ul>
<li>首先判断关系表达式看其结果是true还是false</li>
<li>如果是rue就执行语句体</li>
<li>如果是false就不执行语句体</li>
</ul>
<img data-src="/2020/03/11/java/%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5/02-%E5%8D%95if%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="" alt="02-单if语句的流程图">

<h2 id="if…else"><a href="#if…else" class="headerlink" title="if…else"></a>if…else</h2><ul>
<li><strong>if语句第二种格式</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)&#123;</span><br><span class="line">	语句体<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JudgmentStatementIf</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span> (a == <span class="number">10</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;a等于10&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;a不等于10&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="if…else的流程图"><a href="#if…else的流程图" class="headerlink" title="if…else的流程图"></a>if…else的流程图</h3><ul>
<li>首先判断关系表达式看其结果的true还是false</li>
<li>如果true就执行语句体1</li>
<li>如果false就执行语句体2</li>
</ul>
<img data-src="/2020/03/11/java/%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5/03-%E6%A0%87%E5%87%86if-else%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="" alt="03-标准if-else语句的流程图">

<h2 id="if…else-if…else"><a href="#if…else-if…else" class="headerlink" title="if…else if…else"></a>if…else if…else</h2><ul>
<li><strong>if语句第三种格式</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (判断条件<span class="number">1</span>)&#123;</span><br><span class="line">	执行语句<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(判断条件<span class="number">2</span>)&#123;</span><br><span class="line">	执行语句<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(判断条件n)&#123;</span><br><span class="line">	执行语句n;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">  执行语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JudgmentStatementIf</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">		<span class="keyword">if</span> (a == <span class="number">10</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;a等于10&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">20</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;a等于20&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;a不等于10也不等于20&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="if…else-if…else的流程图"><a href="#if…else-if…else的流程图" class="headerlink" title="if…else if…else的流程图"></a>if…else if…else的流程图</h3><ul>
<li>首先判断关系表达式1看其结果是true还是false</li>
<li>如果是true就执行语句体1</li>
<li>如果是false就继续判断关系表达式2看其结果是true还是false</li>
<li>如果是true就执行语句体2</li>
<li>如果是false就继续判断关系表达式看其结果是true还是false</li>
<li>…</li>
<li>如果没有任何关系表达式为true，就执行语句体n+1</li>
</ul>
<img data-src="/2020/03/11/java/%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5/04-%E6%89%A9%E5%B1%95if-else%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="" alt="04-扩展if-else语句的流程图">

<h2 id="if语句和三元运算符的互换"><a href="#if语句和三元运算符的互换" class="headerlink" title="if语句和三元运算符的互换"></a>if语句和三元运算符的互换</h2><p>在某些简单的应用中,if语句是可以和三元运算符互换使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">  <span class="comment">// 比较两个值的大小</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">  <span class="comment">// 保存a和b的较大值</span></span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">    c = a;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    c = b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//三元运算符</span></span><br><span class="line">  c = a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>包装类</title>
    <url>/2020/04/14/java/%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>对应的包装类（位于java.lang包中）</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td><strong>Integer</strong></td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td><strong>Character</strong></td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<img data-src="/2020/04/14/java/%E5%8C%85%E8%A3%85%E7%B1%BB/02_%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5.bmp" class="" alt="02_包装类的概念">

<h2 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h2><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p>
<ul>
<li><p><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</p>
</li>
<li><p><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</p>
</li>
</ul>
<p>用Integer与 int为例：（看懂代码即可）</p>
<p>基本数值—-&gt;包装对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">4</span>);<span class="comment">//使用构造函数函数</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">iii</span> <span class="operator">=</span> Integer.valueOf(<span class="number">4</span>);<span class="comment">//使用包装类中的valueOf方法</span></span><br></pre></td></tr></table></figure>

<p>包装对象—-&gt;基本数值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i.intValue();</span><br></pre></td></tr></table></figure>

<h2 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h2><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p>
<p>自动拆箱：Integer时包装类，无法直接参与运算，可以自动转换为基本类型的数据，在计算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>;<span class="comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span></span><br><span class="line">i = i + <span class="number">5</span>;<span class="comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span></span><br><span class="line"><span class="comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span></span><br></pre></td></tr></table></figure>

<h2 id="基本类型与字符串之间的转换"><a href="#基本类型与字符串之间的转换" class="headerlink" title="基本类型与字符串之间的转换"></a>基本类型与字符串之间的转换</h2><h3 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h3><p>   基本类型转换String总共有三种方式，这里只讲最简单的一种方式： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基本类型直接与””相连接即可；如：34+&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>String转换成对应的基本类型 </p>
<p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p>
<ul>
<li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li>
<li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li>
<li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li>
<li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li>
<li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li>
<li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li>
<li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li>
</ul>
<p>代码使用（仅以Integer类的静态方法parseXxx为例）如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo18WrapperParse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>变量和数据类型</title>
    <url>/2020/03/05/java/%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h3><p>Java的数据类型分为两大类：</p>
<ul>
<li><strong>基本数据类型</strong>：包括整数、浮点数、字符、布尔。</li>
<li><strong>引用数据类型</strong>：包括类、数组、接口、字符串…</li>
</ul>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>四类八种基本数据类型：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>关键字</th>
<th>内存占用</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>字节型</td>
<td>byte</td>
<td>1个字节</td>
<td>-2^7~2^7-1</td>
</tr>
<tr>
<td>短整型</td>
<td>short</td>
<td>2个字节</td>
<td>-2^15~2^15-1</td>
</tr>
<tr>
<td>整型</td>
<td>int（默认）</td>
<td>4个字节</td>
<td>-2^31~2^31-1</td>
</tr>
<tr>
<td>长整型</td>
<td>long</td>
<td>8个字节</td>
<td>-2^63~2^63-1</td>
</tr>
<tr>
<td>单精度浮点数</td>
<td>float</td>
<td>4个字节</td>
<td>-2^31~2^31-1</td>
</tr>
<tr>
<td>双精度浮点数</td>
<td>double（默认）</td>
<td>8个字节</td>
<td>4.9E-324~1.7977E+308</td>
</tr>
<tr>
<td>字符型</td>
<td>char</td>
<td>2个字节</td>
<td>0-65535</td>
</tr>
<tr>
<td>布尔型</td>
<td>boolean</td>
<td>1个字节</td>
<td>true，false</td>
</tr>
</tbody></table>
<p>&#x3D;&#x3D;Java中的默认类型：整数类型是int、浮点类型是double&#x3D;&#x3D;</p>
<p>注意事项：</p>
<ul>
<li>字符串不是基本类型，而引用类型</li>
<li>浮点型可能只是一个近似值，并非精确的值</li>
<li>数据范围与字节数不一定相关，例如float数据范围比long更加广泛，但是float是4字节，long是8字节</li>
<li>浮点数当中默认类型是double。如果一定要使用float类型，需要加上一个后缀F</li>
<li>整数默认为int类型，如果一定要使用long类型，需要加上一个后缀L</li>
<li>推荐使用大写字母后缀</li>
</ul>
<h2 id="变量概述"><a href="#变量概述" class="headerlink" title="变量概述"></a>变量概述</h2><ul>
<li>变量：常量是固定不变的数据，那么在程序中可以变化的量称为变量。</li>
<li>数学中，可以使用字母代替数字运算，例如x&#x3D;1+5或者6&#x3D;x+5</li>
<li>程序中，可以使用字母保存数字的方式进行运算，提高计算能力，可以解决更多的问题。比如x保存5，x也可以保存6，这样x保存的数据是可以改变的，也就是我们所讲解的变量。</li>
</ul>
<p>&#x3D;&#x3D;Java中要求一个变量每次只能保存一个数据，必须要明确保存的数据类型。&#x3D;&#x3D;</p>
<h2 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h2><p>变量定义的格式包括三个要素：<strong>数据类型</strong>、<strong>变量名</strong>、<strong>数据值</strong>。</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p><code>数据类型 变量名; 变量名=数据值;</code></p>
<p><code>数据类型 变量名=数据值;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Variable</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">// 创建一个变量</span></span><br><span class="line">		<span class="type">int</span> num1;</span><br><span class="line">		num1 = <span class="number">5</span>;</span><br><span class="line">		<span class="comment">//或者</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当打印输出变量名称的时候,显示出来的是变量的内容</span></span><br><span class="line">		System.out.println(num1); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 改变变量当中本来的数字,变成新的数字</span></span><br><span class="line">		num1 = <span class="number">10</span>;</span><br><span class="line">		System.out.println(num1); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">byte</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="number">30</span>; <span class="comment">// 注意:右侧数值的范围不能超过左侧数据类型的取值范围</span></span><br><span class="line">		System.out.println(num3); <span class="comment">//30</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//byte num4 = 400; //右侧超出了byte数据范围,报错!</span></span><br><span class="line"></span><br><span class="line">		<span class="type">short</span> <span class="variable">num5</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">		System.out.println(num5); <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line">		<span class="type">long</span> <span class="variable">num6</span> <span class="operator">=</span> <span class="number">3000000000L</span>;</span><br><span class="line">		System.out.println(num6); <span class="comment">// 3000000000</span></span><br><span class="line"></span><br><span class="line">		<span class="type">float</span> <span class="variable">num7</span> <span class="operator">=</span> <span class="number">2.5F</span>;</span><br><span class="line">		System.out.println(num7); <span class="comment">// 2.5</span></span><br><span class="line"></span><br><span class="line">		<span class="type">double</span> <span class="variable">num8</span> <span class="operator">=</span> <span class="number">2.5</span>;</span><br><span class="line">		System.out.println(num8); <span class="comment">// 2.5</span></span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">		System.out.println(ch); <span class="comment">// A</span></span><br><span class="line">		ch = <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">		System.out.println(ch); <span class="comment">// 中</span></span><br><span class="line"></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">flag1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">		System.out.println(flag1); <span class="comment">// true</span></span><br><span class="line">		flag1 = <span class="literal">false</span>;</span><br><span class="line">		System.out.println(flag1); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//将一个变量的数据内容,赋值交给另一个变量</span></span><br><span class="line">		<span class="comment">//右侧的变量名称flag1已经存在,里面装的是false布尔值</span></span><br><span class="line">		<span class="comment">//将右侧变量里面的false,向左交给flag2变量进行存储</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">flag2</span> <span class="operator">=</span> flag1;</span><br><span class="line">		System.out.println(flag2); <span class="comment">// false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><p>在同一个大括号范围内，创建多个变量，那么变量之间的名称不可以重复</p>
</li>
<li><p>对于float和long类型来说，字母后缀F和L不要丢掉</p>
</li>
<li><p>如右侧数值的范围不能超过左侧数据类型的取值范围</p>
</li>
<li><p>没有进行赋值的变量，不能直接使用</p>
</li>
<li><p>变量的使用不能超过作用域的范围【作用域：从定义变量的一行开始，一直到直接所属的大括号结束为止】</p>
</li>
<li><p>可以通过一个语句来创建多个变量，但一般不推荐使用</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>多态</title>
    <url>/2020/04/06/java/%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p>多态：一个对象拥有多种形态</p>
<p>面向对象三大特征：封装性，继承性，多态性</p>
<p>extends继承或者implements实现，是多态的前提</p>
<img data-src="/2020/04/06/java/%E5%A4%9A%E6%80%81/03-%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E8%BF%B0.png" class="" alt="03-多态的概述">

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>定义<ul>
<li>是指同一行为，具有多个不同表现形式</li>
</ul>
</li>
<li>前提<ul>
<li>继承或者实现</li>
<li>方法的重写【不重写，无意义】</li>
<li>父类引用指向子类对象【格式体现】</li>
</ul>
</li>
</ul>
<h2 id="多态的体现"><a href="#多态的体现" class="headerlink" title="多态的体现"></a>多态的体现</h2><ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类类型 对象名 = <span class="keyword">new</span> 子类对象();</span><br><span class="line">或者</span><br><span class="line">接口名称 对象名 = <span class="keyword">new</span> 实现类名称();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型。 </p>
</blockquote>
<ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Fu</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">f.method();</span><br></pre></td></tr></table></figure>

<p><strong>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。</strong></p>
<ul>
<li>注意<ul>
<li>成员变量<ul>
<li>直接通过对象名称访问成员变量，看等号左边是谁，优先用谁，没有则向上找</li>
<li>间接通过成员方法访问成员变量，看该方法属于谁，优先用谁，没有则向上找<ul>
<li>子类没有覆盖重写，就是父类的成员变量</li>
<li>子类如果覆盖重写，就是子类的成员变量</li>
</ul>
</li>
<li>编译看左边，运行看左边</li>
</ul>
</li>
<li>成员方法<ul>
<li>看new的是谁，就优先用谁，没有则向上找</li>
<li>编译看左边，运行看右边</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h2><p>好处：无论右边new的时候换成哪个子类对象，等号左边调用方法都不会变化</p>
<img data-src="/2020/04/06/java/%E5%A4%9A%E6%80%81/04-%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%80%81%E7%9A%84%E5%A5%BD%E5%A4%84.png" class="" alt="04-使用多态的好处">

<h2 id="引用类型转换"><a href="#引用类型转换" class="headerlink" title="引用类型转换"></a>引用类型转换</h2><p>多态的转型分为向上转型与向下转型两种：</p>
<h3 id="向上转型（就是多态写法）"><a href="#向上转型（就是多态写法）" class="headerlink" title="向上转型（就是多态写法）"></a>向上转型（就是多态写法）</h3><ul>
<li><strong>向上转型</strong>：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的</li>
</ul>
<p>当父类引用指向一个子类对象时，便是向上转型</p>
<ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类类型 对象名 = <span class="keyword">new</span> 子类对象();</span><br></pre></td></tr></table></figure>

<ul>
<li>注意<ul>
<li>向上转型一定是安全的，从小范围转向了大范围，从小范围到大范围</li>
<li>对象一旦向上转型为父类，那么就无法调用子类原本特有的内容</li>
</ul>
</li>
</ul>
<h3 id="向下转型（还原）"><a href="#向下转型（还原）" class="headerlink" title="向下转型（还原）"></a>向下转型（还原）</h3><ul>
<li>向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的</li>
</ul>
<p>一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型</p>
<ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">子类类型 对象名 = (子类类型) 父类变量名;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意<ul>
<li>必须保证对象本来创建的时候，就是子类对象，才能向下转型成子类对象</li>
<li>如果对象创建的时候本来就不是子类对象，现在非要向下转型为子类对象，就会报错(ClasCastException)</li>
</ul>
</li>
</ul>
<img data-src="/2020/04/06/java/%E5%A4%9A%E6%80%81/05-%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%8A%E4%B8%8B%E8%BD%AC%E5%9E%8B.png" class="" alt="05-对象的上下转型">

<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>为了避免ClassCastException的发生，Java提供了<code>instanceof</code>关键字，给应用比那辆做类型的校验</p>
<ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">变量名 <span class="keyword">instanceof</span> 数据类型</span><br><span class="line">如果变量属于输入该数据类型，返回<span class="literal">true</span></span><br><span class="line">如果变量不属于该数据类型，返回<span class="literal">false</span></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2020/04/21/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？</p>
<p>要解决上述问题,咱们得使用多进程或者多线程来解决.</p>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><ul>
<li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</li>
<li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</li>
</ul>
<img data-src="/2020/04/21/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91.bmp" class="">

<p>在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</p>
<p>而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。</p>
<blockquote>
<p>注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。</p>
</blockquote>
<h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><ul>
<li><p><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p>
</li>
<li><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 </p>
<p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程</p>
</li>
</ul>
<p>我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程：</p>
<p><strong>进程</strong></p>
<img data-src="/2020/04/21/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5.png" class="">

<p><strong>线程</strong></p>
<img data-src="/2020/04/21/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5.png" class="">

<p><strong>线程调度:</strong></p>
<ul>
<li><p>分时调度</p>
<p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p>
</li>
<li><p>抢占式调度</p>
<p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p>
<ul>
<li>设置线程的优先级</li>
</ul>
<img data-src="/2020/04/21/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7.bmp" class="" alt="设置线程优先级">

<ul>
<li><p>抢占式调度详解</p>
<p>大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。</p>
<p>实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。<br>其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。</p>
<img data-src="/2020/04/21/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6.bmp" class="" alt="抢占式调度"></li>
</ul>
</li>
</ul>
<h2 id="创建线程类"><a href="#创建线程类" class="headerlink" title="创建线程类"></a>创建线程类</h2><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p>
<ol>
<li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象</li>
<li>调用线程对象的start()方法来启动该线程</li>
</ol>
<p>代码如下：</p>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建自定义线程对象</span></span><br><span class="line">		<span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;新的线程！&quot;</span>);</span><br><span class="line">		<span class="comment">//开启新线程</span></span><br><span class="line">		mt.start();</span><br><span class="line">		<span class="comment">//在主方法中执行for循环</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;main线程！&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">	<span class="comment">//定义指定线程名称的构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="comment">//调用父类的String参数的构造方法，指定线程的名称</span></span><br><span class="line">		<span class="built_in">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 重写run方法，完成该线程执行的逻辑</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(getName()+<span class="string">&quot;：正在执行！&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>封装</title>
    <url>/2020/03/25/java/%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<h1 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h1><h2 id="什么是Scanner类"><a href="#什么是Scanner类" class="headerlink" title="什么是Scanner类"></a>什么是Scanner类</h2><p>一个可以解析基本类型和字符串的简单文本扫描器。</p>
<p>例如：读取用户键盘输入的一个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> scanner.nextInt();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>System.in系统输入指的是通过键盘录入数据</p>
</blockquote>
<h2 id="引用类型一般使用步骤"><a href="#引用类型一般使用步骤" class="headerlink" title="引用类型一般使用步骤"></a>引用类型一般使用步骤</h2><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><p>使用<code>import</code>关键字导包，在类的所有代码之前导包，引入要使用的类型，java.lang包下的所有类无需导入</p>
<ul>
<li>格式：</li>
</ul>
<p><code>import 包名.类名</code></p>
<ul>
<li>实现：</li>
</ul>
<p><code>import java.util.Scanner</code></p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>使用该类的构造方法，创建一个该类的对象</p>
<ul>
<li>格式：</li>
</ul>
<p><code>数据类型 变量名 = new 数据类型(参数列表)</code></p>
<ul>
<li>实现：</li>
</ul>
<p><code>Scanner scanner = new Scanner(System.in);</code></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>调用该类的成员方法，完成指定功能</p>
<ul>
<li>格式：</li>
</ul>
<p><code>变量名.方法名();</code></p>
<ul>
<li>实现：</li>
</ul>
<p><code>int i = scanner.nextInt();</code></p>
<h2 id="Scanner使用步骤"><a href="#Scanner使用步骤" class="headerlink" title="Scanner使用步骤"></a>Scanner使用步骤</h2><ul>
<li>查看类<ul>
<li><code>java.util.Scanner</code>：该类需要import导入后使用</li>
</ul>
</li>
<li>查看构造方法<ul>
<li><code>public Scanner(InputStream source)</code>：构造一个新的<code>Scanner</code>，它生成的值从指定的输入流扫描</li>
</ul>
</li>
<li>查看成员方法<ul>
<li><code>public int nextInt()</code>：将输入信息的下一个标记扫描为一个<code>int</code>值</li>
</ul>
</li>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。虽然是创建对象的简化写法，但是应用场景非常有限。</p>
<ul>
<li>匿名对象：没有变量名的对象</li>
<li>格式：<ul>
<li><code>new 类名(参数列表);</code></li>
</ul>
</li>
<li>实现：<ul>
<li><code>new Scanner(System.in);</code></li>
</ul>
</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>创建匿名对象直接调用方法，没有变量名</p>
</li>
<li><p><code>new Scanner(System.in).nextInt();</code></p>
</li>
<li><p>但是一旦调用两次方法，就是创建了两个对象，造成浪费</p>
<ul>
<li><pre><code class="java">new Scanner(System.in).nextInt();
new Scanner(System.in).nextInt();
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 匿名对象可以作为方法的参数和返回值</span><br><span class="line"></span><br><span class="line">  - 作为参数</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  public class Test &#123;</span><br><span class="line">      public static void main(String[] args)&#123;</span><br><span class="line">        input(new Scanner(System.in));</span><br><span class="line">  </span><br><span class="line">      &#125;</span><br><span class="line">      public static void input(Scanner scanner)&#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

- 作为返回值
</code></pre>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> input();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Scanner <span class="title function_">input</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>体现：</p>
<ol>
<li>方法就是一种封装</li>
<li>关键字<code>private</code>也是一种封装</li>
</ol>
<h2 id="封装的概述"><a href="#封装的概述" class="headerlink" title="封装的概述"></a>封装的概述</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。</p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>将<strong>属性隐藏</strong>起来，若需要访问某个属性，<strong>提供公共方法</strong>对其访问。</p>
<h2 id="封装的步骤"><a href="#封装的步骤" class="headerlink" title="封装的步骤"></a>封装的步骤</h2><ul>
<li>使用<code>private</code>关键字来修饰成员变量。</li>
<li>对需要访问的成员变量，提供对应的一对<code>getxxx方法、setxxx方法</code>。</li>
</ul>
<h2 id="private关键字"><a href="#private关键字" class="headerlink" title="private关键字"></a>private关键字</h2><h3 id="private的含义"><a href="#private的含义" class="headerlink" title="private的含义"></a>private的含义</h3><ul>
<li><code>private</code>是一个权限修饰符，代表最小权限。</li>
<li>可以修饰成员变量和成员方法。</li>
<li>被<code>private</code>修饰后的成员变量和成员方法，只在本类中才能访问。</li>
</ul>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p><code>private 数据类型 变量名;</code></p>
<ul>
<li>实现</li>
</ul>
<p>使用<code>private</code>修饰成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提供get&#x2F;set方法，访问成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>因为<code>set方法</code>的成员变量赋值会失败（<strong>当方法的局部变量和类的成员变量重名的时候，根据就近原则，优先使用局部变量</strong>），相当于set方法没有用，但是又要满足见名知意的规定</p>
<p>Java就提供了访问当前对象的引用的关键字<code>this</code></p>
<h3 id="this的含义"><a href="#this的含义" class="headerlink" title="this的含义"></a>this的含义</h3><p>this代表所在类的当前对象的引用（地址值），即对象自己的引用。</p>
<blockquote>
<p>记住：方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。</p>
</blockquote>
<h3 id="this的使用"><a href="#this的使用" class="headerlink" title="this的使用"></a>this的使用</h3><ul>
<li>格式</li>
</ul>
<p><code>this.成员变量</code></p>
<ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。</p>
<p>无论你与否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个无参数构造方法，一旦自己定义了构造方法，lava自动提供的默认无参数构造方法就会失效</p>
<ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 构造方法名(参数列表)&#123;</span><br><span class="line"> <span class="comment">//方法体 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法的写法上，方法名与它所在的类名相同。它没有返回值，所以不需要返回值类型，甚至不需要void，使用构造方法后，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">		<span class="comment">//无参构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//有参构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>构造方法的名称必须和所在的类名名称完全一样，就连大小写也要一样</li>
<li>构造方法不要写返回值类型，连void都不要写</li>
<li>构造方法不能return一个具体的返回值</li>
<li>如果你不提供构造方法，系统会给出无参数构造方法</li>
<li>如果你提供了构造方法，系统将不再提供无参数构造方法</li>
<li>构造方法是可以重载的，既可以定义参数，也可以不定义参数</li>
</ul>
<h2 id="JavaBean-标准代码"><a href="#JavaBean-标准代码" class="headerlink" title="JavaBean(标准代码)"></a>JavaBean(标准代码)</h2><p><code>JavaBean</code>是Java语言编写类的一种标准规范。符合J<code>avaBean</code>的类，要求类必须是具体的和公共的，并且具有<code>无参数的构造方法</code>，提供用来操作成员变量的<code>set</code>和<code>get</code>方法。</p>
<ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;</span><br><span class="line">  <span class="comment">//成员变量</span></span><br><span class="line">  <span class="comment">//构造方法</span></span><br><span class="line">  <span class="comment">//无参构造方法【必须】</span></span><br><span class="line">  <span class="comment">//有参构造方法【建议】</span></span><br><span class="line">  <span class="comment">//成员方法</span></span><br><span class="line">  <span class="comment">//get</span></span><br><span class="line">  <span class="comment">//set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reading</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;正在读书&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get set</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>常量</title>
    <url>/2020/03/04/java/%E5%B8%B8%E9%87%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>常量：是指在Java程序中固定不变的数据</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>数据举例</th>
</tr>
</thead>
<tbody><tr>
<td>整数常量</td>
<td>所有的整数</td>
<td>0，1，128，-128</td>
</tr>
<tr>
<td>浮点数常量</td>
<td>所有的小数</td>
<td>0.0，-0.1，2.55</td>
</tr>
<tr>
<td>字符常量</td>
<td>单引号引起来，只能写一个字符，必须有内容</td>
<td>‘a’，’ ‘，’好’</td>
</tr>
<tr>
<td>字符串常量</td>
<td>双引号引起来，可以写多个字符，也可以不写</td>
<td>“A”，”Hello”，””</td>
</tr>
<tr>
<td>布尔常量</td>
<td>只有两个值</td>
<td>true，false</td>
</tr>
<tr>
<td>空常量</td>
<td>只有一个值</td>
<td>null</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constant</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">//整数常量</span></span><br><span class="line">		System.out.println(<span class="number">123</span>);</span><br><span class="line">		System.out.println(-<span class="number">123</span>);</span><br><span class="line">		<span class="comment">//浮点数常量</span></span><br><span class="line">		System.out.println(<span class="number">0.123</span>);</span><br><span class="line">		System.out.println(-<span class="number">0.123</span>);</span><br><span class="line">		<span class="comment">//字符常量</span></span><br><span class="line">		System.out.println(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">		System.out.println(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">		<span class="comment">//System.out.println(&#x27;&#x27;); //两个单引号中间必须有且仅有一个字符</span></span><br><span class="line">		<span class="comment">//System.out.println(&#x27;AB&#x27;); //两个单引号中间必须有且仅有一个字符</span></span><br><span class="line">		<span class="comment">//布尔常量</span></span><br><span class="line">		System.out.println(<span class="literal">true</span>);</span><br><span class="line">		System.out.println(<span class="literal">false</span>);</span><br><span class="line">		<span class="comment">//字符串常量</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Hello Java&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;&quot;</span>); <span class="comment">//字符串两个双引号中间的内容为空</span></span><br><span class="line">		<span class="comment">//空常量</span></span><br><span class="line">		<span class="comment">//System.out.println(null);//空常量不能直接用来打印输出</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>开发前言</title>
    <url>/2020/03/01/java/%E5%BC%80%E5%8F%91%E5%89%8D%E8%A8%80/</url>
    <content><![CDATA[<h2 id="Java语言概述"><a href="#Java语言概述" class="headerlink" title="Java语言概述"></a>Java语言概述</h2><h3 id="什么是Java语言"><a href="#什么是Java语言" class="headerlink" title="什么是Java语言"></a>什么是Java语言</h3><p>Java语言是美国<strong>Sun</strong>公司（Stanford University Network），在<strong>1995</strong>年推出的高级编程语言。所谓编程语言，是计算机的语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。</p>
<h3 id="Java语言发展历史"><a href="#Java语言发展历史" class="headerlink" title="Java语言发展历史"></a>Java语言发展历史</h3><ul>
<li>1995年Sun公司发布Java1.0版本</li>
<li>1997年发布Java 1.1版本</li>
<li>1998年发布Java 1.2版本</li>
<li>2000年发布Java 1.3版本</li>
<li>2002年发布Java 1.4版本</li>
<li>2004年发布Java 5版本</li>
<li>2006年发布Java 6版本</li>
<li>2009年Oracle甲骨文公司收购Sun公司，并于2011发布Java 7版本</li>
<li><strong>2014年发布Java 8版本</strong></li>
<li>2017年9月发布Java 9版本</li>
<li>2018年3月发布Java 10版本</li>
<li>…</li>
</ul>
<h3 id="Java语言能做什么"><a href="#Java语言能做什么" class="headerlink" title="Java语言能做什么"></a>Java语言能做什么</h3><p>Java语言主要应用在互联网程序的开发领域。常见的互联网应用比如<strong>天猫、京东、物流系统、网银系统</strong>等，以及服务器后台处理大数据的存储、查询、数据挖掘等也有很多应用。</p>
<h2 id="计算机基础知识"><a href="#计算机基础知识" class="headerlink" title="计算机基础知识"></a>计算机基础知识</h2><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>计算机中的数据不同于人们生活中的数据，人们生活采用十进制数，而计算机中全部采用二进制数表示，它只包含0、1两个数，逢二进一，1+1&#x3D;10，每一个0或者每一个1，叫做一个<strong>bit</strong>（比特，位）。</p>
<p>下面了解一下十进制和二进制数据之间的转换计算。</p>
<ul>
<li><strong>十进制数据转成二进制数据</strong>：使用除以2获取余数的方式</li>
</ul>
<img data-src="/2020/03/01/java/%E5%BC%80%E5%8F%91%E5%89%8D%E8%A8%80/image-20200330111401992.png" class="" alt="image-20200330111401992">

<ul>
<li><strong>二进制数据转成十进制数据</strong>：使 8421编码的方式</li>
</ul>
 <img data-src="/2020/03/01/java/%E5%BC%80%E5%8F%91%E5%89%8D%E8%A8%80/image-20200330112240805.png" class="" alt="image-20200330112240805">

<h3 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h3><p>字节是我们常见的计算机中最小存储单元。计算机存储任何的数据，都是以字节的形式存储，右键点击文件属性我们可以查看文件的字节大小。</p>
<p>bit（位）：一个数字0或者一个数字1，代表一位</p>
<p>字节（Byte）： 每逢8位是一个字节，这是数据存储的最小单位</p>
<p>8个bit（二进制位）0000-0000为1个字节，写成<strong>1 byte</strong>或者<strong>1 B</strong></p>
<ul>
<li>1 Byte &#x3D; 8 bit</li>
<li>1 KB &#x3D; 1024 Byte</li>
<li>1 MB &#x3D; 1024 KB</li>
<li>1 GB &#x3D; 1024 MB</li>
<li>1 TB &#x3D; 1024 GB</li>
</ul>
<h3 id="常用DOS命令"><a href="#常用DOS命令" class="headerlink" title="常用DOS命令"></a>常用DOS命令</h3><p>Java语言的初学者，学习一些DOS命令，会非常有帮助，DOS是一个早期的操作系统，现在已经Windows系统取代，对于我们开发人员，目前需要在DOS中完成一些事情，因此就需要掌握一些必要的命令。</p>
<p>微软在早年间推出了非图形界面的操作系统：<strong>MS-DOS</strong>(Microsoft Disk Operating System : 磁盘操作系统)，然后推出图形操作系统后，就把<strong>MS-DOS</strong>继承到了<strong>Windows</strong>系统中，当然<strong>Windows 7</strong>的诞生，微软也彻底抛弃它了，<strong>Windows</strong>中的**命令提示符(下面用CMD代替)**也慢慢替代了大部分的命令行操作</p>
<p>启动CMD：Win+R》输入cmd</p>
<img data-src="/2020/03/01/java/%E5%BC%80%E5%8F%91%E5%89%8D%E8%A8%80/image-20200330114552195.png" class="" alt="image-20200330114552195">

<table>
<thead>
<tr>
<th>切换盘符</th>
<th><code>盘符名称:</code></th>
</tr>
</thead>
<tbody><tr>
<td>进入文件夹</td>
<td><code>cd 文件夹名称</code></td>
</tr>
<tr>
<td>进入多级文件夹</td>
<td><code>cd 文件夹\文件夹</code></td>
</tr>
<tr>
<td>返回上一级</td>
<td><code>cd ..</code></td>
</tr>
<tr>
<td>返回根路径</td>
<td><code>cd \</code></td>
</tr>
<tr>
<td>查看当前内容</td>
<td><code>dir</code></td>
</tr>
<tr>
<td>创建目录</td>
<td><code>md 目录名（文件夹）</code></td>
</tr>
<tr>
<td>删除目录</td>
<td><code>rd 目录名（文件夹）</code></td>
</tr>
<tr>
<td>查看本机ip</td>
<td><code>ipconfig</code></td>
</tr>
<tr>
<td>复制文件</td>
<td><code>copy 路径\文件名 路径\文件名 （把一个文件拷贝到另一个地方）</code></td>
</tr>
<tr>
<td>移动文件</td>
<td><code>move 路径\文件名 路径\文件名 （把一个文件移动（就是剪切+复制）到另一个地方）</code></td>
</tr>
<tr>
<td>删除文件</td>
<td><code>del 文件名(这个是专门删除文件的，不能删除文件夹)</code></td>
</tr>
<tr>
<td>测试网络是否畅通</td>
<td><code>ping ip(主机名)</code></td>
</tr>
<tr>
<td>查看所有的dos命令</td>
<td><code>help</code></td>
</tr>
<tr>
<td>清屏</td>
<td><code>cls</code></td>
</tr>
<tr>
<td>推出</td>
<td><code>exit</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>异常</title>
    <url>/2020/04/20/java/%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="异常概念"><a href="#异常概念" class="headerlink" title="异常概念"></a>异常概念</h2><p>异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：</p>
<ul>
<li><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</li>
</ul>
<p>在Java等面向对象的编程语言中，<strong>异常本身是一个类</strong>，<strong>产生异常就是创建异常对象并抛出了一个异常对象</strong>。Java处理异常的方式是中断处理。</p>
<blockquote>
<p>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.</p>
</blockquote>
<h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><p>异常机制其实是帮助我们<strong>找到</strong>程序中的问题，异常的根类是<code>java.lang.Throwable</code>，其下有两个子类：<code>java.lang.Error</code>与<code>java.lang.Exception</code>，平常所说的异常指<code>java.lang.Exception</code>。</p>
<img data-src="/2020/04/20/java/%E5%BC%82%E5%B8%B8/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png" class="">

<p><strong>Throwable体系：</strong></p>
<ul>
<li><strong>Error</strong>:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。</li>
<li><strong>Exception</strong>:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。</li>
</ul>
<p><strong>Throwable中的常用方法：</strong></p>
<ul>
<li><p><code>public void printStackTrace()</code>:打印异常的详细信息。</p>
<p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p>
</li>
<li><p><code>public String getMessage()</code>:获取发生异常的原因。</p>
<p><em>提示给用户的时候,就提示错误原因。</em></p>
</li>
<li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p>
</li>
</ul>
<p><em><strong>出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。</strong></em></p>
<img data-src="/2020/04/20/java/%E5%BC%82%E5%B8%B8/%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%82%E5%B8%B8%E6%9F%A5%E7%9C%8B.bmp" class="">

<h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p>我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。</p>
<p><strong>异常(Exception)的分类</strong>:根据在编译时期还是运行时期去检查异常?</p>
<ul>
<li><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)</li>
<li><strong>运行时期异常</strong>:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)</li>
</ul>
<p>​    <img data-src="/2020/04/20/java/%E5%BC%82%E5%B8%B8/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB.png" class=""></p>
<h2 id="异常的产生过程解析"><a href="#异常的产生过程解析" class="headerlink" title="异常的产生过程解析"></a>异常的产生过程解析</h2><p>先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。</p>
<p> 工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTools</span> &#123;</span><br><span class="line">    <span class="comment">// 对给定的数组通过给定的角标获取元素。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getElement</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123; <span class="number">34</span>, <span class="number">12</span>, <span class="number">67</span> &#125;;</span><br><span class="line">        intnum = ArrayTools.getElement(arr, <span class="number">4</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;num=&quot;</span> + num);</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序执行过程图解：</p>
 



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>异常的处理</title>
    <url>/2020/04/21/java/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p>
<h2 id="抛出异常throw"><a href="#抛出异常throw" class="headerlink" title="抛出异常throw"></a>抛出异常throw</h2><p>在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。</p>
<p>在java中，提供了一个<strong>throw</strong>关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？</p>
<ol>
<li><p>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</p>
</li>
<li><p>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。</p>
<p>throw<strong>用在方法内</strong>，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p>
</li>
</ol>
<p><strong>使用格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">throw new 异常类名(参数);</span><br></pre></td></tr></table></figure>

<p> 例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;要访问的arr数组不存在&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(<span class="string">&quot;该索引在数组中不存在，已超出范围&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThrowDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个数组 </span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">52</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">//根据索引找对应的元素 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> getElement(arr, index);</span><br><span class="line"></span><br><span class="line">        System.out.println(element);</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 根据 索引找到数组中对应的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getElement</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> index)</span>&#123; </span><br><span class="line">       	<span class="comment">//判断  索引是否越界</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。</span></span><br><span class="line"><span class="comment">             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 </span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(<span class="string">&quot;哥们，角标越界了~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。</p>
<p>那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。</p>
</blockquote>
<h2 id="Objects非空判断"><a href="#Objects非空判断" class="headerlink" title="Objects非空判断"></a>Objects非空判断</h2><p>还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。</p>
<ul>
<li><code>public static &lt;T&gt; T requireNonNull(T obj)</code>:查看指定引用对象不是null。</li>
</ul>
<p>查看源码发现这里对为null的进行了抛出异常操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">requireNonNull</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">      	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="声明异常throws"><a href="#声明异常throws" class="headerlink" title="声明异常throws"></a>声明异常throws</h2><p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p>
<p>关键字<strong>throws</strong>运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).</p>
<p><strong>声明异常格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123;   &#125;	</span><br></pre></td></tr></table></figure>

<p>声明异常的代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThrowsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        read(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThrowsDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        read(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(String path)</span><span class="keyword">throws</span> FileNotFoundException, IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;b.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="捕获异常try…catch"><a href="#捕获异常try…catch" class="headerlink" title="捕获异常try…catch"></a>捕获异常try…catch</h2><p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p>
<ol>
<li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li>
<li>在方法中使用try-catch的语句块来处理异常。</li>
</ol>
<p><strong>try-catch</strong>的方式就是捕获异常。</p>
<ul>
<li><strong>捕获异常</strong>：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li>
</ul>
<p>捕获异常语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  e)&#123;</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>try：</strong>该代码块中编写可能产生异常的代码。</p>
<p><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p>
<blockquote>
<p>注意:try和catch都不能单独使用,必须连用。</p>
</blockquote>
<p>演示如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryCatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">// 当产生异常时，必须有处理方式。要么捕获，要么声明。</span></span><br><span class="line">            read(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;<span class="comment">// 括号中需要定义什么呢？</span></span><br><span class="line">          	<span class="comment">//try中抛出的是什么异常，在括号中就定义什么异常类型</span></span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我们 当前的这个方法中 有异常  有编译期异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何获取异常信息：</p>
<p>Throwable类中定义了一些查看方法:</p>
<ul>
<li><p><code>public String getMessage()</code>:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。</p>
</li>
<li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p>
</li>
<li><p><code>public void printStackTrace()</code>:打印异常的跟踪栈信息并输出到控制台。</p>
</li>
</ul>
<p>​            <em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p>
<h2 id="finally-代码块"><a href="#finally-代码块" class="headerlink" title="finally 代码块"></a>finally 代码块</h2><p><strong>finally</strong>：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p>
<p>什么时候的代码必须最终执行？</p>
<p>当我们在try语句块中打开了一些物理资源(磁盘文件&#x2F;网络连接&#x2F;数据库连接等),我们都得在使用完之后,最终关闭打开的资源。</p>
<p>finally的语法:</p>
<p> try…catch….finally:自身需要处理异常,最终还得关闭资源。</p>
<blockquote>
<p>注意:finally不能单独使用。</p>
</blockquote>
<p>比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。</p>
<p>finally代码参考如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryCatchDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            read(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">//抓取到的是编译期异常  抛出去的是运行期 </span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不管程序怎样，这里都将会被执行。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我们 当前的这个方法中 有异常  有编译期异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。</p>
</blockquote>
<img data-src="/2020/04/21/java/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86/%E6%AD%BB%E4%BA%86%E9%83%BD%E8%A6%81try.bmp" class="">

<h2 id="异常注意事项"><a href="#异常注意事项" class="headerlink" title="异常注意事项"></a>异常注意事项</h2><ul>
<li><p>多个异常使用捕获又该如何处理呢？</p>
<ol>
<li>多个异常分别处理。</li>
<li>多个异常一次捕获，多次处理。</li>
<li>多个异常一次捕获一次处理。</li>
</ol>
<p>一般我们是使用一次捕获多次处理方式，格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型A  e)&#123;  当<span class="keyword">try</span>中出现A类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型B  e)&#123;  当<span class="keyword">try</span>中出现B类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</p>
</blockquote>
</li>
<li><p>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</p>
</li>
<li><p>如果finally有return语句,永远返回finally中的结果,避免该情况. </p>
</li>
<li><p>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</p>
</li>
<li><p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>循环语句</title>
    <url>/2020/03/13/java/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="循环概述"><a href="#循环概述" class="headerlink" title="循环概述"></a>循环概述</h2><p>循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复执行这个循环体时，需要在合适的时候把循环判断条件修改为<strong>false</strong>，从而结束循环，否则循环将一直执行下去，形成死循环。</p>
<p>循环结构的基本组成部分，一般可以分成四部分：</p>
<ul>
<li>初始化语句：在循环开始最初执行，而且只做唯一一次</li>
<li>条件判断：如果成立，则循环继续，如不不成立，则循环推出</li>
<li>循环体：重复要做的事情内容，若干行语句</li>
<li>步进语句：每次循环之后都要进行的扫尾工作，每次循环结束之后都要执行一次</li>
</ul>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><ul>
<li>for循环语句格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式① ; 布尔表达式② ; 步进表达式④)&#123;</span><br><span class="line">  循环体③;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoopStatement</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span><span class="comment">/*初始化表达式*/</span>; i &lt; <span class="number">50</span><span class="comment">/*布尔表达式*/</span>; i++<span class="comment">/*步进表达式*/</span>) &#123;</span><br><span class="line">      <span class="comment">//循环体③</span></span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(i); <span class="comment">//50</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="for的流程图"><a href="#for的流程图" class="headerlink" title="for的流程图"></a>for的流程图</h4><ul>
<li>执行顺序：①②③④&gt;②③④&gt;②③④…直到②不满住为止</li>
<li>①负责完成循环变量初始化</li>
<li>②负责判断是否满足循环条件，不满足则跳出循环</li>
<li>③具体执行的语句</li>
<li>④循环后，循环条件所涉及变量的变化情况</li>
</ul>
<img data-src="/2020/03/13/java/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/05-for%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="" alt="05-for循环的流程图">

<h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>while循环有一个标准格式，还有一个扩展格式</p>
<ul>
<li>标准格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件判断)&#123;</span><br><span class="line">  循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>扩展格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化表达式①</span><br><span class="line"><span class="keyword">while</span>(条件判断②)&#123;</span><br><span class="line">  循环体③;</span><br><span class="line">  步进表达式④;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoopStatement</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 初始化表达式</span></span><br><span class="line">		<span class="keyword">while</span>(i &lt; <span class="number">50</span><span class="comment">/*条件判断*/</span>)&#123;</span><br><span class="line">			<span class="comment">//循环体③</span></span><br><span class="line">			i++; <span class="comment">// 步进表达式</span></span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(i); <span class="comment">//50</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="while的流程图"><a href="#while的流程图" class="headerlink" title="while的流程图"></a>while的流程图</h3><ul>
<li>执行顺序：①②③④&gt;②③④&gt;②③④…直到②不满住为止</li>
<li>①负责完成循环变量初始化</li>
<li>②负责判断是否满足循环条件，不满足则跳出循环</li>
<li>③具体执行的语句</li>
<li>④循环后，循环变量的变化情况</li>
</ul>
<img data-src="/2020/03/13/java/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/06-while%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="" alt="06-while循环的流程图">

<h2 id="do…while"><a href="#do…while" class="headerlink" title="do…while"></a>do…while</h2><p>do…while循环有一个标准格式，还有一个扩展格式</p>
<ul>
<li>标准格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  循环体;</span><br><span class="line">&#125; <span class="keyword">while</span> (条件判断);</span><br></pre></td></tr></table></figure>

<ul>
<li>扩展格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化表达式①</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  循环体③;</span><br><span class="line">  步进表达式④</span><br><span class="line">&#125; <span class="keyword">while</span> (布尔表达式②);</span><br></pre></td></tr></table></figure>

<ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoopStatement</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 初始化表达式</span></span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			<span class="comment">//循环体</span></span><br><span class="line">			i++; <span class="comment">// 步进表达式</span></span><br><span class="line">		&#125;<span class="keyword">while</span>(i &lt; <span class="number">50</span><span class="comment">/*布尔表达式*/</span>);</span><br><span class="line">		System.out.println(i); <span class="comment">//50</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="do…while的流程图"><a href="#do…while的流程图" class="headerlink" title="do…while的流程图"></a>do…while的流程图</h3><ul>
<li>执行顺序：①②③④&gt;②③④&gt;②③④…直到②不满住为止</li>
<li>①负责完成循环变量初始化</li>
<li>②负责判断是否满足循环条件，不满足则跳出循环</li>
<li>③具体执行的语句</li>
<li>④循环后，循环变量的变化情况</li>
</ul>
<img data-src="/2020/03/13/java/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/image-20200402161047519.png" class="" alt="image-20200402161047519">

<h2 id="循环语句的区别"><a href="#循环语句的区别" class="headerlink" title="循环语句的区别"></a>循环语句的区别</h2><ul>
<li><strong>for</strong>和<strong>while</strong>的小区别：<ul>
<li>控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消失，能够提高内存的使用效率</li>
<li>如果条件判断从来没有满足过，那么for循环和while循环将会执行0次，但是do…while循环会执行至少一次</li>
<li>在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while</li>
</ul>
</li>
</ul>
<h2 id="跳出语句"><a href="#跳出语句" class="headerlink" title="跳出语句"></a>跳出语句</h2><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>常用的两种：</p>
<ol>
<li>可以用在switch语句当中，一旦执行，整个switch语句立刻结束</li>
<li>还可以用在循环语句当中，一旦执行，整个循环语句立刻结束，打断循环</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoopStatement</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">4</span>)&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;				</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><ul>
<li>一旦执行，立刻跳过当次循环剩余内容，马上开始下次循环</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoopStatement</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">4</span>)&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;				</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环拓展"><a href="#循环拓展" class="headerlink" title="循环拓展"></a>循环拓展</h2><h3 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h3><ul>
<li>死循环：也就是循环中的条件永远为true，死循环的是永不结束的循环。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在后期的开发中，会出现使用死循环的场景，例如：我们需要读取用户输入的输入，但是用户输入多少数据我们不清楚，也只能使用死循环，当用户不想输入数据了，就可以结束循环了，如何去结束一个死循环呢，就需要使用到跳出语句了。</p>
<h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><p>所谓嵌套循环，是指一个循环的循环体是另一个循环。比如for循环里面还有一个for循环，就是嵌套循环。总共的循环次数&#x3D;外循环次数*内循环次数</p>
<ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式① ; 循环条件② ; 步进表达式⑦)&#123;</span><br><span class="line"> 	<span class="keyword">for</span>(初始化表达式③ ; 循环条件④ ; 步进表达式⑥)&#123;</span><br><span class="line">    执行语句⑤;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoopStatement</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;<span class="number">10</span>; j++) &#123;</span><br><span class="line">				System.out.println(i+<span class="string">&quot;------&gt;&quot;</span>+j);</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;				</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="嵌套循环执行流程"><a href="#嵌套循环执行流程" class="headerlink" title="嵌套循环执行流程"></a>嵌套循环执行流程</h4><ul>
<li>执行流程：①②③④⑤⑥&gt;④⑤⑥&gt;⑦②③④⑤⑥&gt;④⑤⑥</li>
<li>外循环一次，内循环多次</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象类</title>
    <url>/2020/04/04/java/%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是抽象类"><a href="#什么是抽象类" class="headerlink" title="什么是抽象类"></a>什么是抽象类</h3><img data-src="/2020/04/04/java/%E6%8A%BD%E8%B1%A1%E7%B1%BB/05-%E6%8A%BD%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5.png" class="" alt="05-抽象的概念">

<h3 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h3><p>父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。</p>
<p>那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。</p>
<p>我们把没有方法主体的方法称为<strong>抽象方法</strong>。Java语法规定，包含抽象方法的类就是<strong>抽象类</strong>。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li><strong>抽象方法</strong>：没有方法体的方法。</li>
<li><strong>抽象类</strong>：包含抽象方法的类。</li>
</ul>
<h2 id="abstract使用格式"><a href="#abstract使用格式" class="headerlink" title="abstract使用格式"></a>abstract使用格式</h2><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>使用<code>abstract</code>关键字修饰方法,该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体</p>
<ul>
<li>格式：</li>
</ul>
<p><code>修饰符 abstract 返回值类型 方法名(参数列表);</code></p>
<ul>
<li>实现</li>
</ul>
<p><code>public abstract void run();</code></p>
<ul>
<li>注意<ul>
<li>抽象方法所在的类，必须是抽象类才行</li>
</ul>
</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>如果一个类包含抽象方法，那么该类必须是抽象类。</p>
<ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> class 类名&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;abstract实现类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意<ul>
<li>抽象类里面是可以定义普通的成员方法</li>
</ul>
</li>
</ul>
<h3 id="抽象类和抽象方法的使用"><a href="#抽象类和抽象方法的使用" class="headerlink" title="抽象类和抽象方法的使用"></a>抽象类和抽象方法的使用</h3><p>继承抽象类的子类<strong>必须重写父类所有的抽象方法</strong></p>
<p>否则，该子类也必须声明为抽象类</p>
<p>最终，必须有子类实现该父类的抽象方法</p>
<p>否则，从最初的父类到最终的子类都不能创建对象，失去意义</p>
<ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        demo.run();</span><br><span class="line">        demo.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;abstract实现类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意<ul>
<li>不能直接创建new抽象类对象</li>
<li>必须用一个子类来继承抽象父类</li>
<li>子类必须覆盖重写抽象父类房中所有的抽象方法<ul>
<li>覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后不上方法体大括号</li>
</ul>
</li>
<li>创建子类对象进行使用</li>
</ul>
</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。<ul>
<li>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</li>
</ul>
</li>
<li>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。<ul>
<li>理解：子类的构造方法中，有默认的<code>super()</code>，需要访问父类构造方法。</li>
</ul>
</li>
<li>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。（设计模式：适配器模式）<ul>
<li>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</li>
</ul>
</li>
<li>抽象类的子类，必须重写抽象父类中<strong>所有的抽象方法</strong>，否则，编译无法通过而报错。除非该子类也是抽象类。<ul>
<li>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>接口</title>
    <url>/2020/04/05/java/%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<ul>
<li>接口就是一种<strong>公共的规范标准</strong></li>
<li>只要符合规范标准，就可以通用</li>
</ul>
<img data-src="/2020/04/05/java/%E6%8E%A5%E5%8F%A3/01-%E7%94%9F%E6%B4%BB%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%B8%BE%E4%BE%8B.png" class="" alt="01-生活中接口的举例">

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>接口，是Java语言中一种引用类型，是方法的集合</p>
<p>如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是<strong>封装了方法</strong></p>
<p>包含<strong>抽象方法</strong>（JDK 7及以前），<strong>默认方法和静态方法</strong>（JDK 8），<strong>私有方法</strong>（JDK9）</p>
<p>接口的定义，它与定义类方式相似，但是使用<code>interface</code>关键字</p>
<p>它也会被编译成class件，但一定要明确它并不是类，而是另外一种引用数据类型</p>
<blockquote>
<p>引用数据类型：数组，类，接口。</p>
</blockquote>
<p>接口的使用，它不能创建对象，但是可以被实现（<code>implements</code>，类似于被继承）</p>
<p>一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。</p>
<ul>
<li>接口就是多个类的公共规范</li>
<li>接口是一种引用数据类型，最重要的内容就是其中的：抽象方法</li>
</ul>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名称&#123;</span><br><span class="line">  <span class="comment">// 常量</span></span><br><span class="line">  <span class="comment">// 抽象方法</span></span><br><span class="line">  <span class="comment">// 默认方法</span></span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="含有抽象方法（JDK-7及以前）"><a href="#含有抽象方法（JDK-7及以前）" class="headerlink" title="含有抽象方法（JDK 7及以前）"></a>含有抽象方法（JDK 7及以前）</h3><ul>
<li>抽象方法：使用<code>abstract</code>关键字修饰，可以省略，没有方法体。该类方法提供子类实现使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接口当中的抽象方法，修饰符必须是两个固定的关键字：<code>public abstract</code></li>
<li>这两个关键字修饰符，可以选择性地省略</li>
</ul>
<h3 id="含有默认方法和静态方法（JDK-8）"><a href="#含有默认方法和静态方法（JDK-8）" class="headerlink" title="含有默认方法和静态方法（JDK 8）"></a>含有默认方法和静态方法（JDK 8）</h3><ul>
<li>默认方法：使用<code>default</code>修饰，不可省略，供子类调用或者子类重写。</li>
<li>静态方法：使用<code>static</code>修饰，供接口直接调用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 执行语句</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 执行语句</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="含有私有方法和私有静态方法（JDK-9）"><a href="#含有私有方法和私有静态方法（JDK-9）" class="headerlink" title="含有私有方法和私有静态方法（JDK 9）"></a>含有私有方法和私有静态方法（JDK 9）</h3><ul>
<li>私有方法：使用<code>private</code>修饰，供接口中的默认方法或者静态方法调用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 执行语句</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本的实现"><a href="#基本的实现" class="headerlink" title="基本的实现"></a>基本的实现</h2><p>类与接口的关系为实现关系，即<strong>类实现接口</strong>，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用<strong>implements</strong>关键字。<br>非抽象子类实现接口：</p>
<ol>
<li>必须重写接口中所有抽象方法。</li>
<li>继承了接口的默认方法，即可以直接调用，也可以重写。</li>
</ol>
<ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 类名 implements 接口类&#123;</span><br><span class="line">  <span class="comment">// 重写接口中抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象方法的使用"><a href="#抽象方法的使用" class="headerlink" title="抽象方法的使用"></a>抽象方法的使用</h3><ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        demo.run();</span><br><span class="line">        demo.test();</span><br><span class="line">        Demo.test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">// 接口</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface 默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：<ul>
<li>不能实例化接口，必须用实现类来引用</li>
<li>抽象方法必须全部实现，如果没有全部实现，那么这个实现类必须是抽象类</li>
<li>默认方法，可以继承，可以重写（可以解决接口升级的问题）</li>
<li>静态和<code>.class</code>文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用</li>
<li>私有方法：只有默认方法可以调用</li>
<li>私有静态方法：默认方法和静态方法可以调用</li>
<li>上面两个配合默认方法使用</li>
</ul>
</li>
</ul>
<h2 id="接口的多实现"><a href="#接口的多实现" class="headerlink" title="接口的多实现"></a>接口的多实现</h2><p>一个类可以实现多个接口，这也叫做接口的多实现。</p>
<ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 类名 [extends 父类名] implements 接口一,接口二,接口三...&#123;</span><br><span class="line"> <span class="comment">// 重写接口中的抽象方法 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意：</p>
<ul>
<li>如果抽象方法有重名的，只需要重写一次</li>
<li>如果默认方法有重名，必须重写一次</li>
<li>接口中，存在同名的静态方法并不会冲突，原因是只能通过各自接口访问静态方法</li>
</ul>
</li>
<li><p>优先级问题</p>
<ul>
<li>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法</li>
</ul>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">Demo</span>, Demo2 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        demo.run();</span><br><span class="line">        demo.test();</span><br><span class="line">        Demo.test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test interface 默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">// 接口</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface 默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="comment">// 接口</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface 默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>接口中也可以定义<code>成员变量</code>，但是必须使用<code>public static final</code>三个关键字进行修饰</p>
<p>其实就是接口的<strong>常量</strong></p>
<ul>
<li>格式</li>
</ul>
<p><code>public staitc final 数据类型 常量名称 = 数据值;</code></p>
<ul>
<li><code>public</code>：作用的范围为全部</li>
<li><code>static</code>：为静态</li>
<li><code>final</code>：不可变</li>
<li>接口中的常量，可以不写<code>public static final</code>，默认就是这样的</li>
<li>接口中的常量，必须赋值</li>
<li>常量推荐用：大写加下划线分割单词</li>
</ul>
<h2 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h2><p>一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。就扣的继承使用<code>extends</code>关键字，子接口继承父接口的方法。<strong>如果父接口中的默认方法又重名，那么子接口需要重写一次。</strong></p>
<ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A 接口&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 接口&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span>,B&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C 接口&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>子接口重写默认方法时，default关键字可以保留。</p>
<p>子类重写默认方法时，default关键字不可以保留。</p>
</blockquote>
<h2 id="其他成员特点"><a href="#其他成员特点" class="headerlink" title="其他成员特点"></a>其他成员特点</h2><ul>
<li>接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用<code>public static final</code>修饰.</li>
<li>接口中，没有构造方法，不能创建对象。</li>
<li>接口中，没有静态代码块。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>成员变量其实是常量：<ul>
<li>格式：<code>[public] [static] [final] 数据类型 常量名称 = 数据值;</code></li>
<li>注意：<ul>
<li>常量必须进行赋值，而且一旦赋值不能改变</li>
<li>常量名称完全大写，用下划线进行分隔</li>
</ul>
</li>
</ul>
</li>
<li>接口中最重要的就是抽象方法<ul>
<li>格式：<code>[public] [abstract] 返回值类型 方法名称(参数列表)</code></li>
<li>注意：<ul>
<li>实现类必须覆盖重写接口所有的抽象方法，除非实现英是抽象类</li>
</ul>
</li>
</ul>
</li>
<li>从Java 8开始，接口里允许定义默认方法<ul>
<li>格式：<code>[public] default 返回值类型 方法名称(参数列表) &#123;方法体&#125;</code></li>
<li>注意：<ul>
<li>默认方法也可以被覆盖重写</li>
</ul>
</li>
</ul>
</li>
<li>从Java 8开始，接口里允许定义静态方法<ul>
<li>格式：<code>[public] static 返回值类型 方法名称(参数列表) &#123;方法体&#125;</code></li>
<li>注意：<ul>
<li>应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法</li>
</ul>
</li>
</ul>
</li>
<li>从Java 9开始，接口里允许定义私有很乏，<ul>
<li>格式：<ul>
<li>普通私有方法：<code>private 返回值类型 方法名称(参数列表) &#123; 方法体 &#125;</code></li>
<li>静态私有方法：<code>private static 返回值类型 方法名称(参数列表) &#123; 方法体 &#125;</code></li>
</ul>
</li>
<li>注意：<ul>
<li>private的方法只有接口自己才能调用，不能被实现类或别人使用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><p>接口没有静态代码块和构造方法</p>
</li>
<li><p>一个类的直接父类时唯一的，但是要一个类可以同时实现多个接口</p>
</li>
<li><p>如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可</p>
</li>
<li><p>如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类</p>
</li>
<li><p>如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写</p>
</li>
<li><p>一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法</p>
</li>
<li><p>接口与接口之间是多继承的</p>
<ul>
<li>同名抽象没问题，同名默认有冲突，需要重写默认方法，而且需要带着<code>default</code>关键字</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型转换</title>
    <url>/2020/03/06/java/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><p>Java程序中要求参与的计算的数据，必须要保证数据类型的一致性，如果数据类型不一致将发生类型的转换</p>
<h2 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h2><ol>
<li>自动转换：将<strong>取值范围小的类型</strong>自动提升为<strong>取值范围大的类型</strong></li>
<li>特点：代码不需要进行特殊处理，自动完成</li>
<li>规则：数据范围从小到大</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataConversion</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">// 自动类型转换</span></span><br><span class="line">		<span class="comment">// 左边是long类型，右边是默认的int类型，左右类型不同</span></span><br><span class="line">		<span class="comment">// 一个等号代表赋值，将右侧的int常量，交给左侧的long变量进行储存</span></span><br><span class="line">		<span class="comment">// int --&gt; long，符合数据范围从小到大的要求</span></span><br><span class="line">		<span class="comment">// 自动类型转换</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">		System.out.println(num1); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 左边是double类型，右边是float类型，左右不一样</span></span><br><span class="line">		<span class="comment">// float-&gt; double，符合从小到大的规则</span></span><br><span class="line">		<span class="comment">// 自动类型转换</span></span><br><span class="line">		<span class="type">double</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">2.5F</span>;</span><br><span class="line">		System.out.println(num2); <span class="comment">// 2.5</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 左边是float类型，右边是long类型，左右不一样</span></span><br><span class="line">		<span class="comment">// long--&gt; float，范围是float更大一些，符合从小到大的规则</span></span><br><span class="line">		<span class="comment">// 自动类型转换</span></span><br><span class="line">		<span class="type">float</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="number">30L</span>;</span><br><span class="line">		System.out.println(num3); <span class="comment">// 30.0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h3><p>范围小的类型向范围大的类型提升，<strong>byte，short，char</strong>运算时直接提升为<strong>int</strong></p>
<p><code>byte, short, char--&gt;int--&gt;long--&gt;float--&gt;double</code></p>
<h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><ol>
<li>强制转换：将<strong>取值范围大的类型</strong>强制转换成<strong>取值范围小的类型</strong></li>
<li>特点：代码需要进行特殊的格式处理，不能自动完成</li>
<li>格式：<code>范围小的类型 范围小的变量名 = (范围小的类型) 原本范围大的数据;</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataConversion</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">// 强制类型转换</span></span><br><span class="line">		<span class="comment">// 左边式int类型，右边式long类型，不一样</span></span><br><span class="line">		<span class="comment">// long --&gt; int，不是从小到大</span></span><br><span class="line">		<span class="comment">// 不能发生自动类型转换</span></span><br><span class="line">		<span class="comment">// 强制类型转换</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">num4</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">100L</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// long --&gt; int 超过int的最大值数据就会直接溢出，不会得到自己想要的值</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">num5</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">6000000000L</span>;</span><br><span class="line">		System.out.println(num5); <span class="comment">// 1705032704</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// double --&gt; int 所有小数都会被舍去</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">num6</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">3.99</span>;</span><br><span class="line">		System.out.println(num6); <span class="comment">// 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// int --&gt; byte 右侧的数值大小不能超过左侧的类型范围</span></span><br><span class="line">		<span class="type">byte</span> <span class="variable">num7</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">40</span>;</span><br><span class="line">		System.out.println(num7); <span class="comment">// 40</span></span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">num8</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">		<span class="comment">//byte num9 = num8; // 错误: 不兼容的类型: 从int转换到byte可能会有损失</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// char --&gt; int 原因ASII</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">num10</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">		System.out.println(num10); <span class="comment">// 65</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>浮点转成整数，直接取消小数点，可能造成数据损失精度。</li>
<li><strong>取值范围大的类型</strong>强制转成<strong>取值范围小的类型</strong>，可能造成数据丢失。</li>
<li><strong>取值范围大的类型</strong>强制转成<strong>取值范围小的类型</strong>的时候范围大的类型数值超过范围小的类型，数据会直接溢出</li>
<li>对于<code>byte/short/char</code>三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器将会自动隐含的不上<code>(byte)(short)(char)</code><ul>
<li>如果右侧超过了左侧范围，那么直接编译器报错</li>
<li>如果右侧的表达式房中全都是常量，那么编译器javac将会直接将若干个常量表达式计算得到结果<ul>
<li>需要注意，右侧的常量结果数值，没有超过左侧范围</li>
<li>这也被成为编译器的常量优化</li>
<li>但一旦有表达式参与，那么编译器就不会进行这种优化了</li>
</ul>
</li>
</ul>
</li>
<li><code>char</code>类型可以直接转换成int类型</li>
<li><code>boolean</code>类型不能发生数据类型转换</li>
</ul>
<h2 id="ASCII编码表"><a href="#ASCII编码表" class="headerlink" title="ASCII编码表"></a>ASCII编码表</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ASCIICodingTable</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">// 字符类型</span></span><br><span class="line">		<span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">		<span class="comment">// 字符类型 + int类型</span></span><br><span class="line">		System.out.println((<span class="type">int</span>)c1); <span class="comment">// 66</span></span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">		System.out.println((<span class="type">int</span>)c2); <span class="comment">// 20013</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在计算机的底层会用一个数字（二进制）来表示字符A，A代表的数字就是65</p>
<p>而数字和字符的对照关系表（编码表）：</p>
<ul>
<li>ASCII码表：American Standard Code for Information Interchange，美国信息卒换标准代码.</li>
<li>Unicode码表：万国码。也是数字和符号的对照关系，开头0-127部分和ASCII完全一样，但是从128开始包含有更多字符。</li>
</ul>
<p>需要记忆的就只有三个</p>
<ul>
<li>48 -&gt; ‘0’</li>
<li>65 -&gt; ‘A’</li>
<li>97 -&gt; ‘a’</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2020/04/18/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="数据结构有什么用？"><a href="#数据结构有什么用？" class="headerlink" title="数据结构有什么用？"></a>数据结构有什么用？</h2><p>当你用着java里面的容器类很爽的时候，你有没有想过，怎么ArrayList就像一个无限扩充的数组，也好像链表之类的。好用吗？好用，这就是数据结构的用处，只不过你在不知不觉中使用了。</p>
<p>现实世界的存储，我们使用的工具和建模。每种数据结构有自己的优点和缺点，想想如果Google的数据用的是数组的存储，我们还能方便地查询到所需要的数据吗？而算法，在这么多的数据中如何做到最快的插入，查找，删除，也是在追求更快。</p>
<p>我们java是面向对象的语言，就好似自动档轿车，C语言好似手动档吉普。数据结构呢？是变速箱的工作原理。你完全可以不知道变速箱怎样工作，就把自动档的车子从 A点 开到 B点，而且未必就比懂得的人慢。写程序这件事，和开车一样，经验可以起到很大作用，但如果你不知道底层是怎么工作的，就永远只能开车，既不会修车，也不能造车。当然了，数据结构内容比较多，细细的学起来也是相对费功夫的，不可能达到一蹴而就。我们将常见的数据结构：堆栈、队列、数组、链表和红黑树 这几种给大家介绍一下，作为数据结构的入门，了解一下它们的特点即可。</p>
<img data-src="/2020/04/18/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%AF%94%E5%96%BB.png" class="">

<h2 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h2><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树。我们分别来了解一下：</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul>
<li><strong>栈</strong>：<strong>stack</strong>,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</li>
</ul>
<p>简单的说：采用该结构的集合，对元素的存取有如下的特点</p>
<ul>
<li><p>先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</p>
</li>
<li><p>栈的入口、出口的都是栈的顶端位置。</p>
<img data-src="/2020/04/18/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86%E6%A0%88.png" class=""></li>
</ul>
<p>这里两个名词需要注意：</p>
<ul>
<li><strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li>
<li><strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li>
</ul>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul>
<li><strong>队列</strong>：<strong>queue</strong>,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</li>
</ul>
<p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li>先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。</li>
<li>队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</li>
</ul>
<img data-src="/2020/04/18/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97%E5%9B%BE.bmp" class="">

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li><strong>数组</strong>:<strong>Array</strong>,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</li>
</ul>
<p>简单的说,采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li><p>查找元素快：通过索引，可以快速访问指定位置的元素</p>
<img data-src="/2020/04/18/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E6%9F%A5%E8%AF%A2%E5%BF%AB.png" class="">
</li>
<li><p>增删元素慢</p>
<ul>
<li><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图<img data-src="/2020/04/18/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E6%B7%BB%E5%8A%A0.png" class=""></li>
<li><strong>指定索引位置删除元素：</strong>需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图<img data-src="/2020/04/18/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E5%88%A0%E9%99%A4.png" class=""></li>
</ul>
</li>
</ul>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul>
<li><p><strong>链表</strong>:<strong>linked list</strong>,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是<strong>单向链表</strong>。</p>
<img data-src="/2020/04/18/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%89%B9%E7%82%B9.png" class=""></li>
</ul>
<p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li><p>多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</p>
<img data-src="/2020/04/18/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png" class="">
</li>
<li><p>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p>
</li>
<li><p>增删元素快：</p>
<ul>
<li><p>增加元素：只需要修改连接下个元素的地址即可。</p>
<img data-src="/2020/04/18/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A2%9E%E5%8A%A0%E7%BB%93%E7%82%B9.png" class="">
</li>
<li><p>删除元素：只需要修改连接下个元素的地址即可。</p>
<img data-src="/2020/04/18/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9.bmp" class=""></li>
</ul>
</li>
</ul>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><ul>
<li><strong>二叉树</strong>：<strong>binary tree</strong> ,是每个结点不超过2的有序<strong>树（tree）</strong> 。</li>
</ul>
<p>简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。</p>
<p>二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。</p>
<p>如图：</p>
<img data-src="/2020/04/18/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91.bmp" class="">

<p>我们要说的是二叉树的一种比较有意思的叫做<strong>红黑树</strong>，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。</p>
<p>红黑树的约束:</p>
<ol>
<li><p>节点可以是红色的或者黑色的</p>
</li>
<li><p>根节点是黑色的</p>
</li>
<li><p>叶子节点(特指空节点)是黑色的</p>
</li>
<li><p>每个红色节点的子节点都是黑色的</p>
</li>
<li><p>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</p>
</li>
</ol>
<p>红黑树的特点:</p>
<p>​	速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2020/03/23/java/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="数组的定义和访问"><a href="#数组的定义和访问" class="headerlink" title="数组的定义和访问"></a>数组的定义和访问</h2><h3 id="容器概念"><a href="#容器概念" class="headerlink" title="容器概念"></a>容器概念</h3><ul>
<li>容器：是将多个数据存储到一起，每个数据称为容器的元素</li>
<li>比如：水杯就时容器，而里面的的存放的水、饮料、酒就可以称为容器的元素</li>
</ul>
<h3 id="数组的概念"><a href="#数组的概念" class="headerlink" title="数组的概念"></a>数组的概念</h3><ul>
<li>数组：数组就是存储数据长度固定的容器<ul>
<li>特点：<ul>
<li><strong>数组是一种引用数据类型</strong></li>
<li><strong>数组当中的多个数据，类型必须统一</strong></li>
<li><strong>数组的长度在运行期间不可以改变</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3><h4 id="动态初始化（指定长度）"><a href="#动态初始化（指定长度）" class="headerlink" title="动态初始化（指定长度）"></a>动态初始化（指定长度）</h4><ul>
<li>格式：</li>
</ul>
<p><code>数据类型[] 数据名称 = new 数据类型[长度]</code></p>
<ul>
<li><p>解释：</p>
<ul>
<li><code>数据类型</code>：创建的数组容器可以存储什么数据类型</li>
<li><code>[]</code>：表示数组。</li>
<li><code>数据名称</code>：为定义的数组起个变量名，满足标识符规范，可以使用名字操作数组。</li>
<li><code>new：关键字</code>，创建数组使用的关键字。</li>
<li><code>数据类型</code>：创建的数组容器可以存储什么数据类型。</li>
<li><code>[长度]</code>：数组的长度，表示数组容器中可以存储多少个元素，是int数字。</li>
<li><strong>注意：数组有定长特性，长度一旦指定，不可更改。</strong><ul>
<li>和水杯一个道理，买了一个2升的水杯，总量也就只有2升，不能多也少不了</li>
</ul>
</li>
</ul>
</li>
<li><p>实现</p>
</li>
</ul>
<p><code>int[] arr = new int[300];</code></p>
<h4 id="静态初始化（指定内容）"><a href="#静态初始化（指定内容）" class="headerlink" title="静态初始化（指定内容）"></a>静态初始化（指定内容）</h4><ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数据名称 = <span class="keyword">new</span> 数据类型[]&#123;元素<span class="number">1</span>,元素<span class="number">2.</span>..&#125;;</span><br><span class="line">或者</span><br><span class="line">数据类型[] 数据名称 = &#123;元素<span class="number">1</span>,元素<span class="number">2.</span>..&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] arr2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>静态初始化没有直接告诉长度，但是根据大括号里面的元素具体内容，也可以自动推算出来长度</li>
<li>静态初始化标准格式可以拆分成为两个步骤</li>
<li>动态初始化可以拆分成为两个步骤</li>
<li>静态初始化一旦使用省略格式，就不能拆分呈两个步骤</li>
<li>建议：<ul>
<li>如果不确定数组当中的具体内容，用动态初始化</li>
<li>已经确定了具体的内容，同静态初始化</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 静态初始化标准格式可以拆分成为两个步骤</span></span><br><span class="line">        <span class="type">int</span>[] arrayA;</span><br><span class="line">        arrayA = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="comment">// 动态初始化可以拆分成为两个步骤</span></span><br><span class="line">        <span class="type">int</span>[] arrayB;</span><br><span class="line">        arrayB = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态初始化一旦使用省略格式，就不能拆分呈两个步骤</span></span><br><span class="line">        <span class="comment">//int [] arrayC;</span></span><br><span class="line">        <span class="comment">//arrayC = &#123;1,2,3&#125;;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据的访问"><a href="#数据的访问" class="headerlink" title="数据的访问"></a>数据的访问</h3><ul>
<li><strong>索引</strong>：每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为数组索引（index），可以通过数组的索引访问到数组中的元素。</li>
<li><strong>格式</strong>：</li>
</ul>
<p><code>数组名[索引]</code></p>
<ul>
<li><strong>数组的长度属性</strong>：<strong>每个数组都具有长度，而且是固定的</strong>，Java中赋予了数组的一个属性，可以获取到数组的长度，语句为：<code>数组名.length</code>，属性length的执行结果是数组的长度，int类型结果。由次可以推断出，费组的最大索引值为<code>数组名.length-1</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(array.length); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>索引访问数组中的元素</strong>：<ul>
<li>数组名[索引] &#x3D; 数组，为数组中的元素赋值</li>
<li>变量 &#x3D; 数组名[索引]，获取出数组中的元素</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(array.length); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 索引从0开始</span></span><br><span class="line">        System.out.println(array[<span class="number">0</span>]); <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// length - 1 结束</span></span><br><span class="line">        System.out.println(array[array.length - <span class="number">1</span>]); <span class="comment">// 3</span></span><br><span class="line">        <span class="comment">// 改变索引的值</span></span><br><span class="line">        array[<span class="number">0</span>] = <span class="number">6</span>;</span><br><span class="line">        System.out.println(array[<span class="number">0</span>]); <span class="comment">// 6</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>动态数组的访问</p>
<ul>
<li>如果使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值<ul>
<li>如果是整数类型，默认为0</li>
<li>如果是浮点类型，默认为0.0</li>
<li>如果是字符类型，默认为’\u0000’</li>
<li>如果是布尔类型，默认为false</li>
<li>如果是引用类型，默认为null</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>静态初始化其实也有默认值的过程，只不过系统马上替换成了大括号中的对应值</li>
</ul>
</li>
</ul>
<h2 id="数组原理内存图"><a href="#数组原理内存图" class="headerlink" title="数组原理内存图"></a>数组原理内存图</h2><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存是计算机中的重要原件，临时存储区域，作用是运行程序。我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。</p>
<p>Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。</p>
<h3 id="Java虚拟机的内存划分"><a href="#Java虚拟机的内存划分" class="headerlink" title="Java虚拟机的内存划分"></a>Java虚拟机的内存划分</h3><p>为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。</p>
<ul>
<li><p>JVM的内存划分：</p>
<table>
<thead>
<tr>
<th>区域名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td>给CPU使用，和开发无关</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>JVM在使用操作系统功能的时候使用，和开发无关</td>
</tr>
<tr>
<td>方法区</td>
<td>存储可以运行的Class文件</td>
</tr>
<tr>
<td>堆内存</td>
<td>存储对象或者数组，new来创建的，都存储在堆内存</td>
</tr>
<tr>
<td>方法栈</td>
<td>方法运行时使用的内存，比如main方法运行，进入方法栈中执行</td>
</tr>
</tbody></table>
<img data-src="/2020/03/23/java/%E6%95%B0%E7%BB%84/01-Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.png" class="" alt="01-Java中的内存划分"></li>
</ul>
<h3 id="数组在内存中的存储"><a href="#数组在内存中的存储" class="headerlink" title="数组在内存中的存储"></a>数组在内存中的存储</h3><h4 id="一个数组内存图"><a href="#一个数组内存图" class="headerlink" title="一个数组内存图"></a>一个数组内存图</h4><img data-src="/2020/03/23/java/%E6%95%B0%E7%BB%84/02-%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png" class="" alt="02-只有一个数组的内存图">

<h4 id="两个数组内存图"><a href="#两个数组内存图" class="headerlink" title="两个数组内存图"></a>两个数组内存图</h4><img data-src="/2020/03/23/java/%E6%95%B0%E7%BB%84/03-%E6%9C%89%E4%B8%A4%E4%B8%AA%E7%8B%AC%E7%AB%8B%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png" class="" alt="03-有两个独立数组的内存图">

<h4 id="两个引用指向同一个数组的内存图"><a href="#两个引用指向同一个数组的内存图" class="headerlink" title="两个引用指向同一个数组的内存图"></a>两个引用指向同一个数组的内存图</h4><img data-src="/2020/03/23/java/%E6%95%B0%E7%BB%84/04-%E4%B8%A4%E4%B8%AA%E5%BC%95%E7%94%A8%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png" class="" alt="04-两个引用指向同一个数组的内存图">

<h3 id="数组长度保持不变的内存图"><a href="#数组长度保持不变的内存图" class="headerlink" title="数组长度保持不变的内存图"></a>数组长度保持不变的内存图</h3><img data-src="/2020/03/23/java/%E6%95%B0%E7%BB%84/05-%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6%E8%BF%90%E8%A1%8C%E6%9C%9F%E9%97%B4%E4%B8%8D%E5%8F%AF%E6%94%B9%E5%8F%98.png" class="" alt="05-数组的长度运行期间不可改变">

<h2 id="数组的常见操作"><a href="#数组的常见操作" class="headerlink" title="数组的常见操作"></a>数组的常见操作</h2><h3 id="数组越界异常"><a href="#数组越界异常" class="headerlink" title="数组越界异常"></a>数组越界异常</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建数组</p>
</li>
<li><p>赋值3个元素，数组的索引就是0，1，2</p>
</li>
<li><p>没有3索引，因此我们不能访问数组中不存在的索引</p>
</li>
<li><p>程序运行后，将会抛出<code>ArrayIndexOutofBoundsException</code>数组越界异常</p>
</li>
<li><p>在开发中，数组的越界异常是<strong>不能出现</strong>的，一旦出现了，就必须要修改我们编写的代码</p>
</li>
</ul>
<img data-src="/2020/03/23/java/%E6%95%B0%E7%BB%84/image-20200404115449968.png" class="" alt="image-20200404115449968">

<h3 id="数组空指针异常"><a href="#数组空指针异常" class="headerlink" title="数组空指针异常"></a>数组空指针异常</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">    arr = <span class="literal">null</span>;</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>arr = null;</code>这行代码，意味着变量arr将不会在保存数组的内存地址，也就不允许再操作数组了</p>
<ul>
<li><strong>所有的引用类型变量，都可以赋值为一个null值，代表其中什么都没有</strong></li>
</ul>
</li>
<li><p>因此运行的时候会抛出<code>Nul1PointerException</code>空指针异常</p>
</li>
<li><p>在开发中，数组的空指针异常是不能出现的，一旦出现了，就必须要修改我们编写的代码</p>
</li>
</ul>
<img data-src="/2020/03/23/java/%E6%95%B0%E7%BB%84/image-20200404115849231.png" class="" alt="image-20200404115849231">

<h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p><strong>数组遍历</strong>：就是将数组中的每个元素分别获取出来，就是遍历。遍历也是数组操作中的基石。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           System.out.println(arr[i]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组获取最大值元素"><a href="#数组获取最大值元素" class="headerlink" title="数组获取最大值元素"></a>数组获取最大值元素</h3><ul>
<li><p>最大值获取：从数组的所有元素中找出最大值。</p>
</li>
<li><p>实现思路：</p>
<ul>
<li>定义变量，保存数组0索引上的元素</li>
<li>遍历数组，获取出数组中的每个元素</li>
<li>将遍历到的元素和保存数组0索引上值的变量进行比较</li>
<li>如果数组元素的值大于了变量的值，变量记录住新的值</li>
<li>数组循环遍历结束，变量保存的就是数组中的最大值</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">321</span>, <span class="number">431</span>, <span class="number">431</span>, <span class="number">431</span>, <span class="number">546</span>, <span class="number">57</span>, <span class="number">48758</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; arr[i]) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h3><ul>
<li>数组的反转：数组中的元素颠倒顺序，实现思想：数组最远端的元素互换位置。<ul>
<li>实现反转，就需要将数组最远端元素位置交换</li>
<li>定义两个变量，保存数组的最小索引和最大索引</li>
<li>两个索引上的元素交换位置</li>
<li>最小索引<code>++</code>，最大索引<code>--</code>，再次交换位置</li>
<li>最小索引超过了最大索引，数组反转操作结束</li>
</ul>
</li>
</ul>
<img data-src="/2020/03/23/java/%E6%95%B0%E7%BB%84/07-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%8F%8D%E8%BD%AC%E7%9A%84%E6%80%9D%E8%B7%AF.png" class="" alt="07-数组元素反转的思路">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">321</span>, <span class="number">431</span>, <span class="number">431</span>, <span class="number">431</span>, <span class="number">546</span>, <span class="number">57</span>, <span class="number">48758</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>, max = arr.length - <span class="number">1</span>; min &lt; max; min++, max--) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[min];</span><br><span class="line">        arr[min] = arr[max];</span><br><span class="line">        arr[max] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        System.out.print(arr[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组为方法参数和返回值"><a href="#数组为方法参数和返回值" class="headerlink" title="数组为方法参数和返回值"></a>数组为方法参数和返回值</h2><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><ul>
<li><p>数组作为方法的参数</p>
</li>
<li><p>当调用方法的时候，向方法的小括号进行传参，传递进去的其实时数组的地址值</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">321</span>, <span class="number">431</span>, <span class="number">431</span>, <span class="number">431</span>, <span class="number">546</span>, <span class="number">57</span>, <span class="number">48758</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    printArray(arr); <span class="comment">// 传递进去的是arr当中保存的地址值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        System.out.print(array[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li>数组作为方法的返回值，返回的是数组的内存地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = NewArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] NewArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">321</span>, <span class="number">431</span>, <span class="number">431</span>, <span class="number">431</span>, <span class="number">546</span>, <span class="number">57</span>, <span class="number">48758</span>, <span class="number">9</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法的参数类型区别"><a href="#方法的参数类型区别" class="headerlink" title="方法的参数类型区别"></a>方法的参数类型区别</h3><ul>
<li>引用类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]); <span class="comment">// 1</span></span><br><span class="line">    change(arr);</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]); <span class="comment">// 200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>基本类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        System.out.println(a); <span class="comment">// 1</span></span><br><span class="line">        change(a);</span><br><span class="line">        System.out.println(a); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        a = a + <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>总结<ul>
<li>方法的参数为基本类型时，传递的是数据值，方法的参数为引用类型时，传递的是地址值</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>方法</title>
    <url>/2020/03/22/java/%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="方法的定义和调用-回顾"><a href="#方法的定义和调用-回顾" class="headerlink" title="方法的定义和调用(回顾)"></a>方法的定义和调用(回顾)</h2><p>定义格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名称()&#123;</span><br><span class="line">  方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名称();</span><br></pre></td></tr></table></figure>

<p>注意事项</p>
<ol>
<li>方法定义的先后顺序无所谓</li>
<li>方法定义必须时挨着的，不能一个方法的内部定义另外一个方法(特殊情况除外)</li>
<li>方法定义之后，自己不会执行的，如果希望执行，一定要进行方法的调用</li>
</ol>
<p>控制台输出矩形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义格式的格式详解"><a href="#定义格式的格式详解" class="headerlink" title="定义格式的格式详解"></a>定义格式的格式详解</h2><p>方法其实就是若干语句的功能集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法格式：</span><br><span class="line">修饰符 返回值类型 方法名(参数类型 参数名称,...)&#123;</span><br><span class="line">  <span class="comment">//代码</span></span><br><span class="line">  <span class="keyword">return</span> 结果;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修饰符：现阶段只有public static固定写法</li>
<li>返回值类型：表示方法运行的结果的数据类型，方法执行后将结果返回到调用者</li>
<li>方法名：方法的名称，规则和变量一样，小驼峰</li>
<li>参数类型：进入方法的数据时什么类型</li>
<li>参数名称：进入方法的数据对应的变量名称（参数有多个用逗号分割）</li>
<li>return：两个作用，第一个停止方法，第二个将后面的返回值还给调用处<ul>
<li>return 返回的返回值，必须和方法名称中的返回值类型保持对应</li>
</ul>
</li>
</ul>
<h2 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h2><ul>
<li>定义方法明确<ul>
<li>返回值类型：明确这个方法必定返回的类型</li>
<li>方法名称：明确这个方法是做什么的</li>
<li>参数列表：明确需要传入的值有哪些</li>
</ul>
</li>
</ul>
<p>实现两个整数求和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewMethodDefine</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法三种调用"><a href="#方法三种调用" class="headerlink" title="方法三种调用"></a>方法三种调用</h2><ol>
<li>单独调用：方法名称(参数);</li>
<li>打印调用</li>
<li>赋值调用<ul>
<li>返回值类型固定写为<strong>void</strong>，这种方法只能单独调用，不能进行打印调用和赋值调用</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewMethodDefine</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//单独调用</span></span><br><span class="line">        sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//打印调用</span></span><br><span class="line">        System.out.println(sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        <span class="comment">//赋值调用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调用方法的流程图"><a href="#调用方法的流程图" class="headerlink" title="调用方法的流程图"></a>调用方法的流程图</h2><img data-src="/2020/03/22/java/%E6%96%B9%E6%B3%95/image-20200403103522213.png" class="" alt="image-20200403103522213">

<h2 id="方法区别"><a href="#方法区别" class="headerlink" title="方法区别"></a>方法区别</h2><h3 id="有参数或无参数"><a href="#有参数或无参数" class="headerlink" title="有参数或无参数"></a>有参数或无参数</h3><p>有参数：小括号当中有内容，当一个方法需要一些数据条件，才能完成任务的时候，就是有参数</p>
<p>无参数：小括号当中留空，一个方法不需要任何数据条件，自己就能独立完成任务，就是无参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewMethodDefine</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有返回值或无返回值"><a href="#有返回值或无返回值" class="headerlink" title="有返回值或无返回值"></a>有返回值或无返回值</h3><img data-src="/2020/03/22/java/%E6%96%B9%E6%B3%95/04-%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%9C%89%E6%97%A0.png" class="" alt="04-方法返回值的有无">

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>方法应该定义在类当中，但是不能在方法当中在定义方法，不能嵌套</li>
<li>方法定义的前后顺序无所谓</li>
<li>方法定义之后不会执行，如果希望执行，一定要调用<ul>
<li>单独调用</li>
<li>打印调用</li>
<li>赋值调用</li>
</ul>
</li>
<li>如果方法又返回值，那么必须写上<code>return 返回值;</code></li>
<li>return后面的返回值数据，必须和方法的返回值类型，对应</li>
<li>对于一个void没有返回值的方法，不能写return后面的返回值，只能写return自己</li>
<li>对于void方法当中最后一行的return可以省略不写</li>
<li>一个方法当中可以有多个return语句，但是必须保证同时只有一个会被执行到，两个return不能连写</li>
</ol>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><ul>
<li>方法重载：指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返回值类型无关。</li>
<li>参数列表：<ul>
<li>个数不同</li>
<li>数据类型不同</li>
<li>顺序不同</li>
</ul>
</li>
<li>重载方法调用：JVM通过方法的参数列表，调用不同的方法。</li>
<li>优势：只需要记住唯一一个方法名称，就可以实现类似的多个功能</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewMethodOverload</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        System.out.println(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(sum(<span class="number">1.0</span>, <span class="number">2.0</span>));</span><br><span class="line">        System.out.println(sum(<span class="number">1.0</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (a + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">double</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//错误!与参数名称无关</span></span><br><span class="line">    <span class="comment">//    public static int sum(double x, int y) &#123;</span></span><br><span class="line">    <span class="comment">//        return (int) (x + y);</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//错误!与返回值类型无关</span></span><br><span class="line">    <span class="comment">//    public static double sum(double a, int b) &#123;</span></span><br><span class="line">    <span class="comment">//        return a + b;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>方法入门</title>
    <url>/2020/03/08/java/%E6%96%B9%E6%B3%95%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们在学习运算符的时候，都为每个运算符单独的创建一个新的类和main方法，我们会发现这样编写代码非常的繁琐，而且重复的代码过多，能否避免这些重复的代码呢，就需要使用方法来实现。</p>
<ul>
<li><strong>方法</strong>：就是将一个<strong>功能</strong>抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。</li>
</ul>
<p>当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。</p>
<h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><ul>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名 (参数列表) &#123;</span><br><span class="line">  代码...</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>格式结束：</p>
<ul>
<li>修饰符：目前固定格式<code>public static</code></li>
<li>返回值类型：目前固定写发<code>void</code></li>
<li>方法名：给定义的方法起一个名称，满足标识符规范，<strong>强烈推荐小驼峰</strong></li>
<li>参数列表：目前无参数</li>
<li><strong>return</strong>：方法结束。返回值类型为<strong>void</strong>时，方法体中的<strong>return</strong>可以不写</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewMethod</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> viod <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> staitc <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法在定义完毕后，方法不会自己运行，必须被调用才能执行，我们可以在主方法main中来调用我们自己定义好的方法。在主方法中，直接写要调用的方法名字就可以调用了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewMethod</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> viod <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">//调用test方法</span></span><br><span class="line">    test();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> staitc <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><ul>
<li>方法定义注意事项：<ul>
<li>方法必须定义在一类中方法外</li>
<li>方法不能定义在另一个方法的里面</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>日期时间类</title>
    <url>/2020/04/11/java/%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code> java.util.Date</code>类 表示特定的瞬间，精确到毫秒（1000毫秒&#x3D;1秒）。</p>
<p>继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。</p>
<ul>
<li><code>public Date()</code>：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</li>
<li><code>public Date(long date)</code>：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即<code>1970年1月1日00:00:00 GMT</code>）以来的指定毫秒数。</li>
</ul>
<blockquote>
<p>由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。</p>
</blockquote>
<p>简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   test1();</span><br><span class="line">   test2();</span><br><span class="line">   test3();</span><br><span class="line">   test4();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * getTime()</span></span><br><span class="line"><span class="comment"> * 成员方法</span></span><br><span class="line"><span class="comment"> * 把日期转换为毫秒数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">0L</span>).getTime());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * new Date(0L);</span></span><br><span class="line"><span class="comment"> * 有参构造方法 OL为毫秒数</span></span><br><span class="line"><span class="comment"> * 获取OL的日期和时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">0L</span>));</span><br><span class="line">    <span class="comment">// Thu Jan 01 08:00:00 CST 1970</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * new Date();</span></span><br><span class="line"><span class="comment"> * 空构造方法</span></span><br><span class="line"><span class="comment"> * 获取当前系统日期和时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * System.currentTimeMillis();</span></span><br><span class="line"><span class="comment"> * 获取当前时间的毫秒数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(System.currentTimeMillis());</span><br><span class="line">    <span class="comment">//获取当前系统时间到1970年1月1日00:00:00经历了多少毫秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。</p>
</blockquote>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>Date类中的多数方法已经过时，常用的方法有：</p>
<ul>
<li><code>public long getTime()</code> 把日期对象转换成对应的时间毫秒值。</li>
</ul>
<h2 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h2><p><code>java.text.DateFormat</code> 是日期&#x2F;时间格式化子类的<strong>抽象类</strong>，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。</p>
<ul>
<li><strong>格式化</strong>：按照指定的格式，从Date对象转换为String对象。</li>
<li><strong>解析</strong>：按照指定的格式，从String对象转换为Date对象。</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>由于DateFormat为抽象类，不能直接使用，所以需要常用的子类<code>java.text.SimpleDateFormat</code>。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：</p>
<ul>
<li><code>public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。</li>
</ul>
<p>参数pattern是一个字符串，代表日期时间的自定义格式。</p>
<h3 id="格式规则"><a href="#格式规则" class="headerlink" title="格式规则"></a>格式规则</h3><p>常用的格式规则为：</p>
<table>
<thead>
<tr>
<th>标识字母（区分大小写）</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>年</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
</tr>
<tr>
<td>H</td>
<td>时</td>
</tr>
<tr>
<td>m</td>
<td>分</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
</tbody></table>
<blockquote>
<p>更详细的格式规则，可以参考SimpleDateFormat类的API文档 </p>
</blockquote>
<p>创建SimpleDateFormat对象的代码如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02SimpleDateFormat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 对应的日期格式如：2018-01-16 15:06:38</span></span><br><span class="line">        <span class="type">DateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>DateFormat类的常用方法有：</p>
<ul>
<li><code>public String format(Date date)</code>：将Date对象格式化为字符串。</li>
<li><code>public Date parse(String source)</code>：将字符串解析为Date对象。</li>
</ul>
<h4 id="format方法"><a href="#format方法" class="headerlink" title="format方法"></a>format方法</h4><p>使用format方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 把Date对象转换成String</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03DateFormatMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="comment">// 创建日期格式化对象,在获取格式化对象时可以指定风格</span></span><br><span class="line">        <span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> df.format(date);</span><br><span class="line">        System.out.println(str); <span class="comment">// 2008年1月23日</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="parse方法"><a href="#parse方法" class="headerlink" title="parse方法"></a>parse方法</h4><p>使用parse方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 把String转换成Date对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04DateFormatMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;2018年12月11日&quot;</span>;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> df.parse(str);</span><br><span class="line">        System.out.println(date); <span class="comment">// Tue Dec 11 00:00:00 CST 2018</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>java.util.Calendar</code>是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。</p>
<h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><p>Calendar为<strong>抽象类</strong>，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：</p>
<p>Calendar静态方法</p>
<ul>
<li><code>public static Calendar getInstance()</code>：使用默认时区和语言环境获得一个日历</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06CalendarInit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance(); <span class="comment">// 多态</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><p>根据Calendar类的API文档，常用方法有：</p>
<ul>
<li><code>public int get(int field)</code>：返回给定日历字段的值。</li>
<li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。</li>
<li><code>public abstract void add(int field, int amount)</code>：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li>
<li><code>public Date getTime()</code>：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</li>
</ul>
<p>Calendar类中提供很多成员常量，代表给定的日历字段：</p>
<table>
<thead>
<tr>
<th>字段值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>年</td>
</tr>
<tr>
<td>MONTH</td>
<td>月（从0开始，可以+1使用）</td>
</tr>
<tr>
<td>DAY_OF_MONTH</td>
<td>月中的天（几号）</td>
</tr>
<tr>
<td>HOUR</td>
<td>时（12小时制）</td>
</tr>
<tr>
<td>HOUR_OF_DAY</td>
<td>时（24小时制）</td>
</tr>
<tr>
<td>MINUTE</td>
<td>分</td>
</tr>
<tr>
<td>SECOND</td>
<td>秒</td>
</tr>
<tr>
<td>DAY_OF_WEEK</td>
<td>周中的天（周几，周日为1，可以-1使用）</td>
</tr>
</tbody></table>
<h4 id="get-set方法"><a href="#get-set方法" class="headerlink" title="get&#x2F;set方法"></a>get&#x2F;set方法</h4><p>get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalendarUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Calendar对象</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 设置年 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> cal.get(Calendar.YEAR);</span><br><span class="line">        <span class="comment">// 设置月</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> cal.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 设置日</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> cal.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07CalendarMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        cal.set(Calendar.YEAR, <span class="number">2020</span>);</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2020年1月17日</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08CalendarMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2018年1月17日</span></span><br><span class="line">        <span class="comment">// 使用add方法</span></span><br><span class="line">        cal.add(Calendar.DAY_OF_MONTH, <span class="number">2</span>); <span class="comment">// 加2天</span></span><br><span class="line">        cal.add(Calendar.YEAR, -<span class="number">3</span>); <span class="comment">// 减3年</span></span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2015年1月18日; </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getTime方法"><a href="#getTime方法" class="headerlink" title="getTime方法"></a>getTime方法</h4><p>Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo09CalendarMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> cal.getTime();</span><br><span class="line">        System.out.println(date); <span class="comment">// Tue Jan 16 16:03:09 CST 2018</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​    西方星期的开始为周日，中国为周一。</p>
<p>​     在Calendar类中，月份的表示是以0-11代表1-12月。</p>
<p>​     日期是有大小关系的，时间靠后，时间越大。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>权限修饰符</title>
    <url>/2020/04/08/java/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限</p>
<ul>
<li>public：公共的。</li>
<li>protected：受保护的</li>
<li>default：默认的</li>
<li>private：私有的</li>
</ul>
<h2 id="不同权限的访问能力"><a href="#不同权限的访问能力" class="headerlink" title="不同权限的访问能力"></a>不同权限的访问能力</h2><table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>default</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一类中</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>同一包中（子类于无关类）</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>不同包的子类</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>不同包中的无关类</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>编写代码时，如果没有特殊的考虑，建议这样使用权限：</p>
<ul>
<li>成员变量使用private，隐藏细节。</li>
<li>构造方法使用public，方便创建对象。</li>
<li>成员方法使用public，方便调用方法。</li>
</ul>
<blockquote>
<p>不加权限修饰符，其访问能力与default修饰符相同</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/2020/04/17/java/%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="泛型概述"><a href="#泛型概述" class="headerlink" title="泛型概述"></a>泛型概述</h2><p>集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p>
<p>大家观察下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">		coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">		coll.add(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">		coll.add(<span class="number">5</span>);<span class="comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span></span><br><span class="line">		<span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			<span class="comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) it.next();</span><br><span class="line">			System.out.println(str.length());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序在运行时发生了问题<strong>java.lang.ClassCastException</strong>。                                                                                             为什么会发生类型转换异常呢？                                                                                                                                       我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。                                                                                                                                                       怎么来解决这个问题呢？                                                                                                                                                           Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p>
<ul>
<li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li>
</ul>
<blockquote>
<p>一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p>
</blockquote>
<img data-src="/2020/04/17/java/%E6%B3%9B%E5%9E%8B/03_%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%A6%82%E5%BF%B5.bmp" class="" alt="03_泛型的概念">

<h2 id="使用泛型的好处"><a href="#使用泛型的好处" class="headerlink" title="使用泛型的好处"></a>使用泛型的好处</h2><p>上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？</p>
<ul>
<li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li>
<li>避免了类型强转的麻烦。</li>
</ul>
<p>通过我们如下代码体验一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        <span class="comment">// list.add(5);//当集合明确类型后，存放类型不一致就会编译报错</span></span><br><span class="line">        <span class="comment">// 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> it.next();</span><br><span class="line">            <span class="comment">//当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span></span><br><span class="line">            System.out.println(str.length());</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</p>
</blockquote>
<h2 id="泛型的定义与使用"><a href="#泛型的定义与使用" class="headerlink" title="泛型的定义与使用"></a>泛型的定义与使用</h2><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</p>
<p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p>
<h3 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h3><p>定义格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>例如，API中的ArrayList集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt;&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123; &#125;</span><br><span class="line">   	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用泛型： 即什么时候确定泛型。</p>
<p><strong>在创建对象的时候确定泛型</strong></p>
<p> 例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p>
<p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;String&gt;&#123; </span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(String e)</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再例如，<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p>
<p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;Integer&gt; &#123; </span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Integer e)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例自定义泛型类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGenericClass</span>&lt;MVP&gt; &#123;</span><br><span class="line">	<span class="comment">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span></span><br><span class="line">	<span class="keyword">private</span> MVP mvp;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMVP</span><span class="params">(MVP mvp)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mvp = mvp;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> MVP <span class="title function_">getMVP</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericClassDemo</span> &#123;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;		 </span><br><span class="line">         <span class="comment">// 创建一个泛型为String的类</span></span><br><span class="line">         MyGenericClass&lt;String&gt; my = <span class="keyword">new</span> <span class="title class_">MyGenericClass</span>&lt;String&gt;();    	</span><br><span class="line">         <span class="comment">// 调用setMVP</span></span><br><span class="line">         my.setMVP(<span class="string">&quot;大胡子登登&quot;</span>);</span><br><span class="line">         <span class="comment">// 调用getMVP</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">mvp</span> <span class="operator">=</span> my.getMVP();</span><br><span class="line">         System.out.println(mvp);</span><br><span class="line">         <span class="comment">//创建一个泛型为Integer的类</span></span><br><span class="line">         MyGenericClass&lt;Integer&gt; my2 = <span class="keyword">new</span> <span class="title class_">MyGenericClass</span>&lt;Integer&gt;(); </span><br><span class="line">         my2.setMVP(<span class="number">123</span>);   	  </span><br><span class="line">         <span class="type">Integer</span> <span class="variable">mvp2</span> <span class="operator">=</span> my2.getMVP();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>例如，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGenericMethod</span> &#123;	  </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(MVP mvp)</span> &#123;</span><br><span class="line">    	System.out.println(mvp.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; MVP <span class="title function_">show2</span><span class="params">(MVP mvp)</span> &#123;	</span><br><span class="line">    	<span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericMethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">MyGenericMethod</span> <span class="variable">mm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyGenericMethod</span>();</span><br><span class="line">        <span class="comment">// 演示看方法提示</span></span><br><span class="line">        mm.show(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        mm.show(<span class="number">123</span>);</span><br><span class="line">        mm.show(<span class="number">12.45</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 interface接口名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>例如，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyGenericInterface</span>&lt;E&gt;&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title function_">getE</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用格式：</p>
<p><strong>1、定义类时确定泛型的类型</strong></p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImp1</span> <span class="keyword">implements</span> <span class="title class_">MyGenericInterface</span>&lt;String&gt; &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String e)</span> &#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getE</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，泛型E的值就是String类型。</p>
<p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p>
<p> 例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImp2</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">MyGenericInterface</span>&lt;E&gt; &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       	 <span class="comment">// 省略...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> E <span class="title function_">getE</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确定泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyImp2&lt;String&gt;  my = <span class="keyword">new</span> <span class="title class_">MyImp2</span>&lt;String&gt;();  </span><br><span class="line">        my.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p>
<h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p>
<p>此时只能接受数据,不能往该集合中存储数据。</p>
<p>举个例子大家理解使用即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Collection&lt;Intger&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    getElement(list1);</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    getElement(list2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span>&#123;&#125;</span><br><span class="line"><span class="comment">//？代表可以接收任意类型</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>泛型不存在继承关系 Collection<Object> list &#x3D; new ArrayList<String>();这种是错误的。</p>
</blockquote>
<h4 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h4><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p>
<p><strong>泛型的上限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li>
</ul>
<p><strong>泛型的下限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li>
</ul>
<p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    Collection&lt;Number&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">    Collection&lt;Object&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">    </span><br><span class="line">    getElement(list1);</span><br><span class="line">    getElement(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement(list3);</span><br><span class="line">    getElement(list4);<span class="comment">//报错</span></span><br><span class="line">  </span><br><span class="line">    getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list3);</span><br><span class="line">    getElement2(list4);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement2</span><span class="params">(Collection&lt;? <span class="built_in">super</span> Number&gt; coll)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote class="blockquote-center" id="guard"></blockquote>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>等待唤醒机制</title>
    <url>/2020/04/21/java/%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p><strong>概念：</strong>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。</p>
<p>比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。</p>
<img data-src="/2020/04/21/java/%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.bmp" class="">

<p><strong>为什么要处理线程间通信：</strong></p>
<p>多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p>
<p><strong>如何保证线程间通信有效利用资源：</strong></p>
<p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— <strong>等待唤醒机制。</strong></p>
<h2 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h2><p><strong>什么是等待唤醒机制</strong></p>
<p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。</p>
<p>就是在一个线程进行了规定操作后，就进入等待状态（**wait()<strong>）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（</strong>notify()**）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。</p>
<p>wait&#x2F;notify 就是线程间的一种协作机制。</p>
<p><strong>等待唤醒中的方法</strong></p>
<p>等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p>
<ol>
<li>wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是“<strong>通知（notify）</strong>”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中</li>
<li>notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。</li>
<li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li>
</ol>
<blockquote>
<p>注意：</p>
<p>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p>
<p>总结如下：</p>
<ul>
<li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；</li>
<li>否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态</li>
</ul>
</blockquote>
<p><strong>调用wait和notify方法需要注意的细节</strong></p>
<ol>
<li>wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li>
<li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li>
<li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</li>
</ol>
<h2 id="生产者与消费者问题"><a href="#生产者与消费者问题" class="headerlink" title="生产者与消费者问题"></a>生产者与消费者问题</h2><p>等待唤醒机制其实就是经典的“生产者与消费者”的问题。</p>
<p>就拿生产包子消费包子来说等待唤醒机制如何有效利用资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">包子铺线程生产包子，吃货线程消费包子。</span><br><span class="line">  当包子没有时（包子状态为<span class="literal">false</span>），</span><br><span class="line">  吃货线程等待，</span><br><span class="line">  包子铺线程生产包子（即包子状态为<span class="literal">true</span>），</span><br><span class="line">  并通知吃货线程（解除吃货的等待状态）,</span><br><span class="line">因为已经有包子了，那么包子铺线程进入等待状态。</span><br><span class="line">  接下来，吃货线程能否进一步执行则取决于锁的获取情况。</span><br><span class="line">  如果吃货获取到锁，那么就执行吃包子动作，</span><br><span class="line">  包子吃完（包子状态为<span class="literal">false</span>），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。</span><br><span class="line">  包子铺线程能否进一步执行则取决于锁的获取情况。</span><br></pre></td></tr></table></figure>

<p><strong>代码演示：</strong></p>
<p>包子资源类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaoZi</span> &#123;</span><br><span class="line">     String  pier ;</span><br><span class="line">     String  xianer ;</span><br><span class="line">     <span class="type">boolean</span>  <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span> ;<span class="comment">//包子资源 是否存在  包子资源状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>吃货线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChiHuo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChiHuo</span><span class="params">(String name,BaoZi bz)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (bz)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bz.flag == <span class="literal">false</span>)&#123;<span class="comment">//没包子</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;吃货正在吃&quot;</span>+bz.pier+bz.xianer+<span class="string">&quot;包子&quot;</span>);</span><br><span class="line">                bz.flag = <span class="literal">false</span>;</span><br><span class="line">                bz.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包子铺线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaoZiPu</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaoZiPu</span><span class="params">(String name,BaoZi bz)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//造包子</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (bz)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bz.flag == <span class="literal">true</span>)&#123;<span class="comment">//包子资源  存在</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        bz.wait();</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 没有包子  造包子</span></span><br><span class="line">                System.out.println(<span class="string">&quot;包子铺开始做包子&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 冰皮  五仁</span></span><br><span class="line">                    bz.pier = <span class="string">&quot;冰皮&quot;</span>;</span><br><span class="line">                    bz.xianer = <span class="string">&quot;五仁&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 薄皮  牛肉大葱</span></span><br><span class="line">                    bz.pier = <span class="string">&quot;薄皮&quot;</span>;</span><br><span class="line">                    bz.xianer = <span class="string">&quot;牛肉大葱&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line"></span><br><span class="line">                bz.flag=<span class="literal">true</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;包子造好了：&quot;</span>+bz.pier+bz.xianer);</span><br><span class="line">                System.out.println(<span class="string">&quot;吃货来吃吧&quot;</span>);</span><br><span class="line">                <span class="comment">//唤醒等待线程 （吃货）</span></span><br><span class="line">                bz.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//等待唤醒案例</span></span><br><span class="line">        <span class="type">BaoZi</span> <span class="variable">bz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BaoZi</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ChiHuo</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChiHuo</span>(<span class="string">&quot;吃货&quot;</span>,bz);</span><br><span class="line">        <span class="type">BaoZiPu</span> <span class="variable">bzp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BaoZiPu</span>(<span class="string">&quot;包子铺&quot;</span>,bz);</span><br><span class="line"></span><br><span class="line">        ch.start();</span><br><span class="line">        bzp.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">包子铺开始做包子</span><br><span class="line">包子造好了：冰皮五仁</span><br><span class="line">吃货来吃吧</span><br><span class="line">吃货正在吃冰皮五仁包子</span><br><span class="line">包子铺开始做包子</span><br><span class="line">包子造好了：薄皮牛肉大葱</span><br><span class="line">吃货来吃吧</span><br><span class="line">吃货正在吃薄皮牛肉大葱包子</span><br><span class="line">包子铺开始做包子</span><br><span class="line">包子造好了：冰皮五仁</span><br><span class="line">吃货来吃吧</span><br><span class="line">吃货正在吃冰皮五仁包子</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>线程</title>
    <url>/2020/04/21/java/%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="多线程的原理"><a href="#多线程的原理" class="headerlink" title="多线程的原理"></a>多线程的原理</h2><img data-src="/2020/04/21/java/%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="" alt="线程流程图">

<p>程序启动运行main时候，java虚拟机启动一个进程，主线程main在main（）调用时候被创建。</p>
<p>随着调用mt的对象的start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。</p>
<p>通过这张图我们可以很清晰的看到多线程的执行流程，那么为什么可以完成并发执行呢？</p>
<p>我们再来讲一讲原理。</p>
<p>多线程执行时，到底在内存中是如何运行的呢？以上个程序为例，进行图解说明：</p>
<p>多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。</p>
<p>进行方法的压栈和弹栈。</p>
<img data-src="/2020/04/21/java/%E7%BA%BF%E7%A8%8B/image-20200415155230943.png" class="" alt="image-20200415155230943">

<p>当执行线程的任务结束了，线程自动在栈内存中释放了。</p>
<p>但是当所有的执行线程都结束了，那么进程就结束了。</p>
<h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><p>构造方法：</p>
<ul>
<li><p><code>public Thread()</code>：分配一个新的线程对象。</p>
</li>
<li><p><code>public Thread(string name)</code>：分配一个指定名字的新的线程对象。</p>
</li>
<li><p><code>public Thread(Runnable target)</code>：分配一个带有指定目标新的线程对象。</p>
</li>
<li><p><code>public Thread(Runnable target,string name)</code>：分配一个带有指定目标新的线程对象并指定名字。</p>
</li>
</ul>
<p>常用方法：</p>
<ul>
<li><code>public String getName()</code>：获取当前线程名称</li>
<li><code>public void start()</code>：导致此线程开始执行；Java虚拟机调用此线程的run方法。</li>
<li><code>public void run()</code>：此线程要执行的任务在此处定义代码。</li>
<li><code>public static void sleep(long millis)</code>：使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）</li>
<li><code>public static Thread currentThread()</code>：返回对当前正在执行的线程对象的引用。</li>
</ul>
<h2 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h2><p>步骤：</p>
<ul>
<li>定义Runnable接口的实现类,并重写该接口的run()方法,该run()方法的方法体同样是该线程的线程执行体</li>
<li>创建Runnable实现类的实例,并以此实例作为Thread的target来创建Thread对象,该Thread对象才是真正的线程对象</li>
<li>调用线程对象的start()方法来启动线程</li>
</ul>
<p>通过实现Runnable接口，使得该类有了多线程类的特征run()方法是多线程程序的一个执行目标。</p>
<p>所有的多线程代码都在run方法里面。</p>
<p>Thread类实际上也是实现了Runnable接口的类。</p>
<p>在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target)构造出对象，然后调用Thread对象的start()方法来运行多线程代码。</p>
<p>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。</p>
<p>因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。</p>
<h2 id="Thread和Runnable的区别"><a href="#Thread和Runnable的区别" class="headerlink" title="Thread和Runnable的区别"></a>Thread和Runnable的区别</h2><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runnable接口的话，则很容易的实现资源共享。<br>总结：<br>实现Runnable接口比继承Thread类所具有的优势：</p>
<ul>
<li>适合多个相同的程序代码的线程去共享同一个资源。</li>
<li>可以避免Java中的单继承的局限性。</li>
<li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li>
<li>线程池只能放入实现Runnable或Callable类线程，不能直接放入继承Thread的类。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>线程安全</title>
    <url>/2020/04/21/java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。<br>以下将会以卖票作为示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread_Safe_Demo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//共100张票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在卖,第&quot;</span>+ticket+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;```</span><br><span class="line"></span><br><span class="line">在main方法中开启两个线程，同时抢<span class="number">100</span>张票：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line"><span class="type">Thread_Safe_Demo</span> <span class="variable">thread_safe_demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread_Safe_Demo</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(thread_safe_demo).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(thread_safe_demo).start();</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img data-src="/2020/04/21/java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/image-20200415161132979.png" class="" alt="image-20200415161132979">

<p>发现同一张票反复售卖，这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。</p>
<blockquote>
<p>线程安全问题都是由全局变量及静态变量引起的。</p>
<p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；</p>
<p>若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p>
</blockquote>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。</p>
<p>要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制(synchronized)来解决。</p>
<p>为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。</p>
<p>那么怎么去使用呢？有三种方式完成同步操作：</p>
<ul>
<li>同步代码块</li>
<li>同步方法</li>
<li>锁机制</li>
</ul>
<h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><ul>
<li><p>同步代码块： synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</p>
</li>
<li><p>格式:</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">		需要同步操作的代码</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>同步锁：</p>
<p>对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁.</p>
<ul>
<li>锁对象 可以是任意类型。</li>
<li>多个线程对象 要使用同一把锁。</li>
</ul>
<blockquote>
<p>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread_Safe_Demo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在卖,第&quot;</span>+ticket+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                        ticket--;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，第一次的问题得以解决。</p>
<h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p>同步方法:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">	可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>同步锁是谁?<br>对于非static方法,同步锁就是this。<br>对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。</p>
</blockquote>
<p>使用同步方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread_Safe_Demo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="comment">//使用代码同步方法实现线程同步控制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">payTicket</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在卖,第&quot;</span>+ticket+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    payTicket();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2><p><code>java.util.concurrent.locks.Lock</code> 机制提供了比<code>synchronized</code>代码块和<code>synchronized</code>方法更广泛的锁定操作,同步代码块&#x2F;同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。<br>Lock锁也称同步锁，加锁与释放锁方法化了，如下：</p>
<ul>
<li><code>public void lock()</code> :加同步锁。</li>
<li><code>public void unlock()</code> :释放同步锁。</li>
</ul>
<p>使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread_Safe_Demo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在卖,第&quot;</span>+ticket+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2020/04/21/java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="线程池思想概述"><a href="#线程池思想概述" class="headerlink" title="线程池思想概述"></a>线程池思想概述</h2><img data-src="/2020/04/21/java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E6%B8%B8%E6%B3%B3%E6%B1%A0.jpg" class="">

<p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：</p>
<p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>
<p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</p>
<p>在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池。</p>
<h2 id="线程池概念"><a href="#线程池概念" class="headerlink" title="线程池概念"></a>线程池概念</h2><ul>
<li><strong>线程池：</strong>其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li>
</ul>
<p>由于线程池中有很多操作都是与优化资源相关的，我们在这里就不多赘述。我们通过一张图来了解线程池的工作原理：</p>
<img data-src="/2020/04/21/java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86.bmp" class="">

<p>合理利用线程池能够带来三个好处：</p>
<ol>
<li>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li>
<li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li>
</ol>
<h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p>
<p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code>java.util.concurrent.Executors</code>线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。</p>
<p>Executors类中有个创建线程池的方法如下：</p>
<ul>
<li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)</li>
</ul>
<p>获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：</p>
<ul>
<li><p><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</p>
<blockquote>
<p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。</p>
</blockquote>
</li>
</ul>
<p>使用线程池中线程对象的步骤：</p>
<ol>
<li>创建线程池对象。</li>
<li>创建Runnable接口子类对象。(task)</li>
<li>提交Runnable接口子类对象。(take task)</li>
<li>关闭线程池(一般不做)。</li>
</ol>
<p>Runnable实现类代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我要一个教练&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;教练来了： &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;教我游泳,交完后，教练回到了游泳池&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);<span class="comment">//包含2个线程对象</span></span><br><span class="line">        <span class="comment">// 创建Runnable实例对象</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自己创建线程对象的方式</span></span><br><span class="line">        <span class="comment">// Thread t = new Thread(r);</span></span><br><span class="line">        <span class="comment">// t.start(); ---&gt; 调用MyRunnable中的run()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从线程池中获取线程对象,然后调用MyRunnable中的run()</span></span><br><span class="line">        service.submit(r);</span><br><span class="line">        <span class="comment">// 再获取个线程对象，调用MyRunnable中的run()</span></span><br><span class="line">        service.submit(r);</span><br><span class="line">        service.submit(r);</span><br><span class="line">        <span class="comment">// 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。</span></span><br><span class="line">        <span class="comment">// 将使用完的线程又归还到了线程池中</span></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        <span class="comment">//service.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>线程状态</title>
    <url>/2020/04/21/java/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<h2 id="线程状态概述"><a href="#线程状态概述" class="headerlink" title="线程状态概述"></a>线程状态概述</h2><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，有几种状态呢？在API中 <code>java.lang.Thread.State</code> 这个枚举中给出了六种线程状态：<br>这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析</p>
<table>
<thead>
<tr>
<th><strong>线程状态</strong></th>
<th><strong>导致状态发生条件</strong></th>
</tr>
</thead>
<tbody><tr>
<td>NEW(新建)</td>
<td>线程刚被创建，但是并未启动。还没调用start方法。</td>
</tr>
<tr>
<td>Runnable(可运行)</td>
<td>线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。</td>
</tr>
<tr>
<td>Blocked(锁阻塞)</td>
<td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。</td>
</tr>
<tr>
<td>Waiting(无限等待)</td>
<td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。</td>
</tr>
<tr>
<td>Timed Waiting(计时等待)</td>
<td>同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。</td>
</tr>
<tr>
<td>Teminated(被终止)</td>
<td>因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</td>
</tr>
</tbody></table>
<p>我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几个状态呢，新建与被终止还是很容易理解的，我们就研究一下线程从Runnable（可运行）状态与非运行状态之间<br>的转换问题。</p>
<img data-src="/2020/04/21/java/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE.png" class="" alt="线程状态图">

<h2 id="Timed-Waiting（计时等待）"><a href="#Timed-Waiting（计时等待）" class="headerlink" title="Timed Waiting（计时等待）"></a>Timed Waiting（计时等待）</h2><p>Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。单独的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？</p>
<p>在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。</p>
<p>其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等待)，那么我们通过一个案例加深对该状态的一个理解。</p>
<p>实现一个计数器，计数到100，在每个数字之间暂停1秒，每隔10个数字输出一个字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTimedWaiting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span> ; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">10</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过案例可以发现，sleep方法的使用还是很简单的。我们需要记住下面几点：</p>
<blockquote>
<p>进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协<br>作关系。</p>
<p>为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程<br>中会睡眠</p>
<p>sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。</p>
</blockquote>
<blockquote>
<p> sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。</p>
</blockquote>
<img data-src="/2020/04/21/java/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/%E8%AE%A1%E6%97%B6%E7%AD%89%E5%BE%85.png" class="" alt="计时等待">

<h2 id="BLOCKED（锁阻塞）"><a href="#BLOCKED（锁阻塞）" class="headerlink" title="BLOCKED（锁阻塞）"></a>BLOCKED（锁阻塞）</h2><p>Blocked状态在API中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。</p>
<p>我们已经知道同步机制，那么这个状态是非常好理解的了。比如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。</p>
<img data-src="/2020/04/21/java/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/%E9%94%81%E9%98%BB%E5%A1%9E.png" class="" alt="锁阻塞">

<h2 id="Waiting（无限等待）"><a href="#Waiting（无限等待）" class="headerlink" title="Waiting（无限等待）"></a>Waiting（无限等待）</h2><p>Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestWaiting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 演示waiting</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println( Thread.currentThread().getName() +<span class="string">&quot;=== 获取到锁对象，调用wait方法，进入waiting状态，释放锁对象&quot;</span>);</span><br><span class="line">                            obj.wait(); <span class="comment">//无限等待</span></span><br><span class="line">                            <span class="comment">//obj.wait(5000);</span></span><br><span class="line">                            <span class="comment">// 计时等待, 5秒 时间到，自动醒来</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println( Thread.currentThread().getName() + <span class="string">&quot;=== 从waiting状态醒来，获取到锁对象，继续执行了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;等待线程&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// while (true)&#123; //每隔3秒 唤醒一次</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println( Thread.currentThread().getName() +<span class="string">&quot;‐‐‐‐‐ 等待3秒钟&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                    System.out.println( Thread.currentThread().getName() +<span class="string">&quot;‐‐‐‐‐ 获取到锁对象,调用notify方法，释放锁对象&quot;</span>);</span><br><span class="line">                            obj.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">        &#125;,<span class="string">&quot;唤醒线程&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的Object.notify()方法 或 Object.notifyAll()方法。</p>
<p>其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司里你和你的同事们，你们可能存在晋升时的竞<br>争，但更多时候你们更多是一起合作以完成某些任务。</p>
<p>当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用notify()方法，那么就会将无限等待的A线程唤醒。</p>
<p>注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。</p>
<img data-src="/2020/04/21/java/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/%E6%97%A0%E9%99%90%E7%AD%89%E5%BE%85.png" class="" alt="无限等待">



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>继承</title>
    <url>/2020/04/03/java/%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。如图所示：</p>
<img data-src="/2020/04/03/java/%E7%BB%A7%E6%89%BF/image-20200406161705307.png" class="" alt="image-20200406161705307">

<p>其中，多个类可以称为<strong>子类</strong>，单独那一个类称为<strong>父类、超类（superclass）</strong>或者<strong>基类</strong>。</p>
<p>继承描述的是事物之间的所属关系，这种关系是：<code>is-a</code>的关系。例如，图中兔子属于食草动物，食草动物属于动物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li><strong>继承</strong>：就是子类继承父类的<strong>属性和行为</strong>，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的<strong>非私有</strong>的属性和行为。</li>
</ul>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ol>
<li>提高<strong>代码的复用性</strong>（共性抽取）</li>
<li>类与类之间产生了关系，是<strong>多态的前提</strong>（没有继承，就没有多态）</li>
</ol>
<img data-src="/2020/04/03/java/%E7%BB%A7%E6%89%BF/01-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png" class="" alt="01-继承的基本概念">

<h2 id="继承的格式"><a href="#继承的格式" class="headerlink" title="继承的格式"></a>继承的格式</h2><ul>
<li><p>通过<code>extends</code>关键字，可以声明一个子类继承另外一个父类</p>
</li>
<li><p>格式</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 父类&#123;</span><br><span class="line">  <span class="comment">// 代码</span></span><br><span class="line">&#125;</span><br><span class="line">class 子类 extends 父类&#123;</span><br><span class="line">  <span class="comment">// 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.lectures();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lectures</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在给学生讲课&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承后的特点–成员变量"><a href="#继承后的特点–成员变量" class="headerlink" title="继承后的特点–成员变量"></a>继承后的特点–成员变量</h2><h3 id="成员变量不重名"><a href="#成员变量不重名" class="headerlink" title="成员变量不重名"></a>成员变量不重名</h3><p>如果子类父类中出现不重名的成员变量，这时的访问是没有影响的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Fu</span> <span class="variable">fu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fu</span>();</span><br><span class="line">        System.out.println(fu.numfu);</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">        System.out.println(zi.mumzi+<span class="string">&quot;:&quot;</span>+zi.numfu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numfu</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mumzi</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="成员变量重名"><a href="#成员变量重名" class="headerlink" title="成员变量重名"></a>成员变量重名</h3><p>子类父类中出现重名的成员变量，访问有两种方式</p>
<ol>
<li>直接通过子类对象访问成员变量<ul>
<li>规则：等号左边是谁，就优先用谁，如果没有则向上找</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Fu</span> <span class="variable">fu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fu</span>();</span><br><span class="line">        System.out.println(fu.num); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">        System.out.println(zi.num); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>简介通过成员方法访问成员变量<ul>
<li>该方法属于谁，就优先用谁，没有则想上找</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Fu</span> <span class="variable">fu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fu</span>();</span><br><span class="line">        fu.methodFu(); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">        zi.methodZi(); <span class="comment">// 10</span></span><br><span class="line">        zi.methodFu(); <span class="comment">// 100</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodFu</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodZi</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="区分子类方法中重名的三种变量"><a href="#区分子类方法中重名的三种变量" class="headerlink" title="区分子类方法中重名的三种变量"></a>区分子类方法中重名的三种变量</h3><ul>
<li>成员变量</li>
<li>本类的成员变量</li>
<li>父类的成员变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">        zi.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        System.out.println(num); <span class="comment">// 局部变量</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.num); <span class="comment">// 本类的成员变量</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.num); <span class="comment">// 父类的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承后的特点–成员方法"><a href="#继承后的特点–成员方法" class="headerlink" title="继承后的特点–成员方法"></a>继承后的特点–成员方法</h2><p>在父子类的继承关系中，创建子类对象，访问成员方法的规则：</p>
<ul>
<li>创建的对象是谁，就优先用谁，如果没有则想上找</li>
<li>无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类的</li>
</ul>
<h3 id="成员方法不重名"><a href="#成员方法不重名" class="headerlink" title="成员方法不重名"></a>成员方法不重名</h3><p>如果子类父类中出现不重名的成员方法，这时的调用是没有影响的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">        zi.method1();</span><br><span class="line">        zi.method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="成员方法重名–重写（Override）"><a href="#成员方法重名–重写（Override）" class="headerlink" title="成员方法重名–重写（Override）"></a>成员方法重名–重写（Override）</h3><p>如果子类父类中出现重名的成员方法，这时的访问是一种特殊情况，叫做<strong>方法重写（Override）</strong></p>
<ul>
<li><strong>方法重写</strong>：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。<strong>声明不变，重新实现。</strong></li>
<li><code> @Override</code> 是可选的注解，如果不写，满足要求也是正确的方法覆盖重写</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">        zi.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>子类方法覆盖父类方法，必须要保证权限<strong>大于等于</strong>父类权限</li>
<li>子类方法覆盖父类方法，返回值类型必须<strong>小于等于</strong>父类方法的返回值范围</li>
<li>子类方法覆盖父类方法，函数名和参数列表都要一模一样</li>
</ul>
<h2 id="继承后的特点–构造方法"><a href="#继承后的特点–构造方法" class="headerlink" title="继承后的特点–构造方法"></a>继承后的特点–构造方法</h2><p>构造方法的定义格式和作用</p>
<ul>
<li>构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。</li>
<li>构造方法的作用是初始化成员变量的。<ul>
<li>所以子类的初始化过程中，必须先执行父类的初始化动作。</li>
<li>子类的构造方法中默认有一个<code>super()</code>，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。</li>
<li>就算没有写<code>super()</code>，也会自动调用父类的构造方法</li>
<li>子类构造可以通过<code>super()</code>关键字来电泳父类重载构造</li>
<li><code>super</code>的父类构造调用，必须是子类构造方法的第一个语句</li>
<li>不能一个子类构造调用多次<code>super</code>构造</li>
</ul>
</li>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">      	<span class="comment">// Fu()</span></span><br><span class="line">				<span class="comment">// Zi()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    Fu() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Fu()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    Zi() &#123;</span><br><span class="line">      <span class="comment">// super(); 调用父类构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Zi()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="super关键字的三种用法和this关键字的三种用法"><a href="#super关键字的三种用法和this关键字的三种用法" class="headerlink" title="super关键字的三种用法和this关键字的三种用法"></a>super关键字的三种用法和this关键字的三种用法</h2><ol>
<li><p>super</p>
<ol>
<li>在子类的成员方法中，调用父类的成员变量</li>
<li>在子类的成员方法在，嗲用父类的成员方法</li>
<li>在子类的构造方法中，方法父类的构造方法</li>
</ol>
</li>
<li><p>this</p>
<ol>
<li>在本类的成员方法中，访问本类的成员变量</li>
<li>在本类的成员方法中，访问本类的另一个成员方法</li>
<li>在本类的构造方法中，访问本类的另一个构造方法</li>
</ol>
</li>
<li><p>注意事项</p>
<ol>
<li>this()和super()调用都必须是构造方法的第一个语句，唯一一个</li>
<li>super和this两种构造调用，不能同时使用</li>
</ol>
</li>
</ol>
<h2 id="super和this图解"><a href="#super和this图解" class="headerlink" title="super和this图解"></a>super和this图解</h2><img data-src="/2020/04/03/java/%E7%BB%A7%E6%89%BF/03-super%E4%B8%8Ethis%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png" class="" alt="03-super与this的内存图">

<h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul>
<li>Java只支持单继承，不支持多继承</li>
<li>Java语言可以多继承</li>
<li>一个子类的直接父类是唯一的，但是一个父类可以拥有多个子类</li>
<li>顶层父类是Object类，所有的类默认继承Object，作为父类</li>
</ul>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义异常</title>
    <url>/2020/04/21/java/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>为什么需要自定义异常类:</strong></p>
<p>我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。</p>
<p>在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？</p>
<p><strong>什么是自定义异常类:</strong></p>
<p>在开发中根据自己业务的异常情况来定义异常类.</p>
<p>自定义一个业务逻辑异常: <strong>RegisterException</strong>。一个注册异常类。</p>
<p><strong>异常类如何定义:</strong></p>
<ol>
<li>自定义一个编译期异常: 自定义类 并继承于<code>java.lang.Exception</code>。</li>
<li>自定义一个运行时期的异常类:自定义类 并继承于<code>java.lang.RuntimeException</code>。</li>
</ol>
<h2 id="自定义异常的练习"><a href="#自定义异常的练习" class="headerlink" title="自定义异常的练习"></a>自定义异常的练习</h2><p>要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。</p>
<p>首先定义一个登陆异常类RegisterException：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 业务逻辑异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegisterException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空参构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RegisterException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 表示异常提示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RegisterException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟数据库中已存在账号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] names = &#123;<span class="string">&quot;bill&quot;</span>,<span class="string">&quot;hill&quot;</span>,<span class="string">&quot;jill&quot;</span>&#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;     </span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">              <span class="comment">// 可能出现异常的代码</span></span><br><span class="line">            checkUsername(<span class="string">&quot;nill&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;注册成功&quot;</span>);<span class="comment">//如果没有异常就是注册成功</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(RegisterException e)&#123;</span><br><span class="line">            <span class="comment">//处理异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前注册账号是否存在</span></span><br><span class="line">    <span class="comment">//因为是编译期异常，又想调用者去处理 所以声明该异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkUsername</span><span class="params">(String uname)</span> <span class="keyword">throws</span> LoginException&#123;</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            <span class="keyword">if</span>(name.equals(uname))&#123;<span class="comment">//如果名字在这里面 就抛出登陆异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RegisterException</span>(<span class="string">&quot;亲&quot;</span>+name+<span class="string">&quot;已经被注册了！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>获取ip</title>
    <url>/2019/04/06/java/%E8%8E%B7%E5%8F%96ip/</url>
    <content><![CDATA[<p>util</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.apache.commons.lang3.StringUtils;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.UnknownHostException;</span><br><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class IpUtil &#123;</span><br><span class="line"></span><br><span class="line">    public final static String ERROR_IP = &quot;127.0.0.1&quot;;</span><br><span class="line"></span><br><span class="line">    public final static Pattern pattern = Pattern.</span><br><span class="line">            compile(&quot;(2[5][0-5]|2[0-4]\\d|1\\d&#123;2&#125;|\\d&#123;1,2&#125;)\\.(25[0-5]|2[0-4]\\d|1\\d&#123;2&#125;|\\d&#123;1,2&#125;)\\.(25[0-5]|2[0-4]\\d|1\\d&#123;2&#125;|\\d&#123;1,2&#125;)\\.(25[0-5]|2[0-4]\\d|1\\d&#123;2&#125;|\\d&#123;1,2&#125;)&quot;);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 取外网IP</span><br><span class="line">     *</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String getRemoteIp(HttpServletRequest request) &#123;</span><br><span class="line">        String ip = request.getHeader(&quot;x-real-ip&quot;);</span><br><span class="line">        if (ip == null) &#123;</span><br><span class="line">            ip = request.getRemoteAddr();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //过滤反向代理的ip</span><br><span class="line">        String[] stemps = ip.split(&quot;,&quot;);</span><br><span class="line">        if (stemps != null &amp;&amp; stemps.length &gt;= 1) &#123;</span><br><span class="line">            //得到第一个IP，即客户端真实IP</span><br><span class="line">            ip = stemps[0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ip = ip.trim();</span><br><span class="line">        if (ip.length() &gt; 23) &#123;</span><br><span class="line">            ip = ip.substring(0, 23);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取用户的真实ip</span><br><span class="line">     *</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String getUserIP(HttpServletRequest request) &#123;</span><br><span class="line"></span><br><span class="line">        // 优先取X-Real-IP</span><br><span class="line">        String ip = request.getHeader(&quot;X-Real-IP&quot;);</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;x-forwarded-for&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getRemoteAddr();</span><br><span class="line">            if (&quot;0:0:0:0:0:0:0:1&quot;.equals(ip)) &#123;</span><br><span class="line">                ip = ERROR_IP;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (&quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = ERROR_IP;</span><br><span class="line">            return ip;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int pos = ip.indexOf(&#x27;,&#x27;);</span><br><span class="line">        if (pos &gt;= 0) &#123;</span><br><span class="line">            ip = ip.substring(0, pos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getLastIpSegment(HttpServletRequest request) &#123;</span><br><span class="line">        String ip = getUserIP(request);</span><br><span class="line">        if (ip != null) &#123;</span><br><span class="line">            ip = ip.substring(ip.lastIndexOf(&#x27;.&#x27;) + 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ip = &quot;0&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean isValidIP(HttpServletRequest request) &#123;</span><br><span class="line">        String ip = getUserIP(request);</span><br><span class="line">        return isValidIP(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断我们获取的ip是否是一个符合规则ip</span><br><span class="line">     *</span><br><span class="line">     * @param ip</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean isValidIP(String ip) &#123;</span><br><span class="line">        if (StringUtils.isEmpty(ip)) &#123;</span><br><span class="line">            log.debug(&quot;ip is null. valid result is false&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Matcher matcher = pattern.matcher(ip);</span><br><span class="line">        boolean isValid = matcher.matches();</span><br><span class="line">        log.debug(&quot;valid ip:&quot; + ip + &quot; result is: &quot; + isValid);</span><br><span class="line">        return isValid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getLastServerIpSegment() &#123;</span><br><span class="line">        String ip = getServerIP();</span><br><span class="line">        if (ip != null) &#123;</span><br><span class="line">            ip = ip.substring(ip.lastIndexOf(&#x27;.&#x27;) + 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ip = &quot;0&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getServerIP() &#123;</span><br><span class="line">        InetAddress inet;</span><br><span class="line">        try &#123;</span><br><span class="line">            inet = InetAddress.getLocalHost();</span><br><span class="line">            String hostAddress = inet.getHostAddress();</span><br><span class="line">            return hostAddress;</span><br><span class="line">        &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;127.0.0.1&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符</title>
    <url>/2020/03/07/java/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>运算符：进行特定操作的符号。如：+</p>
<p>表达式：用运算符连起来的式子。如：a + b</p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><table>
<thead>
<tr>
<th>算术运算符：</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>加法运算，字符串连接运算</td>
</tr>
<tr>
<td><code>-</code></td>
<td>减法运算</td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘法运算</td>
</tr>
<tr>
<td><code>/</code></td>
<td>除法运算</td>
</tr>
<tr>
<td><code>%</code></td>
<td>取模运算，两个数字相除取余数</td>
</tr>
<tr>
<td><code>++</code></td>
<td>自增运算</td>
</tr>
<tr>
<td><code>--</code></td>
<td>自减运算</td>
</tr>
</tbody></table>
<ul>
<li>两个常量之间可以进行数学运算</li>
<li>两个变量之家也可以进行数学运算</li>
<li>变量和常量之间可以混合运算</li>
<li>变量和常量之间可以混合使用</li>
<li>除法用的是整除，整数除以整数，结果也是整数，只看商，不看余数</li>
<li>取模运算:取的余数（只是对于整数的除法来说，取模运算符才有余数的意义）</li>
<li>一旦运算当中又不同类型的数据，那么结果将会是数据类型范围大的</li>
<li>对于<strong>char</strong>类型来说，在计算之前，<strong>char</strong>会被提升为<strong>int</strong>，然后再计算</li>
<li><strong>char</strong>类型字符和<strong>int</strong>类型数字之间的对照关系表：ASCII、Unicode</li>
<li>对于字符串String(首字母大写,并不是关键字)来说，<strong>加号代表字符串连接操作</strong><ul>
<li>字符串类型的变量基本使用</li>
<li>数据类型 变量名称 &#x3D; 数据值;</li>
</ul>
</li>
<li>优先级：小括号优先一切</li>
<li>自增、自减运算符：++、–<ul>
<li>基本含义：让一个变量加一个1或者让一个变量减一个1</li>
<li>使用方法：<ul>
<li>单独使用：不和其他任何操作混合，自己独立成一个步骤</li>
<li>混合使用：和其他操作混合，例如与赋值混合或者打印操作混合，等</li>
</ul>
</li>
<li>使用区别：<ul>
<li>再单独使用的时候，**前++<strong>和后</strong>++**没有任何区别</li>
<li>再混合使用的时候<ul>
<li>如果是<strong>【前++】</strong>，那么变量<strong>【立刻加1】</strong>，然后拿着结果进行使用。<strong>【先加后用】</strong></li>
<li>如果是【后++】，那么首先使用变量本来的数值，<strong>【然后再让变量+1】</strong>。<strong>【先用后加】</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>注意事项：<ul>
<li>只有变量才能使用自增、自减运算符。常量不可发生改变，所以不能用。</li>
<li><strong>byte，short，char</strong>在运算的过程中会强制转换成<strong>int</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArithmeticOperators</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">		<span class="comment">// 两个常量之间可以进行数学运算</span></span><br><span class="line">		System.out.println(<span class="number">10</span> + <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 两个变量之家也可以进行数学运算</span></span><br><span class="line">		System.out.println(a - b); <span class="comment">// -10</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 变量和常量之间可以混合运算</span></span><br><span class="line">		System.out.println(a * b); <span class="comment">// 200</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 变量和常量之间可以混合使用</span></span><br><span class="line">		<span class="comment">// 除法用的是整除，整数除以整数，结果也是整数，只看商，不看余数</span></span><br><span class="line">		System.out.println(a / <span class="number">20</span>); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 取模运算:取的余数（只是对于整数的除法来说，取模运算符才有余数的意义）</span></span><br><span class="line">		System.out.println(a % b); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 一旦运算当中又不同类型的数据，那么结果将会是数据类型范围大的</span></span><br><span class="line">		<span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">30.5</span>;</span><br><span class="line">		System.out.println(b + c); <span class="comment">// 50.5</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 对于char类型来说，在计算之前，char会被提升为int，然后再计算</span></span><br><span class="line">		<span class="comment">// char类型字符和int类型数字之间的对照关系表：ASCII、Unicode</span></span><br><span class="line">		<span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">		System.out.println(d + c); <span class="comment">//95.5</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 对于字符串String(首字母大写,并不是关键字)来说，加号代表字符串连接操作</span></span><br><span class="line">		<span class="comment">// 字符串类型的变量基本使用</span></span><br><span class="line">		<span class="comment">// 数据类型 变量名称 = 数据值;</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">		System.out.println(e + <span class="number">10</span>); <span class="comment">//Hello10</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//优先级：小括号优先一切</span></span><br><span class="line">		System.out.println(e + <span class="number">10</span> + <span class="number">20</span>); <span class="comment">//Hello1020</span></span><br><span class="line">		System.out.println(e + (<span class="number">10</span> + <span class="number">20</span>)); <span class="comment">//Hello30</span></span><br><span class="line">		System.out.println(<span class="number">10</span> + <span class="number">20</span> + e); <span class="comment">//30Hello</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//自增运算符：++</span></span><br><span class="line">		<span class="comment">//自减运算符：--</span></span><br><span class="line">		<span class="comment">//基本含义：让一个变量加一个1或者让一个变量减一个1</span></span><br><span class="line">		<span class="comment">//使用方法：</span></span><br><span class="line">		<span class="comment">//	1. 单独使用：不和其他任何操作混合，自己独立成一个步骤</span></span><br><span class="line">		<span class="comment">//	2. 混合使用：和其他操作混合，例如与赋值混合或者打印操作混合，等</span></span><br><span class="line">		<span class="comment">//使用区别：</span></span><br><span class="line">		<span class="comment">//	1. 再单独使用的时候，前++和后++没有任何区别</span></span><br><span class="line">		<span class="comment">//	2. 再混合使用的时候</span></span><br><span class="line">		<span class="comment">//		- 如果是【前++】，那么变量【立刻加1】，然后拿着结果进行使用。【先加后用】</span></span><br><span class="line">		<span class="comment">//		- 如果是【后++】，那么首先使用变量本来的数值，【然后再让变量+1】。【先用后加】</span></span><br><span class="line">		<span class="comment">//注意事项：</span></span><br><span class="line">		<span class="comment">//	只有变量才能使用自增、自减运算符。常量不可发生改变，所以不能用。</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		f++;</span><br><span class="line">		System.out.println(f); <span class="comment">// 11</span></span><br><span class="line">		++f;</span><br><span class="line">		System.out.println(f); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">g</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		System.out.println(g++); <span class="comment">// 10</span></span><br><span class="line">		System.out.println(++g); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h--;</span><br><span class="line">		System.out.println(i); <span class="comment">// 10</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> --h;</span><br><span class="line">		System.out.println(j); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//30++; // 异常</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// byte，short，char在运算的过程中会强制转换成int</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//byte m = k + l; // 异常</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> k + i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table>
<thead>
<tr>
<th>赋值运算符：</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td>等于号</td>
</tr>
<tr>
<td><code>+=</code></td>
<td>加等于</td>
</tr>
<tr>
<td><code>-=</code></td>
<td>减等于</td>
</tr>
<tr>
<td><code>*=</code></td>
<td>乘等于</td>
</tr>
<tr>
<td><code>/=</code></td>
<td>除等于</td>
</tr>
<tr>
<td><code>%=</code></td>
<td>取模等</td>
</tr>
</tbody></table>
<ul>
<li><p>赋值运算符：就是将符号右边的值，赋给左边的变量。</p>
<ul>
<li>基本赋值运算符：就是一个等号”&#x3D;”，代表将右侧的数据交给左侧的变量。<ul>
<li><code>int a = 30;</code></li>
</ul>
</li>
<li>复合赋值运算符：<ul>
<li><code>+=	a += 1	相当于	a = a + 1</code></li>
<li><code>-=	a -= 1	相当于	a = a - 1</code></li>
<li><code>*=	a *= 1	相当于	a = a * 1</code></li>
<li><code>/=	a /= 1	相当于	a = a / 1</code></li>
<li><code>%=	a %= 1	相当于	a = a % 1</code></li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li>只有变量才能使用赋值运算符，常量不能进行赋值</li>
<li>复合赋值运算符其中隐含了一个强制类型转换</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AssignmentOperator</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		a += <span class="number">3</span>;</span><br><span class="line">		System.out.println(a); <span class="comment">// 13</span></span><br><span class="line"></span><br><span class="line">		a = <span class="number">10</span>;</span><br><span class="line">		a -= <span class="number">3</span>;</span><br><span class="line">		System.out.println(a); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">		a = <span class="number">10</span>;</span><br><span class="line">		a *= <span class="number">3</span>;</span><br><span class="line">		System.out.println(a); <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line">		a = <span class="number">10</span>;</span><br><span class="line">		a /= <span class="number">3</span>;</span><br><span class="line">		System.out.println(a); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">		a = <span class="number">10</span>;</span><br><span class="line">		a %= <span class="number">3</span>;</span><br><span class="line">		System.out.println(a); <span class="comment">// 1</span></span><br><span class="line">		<span class="comment">//强制类型转换</span></span><br><span class="line">		<span class="type">byte</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		num += <span class="number">5</span>;</span><br><span class="line">		<span class="type">byte</span> <span class="variable">num2</span> <span class="operator">=</span> num;</span><br><span class="line">		System.out.println(num2); <span class="comment">// 15</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><table>
<thead>
<tr>
<th>比较运算符：</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>==</code></td>
<td>比较符号两边数据是否相等，相等结果是true</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>比较符号左边的数据是否小于右边的数据，如果小于结果为true</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>比较符号左边的数据是否大于右边的数据，如果大于结果是true</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>比较符号左边的数据是否小于或者等于右边的数据，如果小于结果为true</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>比较符号左边的数据是否大于或者等于右边的数据，如果大于结果是true</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于服好，如果符号两边的数据不相等，结果为true</td>
</tr>
</tbody></table>
<ul>
<li>比较运算符，是两个数据之间进行比较的运算，运算结果都是布尔值<strong>true</strong>或者<strong>false</strong></li>
<li>两个常量之间可以进行比较运算</li>
<li>两个变量之家也可以进行比较运算</li>
<li>变量和常量之间可以比较运算</li>
<li>注意事项：<ul>
<li>不能连续使用，如果要连续使用，<strong>用逻辑运算符关联</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComparisonOperators</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">		System.out.println(<span class="number">2</span>==<span class="number">3</span>); <span class="comment">// false</span></span><br><span class="line">		System.out.println(<span class="number">2</span>&lt;b); <span class="comment">// true</span></span><br><span class="line">		System.out.println(a&gt;<span class="number">3</span>); <span class="comment">// false</span></span><br><span class="line">		System.out.println(a&lt;=b); <span class="comment">// true</span></span><br><span class="line">		System.out.println(a&gt;=<span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line">		System.out.println(a!=b); <span class="comment">// true</span></span><br><span class="line">		<span class="comment">//System.out.println(a&lt;b&lt;5);异常</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table>
<thead>
<tr>
<th>逻辑运算符：</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;&amp;</code>与（短路）</td>
<td>两边都是true，结果为true<br /> 一边为false，结果为false<br /> 短路特点：符号左边是false，右边不再运算</td>
</tr>
<tr>
<td>&#96;</td>
<td></td>
</tr>
<tr>
<td><code>!</code>非</td>
<td>!true结果是false<br /> !false结果是true</td>
</tr>
</tbody></table>
<ul>
<li>逻辑运算符，是用来连接两个布尔类型结果的运算符，运算结果都是布尔值<strong>true</strong>或者<strong>false</strong></li>
<li>与<code>&amp;&amp;</code>，或<code>||</code>，具有短路效果：如果根据左边已经可以判断得到最终结果，那么右边的代码将不再执行，从而节省一定的性能。</li>
<li>注意事项：<ul>
<li>逻辑运算符只能用于boolean值</li>
<li>与、或需要左右各自有一个boolean值，但是取反只要有唯一的boolean值即可</li>
<li>与、或两种运算符，如果有多个条件，可以连续写</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogicalOperators</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		System.out.println(<span class="literal">true</span> &amp;&amp; <span class="literal">false</span>); <span class="comment">// false</span></span><br><span class="line">		System.out.println(<span class="number">3</span>&lt;<span class="number">4</span> &amp;&amp; <span class="number">10</span>&gt;<span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="literal">true</span> || <span class="literal">false</span>); <span class="comment">// true</span></span><br><span class="line">		System.out.println(<span class="literal">true</span> || <span class="literal">true</span>); <span class="comment">// true</span></span><br><span class="line">		System.out.println(<span class="literal">false</span> || <span class="literal">false</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">		System.out.println(!<span class="literal">true</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		System.out.println(<span class="number">3</span>&gt;<span class="number">4</span> &amp;&amp; ++a&lt;<span class="number">100</span>); <span class="comment">// false</span></span><br><span class="line">		System.out.println(a); <span class="comment">// 10</span></span><br><span class="line">		System.out.println(<span class="number">4</span>&gt;<span class="number">3</span> || ++a&lt;<span class="number">100</span>); <span class="comment">// true</span></span><br><span class="line">		System.out.println(a); <span class="comment">// 10</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>一元运算符：只需要一个数据就可以进行操作的运算符。如：！、++、–</p>
<p>二元运算符：需要两个数据才可以进行进行操作的运算符。如：+、&#x3D;</p>
<p>三元运算符：需要三个数据才可以进行进行操作的运算符。</p>
<p>格式：</p>
<ul>
<li><code>数据类型 变量名称 = 条件判断 ? 表达式A : 表达式B</code></li>
</ul>
<p>流程：</p>
<ul>
<li>先判断条件是否成立：</li>
<li>如果成立为true，那么将表达式A的值赋值给左侧的变量</li>
<li>如果不成立为false，那么将表达式B的值赋值给左侧的变量</li>
</ul>
<p>注意事项：</p>
<ul>
<li>必须同时保证表达式A和表达式B都符合左侧数据类型的要求</li>
<li>三元运算符的结果必须被使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreePartOperator</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a &gt; b ? a : b;</span><br><span class="line">		System.out.println(max);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//错误写法</span></span><br><span class="line">		<span class="comment">//int result = 3 &gt; 4 ? 2.5 : 10;</span></span><br><span class="line">		<span class="comment">//a &gt; b ? a : b;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>选择语句</title>
    <url>/2020/03/12/java/%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><ul>
<li><strong>switch语句格式</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">  <span class="keyword">case</span> 常量值<span class="number">1</span>:</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 常量值<span class="number">2</span>:</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    语句体n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectAStatement</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span>(num)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;星期二&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;星期三&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;星期四&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;星期五&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;星期六&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;星期日&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;数据有误&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="switch的流程图"><a href="#switch的流程图" class="headerlink" title="switch的流程图"></a>switch的流程图</h3><ul>
<li>首先计算出表达式的值</li>
<li>其次和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到<strong>break</strong>就会结束</li>
<li>最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束</li>
</ul>
<img data-src="/2020/03/12/java/%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5/image-20200402150825436.png" class="" alt="image-20200402150825436">

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>多个case后面的数值不可以重复</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectAStatement</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">switch</span>(num)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">// 错误: case 标签重复</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>switch后面小括号当中只能是下列数据类型<ul>
<li>基本数据类型：byte&#x2F;short&#x2F;char&#x2F;int</li>
<li>引用数据类型：String（jdk1.7以后支持）、enum枚举</li>
</ul>
</li>
<li>switch语句格式可以很灵活：前后顺序可以颠倒，而且break语句还可以省略<ul>
<li>但是case的后面的break不写，会出现穿透现象，也就是不会再判断下一个case的值，直接向后运行，直到遇到break或者整体switch结束</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectAStatement</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">switch</span>(num)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;输出1&quot;</span>);</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:  </span><br><span class="line">				System.out.println(<span class="string">&quot;输出2&quot;</span>);</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;输出default&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 输出1</span></span><br><span class="line">		<span class="comment">// 输出2</span></span><br><span class="line">		<span class="comment">// 输出default</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/2020/04/21/java/%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p><strong>递归</strong>：指在当前方法内调用自己的这种现象。</p>
</li>
<li><p><strong>递归的分类:</strong></p>
<ul>
<li>递归分为两种，直接递归和间接递归。</li>
<li>直接递归称为方法自身调用自己。</li>
<li>间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。</li>
</ul>
</li>
<li><p><strong>注意事项</strong>：</p>
<ul>
<li>递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。</li>
<li>在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</li>
<li>构造方法，禁止递归</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01DiGui</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// a();</span></span><br><span class="line">		b(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 3.构造方法,禁止递归</span></span><br><span class="line"><span class="comment">	 * 编译报错:构造方法是创建对象使用的,不能让对象一直创建下去</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Demo01DiGui</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//Demo01DiGui();</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 2.在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</span></span><br><span class="line"><span class="comment">	 * 4993</span></span><br><span class="line"><span class="comment">	 * 	Exception in thread &quot;main&quot; java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">		System.out.println(i);</span><br><span class="line">		<span class="comment">//添加一个递归结束的条件,i==5000的时候结束</span></span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">5000</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span>;<span class="comment">//结束方法</span></span><br><span class="line">		&#125;</span><br><span class="line">		b(++i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 1.递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。 Exception in thread &quot;main&quot;</span></span><br><span class="line"><span class="comment">	 * java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;a方法&quot;</span>);</span><br><span class="line">		a();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归累加求和"><a href="#递归累加求和" class="headerlink" title="递归累加求和"></a>递归累加求和</h2><h3 id="计算1-n的和"><a href="#计算1-n的和" class="headerlink" title="计算1 ~ n的和"></a>计算1 ~ n的和</h3><p><strong>分析</strong>：num的累和 &#x3D; num + (num-1)的累和，所以可以把累和的操作定义成一个方法，递归调用。</p>
<p><strong>实现代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiGuiDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//计算1~num的和，使用递归完成</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">      	<span class="comment">// 调用求和的方法</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> getSum(num);</span><br><span class="line">      	<span class="comment">// 输出结果</span></span><br><span class="line">		System.out.println(sum);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="comment">/*</span></span><br><span class="line"><span class="comment">  	  通过递归算法实现.</span></span><br><span class="line"><span class="comment">  	  参数列表:int </span></span><br><span class="line"><span class="comment">  	  返回值类型: int </span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">      	<span class="comment">/* </span></span><br><span class="line"><span class="comment">      	   num为1时,方法返回1,</span></span><br><span class="line"><span class="comment">      	   相当于是方法的出口,num总有是1的情况</span></span><br><span class="line"><span class="comment">      	*/</span></span><br><span class="line">		<span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">          num不为1时,方法返回 num +(num-1)的累和</span></span><br><span class="line"><span class="comment">          递归调用getSum方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		<span class="keyword">return</span> num + getSum(num-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码执行图解"><a href="#代码执行图解" class="headerlink" title="代码执行图解"></a>代码执行图解</h3><img data-src="/2020/04/21/java/%E9%80%92%E5%BD%92/day08_01_%E9%80%92%E5%BD%92%E7%B4%AF%E5%92%8C.jpg" class="">

<blockquote>
<p>递归一定要有条件限定，保证递归能够停止下来，次数不要太多，否则会发生栈内存溢出。</p>
</blockquote>
<h2 id="递归求阶乘"><a href="#递归求阶乘" class="headerlink" title="递归求阶乘"></a>递归求阶乘</h2><ul>
<li><strong>阶乘</strong>：所有小于及等于该数的正整数的积。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n的阶乘：n! = n * (n-<span class="number">1</span>) *...* <span class="number">3</span> * <span class="number">2</span> * <span class="number">1</span> </span><br></pre></td></tr></table></figure>

<p><strong>分析</strong>：这与累和类似,只不过换成了乘法运算，学员可以自己练习，需要注意阶乘值符合int类型的范围。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">推理得出：n! = n * (n-1)!</span><br></pre></td></tr></table></figure>

<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiGuiDemo</span> &#123;</span><br><span class="line">  	<span class="comment">//计算n的阶乘，使用递归完成</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">      	<span class="comment">// 调用求阶乘的方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> getValue(n);</span><br><span class="line">      	<span class="comment">// 输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;阶乘为:&quot;</span>+ value);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">  	  通过递归算法实现.</span></span><br><span class="line"><span class="comment">  	  参数列表:int </span></span><br><span class="line"><span class="comment">  	  返回值类型: int </span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">      	<span class="comment">// 1的阶乘为1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">      	  n不为1时,方法返回 n! = n*(n-1)!</span></span><br><span class="line"><span class="comment">          递归调用getValue方法</span></span><br><span class="line"><span class="comment">      	*/</span></span><br><span class="line">        <span class="keyword">return</span> n * getValue(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归打印多级目录"><a href="#递归打印多级目录" class="headerlink" title="递归打印多级目录"></a>递归打印多级目录</h2><p><strong>分析</strong>：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiGuiDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">// 创建File对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\aaa&quot;</span>);</span><br><span class="line">      	<span class="comment">// 调用打印目录方法</span></span><br><span class="line">        printDir(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">printDir</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">      	<span class="comment">// 获取子文件和目录</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">      	<span class="comment">// 循环打印</span></span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">      	  判断:</span></span><br><span class="line"><span class="comment">      	  当是文件时,打印绝对路径.</span></span><br><span class="line"><span class="comment">      	  当是目录时,继续调用打印目录的方法,形成递归调用.</span></span><br><span class="line"><span class="comment">      	*/</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">    		<span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">              	<span class="comment">// 是文件,输出文件绝对路径</span></span><br><span class="line">                System.out.println(<span class="string">&quot;文件名:&quot;</span>+ file.getAbsolutePath());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">// 是目录,输出目录绝对路径</span></span><br><span class="line">                System.out.println(<span class="string">&quot;目录:&quot;</span>+file.getAbsolutePath());</span><br><span class="line">              	<span class="comment">// 继续遍历,调用printDir,形成递归</span></span><br><span class="line">                printDir(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象</title>
    <url>/2020/03/24/java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="面向对象思想概述"><a href="#面向对象思想概述" class="headerlink" title="面向对象思想概述"></a>面向对象思想概述</h2><p>Java语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，使用Java语言去设计、开发计算机程序。这里的<strong>对象</strong>泛指现实中一切事物，每种事物都具备自己的<strong>属性</strong>和<strong>行为</strong>。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算机事件的设计思想。它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。</p>
<p>面向对象和面向过程区别：</p>
<ul>
<li>面向过程：强调步骤</li>
<li>面向对象，强调对象</li>
</ul>
<p>特点：</p>
<ul>
<li>面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成了指挥者面向对象的语言中，包含了<strong>三大基本特征</strong>，即<strong>封装、继承和多态</strong>。</li>
</ul>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类"></a>什么是类</h3><ul>
<li><strong>类</strong>：是一组相关<strong>属性</strong>和<strong>行为</strong>的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。</li>
</ul>
<p>在先使用，描述一类事物：</p>
<ul>
<li><strong>属性</strong>：就是该事物的状态信息</li>
<li><strong>行为</strong>：就是该事物能够做什么</li>
</ul>
<h3 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h3><ul>
<li><strong>对象</strong>：是一类事物的具体体现。对象是类的一个实例（对象并不是找个女朋友），必然具备该类事物的属性和行为。</li>
</ul>
<h3 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h3><ul>
<li>类是对一类事物的描述，是<strong>抽象的</strong></li>
<li>对象是一类事物的实例，是<strong>具体的</strong></li>
<li><strong>类是对象的模板，对象是类的实体</strong></li>
</ul>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><h3 id="事物与类的对比"><a href="#事物与类的对比" class="headerlink" title="事物与类的对比"></a>事物与类的对比</h3><p>现实世界的一类事物：</p>
<ul>
<li><p><strong>属性</strong>：事物的状态信息</p>
</li>
<li><p><strong>行为</strong>：事物能够做什么</p>
</li>
</ul>
<p>Java中用class描述事物也是如此：</p>
<ul>
<li><p><strong>成员变量</strong>：对应事物的<strong>属性</strong></p>
</li>
<li><p><strong>成员方法</strong>：对应事物的<strong>行为</strong></p>
</li>
</ul>
<h3 id="类的定义格式"><a href="#类的定义格式" class="headerlink" title="类的定义格式"></a>类的定义格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;</span><br><span class="line">  <span class="comment">//成员变量</span></span><br><span class="line">  <span class="comment">//成员方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>定义类</strong>：就是定义类的成员，包括<strong>成员变量</strong>和<strong>成员方法</strong>。</p>
</li>
<li><p><strong>成员变量</strong>：和以前定义变量几乎是一样的。只不过位置发生了改变。<strong>在类中，方法外</strong>。</p>
</li>
<li><p><strong>成员方法</strong>：和以前定义方法几乎是一样的。只不过<strong>把static去掉</strong>，static的作用在面向对象后面课程中再详细讲解。</p>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">  <span class="comment">//成员变量</span></span><br><span class="line">  String name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//成员方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;好好学习&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h2><h3 id="对象的使用格式"><a href="#对象的使用格式" class="headerlink" title="对象的使用格式"></a>对象的使用格式</h3><ul>
<li>创建对象：</li>
</ul>
<p><code>类名 对象名 = new 类名();</code></p>
<ul>
<li>使用对象访问类中的成员:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象名.成员变量;</span><br><span class="line">对象名.成员方法();</span><br></pre></td></tr></table></figure>

<ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">  <span class="comment">//创建对象</span></span><br><span class="line">  <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">  <span class="comment">//获取成员变量</span></span><br><span class="line">  System.out.print(s.name);</span><br><span class="line">  <span class="comment">//给成员变量赋值</span></span><br><span class="line">  s.name = <span class="string">&quot;大黄&quot;</span>;</span><br><span class="line">  <span class="comment">//调用成员方法</span></span><br><span class="line">  s.study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="成员变量的默认值"><a href="#成员变量的默认值" class="headerlink" title="成员变量的默认值"></a>成员变量的默认值</h3><table>
<thead>
<tr>
<th></th>
<th>数据类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>基本类型</td>
<td>整数（byte、short、int、long）</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td>浮点数（float、double）</td>
<td>0.0</td>
</tr>
<tr>
<td></td>
<td>字符（char）</td>
<td>‘\u0000’</td>
</tr>
<tr>
<td></td>
<td>布尔（boolean）</td>
<td>false</td>
</tr>
<tr>
<td>引用类型</td>
<td>数组、类、接口</td>
<td>null</td>
</tr>
</tbody></table>
<h2 id="对象的内存图"><a href="#对象的内存图" class="headerlink" title="对象的内存图"></a>对象的内存图</h2><h3 id="只有一个对象的内存图"><a href="#只有一个对象的内存图" class="headerlink" title="只有一个对象的内存图"></a>只有一个对象的内存图</h3><img data-src="/2020/03/24/java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/01-%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png" class="" alt="01-只有一个对象的内存图">

<h3 id="两个对象使用同一个方法的内存图"><a href="#两个对象使用同一个方法的内存图" class="headerlink" title="两个对象使用同一个方法的内存图"></a>两个对象使用同一个方法的内存图</h3><img data-src="/2020/03/24/java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/02-%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png" class="" alt="02-两个对象使用同一个方法的内存图">

<h3 id="两个引用指向同一个对象的内存图"><a href="#两个引用指向同一个对象的内存图" class="headerlink" title="两个引用指向同一个对象的内存图"></a>两个引用指向同一个对象的内存图</h3><img data-src="/2020/03/24/java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/03-%E4%B8%A4%E4%B8%AA%E5%BC%95%E7%94%A8%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png" class="" alt="03-两个引用指向同一个对象的内存图">

<h3 id="使用对象类型作为方法的参数"><a href="#使用对象类型作为方法的参数" class="headerlink" title="使用对象类型作为方法的参数"></a>使用对象类型作为方法的参数</h3><img data-src="/2020/03/24/java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/04-%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0.png" class="" alt="04-使用对象类型作为方法的参数">

<h3 id="使用对象类型作为方法的返回值"><a href="#使用对象类型作为方法的返回值" class="headerlink" title="使用对象类型作为方法的返回值"></a>使用对象类型作为方法的返回值</h3><img data-src="/2020/03/24/java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/05-%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC.png" class="" alt="05-使用对象类型作为方法的返回值">

<h2 id="成员变量和局部变量区别"><a href="#成员变量和局部变量区别" class="headerlink" title="成员变量和局部变量区别"></a>成员变量和局部变量区别</h2><p>变量根据定义<strong>位置的不同</strong>，我们给变量起了不同的名字。</p>
<img data-src="/2020/03/24/java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20200404165047761.png" class="" alt="image-20200404165047761">

<ul>
<li>在类中的位置不同<ul>
<li>成员变量：类中，方法外</li>
<li>局部变量：方法中或者方法声明上（形式参数）</li>
</ul>
</li>
<li>作用范围不一样<ul>
<li>成员变量：类中</li>
<li>局部变量：方法中</li>
</ul>
</li>
<li>初始化值的不同<ul>
<li>成员变量：有默认值</li>
<li>局部变量：没有默认值。必须先定义，赋值，最后使用</li>
</ul>
</li>
<li>在内存中的位置不同<ul>
<li>成员变量：堆内存</li>
<li>局部变量：栈内存</li>
</ul>
</li>
<li>生命周期不同<ul>
<li>成员变量：随着对象的创建而存在，随着对象的消失而消失</li>
<li>局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序结构</title>
    <url>/2020/03/10/java/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在一个程序执行的过程中，各象语句的执行顺序对程序的结果是有直接影响的，也就是说，程序的流程对运行结果有直接的影响。所以，我们必须清楚每条语句的执行流程。而且，很多时候我们要通过控制语句的执行顺序来实现我们要完成的功能。</p>
<h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><p>顺序执行,根据编写的顺序,从上到下运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sequence</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">//顺序执行,根据编写的顺序,从上到下运行</span></span><br><span class="line">    System.out.print(<span class="string">&quot;先&quot;</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;中&quot;</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;后&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顺序结构的流程图"><a href="#顺序结构的流程图" class="headerlink" title="顺序结构的流程图"></a>顺序结构的流程图</h3><img data-src="/2020/03/10/java/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/01-%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="" alt="01-顺序结构的流程图">





]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax(原生,JQ)</title>
    <url>/2019/04/06/javaScript/Ajax(%E5%8E%9F%E7%94%9F,JQ)/</url>
    <content><![CDATA[<h1 id="XMLHttpRequest发送请求"><a href="#XMLHttpRequest发送请求" class="headerlink" title="XMLHttpRequest发送请求"></a>XMLHttpRequest发送请求</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="comment">//1.获取a节点，并为其添加onclick响应函数</span></span><br><span class="line">	<span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;a&quot;</span>)[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="comment">//3.创建一个XMLHttpRequest对象  </span></span><br><span class="line">		<span class="keyword">var</span> request = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">		<span class="comment">//4.准备发送请求的数据：url</span></span><br><span class="line">		<span class="keyword">var</span> url = <span class="variable language_">this</span>.<span class="property">href</span> + <span class="string">&quot;?time=&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="keyword">var</span> method = <span class="string">&quot;GET&quot;</span>;</span><br><span class="line">		<span class="comment">//5.调用XMLHttpRequest对象的open方法</span></span><br><span class="line">		request.<span class="title function_">open</span>(method, url);</span><br><span class="line">		<span class="comment">//6.调用XMLHttpRequest对象的send方法</span></span><br><span class="line">		request.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line">		<span class="comment">//7.为XMLHttpRequest对象添加onreadystatechange响应函数</span></span><br><span class="line">		request.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">			<span class="comment">//8.判断响应是否完成：XMLHttpRequest对象的readyState属性值为4的时候</span></span><br><span class="line">			<span class="keyword">if</span>(request.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">				<span class="comment">//9.再判断响应是否可用：XMLHttpRequest对象status属性为200</span></span><br><span class="line">				<span class="keyword">if</span>(request.<span class="property">status</span> == <span class="number">200</span> || request.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">					<span class="comment">//10.打印响应结果responseText</span></span><br><span class="line">					<span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">responseText</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//2.取消a节点的默认行为</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Jquery中的Ajax"><a href="#Jquery中的Ajax" class="headerlink" title="Jquery中的Ajax"></a>Jquery中的Ajax</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	$(<span class="string">&quot;a&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="comment">//url</span></span><br><span class="line">		<span class="comment">//args :JSON格式</span></span><br><span class="line">		<span class="comment">//function :回调函数：当响应结束时，回调函数被触发。响应结果在data中</span></span><br><span class="line">		<span class="comment">//使用load方法处理Ajax</span></span><br><span class="line">		<span class="keyword">var</span> url = <span class="variable language_">this</span>.<span class="property">href</span>;</span><br><span class="line">		<span class="keyword">var</span> args = &#123;</span><br><span class="line">			<span class="string">&quot;time&quot;</span>: <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">//结果是直接插入HTML节点中</span></span><br><span class="line">		$(<span class="string">&quot;#con&quot;</span>).<span class="title function_">load</span>(url, args);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//使用load方法处理Ajax,加上选择器</span></span><br><span class="line">		<span class="keyword">var</span> url = <span class="variable language_">this</span>.<span class="property">href</span> + <span class="string">&quot;h2 a&quot;</span>;</span><br><span class="line">		<span class="keyword">var</span> args = &#123;</span><br><span class="line">			<span class="string">&quot;time&quot;</span>: <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">		&#125;;</span><br><span class="line">		$(<span class="string">&quot;#con&quot;</span>).<span class="title function_">load</span>(url, args);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//GET请求,返回结果在返回结果里面需要自己指定</span></span><br><span class="line">		<span class="keyword">var</span> url = <span class="variable language_">this</span>.<span class="property">href</span>;</span><br><span class="line">		<span class="keyword">var</span> args = &#123;</span><br><span class="line">			<span class="string">&quot;time&quot;</span>: <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">		&#125;;</span><br><span class="line">		$.<span class="title function_">get</span>(url, args,</span><br><span class="line">		<span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">			$(<span class="string">&quot;#con&quot;</span>).<span class="title function_">empty</span>().<span class="title function_">append</span>(data);</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//POST请求,返回结果在返回结果里面需要自己指定</span></span><br><span class="line">		<span class="keyword">var</span> url = <span class="variable language_">this</span>.<span class="property">href</span>;</span><br><span class="line">		<span class="keyword">var</span> args = &#123;</span><br><span class="line">			<span class="string">&quot;time&quot;</span>: <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">		&#125;;</span><br><span class="line">		$.<span class="title function_">post</span>(url, args,</span><br><span class="line">		<span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">			$(<span class="string">&quot;#con&quot;</span>).<span class="title function_">empty</span>().<span class="title function_">append</span>(data);</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="Json格式"><a href="#Json格式" class="headerlink" title="Json格式"></a>Json格式</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObject = &#123;</span><br><span class="line">	<span class="string">&quot;name&quot;</span>: <span class="string">&quot;guigui&quot;</span>,</span><br><span class="line">	<span class="string">&quot;age&quot;</span>: <span class="number">12</span>,</span><br><span class="line">	<span class="string">&quot;address&quot;</span>: &#123;</span><br><span class="line">		<span class="string">&quot;city&quot;</span>: <span class="string">&quot;sc&quot;</span>,</span><br><span class="line">		<span class="string">&quot;school&quot;</span>: <span class="string">&quot;sc&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;teaching&quot;</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="title function_">alert</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(jsonObject.<span class="property">name</span>);</span><br><span class="line"><span class="title function_">alert</span>(jsonObject.<span class="property">address</span>.<span class="property">city</span>);</span><br><span class="line"></span><br><span class="line">jsonObject.<span class="title function_">teaching</span>();</span><br><span class="line"><span class="comment">//把字符串转为json</span></span><br><span class="line"><span class="keyword">var</span> jsonStr = <span class="string">&quot;&#123;&#x27;name&#x27;:&#x27;guigui&#x27;&#125;&quot;</span>;</span><br><span class="line">jsonStr = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span> + jsonStr + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(jsonStr.<span class="property">name</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware虚拟机系统Ubuntu安装VMware tools工具</title>
    <url>/2020/04/06/linux/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E7%BB%9FUbuntu%E5%AE%89%E8%A3%85VMware-tools%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="VMware虚拟机系统Ubuntu安装VMware-tools工具"><a href="#VMware虚拟机系统Ubuntu安装VMware-tools工具" class="headerlink" title="VMware虚拟机系统Ubuntu安装VMware tools工具"></a>VMware虚拟机系统Ubuntu安装VMware tools工具</h1><p>在VMware Workstation虚拟机中，如果虚拟Ubuntu系统未安装vmware tools工具，鼠标操作起来将不是很方便，需要使用热键Ctrl+Alt热键切换出来。下面，介绍一下如何在ubuntu虚拟机中安装vmware tools工具。</p>
<p>启动vmware workstation软件，运行ubuntu虚拟操作系统，登陆进入ubuntu桌面。选择“虚拟机”-&gt;“安装vmware tools”VMware tools</p>
<img data-src="/2020/04/06/linux/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E7%BB%9FUbuntu%E5%AE%89%E8%A3%85VMware-tools%E5%B7%A5%E5%85%B7/image-20200403172358617.png" class="" alt="image-20200403172358617">

<p>双击桌面的“vmware tools”,打开vmware tools安装介质。右键选择vmwaretools的gz压缩包，</p>
<p>将该文件复制到<code>下载文件夹</code>，<code>至于复制到什么文件夹。大家可以自行选择</code>。</p>
<img data-src="/2020/04/06/linux/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E7%BB%9FUbuntu%E5%AE%89%E8%A3%85VMware-tools%E5%B7%A5%E5%85%B7/image-20200403172438473.png" class="" alt="image-20200403172438473">

<img data-src="/2020/04/06/linux/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E7%BB%9FUbuntu%E5%AE%89%E8%A3%85VMware-tools%E5%B7%A5%E5%85%B7/image-20200403173538440.png" class="" alt="image-20200403173538440">

<p>右键点击该文件，选择“提取到此处”</p>
<img data-src="/2020/04/06/linux/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E7%BB%9FUbuntu%E5%AE%89%E8%A3%85VMware-tools%E5%B7%A5%E5%85%B7/image-20200403173638585.png" class="" alt="image-20200403173638585">

<p>打开解压后的vmwaretools文件夹，右键点击vmware-tools-distrib文件夹，选择“在终端打开”</p>
<img data-src="/2020/04/06/linux/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E7%BB%9FUbuntu%E5%AE%89%E8%A3%85VMware-tools%E5%B7%A5%E5%85%B7/image-20200403173732626.png" class="" alt="image-20200403173732626">

<p>在终端的命令窗口当中，输入<code>sudo ./vmware-tools-distrib/vmware-install.pl</code>命令。输入用户密码回车开始安装。出现第一个画面时，选择“<code>y</code>”回车。</p>
<img data-src="/2020/04/06/linux/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E7%BB%9FUbuntu%E5%AE%89%E8%A3%85VMware-tools%E5%B7%A5%E5%85%B7/image-20200403174051861.png" class="" alt="image-20200403174051861">

<p>一路回车进行安装，出现以下的画面，安装完成。</p>
<img data-src="/2020/04/06/linux/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E7%BB%9FUbuntu%E5%AE%89%E8%A3%85VMware-tools%E5%B7%A5%E5%85%B7/image-20200403174218198.png" class="" alt="image-20200403174218198">

<p><code>重启电脑，重新进入，安装vmware tools即生效。鼠标和复制粘贴就生效了。</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>修改Ubuntu分辨率</title>
    <url>/2020/04/06/linux/%E4%BF%AE%E6%94%B9Ubuntu%E5%88%86%E8%BE%A8%E7%8E%87/</url>
    <content><![CDATA[<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><img data-src="/2020/04/06/linux/%E4%BF%AE%E6%94%B9Ubuntu%E5%88%86%E8%BE%A8%E7%8E%87/image-20200403165720339.png" class="" alt="image-20200403165720339">

<h2 id="点设备"><a href="#点设备" class="headerlink" title="点设备"></a>点设备</h2><img data-src="/2020/04/06/linux/%E4%BF%AE%E6%94%B9Ubuntu%E5%88%86%E8%BE%A8%E7%8E%87/image-20200403165813924.png" class="" alt="image-20200403165813924">

<h2 id="修改分辨率"><a href="#修改分辨率" class="headerlink" title="修改分辨率"></a>修改分辨率</h2><img data-src="/2020/04/06/linux/%E4%BF%AE%E6%94%B9Ubuntu%E5%88%86%E8%BE%A8%E7%8E%87/image-20200403165857456.png" class="" alt="image-20200403165857456">

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2>



]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>修改Ubuntu的系统源</title>
    <url>/2020/04/06/linux/%E4%BF%AE%E6%94%B9Ubuntu%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%BA%90/</url>
    <content><![CDATA[<img data-src="/2020/04/06/linux/%E4%BF%AE%E6%94%B9Ubuntu%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%BA%90/image-20200403171326693.png" class="" alt="image-20200403171326693">

<p>点击软件和更新</p>
<img data-src="/2020/04/06/linux/%E4%BF%AE%E6%94%B9Ubuntu%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%BA%90/image-20200403171359402.png" class="" alt="image-20200403171359402">

<p>点击中国的服务器</p>
<img data-src="/2020/04/06/linux/%E4%BF%AE%E6%94%B9Ubuntu%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%BA%90/image-20200403171423549.png" class="" alt="image-20200403171423549">

<p>点击其他站点</p>
<img data-src="/2020/04/06/linux/%E4%BF%AE%E6%94%B9Ubuntu%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%BA%90/image-20200403171516801.png" class="" alt="image-20200403171516801">

<p>测试或者选择你觉得可以快一点的镜像</p>
<img data-src="/2020/04/06/linux/%E4%BF%AE%E6%94%B9Ubuntu%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%BA%90/image-20200403171608393.png" class="" alt="image-20200403171608393">

<p>点击确定输入用户密码就好</p>




]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>安装Ubuntu</title>
    <url>/2020/04/06/linux/%E5%AE%89%E8%A3%85Ubuntu/</url>
    <content><![CDATA[<h1 id="安装Ubuntu"><a href="#安装Ubuntu" class="headerlink" title="安装Ubuntu"></a>安装Ubuntu</h1><p>准备工作</p>
<ul>
<li>需要VMware</li>
</ul>
<h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><p>Ubuntu下载地址:<a href="http://releases.ubuntu.com/">http://releases.ubuntu.com/</a></p>
<img data-src="/2020/04/06/linux/%E5%AE%89%E8%A3%85Ubuntu/image-20200403154017477.png" class="" alt="image-20200403154017477">

<img data-src="/2020/04/06/linux/%E5%AE%89%E8%A3%85Ubuntu/image-20200403155024305.png" class="" alt="image-20200403155024305">

<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><img data-src="/2020/04/06/linux/%E5%AE%89%E8%A3%85Ubuntu/image-20200403154049421.png" class="" alt="image-20200403154049421">

<h2 id="准备虚拟机"><a href="#准备虚拟机" class="headerlink" title="准备虚拟机"></a>准备虚拟机</h2><p>在下载的时候，现在VMware里面准备好虚拟机</p>
<h3 id="创建新的虚拟机"><a href="#创建新的虚拟机" class="headerlink" title="创建新的虚拟机"></a>创建新的虚拟机</h3><img data-src="/2020/04/06/linux/%E5%AE%89%E8%A3%85Ubuntu/image-20200403154231003.png" class="" alt="image-20200403154231003">

<h4 id="创建典型的即可"><a href="#创建典型的即可" class="headerlink" title="创建典型的即可"></a>创建典型的即可</h4><img data-src="/2020/04/06/linux/%E5%AE%89%E8%A3%85Ubuntu/image-20200403154423758.png" class="" alt="image-20200403154423758">

<h4 id="创建一个空的虚拟机"><a href="#创建一个空的虚拟机" class="headerlink" title="创建一个空的虚拟机"></a>创建一个空的虚拟机</h4><img data-src="/2020/04/06/linux/%E5%AE%89%E8%A3%85Ubuntu/image-20200403154528596.png" class="" alt="image-20200403154528596">

<h4 id="创建64位的虚拟机"><a href="#创建64位的虚拟机" class="headerlink" title="创建64位的虚拟机"></a>创建64位的虚拟机</h4><p>因为默认下载的为64位的</p>
<img data-src="/2020/04/06/linux/%E5%AE%89%E8%A3%85Ubuntu/image-20200403154642694.png" class="" alt="image-20200403154642694">

<p>所在在选择系统的时候选择64位的系统</p>
<img data-src="/2020/04/06/linux/%E5%AE%89%E8%A3%85Ubuntu/image-20200403154754885.png" class="" alt="image-20200403154754885">

<h4 id="安装的位置"><a href="#安装的位置" class="headerlink" title="安装的位置"></a>安装的位置</h4><p>找自己电脑比较空旷的磁盘安装（预估一下差不多40G~60G）</p>
<table>
<thead>
<tr>
<th><strong>挂载点(目录)</strong></th>
<th><strong>建议大小</strong></th>
<th><strong>格式</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;</td>
<td>20G左右</td>
<td>ext4</td>
<td>根目录</td>
</tr>
<tr>
<td>&#x2F;home</td>
<td>越大越好</td>
<td>ext4</td>
<td>用户工作目录，用户存储的数据，文件，安装的软件都存放在这儿</td>
</tr>
<tr>
<td>&#x2F;boot</td>
<td>300M左右</td>
<td>ext4</td>
<td>一般几百M，主要存放linux内核及一些引导文件</td>
</tr>
<tr>
<td>&#x2F;tmp</td>
<td>10G左右</td>
<td>ext4</td>
<td>系统的一些临时文件</td>
</tr>
<tr>
<td>&#x2F;swap</td>
<td>8G左右</td>
<td>swap交换空间</td>
<td>相当于虚拟内存</td>
</tr>
</tbody></table>
<img data-src="/2020/04/06/linux/%E5%AE%89%E8%A3%85Ubuntu/image-20200403154918626.png" class="" alt="image-20200403154918626">

<h3 id="选择磁盘容量"><a href="#选择磁盘容量" class="headerlink" title="选择磁盘容量"></a>选择磁盘容量</h3><p>这个根据自己的电脑和需求来选择，越大越好，推荐使用多个文件</p>
<img data-src="/2020/04/06/linux/%E5%AE%89%E8%A3%85Ubuntu/image-20200403155511139.png" class="" alt="image-20200403155511139">

<p>然后下一步，就好了</p>
<img data-src="/2020/04/06/linux/%E5%AE%89%E8%A3%85Ubuntu/image-20200403155616418.png" class="" alt="image-20200403155616418">

<h2 id="虚拟机配置"><a href="#虚拟机配置" class="headerlink" title="虚拟机配置"></a>虚拟机配置</h2><p>编辑虚拟机的设置</p>
<img data-src="/2020/04/06/linux/%E5%AE%89%E8%A3%85Ubuntu/image-20200403155721067.png" class="" alt="image-20200403155721067">

<p>修改内存、处理器和ISO镜像的位置（等文件下载完成就可以选择了）</p>
<img data-src="/2020/04/06/linux/%E5%AE%89%E8%A3%85Ubuntu/image-20200403160005254.png" class="" alt="image-20200403160005254">

<img data-src="/2020/04/06/linux/%E5%AE%89%E8%A3%85Ubuntu/image-20200403160112674.png" class="" alt="image-20200403160112674">

<p>然后点开启虚拟机就等待了</p>
<h2 id="安装Ubuntu-1"><a href="#安装Ubuntu-1" class="headerlink" title="安装Ubuntu"></a>安装Ubuntu</h2><p>开始的页面最下面有中文（还是比较友好的）</p>
<img data-src="/2020/04/06/linux/%E5%AE%89%E8%A3%85Ubuntu/image-20200403160327152.png" class="" alt="image-20200403160327152">

<p>点安装Ubuntu</p>
<img data-src="/2020/04/06/linux/%E5%AE%89%E8%A3%85Ubuntu/image-20200403160409883.png" class="" alt="image-20200403160409883">

<p>点继续，这个就看自己的需求了（推荐，正常安装+取消安装Ubuntu时下载更新）</p>
<img data-src="/2020/04/06/linux/%E5%AE%89%E8%A3%85Ubuntu/image-20200403160543542.png" class="" alt="image-20200403160543542">

<p>点继续</p>
<img data-src="/2020/04/06/linux/%E5%AE%89%E8%A3%85Ubuntu/image-20200403160734500.png" class="" alt="image-20200403160734500">

<p>点现在安装，有对话框直接点继续，注意这里时点击中国的图片</p>
<img data-src="/2020/04/06/linux/%E5%AE%89%E8%A3%85Ubuntu/image-20200403160847663.png" class="" alt="image-20200403160847663">

<p>点继续，这个很明白，给你自己写一个用户名和密码</p>
<img data-src="/2020/04/06/linux/%E5%AE%89%E8%A3%85Ubuntu/image-20200403160922375.png" class="" alt="image-20200403160922375">

<p>输入好后点，继续，然后等待安装，安装文成后最好重启</p>
<p>友情提式：·<code>Ctrl+Alt</code>切换出鼠标</p>
<p>关闭虚拟机后，修改镜像</p>
<img data-src="/2020/04/06/linux/%E5%AE%89%E8%A3%85Ubuntu/image-20200403165402354.png" class="" alt="image-20200403165402354">

<p>到此就完成安装了</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/2020/03/08/maven/Maven/</url>
    <content><![CDATA[<h3 id="常用Maven命令"><a href="#常用Maven命令" class="headerlink" title="常用Maven命令"></a>常用Maven命令</h3><p>执行与构建过程相关的命令，必须进入pom.xml所在的目录。</p>
<p>与构建过程相关的：编译、测试、打包…</p>
<ol>
<li>mvn clean：清理</li>
<li>mvn compile：编译主程序</li>
<li>mvn test-compile：编译测试程序</li>
<li>mvn test：执行测试</li>
<li>mvn package：打包</li>
<li>mvn install：安装进入仓库</li>
<li>mvn site：生成站点</li>
</ol>
<h3 id="联网问题"><a href="#联网问题" class="headerlink" title="联网问题"></a>联网问题</h3><ol>
<li><p>Maven的核心程序中仅仅定义了抽象的生命周期，但是具体的工作必须由特定的插件来完成。而插件本身并不包含再Maven的核心程序中。</p>
</li>
<li><p>当我们执行的Maven命令需要用到某些插件时，Maven核心程序首先到本地仓库中查找。</p>
</li>
<li><p>本地仓库的默认位置：[系统中当前用户的目录]\.m2\repository</p>
</li>
<li><p>Maven核心程序如果再本地仓库找不到需要的插件，那么它会自动链接外网，到中央仓库下载。</p>
</li>
<li><p>如果此时无法联网，则构建失败。</p>
</li>
<li><p>修改默认本地仓库的位置可以让Maven核心程序到我们事先准备好的目录下查找插件</p>
<ol>
<li>找到Maven文件下的\conf\settings.xml</li>
<li>找到标签<code>localRepository</code></li>
<li>将标签<code>localRepository</code>从注释中取出</li>
<li>定义当自定义的目录如：<code>&lt;localRepository&gt;E:\maven\maven-repository&lt;/localRepository&gt;</code></li>
</ol>
</li>
<li><p>设置阿里Maven仓库</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">      http://maven.aliyun.com/nexus/content/groups/public/</span><br><span class="line">  <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h3><ol>
<li><p>含义：Project Object Model 项目对象模型</p>
<p>​			DOM Document Object Model 文档对象模型</p>
</li>
<li><p>pom.xml对于Maven工程是核心配置文件，与构建过程相关的一切设置都在这个文件中进行配置。重要程度相当于web.xml对于动态Web工程</p>
</li>
</ol>
<h3 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h3><p>Maven的坐标</p>
<ol>
<li>groupid：公司或组织域名倒序+项目名称</li>
<li>artifactid：模块名</li>
<li>version：版本</li>
</ol>
<h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><ol>
<li><p>仓库的分类</p>
<ol>
<li>本地仓库：当前电脑上部署的仓库目录，当前电脑上所有Maven工程服务</li>
<li>远程仓库<ol>
<li>私服：搭建再局域网环境中，为局域网范围内的所有Maven工程服务（Nexus）</li>
<li>中央仓库：架设再Internet上，为全世界所有Maven工程</li>
<li>中央仓库的镜像：为了分担中央仓库的流量，提升用户访问速度</li>
</ol>
</li>
</ol>
</li>
<li><p>仓库中保存的内容：Maven工程</p>
<ol>
<li>Maven自身所需要的插件</li>
<li>第三方框架或工具的jar包</li>
<li>我们自己开发的Maven工程</li>
</ol>
</li>
</ol>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><ol>
<li><p>Maven解析依赖信息时会到本地仓库中查找被依赖的jar包</p>
</li>
<li><p>对于我们自己开发的Maven工程，使用install命令安装后就可以进入仓库</p>
</li>
<li><p>依赖的范围</p>
<ol>
<li>compile<ol>
<li>对主程序是否有效：有效</li>
<li>对测试程序是否有效：有效</li>
<li>是否参与打包：参与</li>
</ol>
</li>
<li>test<ol>
<li>对主程序是否有效：无效</li>
<li>对测试程序是否有效：有效</li>
<li>是否参与打包：不参与</li>
<li>典型例子：junit.jar</li>
</ol>
</li>
<li>provided<ol>
<li>对主程序是否有效：有效</li>
<li>对测试程序是否有效：有效</li>
<li>是否参与打包：不参与</li>
<li>是否参与部署：不参与</li>
<li>典型例子：servlet-api.jar</li>
</ol>
</li>
</ol>
</li>
<li><p>依赖的传递性</p>
<ol>
<li>在父工程依赖一次既可重复使用</li>
<li>注意：非complie范围的不能传递。所以在各个工程模块中，重复声明</li>
</ol>
</li>
<li><p>依赖的排除</p>
<ol>
<li><p>在不需要j一些ar包或jar包重复时，则要排除一部分jar包</p>
</li>
<li><p>排除设置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">gourpId</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">gourpId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxxxxx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>依赖原则</p>
<ol>
<li>作用：解决模块工程之间的jar包冲突问题</li>
<li>Maven默认解决方案：路径最短者优先</li>
<li>Maven默认解决方案：先声明者有限(dependency先后)</li>
</ol>
</li>
<li><p>统一管理依赖的版本</p>
<ol>
<li>使用properties标签使用自定义标签统一声明版本号</li>
<li>在需要的地方使用${自定义标签}引用声明的版本号</li>
<li>其实properties标签配合自定义标签声明数据的配置并不只能用于声明依赖的版本号，凡是需要统一声明后再引用的声明都能使用。如：字符集、声明…</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol>
<li><p>各个构建环境执行的顺序：不能打乱顺序，必须按照指定的正确顺序来执行。</p>
</li>
<li><p>Maven的核心程序中定义了抽象的生命周期，生命周期中各个阶段的具体任务时由插件来完成的。</p>
</li>
<li><p>Maven有三条相互独立的生命周期：</p>
<ol>
<li>Clean Lifecycle在进行真正的构建之前进行一些清理工作。</li>
<li>Default Lifecycle在构建核心部分，编译，测试，打包，安装，部署等等。</li>
<li>Site Lifecycle生成项目报告，站点，发布站点。</li>
</ol>
</li>
<li><p>Maven核心程序为了更好的实现自动化构建，按照这一特点执行生命周期中的各个阶段：不论现在执行生命周期的哪一个阶段，都是从这个生命周期最初的位置开始执行。</p>
</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ol>
<li><p>统一管理各个模块工程中的test范围的依赖的版本</p>
</li>
<li><p>将test的依赖统一提取到父工程中，在子工程中声明的依赖时不指定版本，以工程中统一设定的为准，同时也便于修改</p>
</li>
<li><p>操作步骤</p>
<ol>
<li><p>创建一个Maven工程为父工程。注意：打包方式为pom</p>
<p><code>&lt;packaging&gt;pom&lt;/packaging&gt;</code></p>
</li>
<li><p>在子工程中声明对父工程的引用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子工程中声明父工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ren.guard.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 以当前文件为基准的父工程pom.xml文件的相对路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../Parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将子工程的坐标中与父工程坐标中重复的内容删除</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ren.guard.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="comment">&lt;!-- 删除 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="comment">&lt;!-- 删除 --&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在父工程中统一管理test依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在子工程中删除test依赖的版本号部分</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在配置继承后，执行安装命令时要先安装父工程</p>
</li>
</ol>
</li>
</ol>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><ol>
<li><p>作用：一键安装各个模块工程</p>
</li>
<li><p>配置方式：在一个“总的聚合工程”中配置各个参与聚合的模块</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定各个子工程的相对路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>jpa_settings<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>log4j_settings<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>logger_settings<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用方式：在聚合工程的pom.xml上点击maven install</p>
</li>
</ol>
<h3 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置当工程构建过程中的特殊设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目最后的名称 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">finalName</span>&gt;</span>mavenWeb<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置构建过程中需要使用的插件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- cargo是一家专门从事“启动Servlet容器”的组织 --&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.cargo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cargo-maven2-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 针对插件进行的配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 配置当前系统中容器的位置 --&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">container</span>&gt;</span></span><br><span class="line">                	<span class="tag">&lt;<span class="name">containerId</span>&gt;</span>tomcat8x<span class="tag">&lt;/<span class="name">containerId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">home</span>&gt;</span>D:\xxxx\xxxxx<span class="tag">&lt;/<span class="name">home</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                	<span class="tag">&lt;<span class="name">type</span>&gt;</span>existing<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">home</span>&gt;</span>D:\xxxx\xxxxx<span class="tag">&lt;/<span class="name">home</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 如果Tomcat端口为默认值8080则不必设置该属性 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                    	<span class="tag">&lt;<span class="name">cargo.servlet.port</span>&gt;</span>8989<span class="tag">&lt;/<span class="name">cargo.servlet.port</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">&lt;!-- 配置插件在什么情况下执行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                	<span class="tag">&lt;<span class="name">id</span>&gt;</span>cargo-run<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 生命周期的阶段 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>install<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 插件的目标 --&gt;</span></span><br><span class="line">                    	<span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>mvn deploy</code></p>
<h3 id="依赖信息网址"><a href="#依赖信息网址" class="headerlink" title="依赖信息网址"></a>依赖信息网址</h3><p><a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql主从设置</title>
    <url>/2024/07/01/mysql/mysql%E4%B8%BB%E4%BB%8E%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>什么是主从，详细百度去吧，我说说我自己的理解</p>
<ul>
<li><p>为了灾备</p>
</li>
<li><p>均衡负载，提高吞吐量</p>
</li>
</ul>
<h2 id="主备的原理"><a href="#主备的原理" class="headerlink" title="主备的原理"></a>主备的原理</h2><p>主服务器（master） 把数据同步到从服务器（slave）</p>
<img data-src="/2024/07/01/mysql/mysql%E4%B8%BB%E4%BB%8E%E8%AE%BE%E7%BD%AE/1.jpg" class="">

<h2 id="下面就是实现了"><a href="#下面就是实现了" class="headerlink" title="下面就是实现了"></a>下面就是实现了</h2><p>首先需要两个mysql（本地测试推荐：phpstudy里面复制两个mysql）</p>
<h3 id="修改my-ini"><a href="#修改my-ini" class="headerlink" title="修改my.ini"></a>修改my.ini</h3><p>— 唯一 ,要与备机的不同</p>
<p><code>server_id = 101</code></p>
<p>— 开启二进制日志</p>
<p><code>log-bin= mysql-bin</code></p>
<h3 id="设置服务"><a href="#设置服务" class="headerlink" title="设置服务"></a>设置服务</h3><p>— 设置服务</p>
<p><code>.\mysqld.exe install MySQL-3310 –defaults-file=”D:\PhpStudy\MySQL\my.ini”</code></p>
<p>— 删除服务</p>
<p><code>.\mysqld.exe remove MySQL-3310</code></p>
<p>— 开启服务</p>
<p><code>net start MySQL-3310</code></p>
<h3 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h3><p>— 查询连接账户</p>
<p><code>SELECT USER,HOST from user;</code></p>
<p>— 开启远程</p>
<p><code>grant all privileges on . to ‘root’@’%’ identified by ‘root’ with grant option;</code></p>
<h3 id="创建连接用户（主机配置）"><a href="#创建连接用户（主机配置）" class="headerlink" title="创建连接用户（主机配置）"></a>创建连接用户（主机配置）</h3><p>— CREATE USER ‘使用名’@’备机IP地址’ IDENTIFIED BY ‘密码’;#创建用户</p>
<p><code>create user ‘usermysql’@’localhost’ identified by ‘123456’;</code></p>
<p>— GRANT REPLICATION SLAVE ON . TO ‘使用名’@’备机IP地址’;#分配权限</p>
<p><code>grant replication slave on . to ‘usermysql’@’localhost’;</code></p>
<p>— 刷新权限</p>
<p><code>flush privileges;</code></p>
<p>— 查看master状态</p>
<p><code>show master status;</code></p>
<p>创建连接（从机配置）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO </span><br><span class="line">MASTER_HOST=’localhost’, #主机的IP</span><br><span class="line">MASTER_PORT=3306,</span><br><span class="line">MASTER_USER=’usermysql’, #之前创建的那个使用名</span><br><span class="line">MASTER_PASSWORD=’123456′, #密码</span><br><span class="line">MASTER_LOG_FILE=’mysql-bin.000001′, #这是主库中show master status;File下的那个值</span><br><span class="line">MASTER_LOG_POS=446;#这是主库Position下的那个值</span><br><span class="line"></span><br><span class="line">Slave_IO_Running: Yes</span><br><span class="line">Slave_SQL_Running: Yes </span><br><span class="line">看到这两个都是Yes就成了</span><br></pre></td></tr></table></figure>
<p>— 关闭</p>
<p><code>stop slave;</code></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>你的答案</title>
    <url>/2020/01/23/%E6%91%98%E8%A6%81/%E4%BD%A0%E7%9A%84%E7%AD%94%E6%A1%88/</url>
    <content><![CDATA[<p>你的答案<br>作曲 : 刘涛<br>作词 : 林晨阳 &#x2F;刘涛<br>编曲 Arranger：谭侃侃</p>
<p>也许世界就这样</p>
<p>我也还在路上</p>
<p>没有人能诉说</p>
<p>也许我只能沉默</p>
<p>眼泪湿润眼眶</p>
<p>可又不甘懦弱</p>
<p>低着头 期待白昼</p>
<p>接受所有的嘲讽</p>
<p>向着风 拥抱彩虹</p>
<p>勇敢的向前走</p>
<p>黎明的那道光</p>
<p>会越过黑暗</p>
<p>打破一切恐惧我能</p>
<p>找到答案</p>
<p>哪怕要逆着光</p>
<p>就驱散黑暗</p>
<p>丢弃所有的负担</p>
<p>不再孤单</p>
<p>不再孤单</p>
<p>也许世界就这样</p>
<p>我也还在路上</p>
<p>没有人能诉说</p>
<p>也许我只能沉默</p>
<p>眼泪湿润眼眶</p>
<p>可又不甘懦弱</p>
<p>低着头 期待白昼</p>
<p>接受所有的嘲讽</p>
<p>向着风 拥抱彩虹</p>
<p>勇敢的向前走</p>
<p>黎明的那道光</p>
<p>会越过黑暗</p>
<p>打破一切恐惧我能</p>
<p>找到答案</p>
<p>哪怕要逆着光</p>
<p>就驱散黑暗</p>
<p>丢弃所有的负担</p>
<p>不再孤单</p>
<p>不再孤单</p>
<p>黎明的那道光</p>
<p>会越过黑暗</p>
<p>打破一切恐惧我能</p>
<p>找到答案</p>
<p>哪怕要逆着光</p>
<p>就驱散黑暗</p>
<p>有一万种的力量</p>
<p>淹没孤单</p>
<p>不再孤单</p>
<p><video class="media" src="blob:https://music.163.com/f4df5b7f-7d2d-4430-9171-d7a2e264dbc2"></video></p>
]]></content>
      <categories>
        <category>摘要</category>
      </categories>
      <tags>
        <tag>摘要</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>修身(一)</title>
    <url>/2020/01/14/%E6%91%98%E8%A6%81/%E4%BF%AE%E8%BA%AB%E4%B8%80/</url>
    <content><![CDATA[<p>一个人在成长的过程里，总会遇到很多，比如心里的矛盾，现实里的阻碍。<br>美好的想法那是自己惬意的美妙的梦想。<br>一个人如何得到自己想要的，如何实现自己的理想，又如何能够改变自己现在的状态？<br>我相信这是太多的人都面临的一个问题。</p>
<p>只是才疏学浅，希望读者能够提出最为宝贵的意见。</p>
<p>所以我只谈一点，那就是修身。</p>
<p>修身齐家治国平天下，这句话都不是陌生的，但是如何做到？<br>且不说治国平天下，那如何齐起家？<br>所以得先修其身啊。</p>
<p>怎么修身？</p>
<p>一个很笼统的话题，那有没有标准？<br>有没有规律，有没有可以快速见到效果的？<br>这就是我们在不断总结出来的一些，现在分享给大家。</p>
<h2 id="1-修口"><a href="#1-修口" class="headerlink" title="1.修口"></a>1.修口</h2><ol>
<li>你能让别人舒服，能够让这个此时此刻的环境和谐，能够达到基本目标，能够简单易行，这一点能够得到已经很不错了。</li>
<li>你能通过自己能为，表达清楚和规划执行，能够明确方向的长远，那种高度，深度，并且可以按照别人接受的顺序讲出来，这还只是你做到了一半，最重要就是执行过程里那种利弊得失，时间空间布局，容易出错的，容易变化的也能补充到位，这就很不容易了。这便是个人的基本趋于综合能力了。</li>
<li>要成为大才，那你还需要按照自然规律，道德，符合规律还不够，还需要创造，得到进步，推动力，你的创造力，奇特的开发在没有条件的时候创造出来的那才是别人震撼和让你口才有魂的基本。这是我粗浅的理解。那么话说回来最基本的修口具体是什么呢？</li>
</ol>
<p>我认为要做到四不。</p>
<h3 id="第一不"><a href="#第一不" class="headerlink" title="第一不"></a>第一不</h3><p>第一不，就是不插嘴。<br>其实很多人有个很不好的习惯，就是喜欢插嘴。<br>试问下，你如果在说话的时候，别人也插嘴你是怎样的感受？<br>既然你不喜欢你很讨厌，那别人说话的时候你插嘴呢？<br>为何不要插嘴！</p>
<p>我认真的思考了一下有这样的原因。</p>
<ol>
<li>你真的把对方的意思理解了吗？还是用你那个人的感觉判断去理解了？</li>
<li>别人信息情报具体了吗？说清楚了没有？还是根本就没有开始？</li>
<li>你都不知道别人目的，不仅仅是事的目的，最重要的是还有人，你要知道他如此说是不是因为可以想到兵法里的话，如何激怒对方？还是在隐藏什么？</li>
</ol>
<p>所以你​需要安静冷静。<br>这不仅仅是智慧，还会是你能够获得面子与尊重。<br>因为你这个细节决定了说话的气氛。<br>所以千万别乱插嘴！<br>但是还有一点，不是一概而论的，就是当你该插嘴的时候必须要插嘴了，所以这个平衡需要自己能够把握一个度。</p>
<h3 id="第二不"><a href="#第二不" class="headerlink" title="第二不"></a>第二不</h3><p>第二不，不争论。<br>你争赢了输了关系，你争输了会输得很惨。<br>大家都知道，争锋对麦芒的！<br>可现实里，又有多少人如此愚蠢？<br>我们大家确实都在争都在论，但是我认为我们得有合适的方法需要正确解决眼前的所有。<br>其实这里就如战场一样。<br>其实你的社会也如是战场，那么你知道了战场，就是生死存亡就是你争我夺的地方。<br>所以难免的就是争论也就会出现输赢出现心里的状态中的悲喜与酸痛。<br>而每个人都一样希望自己是一个智者是一个强者是一个得到支持的人，尤其是在自己说话的时候，所以这里我认为，如何做到与得到你的目标，你应该做到的三点:</p>
<ol>
<li>快速恢复对得失中利益的判断，调整自己情绪，去认同对方。</li>
<li>还需要很认真的去思考别人的意思和言外之意。</li>
<li>明确做的方向，做的方法。</li>
</ol>
<p>其实大家最终要得到的只是一个，那就是大伙达成共识。<br>在这里关于争论与不争论就写到这里，其实还有更加具体的希望可以在以后的过程里分享。</p>
<h3 id="第三不"><a href="#第三不" class="headerlink" title="第三不"></a>第三不</h3><p>第三不，不否定与不反驳。<br>很多时候，我们总是喜欢反驳习惯了否定。<br>你不认同别人别人一辈子都不会认同你，你反驳了别人那是对别人的不尊重最重要的是还会带来了很大的程度伤害。<br>试问下，你懂别人吗？<br>你又了解清楚别人说的事吗？<br>你又明白别人那个时候发生什么？<br>你又明白别人的难处吗？<br>你又知道那个时候别人最应该做的和不得不做的是什么吗？<br>所以人与人之间的相处，就是因为自己往往按照自己的思考去思考，还有很多的时候都是好为人师指手画脚的，试问下你真的是神吗？<br>不，你不是，既然不是的，也无非就是一个凡人，那有必要如此吗？<br>在这里我们得深深思考！<br>为何那些大成家他们能够让身边的人从内心里舒服，明白吗？<br>所以笔者个人认为，一切好商量，就会成为绝大多数的未来的法宝！​<br>所以当我们理解了，明确了我们自己的日子也定然好过起来，尤其是夫妻之间，尤其是最好的关系之间，人往往犯的错就是很难控制住这一切。<br>所以还有更多的法宝，希望读者可以随时与我们交流。</p>
<h3 id="第四不"><a href="#第四不" class="headerlink" title="第四不"></a>第四不</h3><p>第四不，不嘴巴变形。<br>其实这是最讨厌也是最没用最没有礼貌的。<br>只要你用心观察身边的人，说话嘴巴变形的人，他的性格与命运，就当做实践的作业吧。<br>为何人喜欢菩萨？<br>喜欢拜佛？<br>不喜欢雷公脸？<br>知道吗？<br>这里牵系了我下面要说的眼。<br>还有更多的知识内容，也需要后面发表…<br>所以修口，很重要，有了四不，就不断的检查自己不断的告诉自己修炼好。</p>
]]></content>
      <categories>
        <category>摘要</category>
      </categories>
      <tags>
        <tag>摘要</tag>
      </tags>
  </entry>
  <entry>
    <title>寥寥此生虚度</title>
    <url>/2020/01/28/%E6%91%98%E8%A6%81/%E5%AF%A5%E5%AF%A5%E6%AD%A4%E7%94%9F%E8%99%9A%E5%BA%A6/</url>
    <content><![CDATA[<p>寥寥此生虚度<br>作曲 : 暗杠<br>作词 : 竹君<br>编曲：陈夔、暗杠</p>
<p>摘一道闪电</p>
<p>甩进黑黝</p>
<p>造一个深渊</p>
<p>劈开山谷</p>
<p>扯一团浓烟</p>
<p>盖住白骨</p>
<p>携一方书简</p>
<p>刻上荒谬</p>
<p>要多么突兀</p>
<p>才能蔷薇细嗅</p>
<p>像外表风平浪静的烈酒</p>
<p>要多么坚守</p>
<p>才深爱歧途</p>
<p>做一个固执己见的山丘</p>
<p>要多么古旧</p>
<p>才能踏进坟墓</p>
<p>像粒心如死灰的珍珠</p>
<p>要多少尘土</p>
<p>才能掩埋领悟</p>
<p>做一棵贪得无厌的树</p>
<p>折一段笑颜</p>
<p>长成枯木</p>
<p>挖一个溪涧</p>
<p>蒙上薄雾</p>
<p>展一面山岩</p>
<p>描摹繁复</p>
<p>撒一串榆钱</p>
<p>撕碎早露</p>
<p>要多么突兀</p>
<p>才能蔷薇细嗅</p>
<p>像外表风平浪静的烈酒</p>
<p>要多么坚守</p>
<p>才深爱歧途</p>
<p>做一个固执己见的山丘</p>
<p>要多么古旧</p>
<p>才能踏进坟墓</p>
<p>像粒心如死灰的珍珠</p>
<p>要多少尘土</p>
<p>才能掩埋领悟</p>
<p>做一棵贪得无厌的树</p>
<p>要怎样弥补</p>
<p>才能归真返璞</p>
<p>像内心无动于衷的铁杵</p>
<p>要多么仓促</p>
<p>才怪诞谢幕</p>
<p>做一个是非颠倒的囚徒</p>
<p>要多么无辜</p>
<p>才能磨平嫉妒</p>
<p>像只天生丽质的鸿鹄</p>
<p>要多少沉浮</p>
<p>才能生死不顾</p>
<p>寥寥此生虚度</p>
<iframe src="//player.bilibili.com/player.html?aid=48944897&cid=85715082&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

]]></content>
      <categories>
        <category>摘要</category>
      </categories>
      <tags>
        <tag>摘要</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>异地恋如何维持长久？</title>
    <url>/2020/01/14/%E6%91%98%E8%A6%81/%E5%BC%82%E5%9C%B0%E6%81%8B%E5%A6%82%E4%BD%95%E7%BB%B4%E6%8C%81%E9%95%BF%E4%B9%85/</url>
    <content><![CDATA[<p>异地恋，真的不是一张机票就能解决的事，说的很真实，不是我们不在坚持，而是我们遇到了这些…</p>
<h2 id="表达障碍"><a href="#表达障碍" class="headerlink" title="表达障碍"></a>表达障碍</h2><p>短信听不到语气，电话看不到表情。<br>其实我没生气，你当真了；我在笑呢，你看不到吧；我哭了呢？抱着手机哭倦了睡过又醒了，你在忙吗？</p>
<h2 id="共同语言"><a href="#共同语言" class="headerlink" title="共同语言"></a>共同语言</h2><p>如果两个人在一起，两个人的交往圈会溶为共同的圈子，话题永远都在更新。<br>而不在一起的两个人，对彼此身边的环境都会因为陌生而失去兴趣，慢慢的，能说的话只有空洞的“我想你”<br>我在努力找话题呢，不要回信息说”喔，嗯，好”了好吗？</p>
<h2 id="不安全感"><a href="#不安全感" class="headerlink" title="不安全感"></a>不安全感</h2><p>看了10次手机了，你还是没有回信。你在哪，和谁，在干什么？<br>刚刚拒绝了别人的好意，却禁不住想，你身边的莺莺燕燕，一如我身边的花花草草吗？</p>
<h2 id="远水不救近火"><a href="#远水不救近火" class="headerlink" title="远水不救近火"></a>远水不救近火</h2><p>我这里下雨了，来伞的是同学的弟弟；我吃饭忘带钱了，来解围的是朋友的朋友。原来你不吭声是因为你生病了，可我再担忧，也不能在你身边端一杯水呢。</p>
<h2 id="距离产生幻觉"><a href="#距离产生幻觉" class="headerlink" title="距离产生幻觉"></a>距离产生幻觉</h2><p>其实我有些小虚荣，照片有时候修掉了眼袋才给你看；其实你有些小自负，认定的事情就以为自己一定对。<br>为了大老远的爱你，我拒绝接受身边一切说你不好的言论，什么都往好的方向想。你也是吧。<br>其实我们都不是对方想象的那样好。</p>
<h2 id="距离产生误会"><a href="#距离产生误会" class="headerlink" title="距离产生误会"></a>距离产生误会</h2><p>我兴冲冲地发短信给你讲刚刚的趣事，你隔了半天说“喔”，我不知道你在上课的嘛，所以我生闷气了。<br>你给我发了八条短信两个电话我也没回，愤怒得嗷嗷直叫，我在做头发呢，包包寄存了嘛，哪知道手机响着响着没电了。<br>其实我们都知道对方不是故意的，但情绪来了，总需要宣泄的。</p>
<h2 id="善意的谎言"><a href="#善意的谎言" class="headerlink" title="善意的谎言"></a>善意的谎言</h2><p>我碰巧和相熟的男生去看电影了，想了想，对你说和女生去的。<br>你独自去了我们约好要一起去的地方，犹豫再三，对我说你哪也没去。<br>不愿让对方多想，却因为偶尔的疏忽，放对方想的更多。</p>
<h2 id="寂寞"><a href="#寂寞" class="headerlink" title="寂寞"></a>寂寞</h2><p>一个人不寂寞，想念一个人才寂寞。<br>你说，来，抱抱。于是我把自己裹在被窝里，闭上眼，恩，抱抱。<br>从学校回家的路上，你还抬头看月亮吗？</p>
<h2 id="信念坍塌"><a href="#信念坍塌" class="headerlink" title="信念坍塌"></a>信念坍塌</h2><p>我看到身边一对一对的，男生帮女生打开水送饭，在宿舍楼下唧唧我我，周末还能一起爬山，没忍住就对在地图对角线上的你发牢骚，其实是想听你的鼓励。<br>刚刚好你接到朋友异地恋分手倾诉的电话，那么容易就把自己带入了戏，无心的抱怨雪上加霜。<br>有时候折腾一下，只为证明自己的重要性。<br>哪知脆弱基础上的高楼只须多压一根头发的重量，也许就崩溃了…</p>
<blockquote class="blockquote-center">没有人可以带走你的痛，所以也别让任何人带走你的幸福</blockquote>]]></content>
      <categories>
        <category>摘要</category>
      </categories>
      <tags>
        <tag>摘要</tag>
      </tags>
  </entry>
  <entry>
    <title>这个年纪</title>
    <url>/2020/01/23/%E6%91%98%E8%A6%81/%E8%BF%99%E4%B8%AA%E5%B9%B4%E7%BA%AA/</url>
    <content><![CDATA[<p>这个年纪<br>作曲 : 齐一<br>作词 : 齐一</p>
<p>当我发现我已到了该成家的年纪</p>
<p>但我的女人呢，但我的女人呢</p>
<p>当我习惯把实话都变成了童话</p>
<p>那我的单纯呢，那我的单纯呢</p>
<p>这个年纪我已不再将就有些事情无法强求</p>
<p>该来的总会来该走的也无法挽留</p>
<p>青春慢慢从身边溜走我开始变的怀旧</p>
<p>喝光了这杯酒就再也无法回头</p>
<p>这个年纪的我们爱情跟不上分开的节奏</p>
<p>这个年纪的我们更珍惜难得的自由</p>
<p>这个年纪的我们比起从前更容易感动</p>
<p>这个年纪的我们徘徊在理想与现实之中</p>
<p>这个年纪我已不再将就有些事情无法强求</p>
<p>该来的总会来该走的也无法挽留</p>
<p>青春慢慢从身边溜走我开始变的怀旧</p>
<p>喝光了这杯酒就再也无法回头</p>
<p>这个年纪的我们爱情跟不上分开的节奏</p>
<p>这个年纪的我们更珍惜难得的自由</p>
<p>这个年纪的我们比起从前更容易感动</p>
<p>这个年纪的我们徘徊在理想与现实之中</p>
<p>不知不觉孤独不再可耻了</p>
<p>不知不觉爸爸的情绪变得脆弱了</p>
<p>不知不觉一把柴米油盐也成为压力了</p>
<p>不知不觉我们也开始懂事了</p>
<p>呐呐呐呐呐 呐呐呐呐呐</p>
<p>呐呐呐呐呐 呐呐呐呐呐</p>
<p>呐呐呐呐呐 呐呐呐呐呐</p>
<p>呐呐呐呐呐 呐呐呐呐呐</p>
<p><video class="media" src="blob:https://music.163.com/c7e24f71-cfff-4b58-841c-34464754611a"></video></p>
]]></content>
      <categories>
        <category>摘要</category>
      </categories>
      <tags>
        <tag>摘要</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>那年你27、8岁</title>
    <url>/2019/11/01/%E6%91%98%E8%A6%81/%E9%82%A3%E5%B9%B4%E4%BD%A027%E3%80%818%E5%B2%81/</url>
    <content><![CDATA[<p>18岁以后，他已经不是为了自己而活着</p>
<p>18岁，你上了大学。</p>
<p>20岁，你大二结束，开始悔恨<br>自己前两年幼稚的行为<br>于是开始努力</p>
<p>22岁你大学毕业了，却发现<br>找不到一份令自己满意的工作</p>
<p>26岁，你看着身边的人都结了婚<br>婚礼的份子钱逐年递增<br>春节回家，父母从带你串亲戚<br>变成了带你去见相亲对象<br>见了十几个姑娘<br>你每次都觉得和那个她比<br>差了一点</p>
<p>28岁那年，你遇到了一个和你遭遇差不多的姑娘<br>你们有一搭没一搭聊着<br>她说：你还不错<br>你喝了一口可乐说：你也是<br>你还不确定喜不喜欢她<br>双方家长就已经摆好了订婚宴<br>结婚的前一周，你和朋友出去喝酒<br>你说，不想结婚<br>朋友说，你啊，就是想太多。谁不是这么过来的？</p>
<p>29岁，你们终于结了婚<br>婚礼办的不大不小，朋友来的不多不少<br>攒了几年想要去实现理想的钱<br>搭在了这一场百人的私人庙会上<br>婚礼进行到中间<br>司仪带着标准的商业化微笑<br>对着台下的亲朋喊道<br>要不要让他们亲一个！<br>台下那些人跟着一起起哄<br>不知道为什么<br>你简简单单的亲了一口<br>俩人恢复到了一开始的站位<br>你小声说了一句：我爱你<br>那个昨天还看不惯你倒腾模型的新娘<br>愣了一下说：我也爱你<br>你不确定她是不是对你说的<br>就像你不确定是不是对她说的一样<br>婚礼结束后，并没有你想象的浪漫<br>你听着外屋的新娘一笔一笔的算着份子钱<br>想着不过才两年，怎么就变成这样了<br>想着想着，洞房夜就睡着了</p>
<p>30岁，她怀孕了<br>辞掉了工作，在家养胎<br>你在公司逐渐有了点地位<br>手里管着十来个人<br>独立负责一个项目<br>结婚前陪嫁的那辆20万左右的车<br>也变成了你一个人的独享<br>但你依然不敢放松<br>每次加班<br>电话那头都是抱怨与委屈<br>但你不能争辩什么<br>谁让她怀了你的孩子<br>在这一刻<br>不论是她的父母还是你的父母<br>都无条件的站在这一边</p>
<p>31岁，孩子落地了<br>前前后后连孕检带住院费花了10万块钱<br>不过无所谓<br>你看着你的孩子，怎么看怎么喜欢<br>高兴的仿佛这是你的新生</p>
<p>32岁，这是人生最不愿意重复的一年<br>平均睡眠3小时<br>孩子每一个小时都要闹腾一次<br>第二天拖着睡不醒的眼睛去上班<br>老板说你上班不干活<br>回家媳妇说你不干活<br>你想了半天不明白，那谁干活呢？<br>那辆开了3年的车<br>成为了你真正的家<br>你不在抱怨路上拥堵的交通<br>你甚至开始希望<br>再多堵一会<br>回到家，你关了发动机<br>在车上点了一根烟<br>这是你每天最幸福的十分钟<br>车前是功名利禄，车尾是柴米油盐</p>
<p>35岁你因为身体越来越差<br>加班越来越少<br>晋升的速度也越来越缓慢<br>那天下班，媳妇告诉你<br>孩子要上幼儿园了<br>双语的一个月3000<br>你皱了皱眉头，那边就已经不耐烦了<br>“四单元的老王家孩子，一个月6000”<br>“你已经这样了，你想让孩子也输？”<br>你没说话，回屋给媳妇转了6000块钱<br>这笔钱，你原本打算给自己过个生日，买个新电脑</p>
<p>38岁，孩子上了一年级<br>老师说一年级最关键，打好基础很重要<br>你笑着说，是是是，老师您多照顾<br>新生接待的老师看着你不明事理的脸<br>给你指了一条明路<br>“课外辅导班，一个月2200”</p>
<p>40岁的时候，孩子上了三年级<br>老师说，三年级，最关键，承上启下很重要<br>你笑着说：是是是，正打算再报个补习班</p>
<p>44岁，孩子上了初中<br>有一天回到家，她对你说<br>爸爸，我想学钢琴<br>你没什么犹豫的<br>你以为这些年，你已经习惯了<br>但那句“爸爸现在买不起”你始终说不出口<br>好在孩子比较懂事<br>她说：爸爸没事，要不我先学陶笛也可以<br>你看着这么懂事的孩子，却开心不起来</p>
<p>46岁，孩子上了一个不好不差的高中<br>有一天你在开会，接到了老师的电话<br>电话里说你的孩子在学校打架了<br>叫你去一趟<br>你唯唯诺诺的<br>和那个比你还小5岁的领导请了个假<br>到学校又被老师训了一通<br>无非台词就是那一句<br>你们做家长的就知道工作，能不能陪陪孩子<br>你看着这个老师，有点可笑<br>好像当时说：家长在外辛苦点<br>多赚点钱让孩子多补补课的和他不是一个人</p>
<p>50岁，孩子上了大学<br>很争气，是一个一本<br>他学的专业你有点看不懂<br>你只知道工作不一定好找<br>而且学费还死贵<br>你和他深夜想聊聊<br>准备了半斤白酒，一碟花生米<br>你说着那些曾经你最讨厌的话<br>还是要为以后工作着想<br>挑个热门的专业<br>活着比热爱重要<br>你们从交流变成了争吵<br>你发现，你老了<br>老到可能都打不过这个18岁的孩子<br>你说不过他，只能说一句：我是你爸爸！<br>孩子看着你，知道再怎么争辩都没用<br>这场确立你最后威严的酒局不欢而散<br>你听的不真切<br>在孩子回自己屋的路上好像叨叨了一句<br>“我不想活的像你一样”<br>怎么就哭了呢？50岁的人了<br>一定是酒太辣了，对不对<br>一定是酒太辣了</p>
<p>55岁，孩子工作了，似乎有一点理解你了<br>但你却反了过来，你说不要妥协</p>
<p>56岁，孩子也结婚了<br>你问他喜欢那个姑娘么<br>他愣了愣说：喜欢吧</p>
<p>60岁，辛苦了一辈子，想出去走走<br>身边的那个人过了30年<br>你依旧分不清到底喜不喜欢<br>你们开始规划旅游路线<br>这么多年了<br>你们还是存在分歧，还是在争吵<br>某个瞬间，你觉得<br>这样可能也挺好<br>一切都准备好了<br>儿子说：爸妈，我工作太忙了<br>可以帮我照顾一下孩子么<br>你们退了机票，又回到了30年前</p>
<p>70岁，孩子的孩子也长大了，不用天天操心了<br>你下定决心说：一定要去玩一趟<br>可是手边的拐杖<br>只能支持你走到楼下的花园<br>75岁，你在医院的病床上<br>身边聚满了人，你迷迷糊糊的看见医生摇了摇头<br>周围那些人神情肃穆<br>你明白了，你要死掉了<br>你没有感到一丝害怕<br>你突然问自己，我到底是什么时候死掉的呢？<br>你想起来30岁的那场婚礼<br>原来，那时候，你就死掉了吧<br>依照惯例<br>死前的3秒，你的大脑要走马灯<br>倒叙你这75个年头的一生<br>画面一张一张的过<br>1秒<br>2秒<br>两秒过去了<br>你面无表情的看着这两秒内的回忆<br>第3秒<br>突然你笑了<br>原来已经回到了15岁的那一年<br>你看见一个男孩<br>他叼着一袋牛奶，背着书包<br>从另一个女孩家的阳台下跑过<br>那个男孩朝窗户里看了看<br>那是15岁的你暗恋的那个女孩子<br>你想不起来她长什么样子了<br>最后一秒你努力的回忆着<br>然后终于笑了出来<br>3秒过去了<br>身边的人突然间开始嚎啕大哭<br>你可能听不清了<br>你最后听到的嘈杂的声音<br>是一群十五六的少年 起着哄说的<br>答应他<br>答应他<br>答应他</p>
]]></content>
      <categories>
        <category>摘要</category>
      </categories>
      <tags>
        <tag>摘要</tag>
      </tags>
  </entry>
  <entry>
    <title>分机号</title>
    <url>/2018/04/13/%E7%AE%97%E6%B3%95/%E5%88%86%E6%9C%BA%E5%8F%B7/</url>
    <content><![CDATA[<p>X老板脾气古怪，他们公司的电话分机号都是3位数，老板规定，所有号码必须是降序排列，且不能有重复的数位。比如：</p>
<p>751,520,321 都满足要求，而，<br>766,918,201 就不符合要求。</p>
<p>现在请你计算一下，按照这样的规定，一共有多少个可用的3位分机号码？</p>
<p>请直接提交该数字，不要填写任何多余的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int num = 0;</span><br><span class="line">		for (int i = 9; i &gt;= 0; i--) &#123;</span><br><span class="line">			for (int j = 9; j &gt;= 0; j--) &#123;</span><br><span class="line">				for (int k = 9; k &gt;= 0; k--) &#123;</span><br><span class="line">					if (i &gt; j &amp;&amp; j &gt; k) &#123;</span><br><span class="line">						num++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>切开字符串</title>
    <url>/2018/04/09/%E7%AE%97%E6%B3%95/%E5%88%87%E5%BC%80%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>Pear有一个字符串，不过他希望把它切成两段。<br>这是一个长度为N（&lt;&#x3D;10^5）的字符串。<br>Pear希望选择一个位置，把字符串不重复不遗漏地切成两段，长度分别是t和N-t（这两段都必须非空）。<br>Pear用如下方式评估切割的方案：<br>定义“正回文子串”为：长度为奇数的回文子串。<br>设切成的两段字符串中，前一段中有A个不相同的正回文子串，后一段中有B个不相同的非正回文子串，则该方案的得分为A<em>B。<br>注意，后一段中的B表示的是：“…非正回文…”，而不是: “…正回文…”。<br>那么所有的切割方案中，A</em>B的最大值是多少呢？<br>【输入数据】<br>输入第一行一个正整数N（&lt;&#x3D;10^5）<br>接下来一行一个字符串，长度为N。该字符串仅包含小写英文字母。<br>【输出数据】<br>一行一个正整数，表示所求的A*B的最大值。<br>【样例输入】<br>10<br>bbaaabcaba<br>【样例输出】<br>38<br>【数据范围】<br>对于20%的数据，N&lt;&#x3D;100<br>对于40%的数据，N&lt;&#x3D;1000<br>对于100%的数据，N&lt;&#x3D;10^5<br>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 512M<br>CPU消耗 &lt; 2000ms<br>请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。<br>所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。<br>注意：不要使用package语句。不要使用jdk1.7及以上版本的特性。<br>注意：主类的名字必须是：Main，否则按无效代码处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.Set;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int max = -1;</span><br><span class="line">		String[] str = input();</span><br><span class="line">		System.out.println(1);</span><br><span class="line">		for (int i = 0; i &lt; str.length; i += 2) &#123;</span><br><span class="line">			int x = palindrome(str[i]);</span><br><span class="line">			int y = notPalindrome(str[i + 1]);</span><br><span class="line">			max = Math.max(max, x * y);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(max);</span><br><span class="line">	&#125;</span><br><span class="line">// 非回文</span><br><span class="line">	private static int notPalindrome(String str) &#123;</span><br><span class="line">		int sum = 0;</span><br><span class="line">		Set set = new HashSet&lt;&gt;();</span><br><span class="line">		for (int i = 1; i &lt;= str.length(); i++) &#123;</span><br><span class="line">			for (int j = 0; j &lt;= str.length() - i; j++) &#123;</span><br><span class="line">				set.add(str.substring(j, i + j));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Iterator iterator = set.iterator();</span><br><span class="line">		while (iterator.hasNext()) &#123;</span><br><span class="line">			if (!verification(iterator.next())) &#123;</span><br><span class="line">				sum++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// String[] array = set.toArray(new String[0]);</span><br><span class="line">		// for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">		// if (!verification(array[i])) &#123;</span><br><span class="line">		// sum++;</span><br><span class="line">		// &#125;</span><br><span class="line">		// &#125;</span><br><span class="line">		return sum;</span><br><span class="line">	&#125;</span><br><span class="line">// 回问</span><br><span class="line">	private static int palindrome(String str) &#123;</span><br><span class="line">		int sum = 0;</span><br><span class="line">		Set set = new HashSet&lt;&gt;();</span><br><span class="line">		for (int i = 1; i &lt;= str.length(); i++) &#123;</span><br><span class="line">			for (int j = 0; j &lt;= str.length() - i; j++) &#123;</span><br><span class="line">				set.add(str.substring(j, i + j));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Iterator iterator = set.iterator();</span><br><span class="line">		while (iterator.hasNext()) &#123;</span><br><span class="line">			if (verification(iterator.next())) &#123;</span><br><span class="line">				sum++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// String[] array = set.toArray(new String[0]);</span><br><span class="line">		// for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">		// if (verification(array[i])) &#123;</span><br><span class="line">		// sum++;</span><br><span class="line">		// &#125;</span><br><span class="line">		// &#125;</span><br><span class="line">		return sum;</span><br><span class="line">	&#125;</span><br><span class="line">private static boolean verification(String str) &#123;</span><br><span class="line">		StringBuffer sb = new StringBuffer(str);</span><br><span class="line">		String s = sb.reverse().toString();</span><br><span class="line">		if (str.length() % 2 == 0) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			if (str.equals(s)) &#123;</span><br><span class="line">				return true;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">private static String[] input() &#123;</span><br><span class="line">		Scanner scanner = new Scanner(System.in);</span><br><span class="line">		int number = scanner.nextInt();</span><br><span class="line">		String[] str = new String[(number - 1) * 2];</span><br><span class="line">		String s = scanner.next();</span><br><span class="line">		int j = 1;</span><br><span class="line">		for (int i = 0; i &lt; str.length; i += 2) &#123;</span><br><span class="line">			str[i] = s.substring(0, j);</span><br><span class="line">			str[i + 1] = s.substring(j, s.length());</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		scanner.close();</span><br><span class="line">		return str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>只能解决20%</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>四阶幻方</title>
    <url>/2018/04/07/%E7%AE%97%E6%B3%95/%E5%9B%9B%E9%98%B6%E5%B9%BB%E6%96%B9/</url>
    <content><![CDATA[<p>把1~16的数字填入4×4的方格中，使得行、列以及两个对角线的和都相等，满足这样的特征时称为：四阶幻方。<br>四阶幻方可能有很多方案。如果固定左上角为1，请计算一共有多少种方案。<br>比如：<br>1 2 15 16<br>12 14 3 5<br>13 7 10 4<br>8 11 6 9<br>以及：<br>1 12 13 8<br>2 14 7 11<br>15 3 10 6<br>16 5 4 9<br>就可以算为两种不同的方案。<br>请提交左上角固定为1时的所有方案数字，不要填写任何多余内容或说明文字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	static int[] num = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 &#125;;</span><br><span class="line">	static int su = 0;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		sun(1);</span><br><span class="line">&#125;</span><br><span class="line">private static void sun(int i) &#123;</span><br><span class="line">		if (sum() &amp;&amp; i == num.length) &#123;</span><br><span class="line">			su++;</span><br><span class="line">			System.out.println(su);</span><br><span class="line">		&#125;</span><br><span class="line">		int tmp = 0;</span><br><span class="line">		for (int j = i; j &lt; num.length; j++) &#123;</span><br><span class="line">			tmp = num[j];</span><br><span class="line">			num[j] = num[i];</span><br><span class="line">			num[i] = tmp;</span><br><span class="line">			sun(i + 1);</span><br><span class="line">			tmp = num[j];</span><br><span class="line">			num[j] = num[i];</span><br><span class="line">			num[i] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">private static boolean sum() &#123;</span><br><span class="line">		int tmp = num[0] + num[1] + num[2] + num[3];</span><br><span class="line">		for (int i = 0; i &lt; num.length; i += 4) &#123;</span><br><span class="line">			if (tmp != num[i] + num[i + 1] + num[i + 2] + num[i + 3])</span><br><span class="line">				return false;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">			if (tmp != num[i] + num[i + 4] + num[i + 8] + num[i + 12])</span><br><span class="line">				return false;</span><br><span class="line">		&#125;</span><br><span class="line">		if (tmp != num[0] + num[5] + num[10] + num[15])</span><br><span class="line">			return false;</span><br><span class="line">		if (tmp != num[3] + num[6] + num[9] + num[12])</span><br><span class="line">			return false;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理论有解</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>奇怪的数列</title>
    <url>/2018/04/10/%E7%AE%97%E6%B3%95/%E5%A5%87%E6%80%AA%E7%9A%84%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>从X星截获一份电码，是一些数字，如下：<br>13<br>1113<br>3113<br>132113<br>1113122113<br>….</p>
<p>YY博士经彻夜研究，发现了规律：<br>第一行的数字随便是什么，以后每一行都是对上一行“读出来”<br>比如第2行，是对第1行的描述，意思是：1个1，1个3，所以是：1113<br>第3行，意思是：3个1,1个3，所以是：3113</p>
<p>请你编写一个程序，可以从初始数字开始，连续进行这样的变换。</p>
<p>数据格式：</p>
<p>第一行输入一个数字组成的串，不超过100位<br>第二行，一个数字n，表示需要你连续变换多少次，n不超过20</p>
<p>输出一个串，表示最后一次变换完的结果。</p>
<p>例如：<br>用户输出：<br>5<br>7</p>
<p>则程序应该输出：<br>13211321322115</p>
<p>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 512M<br>CPU消耗 &lt; 1000ms</p>
<p>请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。</p>
<p>所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。<br>注意：不要使用package语句。不要使用jdk1.7及以上版本的特性。<br>注意：主类的名字必须是：Main，否则按无效代码处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner scanner = new Scanner(System.in);</span><br><span class="line">		String input = scanner.next();</span><br><span class="line">		int num = scanner.nextInt();</span><br><span class="line">		String number = list(input);</span><br><span class="line">		for (int i = 1; i &lt; num; i++) &#123;</span><br><span class="line">			number = list(number);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(number);</span><br><span class="line">		scanner.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static String list(String input) &#123;</span><br><span class="line">		int i = 0;</span><br><span class="line">		int tmp;</span><br><span class="line">		String index = &quot;&quot;;</span><br><span class="line">		while (i &lt; input.length()) &#123;</span><br><span class="line">			tmp = 1;</span><br><span class="line">			while (flag(i, input)) &#123;</span><br><span class="line">				i++;</span><br><span class="line">				tmp++;</span><br><span class="line">			&#125;</span><br><span class="line">			index = index + tmp + String.valueOf(input.charAt(i));</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		return index;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static boolean flag(int i, String input) &#123;</span><br><span class="line">		String valueOf = String.valueOf(input.charAt(i));</span><br><span class="line">		if (i + 1 &lt; input.length()) &#123;</span><br><span class="line">			String valueOf2 = String.valueOf(input.charAt(i + 1));</span><br><span class="line">			if (valueOf.equals(valueOf2)) &#123;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>居民集会</title>
    <url>/2018/04/08/%E7%AE%97%E6%B3%95/%E5%B1%85%E6%B0%91%E9%9B%86%E4%BC%9A/</url>
    <content><![CDATA[<p>蓝桥村的居民都生活在一条公路的边上，公路的长度为L，每户家庭的位置都用这户家庭到公路的起点的距离来计算，第i户家庭距起点的距离为di。</p>
<p>每年，蓝桥村都要举行一次集会。今年，由于村里的人口太多，村委会决定要在4个地方举行集会，其中3个位于公路中间，1个位最公路的终点。</p>
<p>已知每户家庭都会向着远离公路起点的方向去参加集会，参加集会的路程开销为家庭内的人数ti与距离的乘积。</p>
<p>给定每户家庭的位置di和人数ti，请为村委会寻找最好的集会举办地：p1, p2, p3, p4 (p1&lt;&#x3D;p2&lt;&#x3D;p3&lt;&#x3D;p4&#x3D;L),使得村内所有人的路程开销和最小。</p>
<p>【输入格式】<br>输入的第一行包含两个整数n, L，分别表示蓝桥村的家庭数和公路长度。<br>接下来n行，每行两个整数di, ti，分别表示第i户家庭距离公路起点的距离和家庭中的人数。</p>
<p>【输出格式】<br>输出一行，包含一个整数，表示村内所有人路程的开销和。<br>【样例输入】<br>6 10<br>1 3<br>2 2<br>4 5<br>5 20<br>6 5<br>8 7<br>【样例输出】<br>18<br>【样例说明】<br>在距起点2, 5, 8, 10这4个地方集会，6个家庭需要的走的距离分别为1, 0, 1, 0, 2, 0，总的路程开销为1<em>3+0</em>2+1<em>5+0</em>20+2<em>5+0</em>7&#x3D;18。</p>
<p>【数据规模与约定】<br>对于10%的评测数据，1&lt;&#x3D;n&lt;&#x3D;300。<br>对于30%的评测数据，1&lt;&#x3D;n&lt;&#x3D;2000，1&lt;&#x3D;L&lt;&#x3D;10000，0&lt;&#x3D;di&lt;&#x3D;L，di&lt;&#x3D;di+1，0&lt;&#x3D;ti&lt;&#x3D;20。<br>对于100%的评测数据，1&lt;&#x3D;n&lt;&#x3D;100000，1&lt;&#x3D;L&lt;&#x3D;1000000，0&lt;&#x3D;di&lt;&#x3D;L，di&lt;&#x3D;di+1，0&lt;&#x3D;ti&lt;&#x3D;1000000。</p>
<p>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 512M<br>CPU消耗 &lt; 8000ms</p>
<p>请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。</p>
<p>所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。<br>注意：不要使用package语句。不要使用jdk1.7及以上版本的特性。<br>注意：主类的名字必须是：Main，否则按无效代码处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	static int n = 0, l = 0;// 家庭数和公路长度</span><br><span class="line">	static int[][] family;// 家庭距离公路起点的距离和家庭中的人数</span><br><span class="line">	static int sum = 0;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner scanner = new Scanner(System.in);</span><br><span class="line">		n = scanner.nextInt();</span><br><span class="line">		l = scanner.nextInt();</span><br><span class="line">		family = new int[n][2];</span><br><span class="line">		for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">			family[i][0] = scanner.nextInt();</span><br><span class="line">			family[i][1] = scanner.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">		scanner.close();</span><br><span class="line">		punctuation(l);</span><br><span class="line">		System.out.println(sum);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static void punctuation(int num) &#123;</span><br><span class="line">		int tmp = 0;</span><br><span class="line">		for (int i = 0; i &lt;= num; i++) &#123;</span><br><span class="line">			for (int j = i; j &lt;= num; j++) &#123;</span><br><span class="line">				for (int k = 0; k &lt;= num; k++) &#123;</span><br><span class="line">					tmp = overhead(i, j, k);</span><br><span class="line">					if (tmp &lt;= sum) &#123;</span><br><span class="line">						sum = tmp;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static int overhead(int i, int j, int k) &#123;</span><br><span class="line">		int number = 0;</span><br><span class="line">		int with = 0;</span><br><span class="line">		for (int l = 0; l &lt; n; l++) &#123;</span><br><span class="line">			number = family[l][0];</span><br><span class="line">			int contrast = Compared(number, i, j, k);</span><br><span class="line">			with += (contrast - number) * family[l][1];</span><br><span class="line">		&#125;</span><br><span class="line">		if (i == 0 &amp;&amp; j == 0 &amp;&amp; k == 0) &#123;</span><br><span class="line">			sum = with;</span><br><span class="line">		&#125;</span><br><span class="line">		return with;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static int Compared(int number, int i, int j, int k) &#123;</span><br><span class="line">		if (number &lt;= i) &#123;</span><br><span class="line">			return i;</span><br><span class="line">		&#125; else if (number &lt;= j) &#123;</span><br><span class="line">			return j;</span><br><span class="line">		&#125; else if (number &lt;= k) &#123;</span><br><span class="line">			return k;</span><br><span class="line">		&#125; else if (number &lt;= l) &#123;</span><br><span class="line">			return l;</span><br><span class="line">		&#125;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>显示二叉树</title>
    <url>/2018/04/15/%E7%AE%97%E6%B3%95/%E6%98%BE%E7%A4%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>排序二叉树的特征是：<br>某个节点的左子树的所有节点值都不大于本节点值。<br>某个节点的右子树的所有节点值都不小于本节点值。</p>
<p>为了能形象地观察二叉树的建立过程，小明写了一段程序来显示出二叉树的结构来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">		public static void main(String[] args) &#123;</span><br><span class="line">		BiTree tree = new BiTree(500);</span><br><span class="line">		tree.add(new BiTree(200));</span><br><span class="line">		tree.add(new BiTree(509));</span><br><span class="line">		tree.add(new BiTree(100));</span><br><span class="line">		tree.add(new BiTree(250));</span><br><span class="line">		tree.add(new BiTree(507));</span><br><span class="line">		tree.add(new BiTree(600));</span><br><span class="line">		tree.add(new BiTree(650));</span><br><span class="line">		tree.add(new BiTree(450));</span><br><span class="line">		tree.add(new BiTree(510));</span><br><span class="line">		tree.add(new BiTree(440));</span><br><span class="line">		tree.add(new BiTree(220));</span><br><span class="line">		tree.show();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static class BiTree &#123;</span><br><span class="line">		private int v;</span><br><span class="line">		private BiTree l;// 左</span><br><span class="line">		private BiTree r;// 右</span><br><span class="line"></span><br><span class="line">		public BiTree(int v) &#123;</span><br><span class="line">			this.v = v;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public void add(BiTree the) &#123;</span><br><span class="line">			if (the.v &lt; v) &#123;</span><br><span class="line">				if (l == null)</span><br><span class="line">					l = the;</span><br><span class="line">				else</span><br><span class="line">					l.add(the);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				if (r == null)</span><br><span class="line">					r = the;</span><br><span class="line">				else</span><br><span class="line">					r.add(the);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public int getHeight() &#123;</span><br><span class="line">			int h = 2;</span><br><span class="line">			int hl = l == null ? 0 : l.getHeight();</span><br><span class="line">			int hr = r == null ? 0 : r.getHeight();</span><br><span class="line">			return h + Math.max(hl, hr);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public int getWidth() &#123;</span><br><span class="line">			int w = (&quot;&quot; + v).length();</span><br><span class="line">			if (l != null)</span><br><span class="line">				w += l.getWidth();</span><br><span class="line">			if (r != null)</span><br><span class="line">				w += r.getWidth();</span><br><span class="line">			return w;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public void show() &#123;</span><br><span class="line">			char[][] buf = new char[getHeight()][getWidth()];</span><br><span class="line">			printInBuf(buf, 0, 0);</span><br><span class="line">			showBuf(buf);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		private void showBuf(char[][] x) &#123;</span><br><span class="line">			for (int i = 0; i &lt; x.length; i++) &#123;</span><br><span class="line">				for (int j = 0; j &lt; x[i].length; j++)</span><br><span class="line">					System.out.print(x[i][j] == 0 ? &#x27; &#x27; : x[i][j]);</span><br><span class="line">				System.out.println();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		private void printInBuf(char[][] buf, int x, int y) &#123;</span><br><span class="line">			String sv = &quot;&quot; + v;</span><br><span class="line">			int p1 = l == null ? x : l.getRootPos(x);</span><br><span class="line">			int p2 = getRootPos(x);</span><br><span class="line">			int p3 = r == null ? p2 : r.getRootPos(p2 + sv.length());</span><br><span class="line">			buf[y][p2] = &#x27;|&#x27;;</span><br><span class="line">			for (int i = p1; i &lt;= p3; i++)</span><br><span class="line">				buf[y + 1][i] = &#x27;-&#x27;;</span><br><span class="line">			for (int i = 0; i &lt; sv.length(); i++)</span><br><span class="line">				buf[y + 1][p2 + i] = sv.charAt(i);// 填空位置</span><br><span class="line">			if (p1 &lt; p2) buf[y + 1][p1] = &#x27;/&#x27;; if (p3 &gt; p2)</span><br><span class="line">				buf[y + 1][p3] = &#x27;\\&#x27;;</span><br><span class="line">			if (l != null)</span><br><span class="line">				l.printInBuf(buf, x, y + 2);</span><br><span class="line">			if (r != null)</span><br><span class="line">				r.printInBuf(buf, p2 + sv.length(), y + 2);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		private int getRootPos(int x) &#123;</span><br><span class="line">			return l == null ? x : x + l.getWidth();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>生成回文数</title>
    <url>/2018/04/12/%E7%AE%97%E6%B3%95/%E7%94%9F%E6%88%90%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<p>所谓回文数就是左右对称的数字，比如：<br>585,5885,123321…<br>当然，单个的数字也可以算作是对称的。</p>
<p>小明发现了一种生成回文数的方法：<br>比如，取数字19，把它与自己的翻转数相加：<br>19 + 91 &#x3D; 110，如果不是回文数，就再进行这个过程：<br>110 + 011 &#x3D; 121 这次是回文数了。</p>
<p>200以内的数字中，绝大多数都可以在30步以内变成回文数，只有一个数字很特殊，就算迭代了1000次，它还是顽固地拒绝回文！</p>
<p>请你提交该顽固数字，不要填写任何多余的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.math.BigInteger;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		StringBuffer buffer = new StringBuffer();</span><br><span class="line">		Long i = 10L;</span><br><span class="line">		BigInteger tmp = new BigInteger(i + &quot;&quot;);</span><br><span class="line">		int count = 0;</span><br><span class="line">		while (i &lt;= 200) &#123;</span><br><span class="line">			while (!isHuiWen(tmp) &amp;&amp; i &lt;= 200) &#123;</span><br><span class="line">				buffer.append(tmp);</span><br><span class="line">				// Long tmp2 = Long.valueOf(buffer.reverse().toString().trim());</span><br><span class="line">				// tmp = tmp + tmp2;</span><br><span class="line">				BigInteger big = new BigInteger(buffer.toString());</span><br><span class="line">				BigInteger big2 = new BigInteger(buffer.reverse().toString());</span><br><span class="line">				tmp = big.add(big2);</span><br><span class="line">				buffer.delete(0, buffer.length());</span><br><span class="line">				count++;</span><br><span class="line">				</span><br><span class="line">				if (count &gt; 9999) &#123;</span><br><span class="line">					System.out.println(i);</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;			</span><br><span class="line">			count = 0;			</span><br><span class="line">			i++;</span><br><span class="line">			tmp = new BigInteger(i + &quot;&quot;);</span><br><span class="line">			buffer.delete(0, buffer.length());</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static boolean isHuiWen(BigInteger tmp) &#123;</span><br><span class="line">		StringBuffer buffer1 = new StringBuffer();</span><br><span class="line">		StringBuffer buffer2 = new StringBuffer();</span><br><span class="line">		buffer1.append(tmp);</span><br><span class="line">		buffer2.append(tmp).reverse();</span><br><span class="line">		boolean flag = false;</span><br><span class="line">		// int i = 0;</span><br><span class="line">		// while (buffer1.length() / 2 &gt; i) &#123;</span><br><span class="line">		// if (!(buffer1.charAt(i) == buffer2.charAt(i))) &#123;</span><br><span class="line">		// flag = false;</span><br><span class="line">		// break;</span><br><span class="line">		// &#125;</span><br><span class="line">		// i++;</span><br><span class="line">		// &#125;</span><br><span class="line">		if (buffer1.toString().equals(buffer2.toString())) &#123;</span><br><span class="line">			flag = true;</span><br><span class="line">		&#125;</span><br><span class="line">		return flag;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>空心菱形</title>
    <url>/2018/04/11/%E7%AE%97%E6%B3%95/%E7%A9%BA%E5%BF%83%E8%8F%B1%E5%BD%A2/</url>
    <content><![CDATA[<p>小明刚刚开发了一个小程序，可以打印出任意规模的空心菱形，规模为6时，如下图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">****** ******</span><br><span class="line">***** 	*****</span><br><span class="line">**** 	 ****</span><br><span class="line">*** 	  ***</span><br><span class="line">** 		   **</span><br><span class="line">*           *</span><br><span class="line">**         **</span><br><span class="line">*** 	  ***</span><br><span class="line">**** 	 ****</span><br><span class="line">***** 	*****</span><br><span class="line">****** ******</span><br><span class="line">（如果有对齐问题，参看【图1.png】）</span><br></pre></td></tr></table></figure>

<p>他一高兴，踢掉了电源，最后一次修改没有保存…..<br>毛病出在划线的部分。<br>请你帮助小明分析程序，填写划线部分缺失的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	static String pr(int m, int n) &#123;</span><br><span class="line">		String s = &quot;&quot;;</span><br><span class="line">		for (int i = 0; i &lt; n; i++)</span><br><span class="line">			s += &quot; &quot;;</span><br><span class="line">		for (int i = 0; i &lt; m; i++)</span><br><span class="line">			s = &quot;*&quot; + s + &quot;*&quot;;</span><br><span class="line">		return s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static void f(int n) &#123;</span><br><span class="line">		String s = pr(1, n * 2 - 1) + &quot;\n&quot;;</span><br><span class="line">		String s2 = s;</span><br><span class="line"></span><br><span class="line">		for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">			s = pr(1 + i, n * 2 - i * 2 - 1) + &quot;\n&quot;; // 填空位置</span><br><span class="line">			s2 = s + s2 + s;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.print(s2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		f(10);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>穿越雷区</title>
    <url>/2018/04/16/%E7%AE%97%E6%B3%95/%E7%A9%BF%E8%B6%8A%E9%9B%B7%E5%8C%BA/</url>
    <content><![CDATA[<p>X星的坦克战车很奇怪，它必须交替地穿越正能量辐射区和负能量辐射区才能保持正常运转，否则将报废。<br>某坦克需要从A区到B区去（A，B区本身是安全区，没有正能量或负能量特征），怎样走才能路径最短？</p>
<p>已知的地图是一个方阵，上面用字母标出了A，B区，其它区都标了正号或负号分别表示正负能量辐射区。<br>例如：<br>A + – + –<br>– + – – +<br>– + + + –</p>
<ul>
<li>– + – +<br>B + – + –</li>
</ul>
<p>坦克车只能水平或垂直方向上移动到相邻的区。</p>
<p>数据格式要求：</p>
<p>输入第一行是一个整数n，表示方阵的大小， 4&lt;&#x3D;n&lt;100<br>接下来是n行，每行有n个数据，可能是A，B，+，-中的某一个，中间用空格分开。<br>A，B都只出现一次。</p>
<p>要求输出一个整数，表示坦克从A区到B区的最少移动步数。<br>如果没有方案，则输出-1</p>
<p>例如：<br>用户输入：<br>5<br>A + – + –<br>– + – – +<br>– + + + –</p>
<ul>
<li>– + – +<br>B + – + –</li>
</ul>
<p>则程序应该输出：<br>10</p>
<p>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 512M<br>CPU消耗 &lt; 2000ms</p>
<p>请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。</p>
<p>所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。<br>注意：不要使用package语句。不要使用jdk1.7及以上版本的特性。<br>注意：主类的名字必须是：Main，否则按无效代码处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">	static String[][] figure;</span><br><span class="line">	static int[] start = new int[2];</span><br><span class="line">	static int min = Integer.MAX_VALUE;</span><br><span class="line">	static int count = 0;</span><br><span class="line">	static int[] direction = new int[] &#123; 0, 1, 1, 0, 0, -1, -1, 0 &#125;;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String[][] image = input();</span><br><span class="line">		initial(image, start[0], start[1]);</span><br><span class="line">		System.out.println(min);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 开始</span><br><span class="line">	private static void initial(String[][] image, int x, int y) &#123;</span><br><span class="line">		// 判断四个方向</span><br><span class="line">		for (int i = 0; i &lt; 8; i += 2) &#123; //下一步的坐标 int x2 = x + direction[i]; int y2 = y + direction[i + 1]; if (x2 &gt;= 0 &amp;&amp; x2 &lt; image.length &amp;&amp; y2 &gt;= 0 &amp;&amp; y2 &lt; image.length) &#123; //结束 if (figure[x][y].equals(&quot;B&quot;) || count &gt; min) &#123;</span><br><span class="line">					if (min &gt; count) &#123;</span><br><span class="line">						min = count;</span><br><span class="line">					&#125;</span><br><span class="line">					// 找到退一步</span><br><span class="line">					count--;</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line">				//相反，没走过</span><br><span class="line">				if (!(figure[x][y].equals(figure[x2][y2])) &amp;&amp; !(image[x2][y2].equals(&quot;0&quot;))) &#123;</span><br><span class="line">					image[x][y] = &quot;0&quot;;</span><br><span class="line">					//out(image);</span><br><span class="line">					count++;</span><br><span class="line">					initial(image, x2, y2);</span><br><span class="line">					image[x][y] = figure[x][y];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// 找不到退一步</span><br><span class="line">		count--;</span><br><span class="line">	&#125;</span><br><span class="line">	//测试显示</span><br><span class="line">	private static void out(String[][] image) &#123;</span><br><span class="line">		for (int i = 0; i &lt; image.length; i++) &#123;</span><br><span class="line">			System.out.println(Arrays.toString(image[i]));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 输入</span><br><span class="line">	private static String[][] input() &#123;</span><br><span class="line">		Scanner scanner = new Scanner(System.in);</span><br><span class="line">		int number = scanner.nextInt();</span><br><span class="line">		figure = new String[number][number];</span><br><span class="line">		String[][] image = new String[number][number];</span><br><span class="line">		for (int i = 0; i &lt; number; i++) &#123;</span><br><span class="line">			for (int j = 0; j &lt; number; j++) &#123;</span><br><span class="line">				image[i][j] = figure[i][j] = scanner.next();</span><br><span class="line"></span><br><span class="line">				if (figure[i][j].equals(&quot;A&quot;)) &#123;</span><br><span class="line">					start[0] = i;</span><br><span class="line">					start[1] = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		scanner.close();</span><br><span class="line">		return image;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第39级台阶</title>
    <url>/2018/04/05/%E7%AE%97%E6%B3%95/%E7%AC%AC39%E7%BA%A7%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<p>小明刚刚看完电影《第39级台阶》，离开电影院的时候，他数了数礼堂前的台阶数，恰好是39级！站在台阶前，他突然又想着一个问题：如果我每一步只能迈上1个或2个台阶。先迈左脚，然后左右交替，最后一步是迈右脚，也就是说一共要走偶数步。那么，上完39级台阶，有多少种不同的上法呢？</p>
<p>请你利用计算机的优势，帮助小明寻找答案。要求提交的是一个整数。</p>
<p>解：</p>
<p>阶乘》递归</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int count = 0;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		System.out.println(pace(0, 0));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static int pace(int step, int frequency) &#123;</span><br><span class="line">		if (step &gt; 39) &#123;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		if (step == 39) &#123;</span><br><span class="line">			if (frequency % 2 == 0) &#123;</span><br><span class="line">				count++;</span><br><span class="line">				return count;</span><br><span class="line">			&#125;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		pace(step + 1, frequency + 1);</span><br><span class="line">		pace(step + 2, frequency + 1);</span><br><span class="line">		return count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>胡同门牌号</title>
    <url>/2018/04/06/%E7%AE%97%E6%B3%95/%E8%83%A1%E5%90%8C%E9%97%A8%E7%89%8C%E5%8F%B7/</url>
    <content><![CDATA[<p>小明家住在一条胡同里。胡同里的门牌号都是连续的正整数，由于历史原因，最小的号码并不是从1开始排的。<br>有一天小明突然发现了有趣的事情：<br>如果除去小明家不算，胡同里的其它门牌号加起来，刚好是100！<br>并且，小明家的门牌号刚好等于胡同里其它住户的个数！<br>请你根据这些信息，推算小明家的门牌号是多少？<br>请提交该整数，不要填写任何多余的内容或说明性文字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		for (int i = 2; i &lt; 100; i++) &#123;</span><br><span class="line">			for (int j = i + 1; j &lt; 100; j++) &#123;</span><br><span class="line">				for (int k = i; k &lt;= j; k++) &#123;</span><br><span class="line">					if ((i + j) * (j - i + 1) / 2 - k == 100 &amp;&amp; k == j - i) &#123;</span><br><span class="line">						System.out.println(i + &quot; &quot; + j + &quot; &quot; + k);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>表格计算</title>
    <url>/2018/04/17/%E7%AE%97%E6%B3%95/%E8%A1%A8%E6%A0%BC%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<p>某次无聊中， atm 发现了一个很老的程序。这个程序的功能类似于 Excel ，它对一个表格进行操作。<br>不妨设表格有 n 行，每行有 m 个格子。<br>每个格子的内容可以是一个正整数，也可以是一个公式。<br>公式包括三种：</p>
<ol>
<li>SUM(x1,y1:x2,y2) 表示求左上角是第 x1 行第 y1 个格子，右下角是第 x2 行第 y2 个格子这个矩形内所有格子的值的和。</li>
<li>AVG(x1,y1:x2,y2) 表示求左上角是第 x1 行第 y1 个格子，右下角是第 x2 行第 y2 个格子这个矩形内所有格子的值的平均数。</li>
<li>STD(x1,y1:x2,y2) 表示求左上角是第 x1 行第 y1 个格子，右下角是第 x2 行第 y2 个格子这个矩形内所有格子的值的标准差。</li>
</ol>
<p>标准差即为方差的平方根。<br>方差就是：每个数据与平均值的差的平方的平均值，用来衡量单个数据离开平均数的程度。</p>
<p>公式都不会出现嵌套。</p>
<p>如果这个格子内是一个数，则这个格子的值等于这个数，否则这个格子的值等于格子公式求值结果。</p>
<p>输入这个表格后，程序会输出每个格子的值。atm 觉得这个程序很好玩，他也想实现一下这个程序。</p>
<p>「输入格式」<br>第一行两个数 n, m 。<br>接下来 n 行输入一个表格。每行 m 个由空格隔开的字符串，分别表示对应格子的内容。<br>输入保证不会出现循环依赖的情况，即不会出现两个格子 a 和 b 使得 a 的值依赖 b 的值且 b 的值依赖 a 的值。</p>
<p>「输出格式」<br>输出一个表格，共 n 行，每行 m 个保留两位小数的实数。<br>数据保证不会有格子的值超过 1e6 。</p>
<p>「样例输入」<br>3 2<br>1 SUM(2,1:3,1)<br>2 AVG(1,1:1,2)<br>SUM(1,1:2,1) STD(1,1:2,2)</p>
<p>「样例输出」<br>1.00 5.00<br>2.00 3.00<br>3.00 1.48</p>
<p>「数据范围」<br>对于 30% 的数据，满足： n, m &lt;&#x3D; 5<br>对于 100% 的数据，满足： n, m &lt;&#x3D; 50</p>
<p>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 512M<br>CPU消耗 &lt; 2000ms</p>
<p>请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。</p>
<p>所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。<br>注意：不要使用package语句。不要使用jdk1.7及以上版本的特性。<br>注意：主类的名字必须是：Main，否则按无效代码处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	static String[][] form;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		input();// 输入</span><br><span class="line">		for (int i = 0; i &lt; form.length; i++) &#123;</span><br><span class="line">			for (int j = 0; j &lt; form[i].length; j++) &#123;</span><br><span class="line">				form[i][j] = judgment(form[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		out();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 判断</span><br><span class="line">	private static String judgment(String str) &#123;</span><br><span class="line"></span><br><span class="line">		if (str.charAt(0) == &#x27;A&#x27;) &#123;// 平均数</span><br><span class="line">			return average(str);</span><br><span class="line">		&#125; else if (str.charAt(0) == &#x27;S&#x27;) &#123;</span><br><span class="line">			if (str.charAt(1) == &#x27;U&#x27;) &#123; // 和</span><br><span class="line">				return with(str);</span><br><span class="line">			&#125; else &#123;// 标准差</span><br><span class="line">				return standardDeviation(str);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;// 数</span><br><span class="line">			return String.format(&quot;%.2f&quot;, Double.parseDouble(str));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 标准差</span><br><span class="line">	private static String standardDeviation(String str) &#123;</span><br><span class="line">		int[] number = axis(str);</span><br><span class="line">		ArrayList squ = new ArrayList&lt;&gt;();</span><br><span class="line">		double ave = 0, square = 0, num = 0;</span><br><span class="line">		for (int i = number[0]; i &lt;= number[2]; i++) &#123;</span><br><span class="line">			for (int j = number[1]; j &lt;= number[3]; j++) &#123;</span><br><span class="line">				ave += Double.parseDouble(judgment(form[i][j]));</span><br><span class="line">				squ.add(Double.parseDouble(judgment(form[i][j])));</span><br><span class="line">				num++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ave = ave / num;</span><br><span class="line">		for (int i = 0; i &lt; squ.size(); i++) &#123;</span><br><span class="line">			square += (squ.get(i) - ave) * (squ.get(i) - ave);</span><br><span class="line">		&#125;</span><br><span class="line">		return String.format(&quot;%.2f&quot;, Math.sqrt(square / num));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 和</span><br><span class="line">	private static String with(String str) &#123;</span><br><span class="line">		int[] number = axis(str);</span><br><span class="line">		double sum = 0;</span><br><span class="line">		for (int i = number[0]; i &lt;= number[2]; i++) &#123;</span><br><span class="line">			for (int j = number[1]; j &lt;= number[3]; j++) &#123;</span><br><span class="line">				sum += Double.parseDouble(judgment(form[i][j]));</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return String.format(&quot;%.2f&quot;, sum);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 平均数</span><br><span class="line">	private static String average(String str) &#123;</span><br><span class="line">		int[] number = axis(str);</span><br><span class="line">		double ave = 0, num = 0;</span><br><span class="line">		for (int i = number[0]; i &lt;= number[2]; i++) &#123;</span><br><span class="line">			for (int j = number[1]; j &lt;= number[3]; j++) &#123;</span><br><span class="line">				ave += Double.parseDouble(judgment(form[i][j]));</span><br><span class="line">				num++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return String.format(&quot;%.2f&quot;, ave / num);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static int[] axis(String str) &#123;</span><br><span class="line">		int[] number = new int[4];</span><br><span class="line">		int a = str.indexOf(&quot;(&quot;);</span><br><span class="line">		int b = str.indexOf(&quot;,&quot;);</span><br><span class="line">		int c = str.indexOf(&quot;:&quot;);</span><br><span class="line">		int d = str.lastIndexOf(&quot;,&quot;);</span><br><span class="line">		int e = str.indexOf(&quot;)&quot;);</span><br><span class="line">		String x1 = str.substring(a + 1, b);</span><br><span class="line">		String y1 = str.substring(b + 1, c);</span><br><span class="line">		String x2 = str.substring(c + 1, d);</span><br><span class="line">		String y2 = str.substring(d + 1, e);</span><br><span class="line">		number[0] = Integer.parseInt(x1) - 1;</span><br><span class="line">		number[1] = Integer.parseInt(y1) - 1;</span><br><span class="line">		number[2] = Integer.parseInt(x2) - 1;</span><br><span class="line">		number[3] = Integer.parseInt(y2) - 1;</span><br><span class="line">		return number;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 输入</span><br><span class="line">	private static void input() &#123;</span><br><span class="line">		Scanner scanner = new Scanner(System.in);</span><br><span class="line">		int row = scanner.nextInt();</span><br><span class="line">		int col = scanner.nextInt();</span><br><span class="line">		form = new String[row][col];</span><br><span class="line">		for (int i = 0; i &lt; form.length; i++) &#123;</span><br><span class="line">			for (int j = 0; j &lt; form[i].length; j++) &#123;</span><br><span class="line">				form[i][j] = scanner.next();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		scanner.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 输出</span><br><span class="line">	private static void out() &#123;</span><br><span class="line">		for (int i = 0; i &lt; form.length; i++) &#123;</span><br><span class="line">			for (int j = 0; j &lt; form[i].length; j++) &#123;</span><br><span class="line">				System.out.print(form[i][j] + &quot; &quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Could-not-find-result-map</title>
    <url>/2019/01/19/%E9%97%AE%E9%A2%98/Could-not-find-result-map-20190119/</url>
    <content><![CDATA[<p>今天在写代码的时候，写完代码测试的时候发现登陆的时候登陆不进去，然后在登陆的断点处，抛出了这个异常</p>
<p><code>Could not find result map ren.guard.dao.SysDeptMapper.int</code></p>
<p>就是在 SysDeptMapper .xml里面本该是</p>
<p><code>resultType=&#39;int&#39;</code></p>
<p>写成了</p>
<p><code>resultMap=&#39;int&#39;</code></p>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>问题：因为在此系统上禁止运行脚本。</title>
    <url>/2024/06/20/%E9%97%AE%E9%A2%98/%E9%97%AE%E9%A2%98%EF%BC%9A%E5%9B%A0%E4%B8%BA%E5%9C%A8%E6%AD%A4%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%A6%81%E6%AD%A2%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC%E3%80%82/</url>
    <content><![CDATA[<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>在VSCode终端使用npm命令时，出现如下报错信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm : 无法加载文件 D:\ProgramFiles\nodejs\npm.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?Link</span><br><span class="line">ID=135170 中的 about_Execution_Policies。</span><br><span class="line">所在位置 行:1 字符: 1</span><br><span class="line">+ npm i</span><br><span class="line">+ ~~~</span><br><span class="line">    + CategoryInfo          : SecurityError: (:) []，PSSecurityException</span><br><span class="line">    + FullyQualifiedErrorId : UnauthorizedAccess</span><br></pre></td></tr></table></figure>

<h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><p>在终端输入get-ExecutionPolicy查看执行策略&#x2F;权限；<br>输出Restricted(受限制的)；<br>终端输入Set-ExecutionPolicy -Scope CurrentUser命令给用户赋予权限；<br>输入RemoteSigned；<br>终端输入get-ExecutionPolicy查看一下权限，显示RemoteSigned就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get-ExecutionPolicy</span><br><span class="line">Set-ExecutionPolicy -Scope CurrentUser</span><br><span class="line">RemoteSigned</span><br><span class="line">get-ExecutionPolicy</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
</search>
