<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo搭建教程(二)-熟悉官方文件、配置、命令</title>
      <link href="/ea288665459e.html"/>
      <url>/ea288665459e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>  前言：承接上文，现在已经成功搭建了一个不错的环境，但是我们对生成出来的文件还是感觉有点莫名其妙，而且不知道怎么去创建文章，怎么去修改一些配置，这次我们就来熟悉下官方提供的配置有哪些，但是应该不会出现截图，因为我的已经搭建完成，而且偷懒不想再搭建，具体呈现的效果需要自己去测试，好的Go~ Go~ Go~（当然这一章的内容很大部分都是官网，我只是抽出一部分需要注意的东西，而且和后面会出现一定的联动，请自己斟酌）</p></blockquote><h1 id="官方文件、配置、命令"><a href="#官方文件、配置、命令" class="headerlink" title="官方文件、配置、命令"></a>官方文件、配置、命令</h1><blockquote><p>  以下的内容只是针对Windows</p></blockquote><p>附上官网：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><h2 id="文件夹及文件"><a href="#文件夹及文件" class="headerlink" title="文件夹及文件"></a>文件夹及文件</h2><p>成功生成文件后在选中的文件夹下面会生成一些文件，现在就来看看这些文件有上面作用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>我们先看文件夹再看文件</p><h3 id="themes（主题）"><a href="#themes（主题）" class="headerlink" title="themes（主题）"></a>themes（主题）</h3><p>这个主题文件夹在<code>hexo 5.0</code>版本以后就没有太大作用了，一般都是改用<code>npm i hexo-theme-主题名称</code>来下载主题，就算需要自己去魔改主题都是推荐在<code>Github</code>找到对应主题，然后<code>Fork</code>到自己的仓库，然后做更改，这样在主仓库更新新功能的时候也可以及时更新和保留自己修改的文件</p><p>如果是现在安装<code>Hexo</code>版本都比这高了，所以可以不用关心这个文件夹了</p><h3 id="scaffolds（模板）"><a href="#scaffolds（模板）" class="headerlink" title="scaffolds（模板）"></a>scaffolds（模板）</h3><p>这个是模板的文件夹里面只有三个文件，这三个主文件都是在使用命令<code>hexo new post &quot;名称&quot;  </code>和</p><p><code>hexo new page &quot;名称&quot;  </code>才有用，按道理还有一个但是不常用就不说了，这名称对照一下应该就看出什么了，就是<code>hexo new 文件名 名称</code>，下面就是描述一下这三个文件的作用（只讲两个）</p><ul><li><p><code>page.md</code>：这个文件是管目录的，在使用<code>hexo new page &quot;名称&quot;</code>的时候会在<code>source</code>文件夹下生成一个文件夹和文件，而且名称和你输入的名称一样，而文件内容是</p>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125; //输入的名称</span><br><span class="line"><span class="section">type:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure></li><li><p><code>post.md</code>：这个管文章的，在使用<code>hexo new post &quot;名称&quot;</code>的时候会在<code>source/_posts</code>文件夹下生成文件，而且名称和你输入的名称一样，而文件内容是</p>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125; //输入的名称</span><br><span class="line">tags: []</span><br><span class="line">categories: </span><br><span class="line"><span class="section">date: &#123;&#123; date &#125;&#125;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure></li></ul><p>这两个文件主要是配合主题使用，因为不同的主题在里面添加的内容也不一样，但<code>post.md</code>提供了一部分是官方指定的参数，可以根据自己的情况添加</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th><th>是否常用</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td><td align="left"><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td><td>否</td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td><td align="left">文章的文件名</td><td>是</td></tr><tr><td align="left"><code>date</code></td><td align="left">建立日期</td><td align="left">文件建立日期</td><td>是</td></tr><tr><td align="left"><code>updated</code></td><td align="left">更新日期</td><td align="left">文件更新日期</td><td>是</td></tr><tr><td align="left"><code>comments</code></td><td align="left">开启文章的评论功能</td><td align="left">true</td><td>是</td></tr><tr><td align="left"><code>tags</code></td><td align="left">标签（不适用于分页），支持数组</td><td align="left"></td><td>是</td></tr><tr><td align="left"><code>categories</code></td><td align="left">分类（不适用于分页）</td><td align="left"></td><td>是</td></tr><tr><td align="left"><code>permalink</code></td><td align="left">覆盖文章网址</td><td align="left"></td><td>否</td></tr><tr><td align="left"><code>excerpt</code></td><td align="left">纯文本页面摘录。 使用<a href="https://hexo.io/docs/tag-plugins#Post-Excerpt">这个插件</a>格式化文本</td><td align="left"></td><td>否</td></tr><tr><td align="left"><code>disableNunjucks</code></td><td align="left">启用时禁用 Nunjucks 标签<code>&#123;&#123; &#125;&#125;/&#123;% %&#125;</code>和标签插件的呈现</td><td align="left"></td><td>否</td></tr><tr><td align="left"><code>lang</code></td><td align="left">设置语言覆盖<a href="https://hexo.io/docs/internationalization#Path">自动检测</a></td><td align="left">Inherited from <code>_config.yml</code></td><td>否</td></tr></tbody></table><h3 id="source（资源）"><a href="#source（资源）" class="headerlink" title="source（资源）"></a>source（资源）</h3><p>差不多全部需要编译的文件都在这个文件里面，什么目录、文章、图片…都在这个文件夹里面，官方提供了有文章（<code>_posts</code>）和草稿（<code>_drafts</code>），但是一般没有用草稿，一般都是在文章编写完成后才做上传，没写完不做提交就好了，如果有需要的也可以自己设置，这里面的内容都会通过编译后放在<code>public</code>文件夹下，自己添加的<code>html</code>页面也会所以在<code>_config.yml</code>会设置排除，这个不用担心</p><h3 id="config-yml（配置）"><a href="#config-yml（配置）" class="headerlink" title="_config.yml（配置）"></a>_config.yml（配置）</h3><p>这里面的一大坨东西分批来看</p><h4 id="Site（网站）"><a href="#Site（网站）" class="headerlink" title="Site（网站）"></a>Site（网站）</h4><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th>使用描述</th></tr></thead><tbody><tr><td align="left"><code>title</code></td><td align="left">网站标题</td><td>大标题</td></tr><tr><td align="left"><code>subtitle</code></td><td align="left">网站副标题</td><td>小标题</td></tr><tr><td align="left"><code>description</code></td><td align="left">网站描述</td><td>这个网站是做什么的主要是给<code>SEO</code>看</td></tr><tr><td align="left"><code>keywords</code></td><td align="left">网站的关键词。支持多个关键词。</td><td>这个看心情填写</td></tr><tr><td align="left"><code>author</code></td><td align="left">您的名字</td><td>网站的站长嘛，取个漂亮的名字没问题</td></tr><tr><td align="left"><code>language</code></td><td align="left">网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。</td><td>这个根据你自己观看情况填写吧</td></tr><tr><td align="left"><code>timezone</code></td><td align="left">网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td><td>这个也是差不多看你心情</td></tr></tbody></table><p>参考</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">梦里的竹蜻蜓</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;假话全不说 真话不全说&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;一个写bug的程序员&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">&#x27;Hexo,JavaScript,html5,css3,Jquery,NodeJs,github,css,js,html,java,blog,博客&#x27;</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">竹蜻蜓</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="URL（网址）"><a href="#URL（网址）" class="headerlink" title="URL（网址）"></a>URL（网址）</h4><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th><th>使用描述</th></tr></thead><tbody><tr><td align="left"><code>url</code></td><td align="left">网址, 必须以 <code>http://</code> 或 <code>https://</code> 开头</td><td align="left"></td><td>这个看情况更改，使用github还是coding或者自己的域名，都行</td></tr><tr><td align="left"><code>root</code></td><td align="left">网站根目录</td><td align="left"><code>url&#39;s pathname</code></td><td>是否未子目录</td></tr><tr><td align="left"><code>permalink</code></td><td align="left">文章的永久链接格式</td><td align="left"><code>:year/:month/:day/:title/</code></td><td>这个默认的太长了，一般都会改，怎么改，下面有个描述，自己搭配</td></tr><tr><td align="left"><code>permalink_defaults</code></td><td align="left">永久链接中各部分的默认值</td><td align="left"></td><td>对我没用</td></tr><tr><td align="left"><code>pretty_urls</code></td><td align="left">改写 <a href="https://hexo.io/zh-cn/docs/variables"><code>permalink</code></a> 的值来美化 URL</td><td align="left"></td><td></td></tr><tr><td align="left"><code>pretty_urls.trailing_index</code></td><td align="left">是否在永久链接中保留尾部的 <code>index.html</code>，设置为 <code>false</code> 时去除</td><td align="left"><code>true</code></td><td>没改</td></tr><tr><td align="left"><code>pretty_urls.trailing_html</code></td><td align="left">是否在永久链接中保留尾部的 <code>.html</code>, 设置为 <code>false</code> 时去除 (<em>对尾部的 <code>index.html</code>无效</em>)</td><td align="left"><code>true</code></td><td>没改</td></tr></tbody></table><p>参考</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## 在此处设置您的网站网址。 例如，如果您使用 GitHub Page，请将 url 设置为“https://username.github.io/project” </span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://blog.guard.ren</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:hash.html</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># 设置为 false 以从永久链接中删除尾随的“index.html” </span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># 设置为 false 以从永久链接中删除尾随 &#x27;.html&#x27; </span></span><br></pre></td></tr></table></figure><blockquote><p>  <strong>网站存放在子目录</strong></p><p>  如果您的网站存放在子目录中，例如 <code>http://example.com/blog</code>，则请将您的 <code>url</code> 设为 <code>http://example.com/blog</code> 并把 <code>root</code> 设为 <code>/blog/</code>。</p></blockquote><h5 id="permalink-（永久链接）"><a href="#permalink-（永久链接）" class="headerlink" title="permalink （永久链接）"></a>permalink （永久链接）</h5><table><thead><tr><th align="left">变量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>:year</code></td><td align="left">文章的发表年份（4 位数）</td></tr><tr><td align="left"><code>:month</code></td><td align="left">文章的发表月份（2 位数）</td></tr><tr><td align="left"><code>:i_month</code></td><td align="left">文章的发表月份（去掉开头的零）</td></tr><tr><td align="left"><code>:day</code></td><td align="left">文章的发表日期 (2 位数)</td></tr><tr><td align="left"><code>:i_day</code></td><td align="left">文章的发表日期（去掉开头的零）</td></tr><tr><td align="left"><code>:hour</code></td><td align="left">文章发表时的小时 (2 位数)</td></tr><tr><td align="left"><code>:minute</code></td><td align="left">文章发表时的分钟 (2 位数)</td></tr><tr><td align="left"><code>:second</code></td><td align="left">文章发表时的秒钟 (2 位数)</td></tr><tr><td align="left"><code>:title</code></td><td align="left">文件名称 (relative to “source/_posts/“ folder)</td></tr><tr><td align="left"><code>:name</code></td><td align="left">文件名称</td></tr><tr><td align="left"><code>:post_title</code></td><td align="left">文章标题</td></tr><tr><td align="left"><code>:id</code></td><td align="left">文章 ID (<em>not persistent across <a href="https://hexo.io/zh-cn/docs/commands#clean">cache reset</a></em>)</td></tr><tr><td align="left"><code>:category</code></td><td align="left">分类。如果文章没有分类，则是 <code>default_category</code> 配置信息。</td></tr><tr><td align="left"><code>:hash</code></td><td align="left">SHA1 hash of filename (same as <code>:title</code>) and date (12-hexadecimal)</td></tr></tbody></table><p>我为了方便直接使用的是<code>:hash.html</code>，除了在设置默认方面会有点麻烦其他还好</p><h4 id="Directory（目录）"><a href="#Directory（目录）" class="headerlink" title="Directory（目录）"></a>Directory（目录）</h4><p>没怎么改，就加了一个，看参考吧</p><table><thead><tr><th align="left"></th><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">参数</td><td align="left">描述</td><td align="left">默认值</td></tr><tr><td align="left"><code>source_dir</code></td><td align="left">资源文件夹，这个文件夹用来存放内容。</td><td align="left"><code>source</code></td></tr><tr><td align="left"><code>public_dir</code></td><td align="left">公共文件夹，这个文件夹用于存放生成的站点文件。</td><td align="left"><code>public</code></td></tr><tr><td align="left"><code>tag_dir</code></td><td align="left">标签文件夹</td><td align="left"><code>tags</code></td></tr><tr><td align="left"><code>archive_dir</code></td><td align="left">归档文件夹</td><td align="left"><code>archives</code></td></tr><tr><td align="left"><code>category_dir</code></td><td align="left">分类文件夹</td><td align="left"><code>categories</code></td></tr><tr><td align="left"><code>code_dir</code></td><td align="left">Include code 文件夹，<code>source_dir</code> 下的子目录</td><td align="left"><code>downloads/code</code></td></tr><tr><td align="left"><code>i18n_dir</code></td><td align="left">国际化（i18n）文件夹</td><td align="left"><code>:lang</code></td></tr><tr><td align="left"><code>skip_render</code></td><td align="left">跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 <code>public</code> 目录中。您可使用 <a href="https://github.com/micromatch/micromatch#extended-globbing">glob 表达式</a>来匹配路径。</td><td align="left"></td></tr></tbody></table><p>参考</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span> <span class="comment">#资源文件夹，默认是source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span> <span class="comment">#公共文件夹，默认是public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span> <span class="comment">#标签文件夹，默认是tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span> <span class="comment">#档案文件夹，默认是archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span> <span class="comment">#分类文件夹，默认是categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span> <span class="comment">#代码文件夹，默认是downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span> <span class="comment">#国际化文件夹，默认跟language相同</span></span><br><span class="line"><span class="attr">skip_render:</span> [<span class="string">&#x27;menu/aria2/**&#x27;</span>] <span class="comment">#不需要渲染的文件夹或文件夹,放在[]中</span></span><br></pre></td></tr></table></figure><h4 id="Writing（文章）"><a href="#Writing（文章）" class="headerlink" title="Writing（文章）"></a>Writing（文章）</h4><table><thead><tr><th align="left"></th><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">参数</td><td align="left">描述</td><td align="left">默认值</td></tr><tr><td align="left"><code>new_post_name</code></td><td align="left">新文章的文件名称</td><td align="left">:title.md</td></tr><tr><td align="left"><code>default_layout</code></td><td align="left">预设布局</td><td align="left">post</td></tr><tr><td align="left"><code>auto_spacing</code></td><td align="left">在中文和英文之间加入空格</td><td align="left">false</td></tr><tr><td align="left"><code>titlecase</code></td><td align="left">把标题转换为 title case</td><td align="left">false</td></tr><tr><td align="left"><code>external_link</code></td><td align="left">在新标签中打开链接</td><td align="left">true</td></tr><tr><td align="left"><code>external_link.enable</code></td><td align="left">在新标签中打开链接</td><td align="left"><code>true</code></td></tr><tr><td align="left"><code>external_link.field</code></td><td align="left">对整个网站（<code>site</code>）生效或仅对文章（<code>post</code>）生效</td><td align="left"><code>site</code></td></tr><tr><td align="left"><code>external_link.exclude</code></td><td align="left">需要排除的域名。主域名和子域名如 <code>www</code> 需分别配置</td><td align="left"><code>[]</code></td></tr><tr><td align="left"><code>filename_case</code></td><td align="left">把文件名称转换为 (1) 小写或 (2) 大写</td><td align="left">0</td></tr><tr><td align="left"><code>render_drafts</code></td><td align="left">显示草稿</td><td align="left">false</td></tr><tr><td align="left"><code>post_asset_folder</code></td><td align="left">启动 <a href="https://hexo.io/zh-cn/docs/asset-folders">Asset 文件夹</a></td><td align="left">false</td></tr><tr><td align="left"><code>relative_link</code></td><td align="left">把链接改为与根目录的相对位址</td><td align="left">false</td></tr><tr><td align="left"><code>future</code></td><td align="left">显示未来的文章</td><td align="left">true</td></tr><tr><td align="left"><code>highlight</code></td><td align="left">代码块的设置, 请参考 <a href="https://hexo.io/docs/syntax-highlight#Highlight-js">Highlight.js</a> 进行设置</td><td align="left"></td></tr><tr><td align="left"><code>prismjs</code></td><td align="left">代码块的设置, 请参考 <a href="https://hexo.io/docs/syntax-highlight#PrismJS">PrismJS</a> 进行设置</td><td align="left"></td></tr></tbody></table><p>参考</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写作 </span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># 新帖子的文件名 </span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">true</span> <span class="comment"># 将 title 转换为 titlecase </span></span><br><span class="line"><span class="attr">external_link:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 在新标签页中打开外部链接 </span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># 适用于全站 </span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">prismjs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">preprocess:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><p>下面的基本都没有做修改，可以直接看一下</p><ul><li>  <code>theme</code>：为主题，这个最开始的肯定不是这个，后面会做修改，也可以更具自己喜欢去找主题</li><li>  <code>deploy</code>：这个是提交，但是后面不会在本地提交，就只用来提交百度的搜录，刚开始应该为空，这个也可以不用管</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首页设置 </span></span><br><span class="line"><span class="comment"># path: 您的博客索引页面的根路径。 (default = &#x27;&#x27;)</span></span><br><span class="line"><span class="comment"># per_page: 每页显示的帖子。 （0 = 禁用分页）</span></span><br><span class="line"><span class="comment"># order_by: 发布订单。 （默认按日期降序排列）</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类和标签</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元数据元素</span></span><br><span class="line"><span class="comment">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span></span><br><span class="line"><span class="attr">meta_generator:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日期/时间格式</span></span><br><span class="line"><span class="comment">## Hexo使用Moment.js解析和显示日期</span></span><br><span class="line"><span class="comment">## 您可以按照定义自定义日期格式</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="string">HH:mm:ss</span></span><br><span class="line"><span class="comment">## 更新_选项 支持 &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;</span></span><br><span class="line"><span class="attr">updated_option:</span> <span class="string">&#x27;mtime&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分页 </span></span><br><span class="line"><span class="comment">## 将 per_page 设置为 0 以禁用分页 </span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含/排除文件 </span></span><br><span class="line"><span class="comment">## 包括：/排除：选项仅适用于&#x27;source/&#x27;文件夹 </span></span><br><span class="line"><span class="attr">include:</span></span><br><span class="line"><span class="attr">exclude:</span></span><br><span class="line"><span class="attr">ignore:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩展</span></span><br><span class="line"><span class="comment">## 插件 : https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## 主题: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署</span></span><br><span class="line"><span class="comment">## 文档: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">&#x27;baidu_url_submitter&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="package-json（项目文件，没必要不要手动）"><a href="#package-json（项目文件，没必要不要手动）" class="headerlink" title="package.json（项目文件，没必要不要手动）"></a>package.json（项目文件，没必要不要手动）</h3><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>这下面只使用去描述常用的命令，特别的命令请去官网查</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>hexo new page &#39;名称&#39;</code></td><td>创建文件夹及文件（一般用来目录）</td></tr><tr><td><code>hexo new post &#39;名称&#39;</code></td><td>创建文章</td></tr><tr><td><code>hexo generate</code> or <code>hexo g</code></td><td>生成静态文件到<code>public</code>下</td></tr><tr><td><code>hexo server</code> or <code>hexo s</code></td><td>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</td></tr><tr><td><code>hexo deploy</code> or <code>hexo d</code></td><td>部署网站</td></tr><tr><td><code>hexo clean</code></td><td>清除缓存</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建教程(一)-快速开始</title>
      <link href="/a27d16b8d0e7.html"/>
      <url>/a27d16b8d0e7.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>  前言：因为自己重新整理博客，所以准备重新写一下步骤，也给自己以后做一个参考</p><p>  其实这个博客所使用的技术和它本身存在也有其他的原因</p><p>  我也给想用这个Hexo作为自己博客的人说一下自己使用这么久的心得</p><ol><li>  博客需要一定的运行环境，而我不想每个月为了这个而付出太多</li><li>  我想这个博客自己在使用的时候对于搭建者存在较高的自由度</li><li>  所以选择了 Hexo+ GitHub 的方式，当然后面还加入了语雀</li><li>  在写搭建教程的时候会写出一定利弊和我做出的选择，请酌情观看</li></ol></blockquote><h1 id="安装必须的环境及运行"><a href="#安装必须的环境及运行" class="headerlink" title="安装必须的环境及运行"></a>安装必须的环境及运行</h1><blockquote><p>  以下的内容只是针对Windows</p></blockquote><p>附上官网：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><p>选择Hexo我相信应该对这个应该有一定的了解了，这里只是简单说一下，Hexo差不多就是在生成工具，并没有其他什么华丽的功能，可以生成直接提供访问的<code>Html</code>，更多可以去官方网站看看。</p><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>附上官网：<a href="http://nodejs.org/">Node.js</a> </p><p>在语雀中我写过但是为了水字数在写一遍（当然写的会快一点）</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>下载的时候尽量选择长期维护而不是最新</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/a27d16b8d0e7/1625556470719-f9200f9f-01cf-4d2b-8ecb-b196aba8e461.png" alt="img"></p><p>然后就是点击下载好的安装包，下一步，下一步，我贴出需要注意的几个东西</p><h4 id="选择安装"><a href="#选择安装" class="headerlink" title="选择安装"></a>选择安装</h4><p>如果是新手最好确保全部选择，避免出现奇奇怪怪的问题，让自己很难受</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/a27d16b8d0e7/1625556623778-e97b02e2-27c5-4179-909e-35c70d7608f1.png" alt="img"></p><h4 id="安装Python和VS-build-tools"><a href="#安装Python和VS-build-tools" class="headerlink" title="安装Python和VS build tools"></a>安装Python和VS build tools</h4><p>如果是新手最好这个也给勾上，也是避免一些奇奇怪怪的问题</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/a27d16b8d0e7/1625556759661-c3ced1c3-85b3-43ad-94f2-77fa0533bda5.png" alt="img"></p><p>然后就是下一步下一步，在选择完以后会出现一个大黑框</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/a27d16b8d0e7/1625556927852-721fdecb-67dc-4b67-8b20-98a41ff70e6a.png" alt="img"></p><p>这个就是勾选了上面的<code>安装Python和VS build tools</code>无需惊慌一路回车下去，然后就是等待安装</p><p>安装完成后记得在控制台输入下面的两个命令，确保没有问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line"></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>附上官网：<a href="https://git-scm.com/">Git</a> </p><p>这个没写过，但是也不是太麻烦，我也就大致写写意思一下</p><h3 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h3><p>点击以后就会下载了，然后会跳跃到另外一个页面里面也有详细的描述，根据电脑情况选择下载</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/a27d16b8d0e7/image-20210820164726509.png" alt="image-20210820164726509"></p><p>还是点击安装包然后安装也差不多是下一步下一步，其中比较重要的我写一下</p><h4 id="选择安装-1"><a href="#选择安装-1" class="headerlink" title="选择安装"></a>选择安装</h4><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/a27d16b8d0e7/1705204-20191122204329670-706153120.png" alt="img"></p><p>上图红框内的选项是默认勾选的，建议不要动。</p><p>绿色框1是决定是否在桌面创建快捷方式的。</p><p>绿色框2是决定在所有控制台窗口中使用TrueType字体和是否每天检查Git是否有Windows更新的。</p><p>这些根据自己需要选择。</p><h4 id="Git文件默认的编辑器"><a href="#Git文件默认的编辑器" class="headerlink" title="Git文件默认的编辑器"></a>Git文件默认的编辑器</h4><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/a27d16b8d0e7/1705204-20191122204411243-1420181946.png" alt="img"></p><p>直接默认即可</p><h4 id="PATH环境"><a href="#PATH环境" class="headerlink" title="PATH环境"></a>PATH环境</h4><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/a27d16b8d0e7/1705204-20191122204433985-925145764.png" alt="img"></p><p><code>推荐第二种</code></p><p>第一种配置是“仅从Git Bash使用Git”。这是最安全的选择，因为您的PATH根本不会被修改。您只能使用 Git Bash 的 Git 命令行工具。但是这将不能通过第三方软件使用。</p><p>第二种配置是“从命令行以及第三方软件进行Git”。该选项被认为是安全的，因为它仅向PATH添加了一些最小的Git包装器，以避免使用可选的Unix工具造成环境混乱。<br>您将能够从Git Bash，命令提示符和Windows PowerShell以及在PATH中寻找Git的任何第三方软件中使用Git。这也是推荐的选项。</p><p>第三种配置是“从命令提示符使用Git和可选的Unix工具”。警告：这将覆盖Windows工具，如 “ find 和 sort ”。只有在了解其含义后才使用此选项。</p><h4 id="选择HTTPS后端传输"><a href="#选择HTTPS后端传输" class="headerlink" title="选择HTTPS后端传输"></a>选择HTTPS后端传输</h4><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/a27d16b8d0e7/1705204-20191122204458869-580118165.png" alt="img"></p><p><code>推荐第一个</code></p><p>第一个选项是“使用 OpenSSL 库”。服务器证书将使用ca-bundle.crt文件进行验证。这也是我们常用的选项。</p><p>第二个选项是“使用本地 Windows 安全通道库”。服务器证书将使用Windows证书存储验证。此选项还允许您使用公司的内部根CA证书，例如通过Active Directory Domain Services 。</p><h4 id="行尾符号转换"><a href="#行尾符号转换" class="headerlink" title="行尾符号转换"></a>行尾符号转换</h4><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/a27d16b8d0e7/1705204-20191122204518715-826904755.png" alt="img"></p><p><code>推荐第一个</code></p><p>第一个选项是“签出Windows风格，提交Unix风格的行尾”。签出文本文件时，Git会将LF转换为CRLF。提交文本文件时，CRLF将转换为LF。对于跨平台项目，这是Windows上的推荐设置（“ core.autocrlf”设置为“ true”）</p><p>第二个选项是“按原样签出，提交Unix样式的行尾”。签出文本文件时，Git不会执行任何转换。 提交文本文件时，CRLF将转换为LF。对于跨平台项目，这是Unix上的建议设置（“ core.autocrlf”设置为“ input”）</p><p>第三种选项是“按原样签出，按原样提交”。当签出或提交文本文件时，Git不会执行任何转换。不建议跨平台项目选择此选项（“ core.autocrlf”设置为“ false”）</p><h4 id="终端模拟器以与Git-Bash一起使用"><a href="#终端模拟器以与Git-Bash一起使用" class="headerlink" title="终端模拟器以与Git Bash一起使用"></a>终端模拟器以与Git Bash一起使用</h4><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/a27d16b8d0e7/1705204-20191122204538172-1419125919.png" alt="img"></p><p><code>推荐第一个</code></p><p>第一个选项是“使用MinTTY（MSYS2的默认终端）”。Git Bash将使用MinTTY作为终端模拟器，该模拟器具有可调整大小的窗口，非矩形选择和Unicode字体。Windows控制台程序（例如交互式Python）必须通过“ winpty”启动才能在MinTTY中运行。</p><p>第二个选项是“使用Windows的默认控制台窗口”。Git将使用Windows的默认控制台窗口（“cmd.exe”），该窗口可以与Win32控制台程序（如交互式Python或node.js）一起使用，但默认的回滚非常有限，需要配置为使用unicode 字体以正确显示非ASCII字符，并且在Windows 10之前，其窗口不能自由调整大小，并且只允许矩形文本选择。</p><h4 id="配置配置额外的选项"><a href="#配置配置额外的选项" class="headerlink" title="配置配置额外的选项"></a>配置配置额外的选项</h4><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/a27d16b8d0e7/1705204-20191122204555648-377025701.png" alt="img"></p><p><code>推荐第一个和第二个</code></p><p>第一个选项是“启用文件系统缓存”。文件系统数据将被批量读取并缓存在内存中用于某些操作（“core.fscache”设置为“true”）。 这提供了显著的性能提升。</p><p>第二个选项是“启用Git凭证管理器”。Windows的Git凭证管理器为Windows提供安全的Git凭证存储，最显着的是对Visual Studio Team Services和GitHub的多因素身份验证支持。 （需要.NET Framework v4.5.1或更高版本）。</p><p>第三个选项是“启用符号链接”。启用符号链接（需要SeCreateSymbolicLink权限）。请注意，现有存储库不受此设置的影响。</p><h4 id="实验选项"><a href="#实验选项" class="headerlink" title="实验选项"></a>实验选项</h4><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/a27d16b8d0e7/1705204-20191122204613254-471895252.png" alt="img"></p><p>推荐不要选，然后就是下一步下一步</p><p>安装完成后，可以在桌面鼠标右键，可以看到多出来了两个选项</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/a27d16b8d0e7/image-20210820170301245.png" alt="image-20210820170301245"></p><p>选择<code>Git Bash Here</code>打开</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置邮箱和名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的GitHub用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的GitHub注册邮箱&quot;</span><br></pre></td></tr></table></figure><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>附上官网：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><p>直接在上面打开的<code>Git Bash Here</code>里面操作</p><p>输入<code>npm install hexo-cli -g</code>这个是全局安装，安装的位置是<code>Node.js</code>里面默认的，可以更改，但是不建议</p><p>安装完成了下一步就是建站</p><p>选择一个你喜欢的位置，然后右键<code>Git Bash Here</code>输入</p><p><code>hexo init blog</code></p><p>blog就是个名称，可以替换成你喜欢的名字，但必须用英文</p><blockquote><p>  可能出现的异常</p><p>  这个时候可能会有些人的在<code>hexo init blog</code>的时候会出现异常说找不到<code>hexo</code>这个命令</p><p>  这时候需要在环境变量下添加点东西</p><ol><li>  因为前面全局安装了<code>hexo-cli</code>，现在需要找一下你电脑下的全局目录在哪里（就是node.js的全局目录，因为电脑的不同，需要你自己去百度一下）</li><li>  在本机的（此电脑右键-&gt;属性-&gt;高级系统设置）环境变量下的系统变量下的<code>Path</code>变量名称，选中然后编辑，然后点击新建或者在最后面添加<code>你查询到的目录\node_modules\.bin</code></li></ol><p>  这时候应该差不多就好了，如果还没好，就去百度</p></blockquote><p>接着上面输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 进入文件夹</span><br><span class="line">cd blog</span><br><span class="line"># 更新文件</span><br><span class="line">npm install</span><br><span class="line"># 运行</span><br><span class="line">hexo server</span><br><span class="line"># 或者</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>在等待一会后会出现一个链接按住 Ctrl 然后左键 就能进入页面了。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>  Git数据：<a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html">https://www.cnblogs.com/xueweisuoyong/p/11914045.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毒瓶子二进制法</title>
      <link href="/918110f64071.html"/>
      <url>/918110f64071.html</url>
      
        <content type="html"><![CDATA[<p>有 1000 个一模一样的瓶子<br>其中有 999 瓶是普通的水<br>有 1 瓶是毒药<br>任何喝下毒药的生物都会在一星期之后死亡<br>现在，你只有 10 只小白鼠和一星期的时间，如何检验出哪个瓶子里有毒药？</p><p>这个数据太大了相对缩小一下（当然这是知道解法后相对缩小范围，方便理解）</p><p>有 10 个一模一样的瓶子<br>其中有 9 瓶是普通的水<br>有 1 瓶是毒药<br>任何喝下毒药的生物都会在一星期之后死亡<br>现在，你只有 4 只小白鼠和一星期的时间，如何检验出哪个瓶子里有毒药？</p><h1 id="解："><a href="#解：" class="headerlink" title="解："></a>解：</h1><h2 id="1-先把-1-10-换成二进制数据"><a href="#1-先把-1-10-换成二进制数据" class="headerlink" title="1. 先把 1-10 换成二进制数据"></a>1. 先把 1-10 换成二进制数据</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1-----&gt; 0   0   0   1</span><br><span class="line">2-----&gt; 0   0   1   0</span><br><span class="line">3-----&gt; 0   0   1   1</span><br><span class="line">4-----&gt; 0   1   0   0</span><br><span class="line">5-----&gt; 0   1   0   1</span><br><span class="line">6-----&gt; 0   1   1   0</span><br><span class="line">7-----&gt; 0   1   1   1</span><br><span class="line">8-----&gt; 1   0   0   0</span><br><span class="line">9-----&gt; 1   0   0   1</span><br><span class="line">10----&gt; 1   0   1   0</span><br><span class="line"> 🐀  🐀 🐀  🐀</span><br><span class="line">这样应该就差不多</span><br><span class="line">每个耗子喝当列存在1的列</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Optional (一个为了 Null 元素和Lambda设计的类)</title>
      <link href="/d71834e48b4e.html"/>
      <url>/d71834e48b4e.html</url>
      
        <content type="html"><![CDATA[<h1 id="Optional-描述"><a href="#Optional-描述" class="headerlink" title="Optional 描述"></a>Optional 描述</h1><p>然我们先来瞅瞅这个类的描述，他到底干什么的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">可能包含也可能不包含非空值的容器对象。</span><br><span class="line"></span><br><span class="line">如果存在值， isPresent()将返回<span class="literal">true</span> ， get()将返回该值。</span><br><span class="line"></span><br><span class="line">提供了依赖于包含值的存在与否的其他方法，</span><br><span class="line">例如orElse() （如果值不存在则返回默认值）和ifPresent() （如果值存在则执行代码块）。</span><br><span class="line"></span><br><span class="line">这是一个基于值的类；</span><br><span class="line">在Optional实例上使用身份敏感操作（包括引用相等性 ( == )、身份哈希码或同步）可能会产生不可预测的结果，应该避免。</span><br></pre></td></tr></table></figure><p>这个类还是比较简单易懂的，差不多看一遍经常用就能熟悉了，当然这上面说的这么多，个人看来就是 null 的抽象类<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/241578/1627310958615-2900fec1-3416-4b23-809c-09425fa57581.png#align=left&display=inline&height=769&margin=%5Bobject%20Object%5D&name=image.png&originHeight=769&originWidth=850&size=95368&status=done&style=none&width=850" alt="image.png" referrerpolicy="no-referrer"></p><h1 id="初始化对象"><a href="#初始化对象" class="headerlink" title="初始化对象"></a>初始化对象</h1><p>可以通过上面结构看到它其实有两个构造器但都是私有的，这么说来就不能用<code>new</code>的方式来初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * empty()常见实例。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> Optional&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果非空，则该值； 如果为空，则表示不存在值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> T value;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 构造一个空实例。</span></span><br><span class="line"><span class="comment"> * 实现说明：</span></span><br><span class="line"><span class="comment"> * 通常，每个 VM 应该只存在一个空实例EMPTY 。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 构造一个具有当前值的实例。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value – 要存在的非空值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException – 如果值为 null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Objects.requireNonNull 检测是否为null 如果为null 会直接抛出异常 NullPointerException()</span></span><br><span class="line">       <span class="keyword">this</span>.value = Objects.requireNonNull(value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回一个空的Optional实例。 此 Optional 不存在任何值。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@apiNote</span> 尽管这样做可能很诱人，但避免通过将==与Option.empty()返回的实例进行比较来测试对象是否为空。</span></span><br><span class="line"><span class="comment">    * 不能保证它是单例。 相反，使用isPresent() 。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> &lt;T&gt; - 不存在值的类型</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 空的Optional</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">       Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">       <span class="keyword">return</span> t;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面这个是类里面私有的东西，留个印象<br>其实在类里面有两个地方使用了<code>new Optional&lt;&gt;</code> ，这两个地方也就是初始化对象的关键，当然还有一个直接创造了一个空的实例，但不建议这么做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * empty()常见实例。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> Optional&lt;&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回具有指定当前非空值的Optional 。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value – 要存在的值，必须为非空类型参数：&lt;T&gt; - 值的类别</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 一个Optional的值存在</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException – 如果值为 null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">of</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Optional&lt;&gt;(value);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回一个描述指定值的Optional ，如果非空，否则返回一个空的Optional 。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value – 要存在的值，必须为非空类型参数：&lt;T&gt; - 值的类别</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 如果指定的值为非空，则为具有当前值的Optional ，否则为空Optional</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> value == <span class="keyword">null</span> ? empty() : of(value);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>因为第一个<code>new Optional&lt;&gt;</code>是私有化的我们在外部无法访问，那么我们现在就只有两个方式可以去实例化对象，而这个的差别就在判空。</p><p>我们关联上面和下面给出的代码</p><ul><li><code>of</code>方法当我们传入<code>null</code>对象的时候，它调用构造方法的时候会去检验当前对象是否为空，那么必定会抛出异常</li><li><code>ofNullable</code>方法会直接判断是否传入为 null，如果为<code>null</code>调用<code>empty()</code>，不为空那么调用<code>of</code>方法</li></ul><p>那我们就来看看<code>empty()</code>这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回一个空的Optional实例。 此 Optional 不存在任何值。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@apiNote</span> 尽管这样做可能很诱人，</span></span><br><span class="line"><span class="comment">    * 但避免通过将==与Option.empty()返回的实例进行比较来测试对象是否为空。</span></span><br><span class="line"><span class="comment">    * 不能保证它是单例。 相反，使用isPresent() 。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> &lt;T&gt; - 不存在值的类型</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 空的Optional</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">       Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">       <span class="keyword">return</span> t;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个确实干了一件很简单的事，强制使用<code>EMPTY</code>，从而避免<code>null</code>。</p><h2 id="如："><a href="#如：" class="headerlink" title="如："></a>如：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;String&gt; string1 = Optional.of(<span class="string">&quot;这是一个String&quot;</span>);</span><br><span class="line">    <span class="comment">//Optional&lt;String&gt; strNull1 = Optional.of(null); java.lang.NullPointerException</span></span><br><span class="line">    Optional&lt;String&gt; string2 = Optional.ofNullable(<span class="string">&quot;这是另一个String&quot;</span>);</span><br><span class="line">    Optional&lt;String&gt; strNull2 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">    Optional.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果此Optional存在值，则返回该值，否则抛出NoSuchElementException 。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 此Optional持有的非空值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NoSuchElementException – 如果没有值存在</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> Optional#isPresent()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;No value present&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个方法很简单了就是获取 value 的值。</p><h3 id="如"><a href="#如" class="headerlink" title="如:"></a>如:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Optional.of(<span class="string">&quot;这是一个String&quot;</span>).get());</span><br><span class="line">    <span class="comment">//这是一个String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isPresent"><a href="#isPresent" class="headerlink" title="isPresent"></a>isPresent</h2><p>这是两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果存在值则返回true ，否则返回false 。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果存在值则为true ，否则为false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPresent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用于判断当前对象存不存在值，也就是 value 是不是为空</p><h3 id="如：-1"><a href="#如：-1" class="headerlink" title="如："></a>如：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;String&gt; string1 = Optional.of(<span class="string">&quot;这是一个String&quot;</span>);</span><br><span class="line">    System.out.println(string1.isPresent());</span><br><span class="line">    <span class="comment">//true</span></span><br><span class="line">    Optional&lt;String&gt; strNull2 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">    System.out.println(strNull2.isPresent());</span><br><span class="line">    <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ifPresent"><a href="#ifPresent" class="headerlink" title="ifPresent"></a>ifPresent</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果存在值，则使用该值调用指定的使用者，否则不执行任何操作。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> 消费者 – 如果存在值则执行块</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException – 如果值存在且consumer为空</span></span><br><span class="line"><span class="comment"> * null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ifPresent</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">        consumer.accept(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法和上一个判断差不多，但是提供了一个函数式接口，可以直接操作其中的对象<br>这个方法支持传入<code>null</code>但是不会做任何操作</p><h3 id="如：-2"><a href="#如：-2" class="headerlink" title="如："></a>如：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;String&gt; string1 = Optional.of(<span class="string">&quot;这是一个String&quot;</span>);</span><br><span class="line">    string1.ifPresent(System.out::println);</span><br><span class="line">    <span class="comment">//这是一个String</span></span><br><span class="line">    Optional&lt;String&gt; strNull2 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">    strNull2.ifPresent(System.out::println);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果存在一个值，并且该值与给定的谓词匹配，</span></span><br><span class="line"><span class="comment">    * 则返回一个描述该值的Optional ，否则返回一个空的Optional 。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> predicate – 应用于值的谓词（如果存在）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 一个Optional描述此的值Optional一个值是否存在，</span></span><br><span class="line"><span class="comment">    * 并且值给定的谓词相匹配，否则一个空Optional</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException – 如果谓词为空</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span> </span>&#123;</span><br><span class="line">       Objects.requireNonNull(predicate);</span><br><span class="line">       <span class="keyword">if</span> (!isPresent())</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> predicate.test(value) ? <span class="keyword">this</span> : empty();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个是一个用于筛选数据的方法，提供了一个函数接口返回<code>boolean</code>，这里里面的筛选机制很有趣</p><ul><li>当前对象为<code>null</code>的时候直接返回当前对象</li><li>当前对象不为<code>null</code>的时候，运行接口方法，并且当条件不满足的时候还会返回一个空的对象类，只不过不存在<code>value</code></li></ul><h3 id="如：-3"><a href="#如：-3" class="headerlink" title="如："></a>如：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;String&gt; strNull2 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">    System.out.println(strNull2.filter(x -&gt; x.length() &gt; <span class="number">6</span>).isPresent());</span><br><span class="line">    <span class="comment">//false</span></span><br><span class="line">    Optional&lt;String&gt; string1 = Optional.of(<span class="string">&quot;这是一个String&quot;</span>);</span><br><span class="line">    System.out.println(string1.filter(x -&gt; x.length() &gt; <span class="number">6</span>).isPresent());</span><br><span class="line">    <span class="comment">//true</span></span><br><span class="line">    List&lt;Optional&lt;Integer&gt;&gt; collect = <span class="keyword">new</span> Random().ints(<span class="number">1</span>, <span class="number">100</span>).limit(<span class="number">100</span>).boxed().collect(() -&gt; &#123;</span><br><span class="line">        List&lt;Optional&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(Optional.of(-<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;, (lastList, value) -&gt; &#123;</span><br><span class="line">        lastList.add(Optional.of(value));</span><br><span class="line">    &#125;, List::addAll);</span><br><span class="line">    collect.forEach(x -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (x.isPresent()) &#123;</span><br><span class="line">            x.filter(y -&gt; y &gt; <span class="number">50</span>).ifPresent(y-&gt; System.out.print(y+<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果存在值，则对其应用提供的映射函数，如果结果非空，则返回描述结果的Optional 。</span></span><br><span class="line"><span class="comment">    * 否则返回一个空的Optional 。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@apiNote</span></span></span><br><span class="line"><span class="comment">    * 此方法支持对可选值进行后处理，而无需显式检查返回状态。</span></span><br><span class="line"><span class="comment">    * 例如，以下代码遍历文件名流，选择尚未处理的文件名，然后打开该文件，返回Optional&lt;FileInputStream&gt; ：</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Optional&lt;FileInputStream&gt; fis =</span></span><br><span class="line"><span class="comment">    *    names.stream().filter(name -&gt; !isProcessedYet(name))</span></span><br><span class="line"><span class="comment">    *                  .findFirst()</span></span><br><span class="line"><span class="comment">    *                  .map(name -&gt; new FileInputStream(name));</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 在这里， findFirst返回一个Optional&lt;String&gt; ，然后map返回一个Optional&lt;FileInputStream&gt;所需的文件（如果存在）。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> &lt;U&gt; - 映射函数的结果类型</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> mapper – 应用于值的映射函数（如果存在）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 一个Optional描述应用映射函数此的值的结果Optional ，</span></span><br><span class="line"><span class="comment">    * 如果一个值存在，否则一个空Optional</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException – 如果映射函数为空</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper)</span> </span>&#123;</span><br><span class="line">       Objects.requireNonNull(mapper);</span><br><span class="line">       <span class="keyword">if</span> (!isPresent())</span><br><span class="line">           <span class="keyword">return</span> empty();</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> Optional.ofNullable(mapper.apply(value));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>map</code>和上面<code>filter</code>差不多但是对返回又有少许差别</p><ul><li>当前对象为<code>null</code>返回<code>value</code>为<code>null</code>的对象</li><li>当前对象不为<code>null</code>时，函数接口运行后的结果包裹一层<code>Optional</code>而且使用的是<code>ofNullable</code>避免返回为<code>null</code>时直接报错</li></ul><h3 id="如：-4"><a href="#如：-4" class="headerlink" title="如："></a>如：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;String&gt; strNull2 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">    System.out.println(strNull2.map(String::length).isPresent());</span><br><span class="line">    <span class="comment">//false</span></span><br><span class="line">    Optional&lt;String&gt; string1 = Optional.of(<span class="string">&quot;这是一个String&quot;</span>);</span><br><span class="line">    string1.map(String::length).ifPresent(System.out::println);</span><br><span class="line">    <span class="comment">//10</span></span><br><span class="line">    System.out.println(string1.filter(x -&gt; <span class="keyword">false</span>).map(String::length).isPresent());</span><br><span class="line">    <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果存在一个值，则将提供的Optional承载映射函数应用于它，返回该结果，否则返回一个空的Optional 。</span></span><br><span class="line"><span class="comment">    * 此方法类似于map(Function) ，但提供的映射器的结果已经是Optional ，并且如果调用， flatMap不会用额外的Optional包装它。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> &lt;U&gt; - Optional返回的类型参数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> mapper – 应用于值的映射函数，如果存在映射函数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 将此Optional的值应用Optional承载映射函数的结果，如果存在值，否则为空Optional</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException – 如果映射函数为空或返回空结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, Optional&lt;U&gt;&gt; mapper)</span> </span>&#123;</span><br><span class="line">       Objects.requireNonNull(mapper);</span><br><span class="line">       <span class="keyword">if</span> (!isPresent())</span><br><span class="line">           <span class="keyword">return</span> empty();</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> Objects.requireNonNull(mapper.apply(value));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个和<code>map</code>方法差不多，只不过里面存在一个<code>null</code>判断，当函数式接口返回的值是空，那么会直接抛出异常</p><h3 id="如：-5"><a href="#如：-5" class="headerlink" title="如："></a>如：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;String&gt; strNull2 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">    System.out.println(strNull2.flatMap(x-&gt; Optional.ofNullable(x.toLowerCase())).isPresent());</span><br><span class="line">    <span class="comment">//false</span></span><br><span class="line">    Optional&lt;String&gt; string1 = Optional.of(<span class="string">&quot;这是一个String&quot;</span>);</span><br><span class="line">    string1.flatMap(x-&gt; Optional.of(x.toUpperCase())).ifPresent(System.out::println);</span><br><span class="line">    <span class="comment">//这是一个STRING</span></span><br><span class="line">    System.out.println(string1.filter(x -&gt; <span class="keyword">false</span>).flatMap(x-&gt; Optional.ofNullable(x.toLowerCase())).isPresent());</span><br><span class="line">    <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="orElse"><a href="#orElse" class="headerlink" title="orElse"></a>orElse</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果存在则返回值，否则返回other 。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> 其他 - 如果没有值，则返回值，可能为空</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 值（如果存在），否则为other</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElse</span><span class="params">(T other)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> value != <span class="keyword">null</span> ? value : other;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>有一个很标准的三元运算符，这个没什么好说的</p><h3 id="如：-6"><a href="#如：-6" class="headerlink" title="如："></a>如：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;String&gt; strNull2 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">    System.out.println(strNull2.orElse(<span class="string">&quot;这是一个null&quot;</span>));</span><br><span class="line">    <span class="comment">//这是一个null</span></span><br><span class="line">    Optional&lt;String&gt; string1 = Optional.of(<span class="string">&quot;这是一个String&quot;</span>);</span><br><span class="line">    System.out.println(string1.orElse(<span class="string">&quot;这不是一个null&quot;</span>));</span><br><span class="line">    <span class="comment">//这是一个String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="orElseGet"><a href="#orElseGet" class="headerlink" title="orElseGet"></a>orElseGet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回值（如果存在），否则调用other并返回该调用的结果。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> 其他 - 如果没有值则返回结果的Supplier</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 值（如果存在）否则other.get()的结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException – 如果值不存在且other为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span> ? value : other.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个其实也差不多就是可以在最后使用一个<code>Supplier</code>来收个尾巴</p><h3 id="如：-7"><a href="#如：-7" class="headerlink" title="如："></a>如：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;String&gt; strNull2 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">    System.out.println(strNull2.orElseGet(()-&gt;<span class="string">&quot;这是一个null&quot;</span>));</span><br><span class="line">    <span class="comment">//这是一个null</span></span><br><span class="line">    Optional&lt;String&gt; string1 = Optional.of(<span class="string">&quot;这是一个String&quot;</span>);</span><br><span class="line">    System.out.println(string1.orElseGet(()-&gt;<span class="string">&quot;这不是一个null&quot;</span>));</span><br><span class="line">    <span class="comment">//这是一个String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="orElseThrow"><a href="#orElseThrow" class="headerlink" title="orElseThrow"></a>orElseThrow</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回包含的值（如果存在），否则抛出由提供的供应商创建的异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@apiNote</span> 对带有空参数列表的异常构造函数的方法引用可以用作提供者。 例如， IllegalStateException::new</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;X&gt; - 要抛出的异常类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> exceptionSupplier – 将返回要抛出的异常的供应商</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 现值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> X – 如果没有值存在</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException – 如果不存在任何值且exceptionSupplier为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;X extends Throwable&gt; <span class="function">T <span class="title">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="keyword">throws</span> X </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> exceptionSupplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就比较常用了直接抛出异常，当然推荐自定义异常后抛出，毕竟这是业务异常</p><h3 id="如：-8"><a href="#如：-8" class="headerlink" title="如："></a>如：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;String&gt; string1 = Optional.of(<span class="string">&quot;这是一个String&quot;</span>);</span><br><span class="line">    System.out.println(string1.orElseThrow(()-&gt; <span class="keyword">new</span> RuntimeException(<span class="string">&quot;这个异常出去&quot;</span>)));</span><br><span class="line">    <span class="comment">//这是一个String</span></span><br><span class="line">    Optional&lt;String&gt; strNull2 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">    System.out.println(strNull2.orElseThrow(RuntimeException::<span class="keyword">new</span>));</span><br><span class="line">    <span class="comment">//java.lang.RuntimeException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="equals-hashCode-toString"><a href="#equals-hashCode-toString" class="headerlink" title="equals/hashCode/toString"></a>equals/hashCode/toString</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指示其他某个对象是否“等于”此 Optional。 在以下情况下，另一个对象被视为相等：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - 它也是一个Optional和；</span></span><br><span class="line"><span class="comment"> * - 两个实例都没有价值存在或；</span></span><br><span class="line"><span class="comment"> * - 当前值通过equals()彼此“相等”。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj – 要测试是否相等的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;code true&#125; 如果另一个对象“等于”这个对象，否则为false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Optional)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Optional&lt;?&gt; other = (Optional&lt;?&gt;) obj;</span><br><span class="line">    <span class="keyword">return</span> Objects.equals(value, other.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前值的哈希码值（如果有），如果没有值则返回 0（零）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前值的哈希码值，如果不存在值则为 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回适合调试的此 Optional 的非空字符串表示形式。 确切的表示格式未指定，可能因实现和版本而异。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@implSpec</span> 如果存在值，则结果必须在结果中包含其字符串表示。 Empty 和present Optionals 必须可以明确区分。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 此实例的字符串表示形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span></span><br><span class="line">        ? String.format(<span class="string">&quot;Optional[%s]&quot;</span>, value)</span><br><span class="line">        : <span class="string">&quot;Optional.empty&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="干点有趣的事"><a href="#干点有趣的事" class="headerlink" title="干点有趣的事"></a>干点有趣的事</h1><p>没什么用就当写着玩了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//随机数100个</span></span><br><span class="line">    List&lt;Map&lt;String, Optional&lt;Integer&gt;&gt;&gt; mapList = <span class="keyword">new</span> Random().ints(<span class="number">1</span>, <span class="number">100</span>).limit(<span class="number">100</span>).boxed().collect(() -&gt; &#123;</span><br><span class="line">        List&lt;Map&lt;String, Optional&lt;Integer&gt;&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;String, Optional&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        map.put(Thread.currentThread().getName(), Optional.empty());</span><br><span class="line">        list.add(map);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;, (lastList, value) -&gt; &#123;</span><br><span class="line">        Map&lt;String, Optional&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        map.put(Thread.currentThread().getName(), Optional.of(value));</span><br><span class="line">        lastList.add(map);</span><br><span class="line">    &#125;, List::addAll);</span><br><span class="line">    <span class="comment">//做个筛选</span></span><br><span class="line">    IntSummaryStatistics intSummaryStatistics = mapList.stream().map(x -&gt; &#123;</span><br><span class="line">        System.out.println(Arrays.toString(x.keySet().toArray()));</span><br><span class="line">        <span class="keyword">return</span> x.values();</span><br><span class="line">    &#125;).flatMap(Collection::stream)</span><br><span class="line">        .mapToInt(x -&gt; x.map(y -&gt; y - <span class="number">50</span>).orElse(<span class="number">0</span>)).summaryStatistics();</span><br><span class="line">    System.out.printf(<span class="string">&quot;MAX: %d MIN: %d AVE: %f SUM: %d COUNT: %d&quot;</span>,</span><br><span class="line">                      intSummaryStatistics.getMax(),</span><br><span class="line">                      intSummaryStatistics.getMin(),</span><br><span class="line">                      intSummaryStatistics.getAverage(),</span><br><span class="line">                      intSummaryStatistics.getSum(),</span><br><span class="line">                      intSummaryStatistics.getCount()</span><br><span class="line">                     );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 请求 (随笔写的很少)</title>
      <link href="/e6ddddcf68e6.html"/>
      <url>/e6ddddcf68e6.html</url>
      
        <content type="html"><![CDATA[<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 添加的内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="测试内容"><a href="#测试内容" class="headerlink" title="测试内容"></a>测试内容</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/index&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">       <span class="comment">//标识量</span></span><br><span class="line">       model.addAttribute(<span class="string">&quot;string1&quot;</span>,<span class="string">&quot;这是一个字符串1&quot;</span>);</span><br><span class="line">       model.addAttribute(<span class="string">&quot;string2&quot;</span>,<span class="string">&quot;这是一个字符串2&quot;</span>);</span><br><span class="line">       model.addAttribute(<span class="string">&quot;string3&quot;</span>,<span class="string">&quot;这是一个字符串3&quot;</span>);</span><br><span class="line">       model.addAttribute(<span class="string">&quot;number1&quot;</span>,<span class="number">0</span>);</span><br><span class="line">       model.addAttribute(<span class="string">&quot;number2&quot;</span>,<span class="number">1</span>);</span><br><span class="line">       model.addAttribute(<span class="string">&quot;number3&quot;</span>,-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//变量取值 获取请求域、session域、对象等值</span></span><br><span class="line">       model.addAttribute(<span class="string">&quot;variable&quot;</span>,<span class="string">&quot;变量取值IndexController&quot;</span>);</span><br><span class="line">       <span class="comment">//选择变量 获取上下文对象值</span></span><br><span class="line">       model.addAttribute(<span class="string">&quot;selectVariable&quot;</span>,<span class="string">&quot;选择变量IndexController&quot;</span>);</span><br><span class="line">       <span class="comment">//消息 获取国际化等值</span></span><br><span class="line">       model.addAttribute(<span class="string">&quot;news.name&quot;</span>,<span class="string">&quot;选择变量IndexController&quot;</span>);</span><br><span class="line">       <span class="comment">//链接 生成链接</span></span><br><span class="line">       model.addAttribute(<span class="string">&quot;url&quot;</span>,<span class="string">&quot;/urlIndexController&quot;</span>);</span><br><span class="line">       <span class="comment">//布尔文字</span></span><br><span class="line">       model.addAttribute(<span class="string">&quot;boolean1&quot;</span>,<span class="keyword">false</span>);</span><br><span class="line">       <span class="comment">//空字面量</span></span><br><span class="line">       model.addAttribute(<span class="string">&quot;null1&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">       List&lt;Object&gt; collect = Stream.builder()</span><br><span class="line">               .add(<span class="keyword">new</span> Param(<span class="string">&quot;a1&quot;</span>, <span class="number">1</span>, <span class="keyword">new</span> Par(<span class="string">&quot;b1&quot;</span>, <span class="number">1</span>)))</span><br><span class="line">               .add(<span class="keyword">new</span> Param(<span class="string">&quot;a2&quot;</span>, <span class="number">2</span>, <span class="keyword">new</span> Par(<span class="string">&quot;b2&quot;</span>, <span class="number">2</span>)))</span><br><span class="line">               .add(<span class="keyword">new</span> Param(<span class="string">&quot;a3&quot;</span>, <span class="number">3</span>, <span class="keyword">new</span> Par(<span class="string">&quot;b3&quot;</span>, <span class="number">3</span>))).build().collect(Collectors.toList());</span><br><span class="line">       model.addAttribute(<span class="string">&quot;collect&quot;</span>,collect);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="请求进入"><a href="#请求进入" class="headerlink" title="请求进入"></a>请求进入</h1><p><code>org/springframework/web/servlet/DispatcherServlet.java</code><br>第 1000 行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1000行</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function">将请求转换为多部分请求，并使多部分解析器可用。</span></span></span><br><span class="line"><span class="comment"><span class="function">如果未设置多部分解析器，只需使用现有请求。</span></span></span><br><span class="line"><span class="comment"><span class="function">参数：</span></span></span><br><span class="line"><span class="comment"><span class="function">请求 - 当前的 HTTP 请求</span></span></span><br><span class="line"><span class="comment"><span class="function">返回值：</span></span></span><br><span class="line"><span class="comment"><span class="function">处理的请求（如有必要，多部分包装器）</span></span></span><br><span class="line"><span class="comment"><span class="function">请参见： MultipartResolver.resolveMultipart</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"><span class="comment">// 没有多部分包装器 所以还是原来的请求</span></span></span><br><span class="line"><span class="function">processedRequest </span>= checkMultipart(request);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1015行</span></span><br><span class="line"><span class="comment">// 确定当前请求的处理程序 判断谁可以处理当前请求</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1023行</span></span><br><span class="line"><span class="comment">// 确定当前请求的处理程序适配器。 图1  四选一</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1039行</span></span><br><span class="line"><span class="comment">// 实际调用处理程序。</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反射调用方法 当然他还判断了是否同步异步</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><h2 id="图-1"><a href="#图-1" class="headerlink" title="图 1"></a>图 1</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/241578/1627213339370-58cca3ff-759b-4be3-9283-da63e866cb59.png#align=left&display=inline&height=203&margin=%5Bobject%20Object%5D&name=image.png&originHeight=203&originWidth=458&size=30752&status=done&style=none&width=458" alt="image.png" referrerpolicy="no-referrer"></p>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Devtools 属性</title>
      <link href="/0af545735672.html"/>
      <url>/0af545735672.html</url>
      
        <content type="html"><![CDATA[<h2 id="devtools"><a href="#devtools" class="headerlink" title="devtools"></a>devtools</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.devtools.add-properties</code></td><td><code>true</code></td><td>是否启用开发属性默认。</td></tr><tr><td><code>spring.devtools.livereload.enabled</code></td><td><code>true</code></td><td>是否启用 livereload.com 兼容的服务器。</td></tr><tr><td><code>spring.devtools.livereload.port</code></td><td><code>35729.0</code></td><td>Server port.</td></tr><tr><td><code>spring.devtools.remote.context-path</code></td><td><code>/.~~spring-boot!~</code></td><td>用于处理远程连接的上下文路径。</td></tr><tr><td><code>spring.devtools.remote.proxy.host</code></td><td></td><td>用于连接到远程应用程序的代理主机。</td></tr><tr><td><code>spring.devtools.remote.proxy.port</code></td><td></td><td>连接到远程应用程序的代理端口。</td></tr><tr><td><code>spring.devtools.remote.restart.enabled</code></td><td><code>true</code></td><td>是否启用远程重启。</td></tr><tr><td><code>spring.devtools.remote.secret</code></td><td></td><td>建立连接所需的共享秘密（启用远程支持所需）。</td></tr><tr><td><code>spring.devtools.remote.secret-header-name</code></td><td><code>X-AUTH-TOKEN</code></td><td>用于传输共享秘密的 HTTP 头。</td></tr><tr><td><code>spring.devtools.restart.additional-exclude</code></td><td></td><td>应排除在触发完全重启之外的其他模式。</td></tr><tr><td><code>spring.devtools.restart.additional-paths</code></td><td></td><td>额外的路径要注意变化。</td></tr><tr><td><code>spring.devtools.restart.enabled</code></td><td><code>true</code></td><td>是否启用自动重启。</td></tr><tr><td><code>spring.devtools.restart.exclude</code></td><td><code>META-INF/maven/**,META-INF/resources/**,resources/**,static/**,public/**,templates/**,**/*Test.class,**/*Tests.class,git.properties,META-INF/build-info.properties</code></td><td>应排除在触发完全重启之外的模式。</td></tr><tr><td><code>spring.devtools.restart.log-condition-evaluation-delta</code></td><td><code>true</code></td><td>是否在重新启动时记录条件评价 delta。</td></tr><tr><td><code>spring.devtools.restart.poll-interval</code></td><td><code>1s</code></td><td>类路径更改的轮询之间的等待时间。</td></tr><tr><td><code>spring.devtools.restart.quiet-period</code></td><td><code>400ms</code></td><td>在触发重启之前，在没有改变任何 classpath 的情况下所需的安静时间。</td></tr><tr><td><code>spring.devtools.restart.trigger-file</code></td><td></td><td>一个特定文件的名称，当改变时，会触发重启检查。必须是出现在 classpath 上的文件的简单名称（没有任何路径）。如果没有指定，任何 classpath 文件的改变都会触发重启。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>执行器属性</title>
      <link href="/63d02054b042.html"/>
      <url>/63d02054b042.html</url>
      
        <content type="html"><![CDATA[<h1 id="management"><a href="#management" class="headerlink" title="management"></a>management</h1><h2 id="auditevents"><a href="#auditevents" class="headerlink" title="auditevents"></a>auditevents</h2><table><thead><tr><th><code>management.auditevents.enabled</code></th><th><code>true</code></th><th>是否启用审计事件的存储。</th></tr></thead></table><h2 id="cloudfoundry"><a href="#cloudfoundry" class="headerlink" title="cloudfoundry"></a>cloudfoundry</h2><table><thead><tr><th><code>management.cloudfoundry.enabled</code></th><th><code>true</code></th><th>是否启用扩展的 Cloud Foundry 执行器端点。</th></tr></thead><tbody><tr><td><code>management.cloudfoundry.skip-ssl-validation</code></td><td><code>false</code></td><td>是否跳过 Cloud Foundry 执行器端点安全调用的 SSL 验证。</td></tr></tbody></table><h2 id="endpoint"><a href="#endpoint" class="headerlink" title="endpoint"></a>endpoint</h2><table><thead><tr><th><code>management.endpoint.auditevents.cache.time-to-live</code></th><th><code>0ms</code></th><th>响应可以被缓存的最长时间。</th></tr></thead><tbody><tr><td><code>management.endpoint.auditevents.enabled</code></td><td><code>true</code></td><td>是否启用 auditevents 端点。</td></tr><tr><td><code>management.endpoint.beans.cache.time-to-live</code></td><td><code>0ms</code></td><td>响应可以被缓存的最长时间。</td></tr><tr><td><code>management.endpoint.beans.enabled</code></td><td><code>true</code></td><td>是否启用豆瓣端点。</td></tr><tr><td><code>management.endpoint.caches.cache.time-to-live</code></td><td><code>0ms</code></td><td>响应可以被缓存的最长时间。</td></tr><tr><td><code>management.endpoint.caches.enabled</code></td><td><code>true</code></td><td>是否启用缓存端点。</td></tr><tr><td><code>management.endpoint.conditions.cache.time-to-live</code></td><td><code>0ms</code></td><td>响应可以被缓存的最长时间。</td></tr><tr><td><code>management.endpoint.conditions.enabled</code></td><td><code>true</code></td><td>是否启用条件端点。</td></tr><tr><td><code>management.endpoint.configprops.cache.time-to-live</code></td><td><code>0ms</code></td><td>响应可以被缓存的最长时间。</td></tr><tr><td><code>management.endpoint.configprops.enabled</code></td><td><code>true</code></td><td>是否启用 configprops 端点。</td></tr><tr><td><code>management.endpoint.configprops.keys-to-sanitize</code></td><td><code>[password, secret, key, token, .*credentials.*, vcap_services, sun.java.command]</code></td><td>应该被净化的键。密钥可以是属性结尾的简单字符串或正则表达式。</td></tr><tr><td><code>management.endpoint.env.cache.time-to-live</code></td><td><code>0ms</code></td><td>响应可以被缓存的最长时间。</td></tr><tr><td><code>management.endpoint.env.enabled</code></td><td><code>true</code></td><td>是否启用 env 端点。</td></tr><tr><td><code>management.endpoint.env.keys-to-sanitize</code></td><td><code>[password, secret, key, token, .*credentials.*, vcap_services, sun.java.command]</code></td><td>应该被净化的键。密钥可以是属性结尾的简单字符串或正则表达式。</td></tr><tr><td><code>management.endpoint.flyway.cache.time-to-live</code></td><td><code>0ms</code></td><td>响应可以被缓存的最长时间。</td></tr><tr><td><code>management.endpoint.flyway.enabled</code></td><td><code>true</code></td><td>是否启用飞航端点。</td></tr><tr><td><code>management.endpoint.health.cache.time-to-live</code></td><td><code>0ms</code></td><td>响应可以被缓存的最长时间。</td></tr><tr><td><code>management.endpoint.health.enabled</code></td><td><code>true</code></td><td>是否启用健康端点。</td></tr><tr><td><code>management.endpoint.health.group.*</code></td><td></td><td>健康终点组。</td></tr><tr><td><code>management.endpoint.health.probes.enabled</code></td><td><code>false</code></td><td>是否启用活泼度和准备度探究。</td></tr><tr><td><code>management.endpoint.health.roles</code></td><td></td><td>用于确定用户是否被授权显示详细信息的角色。当为空时，所有经过认证的用户都被授权。</td></tr><tr><td><code>management.endpoint.health.show-components</code></td><td></td><td>何时显示组件。如果没有指定，将使用’show-details’设置。</td></tr><tr><td><code>management.endpoint.health.show-details</code></td><td><code>never</code></td><td>何时显示全部健康细节。</td></tr><tr><td><code>management.endpoint.health.status.http-mapping.*</code></td><td></td><td>将健康状态映射到 HTTP 状态码。默认情况下，注册的健康状态映射到合理的默认值（例如，UP 映射到 200）。</td></tr><tr><td><code>management.endpoint.health.status.order</code></td><td><code>[DOWN, OUT_OF_SERVICE, UP, UNKNOWN]</code></td><td>按严重程度以逗号分隔的健康状况清单。</td></tr><tr><td><code>management.endpoint.heapdump.cache.time-to-live</code></td><td><code>0ms</code></td><td>响应可以被缓存的最长时间。</td></tr><tr><td><code>management.endpoint.heapdump.enabled</code></td><td><code>true</code></td><td>是否启用堆栈端点。</td></tr><tr><td><code>management.endpoint.httptrace.cache.time-to-live</code></td><td><code>0ms</code></td><td>响应可以被缓存的最长时间。</td></tr><tr><td><code>management.endpoint.httptrace.enabled</code></td><td><code>true</code></td><td>是否启用 httptrace 端点。</td></tr><tr><td><code>management.endpoint.info.cache.time-to-live</code></td><td><code>0ms</code></td><td>响应可以被缓存的最长时间。</td></tr><tr><td><code>management.endpoint.info.enabled</code></td><td><code>true</code></td><td>是否启用信息端点。</td></tr><tr><td><code>management.endpoint.integrationgraph.cache.time-to-live</code></td><td><code>0ms</code></td><td>响应可以被缓存的最长时间。</td></tr><tr><td><code>management.endpoint.integrationgraph.enabled</code></td><td><code>true</code></td><td>是否启用 integrationgraph 端点。</td></tr><tr><td><code>management.endpoint.jolokia.config.*</code></td><td></td><td>Jolokia 的设置。更多细节请参考 Jolokia 的文档。</td></tr><tr><td><code>management.endpoint.jolokia.enabled</code></td><td><code>true</code></td><td>是否启用 jolokia 端点。</td></tr><tr><td><code>management.endpoint.liquibase.cache.time-to-live</code></td><td><code>0ms</code></td><td>响应可以被缓存的最长时间。</td></tr><tr><td><code>management.endpoint.liquibase.enabled</code></td><td><code>true</code></td><td>是否启用 liquibase 端点。</td></tr><tr><td><code>management.endpoint.logfile.cache.time-to-live</code></td><td><code>0ms</code></td><td>响应可以被缓存的最长时间。</td></tr><tr><td><code>management.endpoint.logfile.enabled</code></td><td><code>true</code></td><td>是否启用日志文件端点。</td></tr><tr><td><code>management.endpoint.logfile.external-file</code></td><td></td><td>要访问的外部日志文件。如果日志文件是通过输出重定向而非日志系统本身写入的，可以使用。</td></tr><tr><td><code>management.endpoint.loggers.cache.time-to-live</code></td><td><code>0ms</code></td><td>响应可以被缓存的最长时间。</td></tr><tr><td><code>management.endpoint.loggers.enabled</code></td><td><code>true</code></td><td>是否启用记录仪端点。</td></tr><tr><td><code>management.endpoint.mappings.cache.time-to-live</code></td><td><code>0ms</code></td><td>响应可以被缓存的最长时间。</td></tr><tr><td><code>management.endpoint.mappings.enabled</code></td><td><code>true</code></td><td>是否启用映射端点。</td></tr><tr><td><code>management.endpoint.metrics.cache.time-to-live</code></td><td><code>0ms</code></td><td>响应可以被缓存的最长时间。</td></tr><tr><td><code>management.endpoint.metrics.enabled</code></td><td><code>true</code></td><td>是否启用指标端点。</td></tr><tr><td><code>management.endpoint.prometheus.cache.time-to-live</code></td><td><code>0ms</code></td><td>响应可以被缓存的最长时间。</td></tr><tr><td><code>management.endpoint.prometheus.enabled</code></td><td><code>true</code></td><td>是否启用 prometheus 端点。</td></tr><tr><td><code>management.endpoint.scheduledtasks.cache.time-to-live</code></td><td><code>0ms</code></td><td>响应可以被缓存的最长时间。</td></tr><tr><td><code>management.endpoint.scheduledtasks.enabled</code></td><td><code>true</code></td><td>是否启用 scheduletasks 端点。</td></tr><tr><td><code>management.endpoint.sessions.enabled</code></td><td><code>true</code></td><td>是否启用会话端点。</td></tr><tr><td><code>management.endpoint.shutdown.enabled</code></td><td><code>false</code></td><td>是否启用关机端点。</td></tr><tr><td><code>management.endpoint.threaddump.cache.time-to-live</code></td><td><code>0ms</code></td><td>响应可以被缓存的最长时间。</td></tr><tr><td><code>management.endpoint.threaddump.enabled</code></td><td><code>true</code></td><td>是否启用线程转储端点。</td></tr><tr><td><code>management.endpoints.enabled-by-default</code></td><td></td><td>是否默认启用或禁用所有端点。</td></tr><tr><td><code>management.endpoints.jmx.domain</code></td><td><code>org.springframework.boot</code></td><td>Endpoints JMX 域名，如果设置了，则返回’spring.jmx.default-domain’。如果设置了，则回退到’spring.jmx.default-domain’。</td></tr><tr><td><code>management.endpoints.jmx.exposure.exclude</code></td><td></td><td>应该排除的端点 ID 或’*‘为所有。</td></tr><tr><td><code>management.endpoints.jmx.exposure.include</code></td><td><code>*</code></td><td>应包括的端点 ID 或’*‘为所有。</td></tr><tr><td><code>management.endpoints.jmx.static-names</code></td><td></td><td>附加的静态属性附加到所有代表端点的 MBeans 的 ObjectNames。</td></tr><tr><td><code>management.endpoints.migrate-legacy-ids</code></td><td><code>false</code></td><td>是否透明地迁移遗留的端点 ID。</td></tr><tr><td><code>management.endpoints.web.base-path</code></td><td><code>/actuator</code></td><td>Web 端点的基本路径。相对于 server.servlet.context-path 或 management.server.servlet.context-path（如果配置了 management.server.port）。</td></tr><tr><td><code>management.endpoints.web.cors.allow-credentials</code></td><td></td><td>是否支持凭证。未设置时，不支持凭证。</td></tr><tr><td><code>management.endpoints.web.cors.allowed-headers</code></td><td></td><td>逗号分隔的请求头列表。’*‘允许所有头信息。</td></tr><tr><td><code>management.endpoints.web.cors.allowed-methods</code></td><td></td><td>逗号分隔的允许使用的方法列表。’*‘允许所有方法。未设置时，默认为 GET。</td></tr><tr><td><code>management.endpoints.web.cors.allowed-origins</code></td><td></td><td>逗号分隔的起源列表允许。’*‘允许所有起源。未设置时，禁用 CORS 支持。</td></tr><tr><td><code>management.endpoints.web.cors.exposed-headers</code></td><td></td><td>以逗号分隔的标题列表包含在响应中。</td></tr><tr><td><code>management.endpoints.web.cors.max-age</code></td><td><code>1800s</code></td><td>客户端可以缓存飞行前请求的响应多长时间。如果没有指定持续时间的后缀，将使用秒。</td></tr><tr><td><code>management.endpoints.web.exposure.exclude</code></td><td></td><td>应该排除的端点 ID 或’*‘为所有。</td></tr><tr><td><code>management.endpoints.web.exposure.include</code></td><td><code>[health, info]</code></td><td>应包括的端点 ID 或’*‘为所有。</td></tr><tr><td><code>management.endpoints.web.path-mapping.*</code></td><td></td><td>端点 ID 和应该暴露它们的路径之间的映射。</td></tr></tbody></table><h2 id="health"><a href="#health" class="headerlink" title="health"></a>health</h2><table><thead><tr><th><code>management.health.cassandra.enabled</code></th><th><code>true</code></th><th>是否启用 Cassandra 健康检查。</th></tr></thead><tbody><tr><td><code>management.health.couchbase.enabled</code></td><td><code>true</code></td><td>是否启用 Couchbase 健康检查。</td></tr><tr><td><code>management.health.db.enabled</code></td><td><code>true</code></td><td>是否启用数据库健康检查。</td></tr><tr><td><code>management.health.defaults.enabled</code></td><td><code>true</code></td><td>是否启用默认健康指标。</td></tr><tr><td><code>management.health.diskspace.enabled</code></td><td><code>true</code></td><td>是否启用磁盘空间健康检查。</td></tr><tr><td><code>management.health.diskspace.path</code></td><td></td><td>用于计算可用磁盘空间的路径。</td></tr><tr><td><code>management.health.diskspace.threshold</code></td><td><code>10MB</code></td><td>应有的最小磁盘空间。</td></tr><tr><td><code>management.health.elasticsearch.enabled</code></td><td><code>true</code></td><td>是否启用 Elasticsearch 健康检查。</td></tr><tr><td><code>management.health.influxdb.enabled</code></td><td><code>true</code></td><td>是否启用 InfluxDB 健康检查。</td></tr><tr><td><code>management.health.jms.enabled</code></td><td><code>true</code></td><td>是否启用 JMS 健康检查。</td></tr><tr><td><code>management.health.ldap.enabled</code></td><td><code>true</code></td><td>是否启用 LDAP 健康检查。</td></tr><tr><td><code>management.health.livenessstate.enabled</code></td><td><code>false</code></td><td>是否启用活泼状态健康检查。</td></tr><tr><td><code>management.health.mail.enabled</code></td><td><code>true</code></td><td>是否启用邮件健康检查。</td></tr><tr><td><code>management.health.mongo.enabled</code></td><td><code>true</code></td><td>是否启用 MongoDB 健康检查。</td></tr><tr><td><code>management.health.neo4j.enabled</code></td><td><code>true</code></td><td>是否启用 Neo4j 健康检查。</td></tr><tr><td><code>management.health.ping.enabled</code></td><td><code>true</code></td><td>是否启用 ping 健康检查。</td></tr><tr><td><code>management.health.rabbit.enabled</code></td><td><code>true</code></td><td>是否启用 RabbitMQ 健康检查。</td></tr><tr><td><code>management.health.readinessstate.enabled</code></td><td><code>false</code></td><td>是否启用准备状态健康检查。</td></tr><tr><td><code>management.health.redis.enabled</code></td><td><code>true</code></td><td>是否启用 Redis 健康检查。</td></tr><tr><td><code>management.health.solr.enabled</code></td><td><code>true</code></td><td>是否启用 Solr 健康检查。</td></tr></tbody></table><h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><table><thead><tr><th><code>management.info.build.enabled</code></th><th><code>true</code></th><th>是否启用构建信息。</th></tr></thead><tbody><tr><td><code>management.info.defaults.enabled</code></td><td><code>true</code></td><td>是否启用默认信息贡献者。</td></tr><tr><td><code>management.info.env.enabled</code></td><td><code>true</code></td><td>是否启用环境信息。</td></tr><tr><td><code>management.info.git.enabled</code></td><td><code>true</code></td><td>是否启用 git 信息。</td></tr><tr><td><code>management.info.git.mode</code></td><td><code>simple</code></td><td>用来公开 git 信息的模式。</td></tr></tbody></table><h2 id="metics"><a href="#metics" class="headerlink" title="metics"></a>metics</h2><table><thead><tr><th><code>management.metrics.enable.*</code></th><th></th><th>是否应该启用以指定名称开头的仪表 ID。匹配时间最长的获胜，键 “all “也可用于配置所有仪表。</th></tr></thead><tbody><tr><td><code>management.metrics.use-global-registry</code></td><td><code>true</code></td><td>自动配置的 MeterRegistry 实现是否应该绑定到 Metrics 的全局静态注册表。对于测试而言，将其设置为 “false”，以最大限度地提高测试的独立性。</td></tr></tbody></table><h3 id="distribution"><a href="#distribution" class="headerlink" title="distribution"></a>distribution</h3><table><thead><tr><th><code>management.metrics.distribution.maximum-expected-value.*</code></th><th></th><th>以指定名称开头的仪表 ID 预计会观察到的最大数值。匹配时间最长者获胜。值可以指定为长值或持续时间值（对于定时器仪表，如果没有指定单位，默认为 ms）。</th></tr></thead><tbody><tr><td><code>management.metrics.distribution.minimum-expected-value.*</code></td><td></td><td>以指定名称开头的仪表 ID 预计将遵守的最小值。匹配时间最长者获胜。值可以指定为长值或持续时间值（对于定时器仪表，如果没有指定单位，默认为 ms）。</td></tr><tr><td><code>management.metrics.distribution.percentiles-histogram.*</code></td><td></td><td>以指定名称开头的仪表 ID 是否应该发布百分位直方图。对于支持基于直方图的可汇总百分位数计算的监控系统，可以将其设置为 “true”。对于其他系统，这没有影响。匹配时间最长者胜出，键<code>all</code>也可用于配置所有仪表。</td></tr><tr><td><code>management.metrics.distribution.percentiles.*</code></td><td></td><td>以指定名称开头的电表 ID 的特定计算的不可聚集的百分比，以运到后台。匹配时间最长者胜出，键<code>all</code>也可用于配置所有仪表。</td></tr><tr><td><code>management.metrics.distribution.slo.*</code></td><td></td><td>以指定名称开头的仪表 ID 的具体服务级目标边界。匹配时间最长者获胜。计数器将为每个指定边界发布。值可以指定为一个长值或一个持续时间值（对于计时器仪表，如果没有指定单位，则默认为 ms）。</td></tr></tbody></table><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><table><thead><tr><th><code>management.metrics.export.appoptics.api-token</code></th><th></th><th>AppOptics API 令牌。</th></tr></thead><tbody><tr><td><code>management.metrics.export.appoptics.batch-size</code></td><td><code>500.0</code></td><td>每次请求使用该后台的测量次数。如果发现更多的测量结果，那么将进行多次请求。</td></tr><tr><td><code>management.metrics.export.appoptics.connect-timeout</code></td><td><code>5s</code></td><td>对该后端请求的连接超时。</td></tr><tr><td><code>management.metrics.export.appoptics.enabled</code></td><td><code>true</code></td><td>是否启用向该后台导出指标。</td></tr><tr><td><code>management.metrics.export.appoptics.floor-times</code></td><td><code>false</code></td><td>是否运送浮动时间，在从多个主机发送测量数据以使其对准给定的时间边界时很有用。</td></tr><tr><td><code>management.metrics.export.appoptics.host-tag</code></td><td><code>instance</code></td><td>当将指标传送到 AppOptics 时，将被映射到”@host “的标签。</td></tr><tr><td><code>management.metrics.export.appoptics.read-timeout</code></td><td><code>10s</code></td><td>读取对该后端请求的超时。</td></tr><tr><td><code>management.metrics.export.appoptics.step</code></td><td><code>1m</code></td><td>使用的步长（即报告频率）。</td></tr><tr><td><code>management.metrics.export.appoptics.uri</code></td><td><code>[https://api.appoptics.com/v1/measurements](https://api.appoptics.com/v1/measurements)</code></td><td>运送指标的 URI。</td></tr><tr><td><code>management.metrics.export.atlas.batch-size</code></td><td><code>10000.0</code></td><td>每次请求使用该后台的测量次数。如果发现更多的测量结果，那么将进行多次请求。</td></tr><tr><td><code>management.metrics.export.atlas.config-refresh-frequency</code></td><td><code>10s</code></td><td>从 LWC 服务刷新配置设置的频率。</td></tr><tr><td><code>management.metrics.export.atlas.config-time-to-live</code></td><td><code>150s</code></td><td>从 LWC 服务的订阅时间活。</td></tr><tr><td><code>management.metrics.export.atlas.config-uri</code></td><td><code>http://localhost:7101/lwc/api/v1/expressions/local-dev</code></td><td>用于 Atlas LWC 端点检索当前订阅的 URI。</td></tr><tr><td><code>management.metrics.export.atlas.connect-timeout</code></td><td><code>1s</code></td><td>对该后端请求的连接超时。</td></tr><tr><td><code>management.metrics.export.atlas.enabled</code></td><td><code>true</code></td><td>是否启用向该后台导出指标。</td></tr><tr><td><code>management.metrics.export.atlas.eval-uri</code></td><td><code>http://localhost:7101/lwc/api/v1/evaluate</code></td><td>用于 Atlas LWC 端点的 URI，以评估订阅的数据。</td></tr><tr><td><code>management.metrics.export.atlas.lwc-enabled</code></td><td><code>false</code></td><td>是否启用流媒体到 Atlas LWC。</td></tr><tr><td><code>management.metrics.export.atlas.meter-time-to-live</code></td><td><code>15m</code></td><td>没有任何活动的电表的生存时间。过了这个时间，该电表将被视为过期，不会被报告。</td></tr><tr><td><code>management.metrics.export.atlas.num-threads</code></td><td><code>4.0</code></td><td>使用指标发布调度器的线程数。</td></tr><tr><td><code>management.metrics.export.atlas.read-timeout</code></td><td><code>10s</code></td><td>读取对该后端请求的超时。</td></tr><tr><td><code>management.metrics.export.atlas.step</code></td><td><code>1m</code></td><td>使用的步长（即报告频率）。</td></tr><tr><td><code>management.metrics.export.atlas.uri</code></td><td><code>http://localhost:7101/api/v1/publish</code></td><td>Atlas 服务器的 URI。</td></tr><tr><td><code>management.metrics.export.datadog.api-key</code></td><td></td><td>Datadog API 密钥。</td></tr><tr><td><code>management.metrics.export.datadog.application-key</code></td><td></td><td>Datadog 应用程序密钥。并非严格要求，但通过向 Datadog 发送仪表描述、类型和基本单位来改善 Datadog 体验。</td></tr><tr><td><code>management.metrics.export.datadog.batch-size</code></td><td><code>10000.0</code></td><td>每次请求使用该后台的测量次数。如果发现更多的测量结果，那么将进行多次请求。</td></tr><tr><td><code>management.metrics.export.datadog.connect-timeout</code></td><td><code>1s</code></td><td>对该后端请求的连接超时。</td></tr><tr><td><code>management.metrics.export.datadog.descriptions</code></td><td><code>true</code></td><td>是否向 Datadog 发布描述元数据。关闭此选项，以减少发送的元数据量。</td></tr><tr><td><code>management.metrics.export.datadog.enabled</code></td><td><code>true</code></td><td>是否启用向该后台导出指标。</td></tr><tr><td><code>management.metrics.export.datadog.host-tag</code></td><td><code>instance</code></td><td>将指标传送到 Datadog 时，将被映射到 “主机 “的标签。</td></tr><tr><td><code>management.metrics.export.datadog.read-timeout</code></td><td><code>10s</code></td><td>读取对该后端请求的超时。</td></tr><tr><td><code>management.metrics.export.datadog.step</code></td><td><code>1m</code></td><td>使用的步长（即报告频率）。</td></tr><tr><td><code>management.metrics.export.datadog.uri</code></td><td><code>[https://api.datadoghq.com](https://api.datadoghq.com)</code></td><td>要将度量值运送到的 URI。如果你需要将指标发布到内部代理的途中，你可以用这个定义代理的位置。</td></tr><tr><td><code>management.metrics.export.dynatrace.api-token</code></td><td></td><td>Dynatrace 认证令牌。</td></tr><tr><td><code>management.metrics.export.dynatrace.batch-size</code></td><td><code>10000.0</code></td><td>每次请求使用该后台的测量次数。如果发现更多的测量结果，那么将进行多次请求。</td></tr><tr><td><code>management.metrics.export.dynatrace.connect-timeout</code></td><td><code>1s</code></td><td>对该后端请求的连接超时。</td></tr><tr><td><code>management.metrics.export.dynatrace.device-id</code></td><td></td><td>将指标导出到 Dynatrace 的自定义设备的 ID。</td></tr><tr><td><code>management.metrics.export.dynatrace.enabled</code></td><td><code>true</code></td><td>是否启用向该后台导出指标。</td></tr><tr><td><code>management.metrics.export.dynatrace.group</code></td><td></td><td>输出指标的组。用于在 Dynatrace 用户界面中指定自定义设备组名称。</td></tr><tr><td><code>management.metrics.export.dynatrace.read-timeout</code></td><td><code>10s</code></td><td>读取对该后端请求的超时。</td></tr><tr><td><code>management.metrics.export.dynatrace.step</code></td><td><code>1m</code></td><td>使用的步长（即报告频率）。</td></tr><tr><td><code>management.metrics.export.dynatrace.technology-type</code></td><td><code>java</code></td><td>导出指标的技术类型。用于在 Dynatrace 用户界面中根据逻辑技术名称对指标进行分组。</td></tr><tr><td><code>management.metrics.export.dynatrace.uri</code></td><td></td><td>用于发送指标的 URI。应该用于 SaaS、自我管理的实例或通过内部代理进行传送。</td></tr><tr><td><code>management.metrics.export.elastic.auto-create-index</code></td><td><code>true</code></td><td>如果索引不存在，是否自动创建索引。</td></tr><tr><td><code>management.metrics.export.elastic.batch-size</code></td><td><code>10000.0</code></td><td>每次请求使用该后台的测量次数。如果发现更多的测量结果，那么将进行多次请求。</td></tr><tr><td><code>management.metrics.export.elastic.connect-timeout</code></td><td><code>1s</code></td><td>对该后端请求的连接超时。</td></tr><tr><td><code>management.metrics.export.elastic.enabled</code></td><td><code>true</code></td><td>是否启用向该后台导出指标。</td></tr><tr><td><code>management.metrics.export.elastic.host</code></td><td><code>http://localhost:9200</code></td><td>要导出指标的主机。</td></tr><tr><td><code>management.metrics.export.elastic.index</code></td><td><code>metrics</code></td><td>输出指标的索引。</td></tr><tr><td><code>management.metrics.export.elastic.index-date-format</code></td><td><code>yyyy-MM</code></td><td>滚动索引使用的索引日期格式。附在指数名称后面。</td></tr><tr><td><code>management.metrics.export.elastic.index-date-separator</code></td><td><code>-</code></td><td>前缀用于将索引名称与滚动索引使用的日期格式分开。</td></tr><tr><td><code>management.metrics.export.elastic.password</code></td><td></td><td>Elastic 服务器的登录密码。</td></tr><tr><td><code>management.metrics.export.elastic.pipeline</code></td><td></td><td>摄取管道名称。默认情况下，事件不会被预处理。</td></tr><tr><td><code>management.metrics.export.elastic.read-timeout</code></td><td><code>10s</code></td><td>读取对该后端请求的超时。</td></tr><tr><td><code>management.metrics.export.elastic.step</code></td><td><code>1m</code></td><td>使用的步长（即报告频率）。</td></tr><tr><td><code>management.metrics.export.elastic.timestamp-field-name</code></td><td><code>@timestamp</code></td><td>时间戳字段的名称。</td></tr><tr><td><code>management.metrics.export.elastic.user-name</code></td><td></td><td>Elastic 服务器的登录用户。</td></tr><tr><td><code>management.metrics.export.ganglia.addressing-mode</code></td><td><code>multicast</code></td><td>UDP 寻址模式，单播或组播。</td></tr><tr><td><code>management.metrics.export.ganglia.duration-units</code></td><td><code>milliseconds</code></td><td>用于报告持续时间的基本时间单位。</td></tr><tr><td><code>management.metrics.export.ganglia.enabled</code></td><td><code>true</code></td><td>是否启用导出指标到 Ganglia。</td></tr><tr><td><code>management.metrics.export.ganglia.host</code></td><td><code>localhost</code></td><td>接收导出指标的 Ganglia 服务器主机。</td></tr><tr><td><code>management.metrics.export.ganglia.port</code></td><td><code>8649.0</code></td><td>Ganglia 服务器接收导出指标的端口。</td></tr><tr><td><code>management.metrics.export.ganglia.step</code></td><td><code>1m</code></td><td>使用的步长（即报告频率）。</td></tr><tr><td><code>management.metrics.export.ganglia.time-to-live</code></td><td><code>1.0</code></td><td>Ganglia 上的指标生存时间。将多播的生存时间设置为大于主机之间的跳数（路由器）。</td></tr><tr><td><code>management.metrics.export.graphite.duration-units</code></td><td><code>milliseconds</code></td><td>用于报告持续时间的基本时间单位。</td></tr><tr><td><code>management.metrics.export.graphite.enabled</code></td><td><code>true</code></td><td>是否启用了将指标导出到 Graphite 的功能。</td></tr><tr><td><code>management.metrics.export.graphite.graphite-tags-enabled</code></td><td></td><td>是否应使用 Graphite 标签，而不是分级命名惯例。除非设置了 “tagsAsPrefix”，否则默认为启用。</td></tr><tr><td><code>management.metrics.export.graphite.host</code></td><td><code>localhost</code></td><td>接收导出指标的 Graphite 服务器的主机。</td></tr><tr><td><code>management.metrics.export.graphite.port</code></td><td><code>2004.0</code></td><td>接收导出指标的 Graphite 服务器的端口。</td></tr><tr><td><code>management.metrics.export.graphite.protocol</code></td><td><code>pickled</code></td><td>向 Graphite 发送数据时使用的协议。</td></tr><tr><td><code>management.metrics.export.graphite.rate-units</code></td><td><code>seconds</code></td><td>用于报告费率的基本时间单位。</td></tr><tr><td><code>management.metrics.export.graphite.step</code></td><td><code>1m</code></td><td>使用的步长（即报告频率）。</td></tr><tr><td><code>management.metrics.export.graphite.tags-as-prefix</code></td><td><code>[]</code></td><td>对于分层命名惯例，将指定的标签键变成度量前缀的一部分。如果 “graphiteTagsEnabled “为真，则忽略。</td></tr><tr><td><code>management.metrics.export.humio.api-token</code></td><td></td><td>Humio API 令牌。</td></tr><tr><td><code>management.metrics.export.humio.batch-size</code></td><td><code>10000.0</code></td><td>每次请求使用该后台的测量次数。如果发现更多的测量结果，那么将进行多次请求。</td></tr><tr><td><code>management.metrics.export.humio.connect-timeout</code></td><td><code>5s</code></td><td>对该后端请求的连接超时。</td></tr><tr><td><code>management.metrics.export.humio.enabled</code></td><td><code>true</code></td><td>是否启用向该后台导出指标。</td></tr><tr><td><code>management.metrics.export.humio.read-timeout</code></td><td><code>10s</code></td><td>读取对该后端请求的超时。</td></tr><tr><td><code>management.metrics.export.humio.step</code></td><td><code>1m</code></td><td>使用的步长（即报告频率）。</td></tr><tr><td><code>management.metrics.export.humio.tags.*</code></td><td></td><td>Humio 标签，描述将存储指标的数据源。Humio 标签与 Micrometer 标签的概念不同。Micrometer 的标签用于按照尺寸边界划分度量。</td></tr><tr><td><code>management.metrics.export.humio.uri</code></td><td><code>[https://cloud.humio.com](https://cloud.humio.com)</code></td><td>URI 来运送指标。如果你需要将指标发布到 Humio 的内部代理，你可以用这个定义代理的位置。</td></tr><tr><td><code>management.metrics.export.influx.auto-create-db</code></td><td><code>true</code></td><td>如果 Influx 数据库不存在，在尝试向其发布指标之前，是否要创建该数据库。</td></tr><tr><td><code>management.metrics.export.influx.batch-size</code></td><td><code>10000.0</code></td><td>每次请求使用该后台的测量次数。如果发现更多的测量结果，那么将进行多次请求。</td></tr><tr><td><code>management.metrics.export.influx.compressed</code></td><td><code>true</code></td><td>是否启用 GZIP 压缩发布到 Influx 的指标批次。</td></tr><tr><td><code>management.metrics.export.influx.connect-timeout</code></td><td><code>1s</code></td><td>对该后端请求的连接超时。</td></tr><tr><td><code>management.metrics.export.influx.consistency</code></td><td><code>one</code></td><td>写出每一点的一致性。</td></tr><tr><td><code>management.metrics.export.influx.db</code></td><td><code>mydb</code></td><td>当将指标传送到 Influx 时，将被映射到 “主机 “的标签。</td></tr><tr><td><code>management.metrics.export.influx.enabled</code></td><td><code>true</code></td><td>是否启用向该后台导出指标。</td></tr><tr><td><code>management.metrics.export.influx.password</code></td><td></td><td>Influx 服务器的登录密码。</td></tr><tr><td><code>management.metrics.export.influx.read-timeout</code></td><td><code>10s</code></td><td>读取对该后端请求的超时。</td></tr><tr><td><code>management.metrics.export.influx.retention-duration</code></td><td></td><td>Influx 应该在当前数据库中保留数据的时间段。例如 7d，请查看 influx 文档了解更多关于持续时间格式的细节。</td></tr><tr><td><code>management.metrics.export.influx.retention-policy</code></td><td></td><td>要使用的保留策略（如果没有指定保留策略，Influx 会写入默认的保留策略）。</td></tr><tr><td><code>management.metrics.export.influx.retention-replication-factor</code></td><td></td><td>集群中存储了多少份数据。对于单节点实例，必须是 1。</td></tr><tr><td><code>management.metrics.export.influx.retention-shard-duration</code></td><td></td><td>一个碎片组所覆盖的时间范围。例如 2w，请查看流入文档，了解更多关于持续时间格式的细节。</td></tr><tr><td><code>management.metrics.export.influx.step</code></td><td><code>1m</code></td><td>使用的步长（即报告频率）。</td></tr><tr><td><code>management.metrics.export.influx.uri</code></td><td><code>http://localhost:8086</code></td><td>Influx 服务器的 URI。</td></tr><tr><td><code>management.metrics.export.influx.user-name</code></td><td></td><td>Influx 服务器的登录用户。</td></tr><tr><td><code>management.metrics.export.jmx.domain</code></td><td><code>metrics</code></td><td>度量 JMX 域名。</td></tr><tr><td><code>management.metrics.export.jmx.enabled</code></td><td><code>true</code></td><td>是否启用将指标导出到 JMX。</td></tr><tr><td><code>management.metrics.export.jmx.step</code></td><td><code>1m</code></td><td>使用的步长（即报告频率）。</td></tr><tr><td><code>management.metrics.export.kairos.batch-size</code></td><td><code>10000.0</code></td><td>每次请求使用该后台的测量次数。如果发现更多的测量结果，那么将进行多次请求。</td></tr><tr><td><code>management.metrics.export.kairos.connect-timeout</code></td><td><code>1s</code></td><td>对该后端请求的连接超时。</td></tr><tr><td><code>management.metrics.export.kairos.enabled</code></td><td><code>true</code></td><td>是否启用向该后台导出指标。</td></tr><tr><td><code>management.metrics.export.kairos.password</code></td><td></td><td>KairosDB 服务器的登录密码。</td></tr><tr><td><code>management.metrics.export.kairos.read-timeout</code></td><td><code>10s</code></td><td>读取对该后端请求的超时。</td></tr><tr><td><code>management.metrics.export.kairos.step</code></td><td><code>1m</code></td><td>使用的步长（即报告频率）。</td></tr><tr><td><code>management.metrics.export.kairos.uri</code></td><td><code>http://localhost:8080/api/v1/datapoints</code></td><td>KairosDB 服务器的 URI。</td></tr><tr><td><code>management.metrics.export.kairos.user-name</code></td><td></td><td>KairosDB 服务器的登录用户。</td></tr><tr><td><code>management.metrics.export.newrelic.account-id</code></td><td></td><td>新的 Relic 账户 ID。</td></tr><tr><td><code>management.metrics.export.newrelic.api-key</code></td><td></td><td>新的 Relic API 密钥。</td></tr><tr><td><code>management.metrics.export.newrelic.batch-size</code></td><td><code>10000.0</code></td><td>每次请求使用该后台的测量次数。如果发现更多的测量结果，那么将进行多次请求。</td></tr><tr><td><code>management.metrics.export.newrelic.client-provider-type</code></td><td></td><td>要使用的客户端提供者类型。</td></tr><tr><td><code>management.metrics.export.newrelic.connect-timeout</code></td><td><code>1s</code></td><td>对该后端请求的连接超时。</td></tr><tr><td><code>management.metrics.export.newrelic.enabled</code></td><td><code>true</code></td><td>是否启用向该后台导出指标。</td></tr><tr><td><code>management.metrics.export.newrelic.event-type</code></td><td><code>SpringBootSample</code></td><td>应该被发布的事件类型。如果’meter-name-event-type-enabled’被设置为’true’，此属性将被忽略。</td></tr><tr><td><code>management.metrics.export.newrelic.meter-name-event-type-enabled</code></td><td><code>false</code></td><td>是否将仪表名称作为事件类型发送，而不是使用 “事件类型 “配置属性值。如果没有遵循 New Relic 指南或需要与以前的 Spring Boot 版本一致的事件类型，可将其设置为’true’。</td></tr><tr><td><code>management.metrics.export.newrelic.read-timeout</code></td><td><code>10s</code></td><td>读取对该后端请求的超时。</td></tr><tr><td><code>management.metrics.export.newrelic.step</code></td><td><code>1m</code></td><td>使用的步长（即报告频率）。</td></tr><tr><td><code>management.metrics.export.newrelic.uri</code></td><td><code>[https://insights-collector.newrelic.com](https://insights-collector.newrelic.com)</code></td><td>运送指标的 URI。</td></tr><tr><td><code>management.metrics.export.prometheus.descriptions</code></td><td><code>true</code></td><td>是否启用发布描述作为 Prometheus 的刮擦有效载荷的一部分。关闭此选项，以尽量减少每次 scrape 发送的数据量。</td></tr><tr><td><code>management.metrics.export.prometheus.enabled</code></td><td><code>true</code></td><td>是否启用向 Prometheus 导出指标。</td></tr><tr><td><code>management.metrics.export.prometheus.histogram-flavor</code></td><td><code>prometheus</code></td><td>直方图类型用于支持 DistributionSummary 和 Timer。</td></tr><tr><td><code>management.metrics.export.prometheus.pushgateway.base-url</code></td><td><code>http://localhost:9091</code></td><td>Pushgateway 的基础 URL。</td></tr><tr><td><code>management.metrics.export.prometheus.pushgateway.enabled</code></td><td><code>false</code></td><td>通过 Prometheus Pushgateway 启用发布。</td></tr><tr><td><code>management.metrics.export.prometheus.pushgateway.grouping-key.*</code></td><td></td><td>推送指标的分组键。</td></tr><tr><td><code>management.metrics.export.prometheus.pushgateway.job</code></td><td></td><td>该应用实例的作业标识符。</td></tr><tr><td><code>management.metrics.export.prometheus.pushgateway.push-rate</code></td><td><code>1m</code></td><td>推送指标的频率。</td></tr><tr><td><code>management.metrics.export.prometheus.pushgateway.shutdown-operation</code></td><td><code>none</code></td><td>关机时应进行的操作。</td></tr><tr><td><code>management.metrics.export.prometheus.step</code></td><td><code>1m</code></td><td>使用的步长（即报告频率）。</td></tr><tr><td><code>management.metrics.export.signalfx.access-token</code></td><td></td><td>SignalFX 访问令牌。</td></tr><tr><td><code>management.metrics.export.signalfx.batch-size</code></td><td><code>10000.0</code></td><td>每次请求使用该后台的测量次数。如果发现更多的测量结果，那么将进行多次请求。</td></tr><tr><td><code>management.metrics.export.signalfx.connect-timeout</code></td><td><code>1s</code></td><td>对该后端请求的连接超时。</td></tr><tr><td><code>management.metrics.export.signalfx.enabled</code></td><td><code>true</code></td><td>是否启用向该后台导出指标。</td></tr><tr><td><code>management.metrics.export.signalfx.read-timeout</code></td><td><code>10s</code></td><td>读取对该后端请求的超时。</td></tr><tr><td><code>management.metrics.export.signalfx.source</code></td><td></td><td>唯一标识向 SignalFx 发布指标的应用程序实例。默认为本地主机名。</td></tr><tr><td><code>management.metrics.export.signalfx.step</code></td><td><code>10s</code></td><td>使用的步长（即报告频率）。</td></tr><tr><td><code>management.metrics.export.signalfx.uri</code></td><td><code>[https://ingest.signalfx.com](https://ingest.signalfx.com)</code></td><td>运送指标的 URI。</td></tr><tr><td><code>management.metrics.export.simple.enabled</code></td><td><code>true</code></td><td>在没有其他导出器的情况下，是否启用将指标导出到内存后端。</td></tr><tr><td><code>management.metrics.export.simple.mode</code></td><td><code>cumulative</code></td><td>计数模式。</td></tr><tr><td><code>management.metrics.export.simple.step</code></td><td><code>1m</code></td><td>使用的步长（即报告频率）。</td></tr><tr><td><code>management.metrics.export.stackdriver.batch-size</code></td><td><code>10000.0</code></td><td>每次请求使用该后台的测量次数。如果发现更多的测量结果，那么将进行多次请求。</td></tr><tr><td><code>management.metrics.export.stackdriver.connect-timeout</code></td><td><code>1s</code></td><td>对该后端请求的连接超时。</td></tr><tr><td><code>management.metrics.export.stackdriver.enabled</code></td><td><code>true</code></td><td>是否启用向该后台导出指标。</td></tr><tr><td><code>management.metrics.export.stackdriver.project-id</code></td><td></td><td>要监控的谷歌云项目的标识符。</td></tr><tr><td><code>management.metrics.export.stackdriver.read-timeout</code></td><td><code>10s</code></td><td>读取对该后端请求的超时。</td></tr><tr><td><code>management.metrics.export.stackdriver.resource-type</code></td><td><code>global</code></td><td>监测的资源类型。</td></tr><tr><td><code>management.metrics.export.stackdriver.step</code></td><td><code>1m</code></td><td>使用的步长（即报告频率）。</td></tr><tr><td><code>management.metrics.export.statsd.enabled</code></td><td><code>true</code></td><td>是否启用导出指标到 StatsD。</td></tr><tr><td><code>management.metrics.export.statsd.flavor</code></td><td><code>datadog</code></td><td>要使用 StatsD 行协议。</td></tr><tr><td><code>management.metrics.export.statsd.host</code></td><td><code>localhost</code></td><td>StatsD 服务器的主机，用于接收导出的指标。</td></tr><tr><td><code>management.metrics.export.statsd.max-packet-length</code></td><td><code>1400.0</code></td><td>单个有效载荷的总长度应保持在你的网络 MTU 之内。</td></tr><tr><td><code>management.metrics.export.statsd.polling-frequency</code></td><td><code>10s</code></td><td>仪表的轮询频率。当一个仪表被轮询时，它的值会被重新计算，如果值发生了变化（或者 publishUnchangedMeters 为真），它将被发送到 StatsD 服务器。</td></tr><tr><td><code>management.metrics.export.statsd.port</code></td><td><code>8125.0</code></td><td>StatsD 服务器的端口，用于接收导出的指标。</td></tr><tr><td><code>management.metrics.export.statsd.publish-unchanged-meters</code></td><td><code>true</code></td><td>是否向 StatsD 服务器发送不变的仪表。</td></tr><tr><td><code>management.metrics.export.wavefront.api-token</code></td><td></td><td>直接向 Wavefront API 主机发布指标时使用的 API 令牌。</td></tr><tr><td><code>management.metrics.export.wavefront.batch-size</code></td><td><code>10000.0</code></td><td>每次请求使用该后台的测量次数。如果发现更多的测量结果，那么将进行多次请求。</td></tr><tr><td><code>management.metrics.export.wavefront.enabled</code></td><td><code>true</code></td><td>是否启用向该后台导出指标。</td></tr><tr><td><code>management.metrics.export.wavefront.global-prefix</code></td><td></td><td>全局前缀，用于在 Wavefront UI 中查看时，将源自此应用程序的白盒仪表的指标与源自其他 Wavefront 集成的指标分开。</td></tr><tr><td><code>management.metrics.export.wavefront.sender.flush-interval</code></td><td><code>1s</code></td><td></td></tr><tr><td><code>management.metrics.export.wavefront.sender.max-queue-size</code></td><td><code>50000.0</code></td><td></td></tr><tr><td><code>management.metrics.export.wavefront.sender.message-size</code></td><td></td><td></td></tr><tr><td><code>management.metrics.export.wavefront.source</code></td><td></td><td>应用程序实例的唯一标识符，它是被发布到 Wavefront 的指标的来源。默认为本地主机名。</td></tr><tr><td><code>management.metrics.export.wavefront.step</code></td><td><code>1m</code></td><td>使用的步长（即报告频率）</td></tr><tr><td><code>management.metrics.export.wavefront.uri</code></td><td><code>[https://longboard.wavefront.com](https://longboard.wavefront.com)</code></td><td>运送指标的 URI。</td></tr></tbody></table><h3 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h3><table><thead><tr><th><code>management.metrics.tags.*</code></th><th></th><th>常见的标签，应用于每个仪表。</th></tr></thead></table><h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><table><thead><tr><th><code>management.metrics.web.client.max-uri-tags</code></th><th><code>100.0</code></th><th>允许的唯一 URI 标签值的最大数量。在达到最大标签值数量后，过滤器会拒绝包含额外标签值的指标。</th></tr></thead><tbody><tr><td><code>management.metrics.web.client.request.autotime.enabled</code></td><td><code>true</code></td><td>是否自动为 Web 客户端请求计时。</td></tr><tr><td><code>management.metrics.web.client.request.autotime.percentiles</code></td><td></td><td>计算出不可汇总的百分比来发布。</td></tr><tr><td><code>management.metrics.web.client.request.autotime.percentiles-histogram</code></td><td><code>false</code></td><td>是否应该公布百分位直方图。</td></tr><tr><td><code>management.metrics.web.client.request.metric-name</code></td><td><code>http.client.requests</code></td><td>发送请求的指标名称。</td></tr><tr><td><code>management.metrics.web.server.max-uri-tags</code></td><td><code>100.0</code></td><td>允许的唯一 URI 标签值的最大数量。在达到最大标签值数量后，过滤器会拒绝包含额外标签值的指标。</td></tr><tr><td><code>management.metrics.web.server.request.autotime.enabled</code></td><td><code>true</code></td><td>是否自动为 Web 服务器请求计时。</td></tr><tr><td><code>management.metrics.web.server.request.autotime.percentiles</code></td><td></td><td>计算出不可汇总的百分比来发布。</td></tr><tr><td><code>management.metrics.web.server.request.autotime.percentiles-histogram</code></td><td><code>false</code></td><td>是否应该公布百分位直方图。</td></tr><tr><td><code>management.metrics.web.server.request.ignore-trailing-slash</code></td><td><code>true</code></td><td>记录指标时，是否应该忽略尾部的斜杠。</td></tr><tr><td><code>management.metrics.web.server.request.metric-name</code></td><td><code>http.server.requests</code></td><td>收到的请求的指标名称。</td></tr></tbody></table><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><table><thead><tr><th><code>management.server.add-application-context-header</code></th><th><code>false</code></th><th>在每个响应中添加 “X-Application-Context “HTTP 头。</th></tr></thead><tbody><tr><td><code>management.server.address</code></td><td></td><td>管理端点应该绑定的网络地址。需要自定义 management.server.port。</td></tr><tr><td><code>management.server.port</code></td><td></td><td>管理端点 HTTP 端口（默认情况下与应用程序使用相同的端口）。配置不同的端口以使用管理专用的 SSL。</td></tr><tr><td><code>management.server.servlet.context-path</code></td><td></td><td>管理端点上下文路径（例如，<code>/management</code>）。需要自定义 management.server.port。</td></tr></tbody></table><h3 id="ssl"><a href="#ssl" class="headerlink" title="ssl"></a>ssl</h3><table><thead><tr><th><code>management.server.ssl.ciphers</code></th><th></th><th>支持的 SSL 密码。</th></tr></thead><tbody><tr><td><code>management.server.ssl.client-auth</code></td><td></td><td>客户端认证模式。需要一个信任存储。</td></tr><tr><td><code>management.server.ssl.enabled</code></td><td><code>true</code></td><td>是否启用 SSL 支持。</td></tr><tr><td><code>management.server.ssl.enabled-protocols</code></td><td></td><td>启用 SSL 协议。</td></tr><tr><td><code>management.server.ssl.key-alias</code></td><td></td><td>在钥匙库中标识钥匙的别名。</td></tr><tr><td><code>management.server.ssl.key-password</code></td><td></td><td>用于访问钥匙库中钥匙的密码。</td></tr><tr><td><code>management.server.ssl.key-store</code></td><td></td><td>存放 SSL 证书的密钥存储路径（通常是一个 jks 文件）。</td></tr><tr><td><code>management.server.ssl.key-store-password</code></td><td></td><td>用于访问钥匙库的密码。</td></tr><tr><td><code>management.server.ssl.key-store-provider</code></td><td></td><td>钥匙库的提供者。</td></tr><tr><td><code>management.server.ssl.key-store-type</code></td><td></td><td>钥匙库的类型。</td></tr><tr><td><code>management.server.ssl.protocol</code></td><td><code>TLS</code></td><td>要使用的 SSL 协议。</td></tr><tr><td><code>management.server.ssl.trust-store</code></td><td></td><td>持有 SSL 证书的信任商店。</td></tr><tr><td><code>management.server.ssl.trust-store-password</code></td><td></td><td>用于访问信托商店的密码。</td></tr><tr><td><code>management.server.ssl.trust-store-provider</code></td><td></td><td>信托商店的提供者。</td></tr><tr><td><code>management.server.ssl.trust-store-type</code></td><td></td><td>信托商店的类型。</td></tr></tbody></table><h2 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h2><table><thead><tr><th><code>management.trace.http.enabled</code></th><th><code>true</code></th><th>是否启用 HTTP 请求-响应跟踪。</th></tr></thead><tbody><tr><td><code>management.trace.http.include</code></td><td><code>[request-headers, response-headers, cookies, errors]</code></td><td>要包含在跟踪中的项目。默认为请求头（不包括授权，但包括 Cookie）、响应头（包括 Set-Cookie）和所需时间。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSocket 属性</title>
      <link href="/83e4d5ba76f4.html"/>
      <url>/83e4d5ba76f4.html</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.rsocket.server.address</code></td><td></td><td>服务器应该绑定的网络地址。</td></tr><tr><td><code>spring.rsocket.server.mapping-path</code></td><td></td><td>RSocket 处理请求的路径（仅适用于 websocket 传输）</td></tr><tr><td><code>spring.rsocket.server.port</code></td><td></td><td>服务器端口。</td></tr><tr><td><code>spring.rsocket.server.transport</code></td><td><code>tcp</code></td><td>RSocket 传输协议。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全属性</title>
      <link href="/fdb3287fae31.html"/>
      <url>/fdb3287fae31.html</url>
      
        <content type="html"><![CDATA[<h2 id="ldap"><a href="#ldap" class="headerlink" title="ldap"></a>ldap</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.ldap.anonymous-read-only</code></td><td></td><td>是否只读操作应使用匿名环境。除非设置了用户名，否则默认为禁用。</td></tr><tr><td><code>spring.ldap.base</code></td><td></td><td>基础后缀，所有操作都应从这里开始。</td></tr><tr><td><code>spring.ldap.base-environment.*</code></td><td></td><td>LDAP 规范设置。</td></tr><tr><td><code>spring.ldap.embedded.base-dn</code></td><td></td><td>基础 DN 清单。</td></tr><tr><td><code>spring.ldap.embedded.credential.password</code></td><td></td><td>嵌入式 LDAP 密码。</td></tr><tr><td><code>spring.ldap.embedded.credential.username</code></td><td></td><td>嵌入式 LDAP 用户名。</td></tr><tr><td><code>spring.ldap.embedded.ldif</code></td><td><code>classpath:schema.ldif</code></td><td>Schema（LDIF）脚本资源参考。</td></tr><tr><td><code>spring.ldap.embedded.port</code></td><td><code>0.0</code></td><td>嵌入式 LDAP 端口。</td></tr><tr><td><code>spring.ldap.embedded.validation.enabled</code></td><td><code>true</code></td><td>是否启用 LDAP 模式验证。</td></tr><tr><td><code>spring.ldap.embedded.validation.schema</code></td><td></td><td>自定义模式的路径。</td></tr><tr><td><code>spring.ldap.password</code></td><td></td><td>服务器的登录密码。</td></tr><tr><td><code>spring.ldap.urls</code></td><td></td><td>服务器的 LDAP URL。</td></tr><tr><td><code>spring.ldap.username</code></td><td></td><td>服务器的登录用户名。</td></tr></tbody></table><h2 id="security"><a href="#security" class="headerlink" title="security"></a>security</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.security.filter.dispatcher-types</code></td><td><code>[async, error, request]</code></td><td>安全过滤链调度器类型。</td></tr><tr><td><code>spring.security.filter.order</code></td><td><code>-100.0</code></td><td>安全过滤链顺序。</td></tr><tr><td><code>spring.security.oauth2.client.provider.*</code></td><td></td><td>OAuth 提供商的详细信息。</td></tr><tr><td><code>spring.security.oauth2.client.registration.*</code></td><td></td><td>OAuth 客户端注册。</td></tr><tr><td><code>spring.security.oauth2.resourceserver.jwt.issuer-uri</code></td><td></td><td>URI 可以是 OpenID Connect 发现端点，也可以是 RFC 8414 定义的 OAuth 2.0 授权服务器元数据端点。</td></tr><tr><td><code>spring.security.oauth2.resourceserver.jwt.jwk-set-uri</code></td><td></td><td>JSON Web Key URI 用于验证 JWT 标记。</td></tr><tr><td><code>spring.security.oauth2.resourceserver.jwt.jws-algorithm</code></td><td><code>RS256</code></td><td>JSON 网络算法用于验证数字签名。</td></tr><tr><td><code>spring.security.oauth2.resourceserver.jwt.public-key-location</code></td><td></td><td>包含用于验证 JWT 的公钥的文件位置。</td></tr><tr><td><code>spring.security.oauth2.resourceserver.opaquetoken.client-id</code></td><td></td><td>客户端 ID 用于使用令牌反省端点进行验证。</td></tr><tr><td><code>spring.security.oauth2.resourceserver.opaquetoken.client-secret</code></td><td></td><td>客户端秘密用于与令牌反省端点进行身份验证。</td></tr><tr><td><code>spring.security.oauth2.resourceserver.opaquetoken.introspection-uri</code></td><td></td><td>OAuth 2.0 端点，通过它来完成令牌反省。</td></tr><tr><td><code>spring.security.saml2.relyingparty.registration.*</code></td><td></td><td>SAML2 依赖方注册。</td></tr><tr><td><code>spring.security.user.name</code></td><td><code>user</code></td><td>默认用户名。</td></tr><tr><td><code>spring.security.user.password</code></td><td></td><td>默认用户名的密码。</td></tr><tr><td><code>spring.security.user.roles</code></td><td></td><td>授予默认用户名的角色。</td></tr></tbody></table><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.session.hazelcast.flush-mode</code></td><td><code>on-save</code></td><td>会话刷新模式。决定何时将会话变更写入会话存储。</td></tr><tr><td><code>spring.session.hazelcast.map-name</code></td><td><code>spring:session:sessions</code></td><td>用于存储会话的地图的名称。</td></tr><tr><td><code>spring.session.hazelcast.save-mode</code></td><td><code>on-set-attribute</code></td><td>会话保存模式。决定如何跟踪会话更改并保存到会话存储中。</td></tr><tr><td><code>spring.session.jdbc.cleanup-cron</code></td><td><code>0 * * * * *</code></td><td>过期会话清理工作的 Cron 表达式。</td></tr><tr><td><code>spring.session.jdbc.flush-mode</code></td><td><code>on-save</code></td><td>会话刷新模式。决定何时将会话变更写入会话存储。</td></tr><tr><td><code>spring.session.jdbc.initialize-schema</code></td><td><code>embedded</code></td><td>数据库模式初始化模式。</td></tr><tr><td><code>spring.session.jdbc.save-mode</code></td><td><code>on-set-attribute</code></td><td>会话保存模式。决定如何跟踪会话更改并保存到会话存储中。</td></tr><tr><td><code>spring.session.jdbc.schema</code></td><td><code>classpath:org/springframework/session/jdbc/schema-@@platform@@.sql</code></td><td>用于初始化数据库模式的 SQL 文件的路径。</td></tr><tr><td><code>spring.session.jdbc.table-name</code></td><td><code>SPRING_SESSION</code></td><td>用于存储会话的数据库表的名称。</td></tr><tr><td><code>spring.session.mongodb.collection-name</code></td><td><code>sessions</code></td><td>用于存储会话的集合名称。</td></tr><tr><td><code>spring.session.redis.cleanup-cron</code></td><td><code>0 * * * * *</code></td><td>过期会话清理工作的 Cron 表达式。</td></tr><tr><td><code>spring.session.redis.configure-action</code></td><td><code>notify-keyspace-events</code></td><td>当没有用户定义的 ConfigureRedisAction bean 时要应用的配置动作。</td></tr><tr><td><code>spring.session.redis.flush-mode</code></td><td><code>on-save</code></td><td>会话刷新模式。决定何时将会话变更写入会话存储。</td></tr><tr><td><code>spring.session.redis.namespace</code></td><td><code>spring:session</code></td><td>用于存储会话的键的命名空间。</td></tr><tr><td><code>spring.session.redis.save-mode</code></td><td><code>on-set-attribute</code></td><td>会话保存模式。决定如何跟踪会话更改并保存到会话存储中。</td></tr><tr><td><code>spring.session.servlet.filter-dispatcher-types</code></td><td><code>[async, error, request]</code></td><td>会话存储库过滤调度器类型。</td></tr><tr><td><code>spring.session.servlet.filter-order</code></td><td></td><td>会话存储库过滤顺序。</td></tr><tr><td><code>spring.session.store-type</code></td><td></td><td>会话存储类型。</td></tr><tr><td><code>spring.session.timeout</code></td><td></td><td>会话超时。如果没有指定持续时间后缀，将使用秒。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器属性</title>
      <link href="/3004cf782434.html"/>
      <url>/3004cf782434.html</url>
      
        <content type="html"><![CDATA[<h1 id="server"><a href="#server" class="headerlink" title="server"></a>server</h1><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>server.address</code></td><td></td><td>服务器应该绑定的网络地址。</td></tr><tr><td><code>server.forward-headers-strategy</code></td><td></td><td>处理 X-Forwarded-*头的策略。</td></tr><tr><td><code>server.max-http-header-size</code></td><td><code>8KB</code></td><td>HTTP 消息头的最大尺寸。</td></tr><tr><td><code>server.port</code></td><td><code>8080.0</code></td><td>HTTP 服务器端口。</td></tr><tr><td><code>server.server-header</code></td><td></td><td>用于服务器响应头的值（如果为空，则不发送头）。</td></tr><tr><td><code>server.shutdown</code></td><td></td><td>服务器将支持的关机类型。</td></tr></tbody></table><h2 id="comprrssion"><a href="#comprrssion" class="headerlink" title="comprrssion"></a>comprrssion</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>server.compression.enabled</code></td><td><code>false</code></td><td>是否启用响应压缩。</td></tr><tr><td><code>server.compression.excluded-user-agents</code></td><td></td><td>不应压缩响应的用户代理的逗号分隔的列表。</td></tr><tr><td><code>server.compression.mime-types</code></td><td><code>[text/html, text/xml, text/plain, text/css, text/javascript, application/javascript, application/json, application/xml]</code></td><td>应该压缩的 MIME 类型的逗号分隔的列表。</td></tr><tr><td><code>server.compression.min-response-size</code></td><td><code>2KB</code></td><td>执行压缩所需的最小 “内容-长度 “值。</td></tr></tbody></table><h2 id="error"><a href="#error" class="headerlink" title="error"></a>error</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>server.error.include-binding-errors</code></td><td><code>never</code></td><td>什么时候加入 “错误 “属性。</td></tr><tr><td><code>server.error.include-exception</code></td><td><code>false</code></td><td>包括 “异常 “属性。</td></tr><tr><td><code>server.error.include-message</code></td><td><code>never</code></td><td>何时加入 “消息 “属性。</td></tr><tr><td><code>server.error.include-stacktrace</code></td><td><code>never</code></td><td>什么时候加入 “trace “属性。</td></tr><tr><td><code>server.error.path</code></td><td><code>/error</code></td><td>误差控制器的路径。</td></tr><tr><td><code>server.error.whitelabel.enabled</code></td><td><code>true</code></td><td>是否启用服务器出错时在浏览器中显示的默认错误页面。</td></tr></tbody></table><h2 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>server.http2.enabled</code></td><td><code>false</code></td><td>是否启用 HTTP/2 支持，如果当前环境支持。</td></tr></tbody></table><h2 id="jetty"><a href="#jetty" class="headerlink" title="jetty"></a>jetty</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>server.jetty.accesslog.append</code></td><td><code>false</code></td><td>添加到日志中。</td></tr><tr><td><code>server.jetty.accesslog.custom-format</code></td><td></td><td>自定义日志格式，参见 org.eclipse.jetty.server.CustomRequestLog。如果定义了，则覆盖 “格式 “配置键。</td></tr><tr><td><code>server.jetty.accesslog.enabled</code></td><td><code>false</code></td><td>启用访问日志。</td></tr><tr><td><code>server.jetty.accesslog.file-date-format</code></td><td></td><td>日期格式要放在日志文件名中。</td></tr><tr><td><code>server.jetty.accesslog.filename</code></td><td></td><td>日志文件名。如果没有指定，日志会重定向到 “System.err”。</td></tr><tr><td><code>server.jetty.accesslog.format</code></td><td><code>ncsa</code></td><td>日志格式。</td></tr><tr><td><code>server.jetty.accesslog.ignore-paths</code></td><td></td><td>不应该被记录的请求路径。</td></tr><tr><td><code>server.jetty.accesslog.retention-period</code></td><td><code>31.0</code></td><td>删除轮换日志文件前的天数。</td></tr><tr><td><code>server.jetty.connection-idle-timeout</code></td><td></td><td>连接关闭前可以闲置的时间。</td></tr><tr><td><code>server.jetty.max-http-form-post-size</code></td><td><code>200000B</code></td><td>任何 HTTP 帖子请求中表单内容的最大尺寸。</td></tr><tr><td><code>server.jetty.threads.acceptors</code></td><td><code>-1.0</code></td><td>要使用的接受者线程数。当值为-1 时，为默认值，接受器的数量由操作环境得出。</td></tr><tr><td><code>server.jetty.threads.idle-timeout</code></td><td><code>60000ms</code></td><td>最大线程空闲时间。</td></tr><tr><td><code>server.jetty.threads.max</code></td><td><code>200.0</code></td><td>最大线程数。</td></tr><tr><td><code>server.jetty.threads.max-queue-capacity</code></td><td></td><td>线程池后备队列的最大容量。根据线程配置计算出默认值。</td></tr><tr><td><code>server.jetty.threads.min</code></td><td><code>8.0</code></td><td>最少的线程数。</td></tr><tr><td><code>server.jetty.threads.selectors</code></td><td><code>-1.0</code></td><td>要使用的选择器线程数。当值为-1 时，为默认值，选择器的数量来自于操作环境。</td></tr></tbody></table><h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>server.netty.connection-timeout</code></td><td></td><td>Netty 通道的连接超时。</td></tr></tbody></table><h2 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>server.servlet.application-display-name</code></td><td><code>application</code></td><td>显示应用程序的名称。</td></tr><tr><td><code>server.servlet.context-parameters.*</code></td><td></td><td>Servlet 上下文初始化参数。</td></tr><tr><td><code>server.servlet.context-path</code></td><td></td><td>应用程序的上下文路径。</td></tr><tr><td><code>server.servlet.encoding.charsets</code></td><td></td><td></td></tr><tr><td><code>server.servlet.encoding.enabled</code></td><td><code>true</code></td><td>是否启用 http 编码支持。</td></tr><tr><td><code>server.servlet.encoding.force</code></td><td></td><td></td></tr><tr><td><code>server.servlet.encoding.force-request</code></td><td></td><td></td></tr><tr><td><code>server.servlet.encoding.force-response</code></td><td></td><td></td></tr><tr><td><code>server.servlet.encoding.mapping.*</code></td><td></td><td></td></tr><tr><td><code>server.servlet.jsp.class-name</code></td><td><code>org.apache.jasper.servlet.JspServlet</code></td><td>要用于 JSP 的 servlet 的类名。如果注册为真，并且这个类*在 classpath 上，那么它将被注册。</td></tr><tr><td><code>server.servlet.jsp.init-parameters.*</code></td><td></td><td>用于配置 JSP servlet 的初始参数。</td></tr><tr><td><code>server.servlet.jsp.registered</code></td><td><code>true</code></td><td>是否注册了 JSP servlet。</td></tr><tr><td><code>server.servlet.register-default-servlet</code></td><td><code>true</code></td><td>是否在容器中注册默认的 Servlet。</td></tr><tr><td><code>server.servlet.session.cookie.comment</code></td><td></td><td>对会话 cookie 的注释。</td></tr><tr><td><code>server.servlet.session.cookie.domain</code></td><td></td><td>会话 cookie 的域。</td></tr><tr><td><code>server.servlet.session.cookie.http-only</code></td><td></td><td>是否对会话 cookie 使用 “HttpOnly “cookie。</td></tr><tr><td><code>server.servlet.session.cookie.max-age</code></td><td></td><td>会话 cookie 的最大年龄。如果没有指定持续时间后缀，将使用秒。</td></tr><tr><td><code>server.servlet.session.cookie.name</code></td><td></td><td>会话 cookie 名称。</td></tr><tr><td><code>server.servlet.session.cookie.path</code></td><td></td><td>会话 cookie 的路径。</td></tr><tr><td><code>server.servlet.session.cookie.secure</code></td><td></td><td>是否总是将会话 cookie 标记为安全。</td></tr><tr><td><code>server.servlet.session.persistent</code></td><td><code>false</code></td><td>是否在重启之间坚持会话数据。</td></tr><tr><td><code>server.servlet.session.store-dir</code></td><td></td><td>用于存储会话数据的目录。</td></tr><tr><td><code>server.servlet.session.timeout</code></td><td><code>30m</code></td><td>会话超时。如果没有指定持续时间后缀，将使用秒。</td></tr><tr><td><code>server.servlet.session.tracking-modes</code></td><td></td><td>会话跟踪模式。</td></tr></tbody></table><h2 id="ssl"><a href="#ssl" class="headerlink" title="ssl"></a>ssl</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>server.ssl.ciphers</code></td><td></td><td>支持的 SSL 密码。</td></tr><tr><td><code>server.ssl.client-auth</code></td><td></td><td>客户端认证模式。需要一个信任存储。</td></tr><tr><td><code>server.ssl.enabled</code></td><td><code>true</code></td><td>是否启用 SSL 支持。</td></tr><tr><td><code>server.ssl.enabled-protocols</code></td><td></td><td>启用 SSL 协议。</td></tr><tr><td><code>server.ssl.key-alias</code></td><td></td><td>在钥匙库中标识钥匙的别名。</td></tr><tr><td><code>server.ssl.key-password</code></td><td></td><td>用于访问钥匙库中钥匙的密码。</td></tr><tr><td><code>server.ssl.key-store</code></td><td></td><td>存放 SSL 证书的密钥存储路径（通常是一个 jks 文件）。</td></tr><tr><td><code>server.ssl.key-store-password</code></td><td></td><td>用于访问钥匙库的密码。</td></tr><tr><td><code>server.ssl.key-store-provider</code></td><td></td><td>钥匙库的提供者。</td></tr><tr><td><code>server.ssl.key-store-type</code></td><td></td><td>钥匙库的类型。</td></tr><tr><td><code>server.ssl.protocol</code></td><td><code>TLS</code></td><td>要使用的 SSL 协议。</td></tr><tr><td><code>server.ssl.trust-store</code></td><td></td><td>持有 SSL 证书的信任商店。</td></tr><tr><td><code>server.ssl.trust-store-password</code></td><td></td><td>用于访问信托商店的密码。</td></tr><tr><td><code>server.ssl.trust-store-provider</code></td><td></td><td>信托商店的提供者。</td></tr><tr><td><code>server.ssl.trust-store-type</code></td><td></td><td>信托商店的类型。</td></tr></tbody></table><h2 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>server.tomcat.accept-count</code></td><td><code>100.0</code></td><td>当所有可能的请求处理线程都在使用时，传入连接请求的最大队列长度。</td></tr><tr><td><code>server.tomcat.accesslog.buffered</code></td><td><code>true</code></td><td>是否对输出进行缓冲，使其只定期刷新。</td></tr><tr><td><code>server.tomcat.accesslog.check-exists</code></td><td><code>false</code></td><td>是否要检查日志文件是否存在，以便在外部进程重新命名时可以重新创建。</td></tr><tr><td><code>server.tomcat.accesslog.condition-if</code></td><td></td><td>是否只有在 “ServletRequest.getAttribute(conditionIf) “没有产生 null 时，才会启用请求的日志记录。</td></tr><tr><td><code>server.tomcat.accesslog.condition-unless</code></td><td></td><td>是否只有在 “ServletRequest.getAttribute(conditionUnless) “产生 null 时，才会启用请求的日志记录。</td></tr><tr><td><code>server.tomcat.accesslog.directory</code></td><td><code>logs</code></td><td>创建日志文件的目录。可以是绝对的，也可以是相对于 Tomcat 基础目录的。</td></tr><tr><td><code>server.tomcat.accesslog.enabled</code></td><td><code>false</code></td><td>启用访问日志。</td></tr><tr><td><code>server.tomcat.accesslog.encoding</code></td><td></td><td>日志文件使用的字符集。默认为系统默认字符集。</td></tr><tr><td><code>server.tomcat.accesslog.file-date-format</code></td><td><code>.yyyy-MM-dd</code></td><td>要放在日志文件名中的日期格式。</td></tr><tr><td><code>server.tomcat.accesslog.ipv6-canonical</code></td><td><code>false</code></td><td>是否使用 RFC 5952 定义的 IPv6 规范表示格式。</td></tr><tr><td><code>server.tomcat.accesslog.locale</code></td><td></td><td>用于在日志条目和日志文件名后缀中格式化时间戳的地域。默认为 Java 进程的默认 locale。</td></tr><tr><td><code>server.tomcat.accesslog.max-days</code></td><td><code>-1.0</code></td><td>在删除访问日志文件之前，保留这些文件的天数。</td></tr><tr><td><code>server.tomcat.accesslog.pattern</code></td><td><code>common</code></td><td>访问日志的格式模式。</td></tr><tr><td><code>server.tomcat.accesslog.prefix</code></td><td><code>access_log</code></td><td>日志文件名前缀。</td></tr><tr><td><code>server.tomcat.accesslog.rename-on-rotate</code></td><td><code>false</code></td><td>是否将文件名中的日期戳推迟到轮换时间。</td></tr><tr><td><code>server.tomcat.accesslog.request-attributes-enabled</code></td><td><code>false</code></td><td>设置请求的属性，包括 IP 地址、主机名、协议和请求使用的端口。</td></tr><tr><td><code>server.tomcat.accesslog.rotate</code></td><td><code>true</code></td><td>是否启用访问日志轮换。</td></tr><tr><td><code>server.tomcat.accesslog.suffix</code></td><td><code>.log</code></td><td>日志文件名后缀。</td></tr><tr><td><code>server.tomcat.additional-tld-skip-patterns</code></td><td></td><td>以逗号分隔的附加模式列表，这些模式与 TLD 扫描时要忽略的 jar 相匹配。特殊的’?’和’*‘字符可用于在模式中分别匹配一个且仅匹配一个字符和零个或多个字符。</td></tr><tr><td><code>server.tomcat.background-processor-delay</code></td><td><code>10s</code></td><td>backgroundProcess 方法调用之间的延迟。如果没有指定持续时间后缀，将使用秒。</td></tr><tr><td><code>server.tomcat.basedir</code></td><td></td><td>Tomcat 基础目录。如果没有指定，则使用临时目录。</td></tr><tr><td><code>server.tomcat.connection-timeout</code></td><td></td><td>连接器在接受连接后，等待请求 URI 行呈现的时间。</td></tr><tr><td><code>server.tomcat.max-connections</code></td><td><code>8192.0</code></td><td>服务器在任何时间接受和处理的最大连接数。一旦达到限制，操作系统仍可根据 “acceptCount “属性接受连接。</td></tr><tr><td><code>server.tomcat.max-http-form-post-size</code></td><td><code>2MB</code></td><td>任何 HTTP 帖子请求中表单内容的最大尺寸。</td></tr><tr><td><code>server.tomcat.max-swallow-size</code></td><td><code>2MB</code></td><td>吞下的请求体的最大数量。</td></tr><tr><td><code>server.tomcat.mbeanregistry.enabled</code></td><td><code>false</code></td><td>Tomcat 的 MBean 注册表是否应该被启用。</td></tr><tr><td><code>server.tomcat.processor-cache</code></td><td><code>200.0</code></td><td>缓存中保留的空闲处理器的最大数量，并在后续请求中重复使用。当设置为-1 时，缓存将是无限制的，理论上的最大大小等于最大连接数</td></tr><tr><td><code>server.tomcat.redirect-context-root</code></td><td><code>true</code></td><td>Whether requests to the context root should be redirected by appending a / to the path.</td></tr><tr><td><code>server.tomcat.relaxed-path-chars</code></td><td></td><td>逗号分隔的 URI 路径中允许使用的附加未编码字符列表。只允许使用”&lt; &gt; [ \ ] ^ ` {</td></tr><tr><td><code>server.tomcat.relaxed-query-chars</code></td><td></td><td>逗号分隔的 URI 查询字符串中应该允许的额外的未编码字符列表。只允许使用”&lt; &gt; [ \ ] ^ ` {</td></tr><tr><td><code>server.tomcat.remoteip.host-header</code></td><td><code>X-Forwarded-Host</code></td><td>Name of the HTTP header from which the remote host is extracted.</td></tr><tr><td><code>server.tomcat.remoteip.internal-proxies</code></td><td>`10\.\d{1,3}\.\d{1,3}\.\d{1,3}</td><td>192\.168\.\d{1,3}\.\d{1,3}</td></tr><tr><td><code>server.tomcat.remoteip.port-header</code></td><td><code>X-Forwarded-Port</code></td><td>用于覆盖原始端口值的 HTTP 头的名称。</td></tr><tr><td><code>server.tomcat.remoteip.protocol-header</code></td><td></td><td>保存传入协议的头，通常命名为 “X-Forwarded-Proto”。</td></tr><tr><td><code>server.tomcat.remoteip.protocol-header-https-value</code></td><td><code>https</code></td><td>协议头的值，表示输入的请求是否使用 SSL。</td></tr><tr><td><code>server.tomcat.remoteip.remote-ip-header</code></td><td></td><td>提取远程 IP 的 HTTP 头的名称。例如，<code>X-FORWARDED-FOR</code>。</td></tr><tr><td><code>server.tomcat.resource.allow-caching</code></td><td><code>true</code></td><td>是否允许该 Web 应用程序进行静态资源缓存。</td></tr><tr><td><code>server.tomcat.resource.cache-ttl</code></td><td></td><td>静态资源缓存的有效时间。</td></tr><tr><td><code>server.tomcat.threads.max</code></td><td><code>200.0</code></td><td>工作线程的最大数量。</td></tr><tr><td><code>server.tomcat.threads.min-spare</code></td><td><code>10.0</code></td><td>最小的工作线程数量。</td></tr><tr><td><code>server.tomcat.uri-encoding</code></td><td><code>UTF-8</code></td><td>用来解码 URI 的字符编码。</td></tr><tr><td><code>server.tomcat.use-relative-redirects</code></td><td><code>false</code></td><td>调用 sendRedirect 生成的 HTTP 1.1 及以后版本的位置头是否会使用相对重定向或绝对重定向。</td></tr></tbody></table><h2 id="undertow"><a href="#undertow" class="headerlink" title="undertow"></a>undertow</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>server.undertow.accesslog.dir</code></td><td></td><td>底槽访问日志目录。</td></tr><tr><td><code>server.undertow.accesslog.enabled</code></td><td><code>false</code></td><td>是否启用访问日志。</td></tr><tr><td><code>server.undertow.accesslog.pattern</code></td><td><code>common</code></td><td>访问日志的格式模式。</td></tr><tr><td><code>server.undertow.accesslog.prefix</code></td><td><code>access_log.</code></td><td>日志文件名前缀。</td></tr><tr><td><code>server.undertow.accesslog.rotate</code></td><td><code>true</code></td><td>是否启用访问日志轮换。</td></tr><tr><td><code>server.undertow.accesslog.suffix</code></td><td><code>log</code></td><td>日志文件名后缀。</td></tr><tr><td><code>server.undertow.allow-encoded-slash</code></td><td><code>false</code></td><td>服务器是否应该对百分比编码的斜线字符进行解码。由于不同的服务器对斜线的解释不同，启用编码的斜线可能会产生安全影响。只有当您的遗留应用程序需要时才启用此功能。</td></tr><tr><td><code>server.undertow.always-set-keep-alive</code></td><td><code>true</code></td><td>Connection: keep-alive “头是否应该被添加到所有的响应中，即使 HTTP 规范没有要求。</td></tr><tr><td><code>server.undertow.buffer-size</code></td><td></td><td>每个缓冲区的大小。默认值来自于 JVM 可用的最大内存量。</td></tr><tr><td><code>server.undertow.decode-url</code></td><td><code>true</code></td><td>URL 是否应该被解码。当禁用时，URL 中的百分比编码字符将保持原样。</td></tr><tr><td><code>server.undertow.direct-buffers</code></td><td></td><td>是否在 Java 堆外分配缓冲区。默认值来自于 JVM 可用的最大内存量。</td></tr><tr><td><code>server.undertow.eager-filter-init</code></td><td><code>true</code></td><td>是否应该在启动时初始化 servlet 过滤器。</td></tr><tr><td><code>server.undertow.max-cookies</code></td><td><code>200.0</code></td><td>允许的最大 cookie 数量。这个限制是为了防止基于哈希碰撞的 DOS 攻击。</td></tr><tr><td><code>server.undertow.max-headers</code></td><td></td><td>允许的最大头数。这个限制是为了防止基于哈希碰撞的 DOS 攻击。</td></tr><tr><td><code>server.undertow.max-http-post-size</code></td><td><code>-1B</code></td><td>HTTP 帖子内容的最大尺寸。当值为-1 时，默认，大小不受限制。</td></tr><tr><td><code>server.undertow.max-parameters</code></td><td></td><td>允许查询或路径参数的最大数量。这个限制是为了防止基于哈希碰撞的 DOS 攻击。</td></tr><tr><td><code>server.undertow.no-request-timeout</code></td><td></td><td>在服务器关闭连接之前，一个连接在不处理请求的情况下可以闲置的时间。</td></tr><tr><td><code>server.undertow.options.server.*</code></td><td></td><td></td></tr><tr><td><code>server.undertow.options.socket.*</code></td><td></td><td></td></tr><tr><td><code>server.undertow.threads.io</code></td><td></td><td>要为 Worker 创建的 I/O 线程的数量。默认值由可用处理器的数量决定。</td></tr><tr><td><code>server.undertow.threads.worker</code></td><td></td><td>工作线程的数量。默认为 8 倍的 I/O 线程数。</td></tr><tr><td><code>server.undertow.url-charset</code></td><td><code>UTF-8</code></td><td>用来解码 URL 的 Charset。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板属性</title>
      <link href="/1b9dca731c12.html"/>
      <url>/1b9dca731c12.html</url>
      
        <content type="html"><![CDATA[<h2 id="freemarker"><a href="#freemarker" class="headerlink" title="freemarker"></a>freemarker</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.freemarker.allow-request-override</code></td><td><code>false</code></td><td>是否允许 HttpServletRequest 属性覆盖（隐藏）控制器生成的同名模型属性。</td></tr><tr><td><code>spring.freemarker.allow-session-override</code></td><td><code>false</code></td><td>是否允许 HttpSession 属性覆盖（隐藏）控制器生成的同名模型属性。</td></tr><tr><td><code>spring.freemarker.cache</code></td><td><code>false</code></td><td>是否启用模板缓存。</td></tr><tr><td><code>spring.freemarker.charset</code></td><td><code>UTF-8</code></td><td>模板编码。</td></tr><tr><td><code>spring.freemarker.check-template-location</code></td><td><code>true</code></td><td>是否检查模板位置是否存在。</td></tr><tr><td><code>spring.freemarker.content-type</code></td><td><code>text/html</code></td><td>Content-Type 值。</td></tr><tr><td><code>spring.freemarker.enabled</code></td><td><code>true</code></td><td>是否启用本技术的 MVC 视图解析。</td></tr><tr><td><code>spring.freemarker.expose-request-attributes</code></td><td><code>false</code></td><td>是否应该在与模板合并之前将所有请求属性添加到模型中。</td></tr><tr><td><code>spring.freemarker.expose-session-attributes</code></td><td><code>false</code></td><td>在与模板合并之前，是否应该将所有 HttpSession 属性添加到模型中。</td></tr><tr><td><code>spring.freemarker.expose-spring-macro-helpers</code></td><td><code>true</code></td><td>是否以 “springMacroRequestContext “为名，公开一个 RequestContext 供 Spring 的宏库使用。</td></tr><tr><td><code>spring.freemarker.prefer-file-system-access</code></td><td><code>true</code></td><td>是否选择文件系统访问来加载模板。文件系统访问可以实现模板更改的热检测。</td></tr><tr><td><code>spring.freemarker.prefix</code></td><td></td><td>当建立一个 URL 时，前缀被添加到视图名称中。</td></tr><tr><td><code>spring.freemarker.request-context-attribute</code></td><td></td><td>所有视图的 RequestContext 属性的名称。</td></tr><tr><td><code>spring.freemarker.settings.*</code></td><td></td><td>众所周知的 FreeMarker 键被传递给 FreeMarker 的配置。</td></tr><tr><td><code>spring.freemarker.suffix</code></td><td><code>.ftlh</code></td><td>建立 URL 时附加到视图名称的后缀。</td></tr><tr><td><code>spring.freemarker.template-loader-path</code></td><td><code>[classpath:/templates/]</code></td><td>逗号分隔的模板路径列表。</td></tr><tr><td><code>spring.freemarker.view-names</code></td><td></td><td>查看可以解决的名字。</td></tr></tbody></table><h2 id="groovy"><a href="#groovy" class="headerlink" title="groovy"></a>groovy</h2><table><thead><tr><th><code>spring.groovy.template.allow-request-override</code></th><th><code>false</code></th><th>是否允许 HttpServletRequest 属性覆盖（隐藏）控制器生成的同名模型属性。</th></tr></thead><tbody><tr><td><code>spring.groovy.template.allow-session-override</code></td><td><code>false</code></td><td>是否允许 HttpSession 属性覆盖（隐藏）控制器生成的同名模型属性。</td></tr><tr><td><code>spring.groovy.template.cache</code></td><td><code>false</code></td><td>是否启用模板缓存。</td></tr><tr><td><code>spring.groovy.template.charset</code></td><td><code>UTF-8</code></td><td>模板编码。</td></tr><tr><td><code>spring.groovy.template.check-template-location</code></td><td><code>true</code></td><td>是否检查模板位置是否存在。</td></tr><tr><td><code>spring.groovy.template.configuration.auto-escape</code></td><td><code>spring.groovy.template.configuration.auto-indent</code></td><td>参见 GroovyMarkupConfigurer</td></tr><tr><td><code>spring.groovy.template.content-type</code></td><td><code>text/html</code></td><td>Content-Type 值。</td></tr><tr><td><code>spring.groovy.template.enabled</code></td><td><code>true</code></td><td>是否启用本技术的 MVC 视图解析。</td></tr><tr><td><code>spring.groovy.template.expose-request-attributes</code></td><td><code>false</code></td><td>是否应该在与模板合并之前将所有请求属性添加到模型中。</td></tr><tr><td><code>spring.groovy.template.expose-session-attributes</code></td><td><code>false</code></td><td>在与模板合并之前，是否应该将所有 HttpSession 属性添加到模型中。</td></tr><tr><td><code>spring.groovy.template.expose-spring-macro-helpers</code></td><td><code>true</code></td><td>是否以 “springMacroRequestContext “为名，公开一个 RequestContext 供 Spring 的宏库使用。</td></tr><tr><td><code>spring.groovy.template.prefix</code></td><td></td><td>当建立一个 URL 时，前缀被添加到视图名称中。</td></tr><tr><td><code>spring.groovy.template.request-context-attribute</code></td><td></td><td>所有视图的 RequestContext 属性的名称。</td></tr><tr><td><code>spring.groovy.template.resource-loader-path</code></td><td><code>classpath:/templates/</code></td><td>模板路径。</td></tr><tr><td><code>spring.groovy.template.suffix</code></td><td><code>.tpl</code></td><td>建立 URL 时附加到视图名称的后缀。</td></tr><tr><td><code>spring.groovy.template.view-names</code></td><td></td><td>查看可以解决的名字。</td></tr></tbody></table><h2 id="mustache"><a href="#mustache" class="headerlink" title="mustache"></a>mustache</h2><table><thead><tr><th><code>spring.mustache.allow-request-override</code></th><th><code>false</code></th><th>是否允许 HttpServletRequest 属性覆盖（隐藏）控制器生成的同名模型属性。</th></tr></thead><tbody><tr><td><code>spring.mustache.allow-session-override</code></td><td><code>false</code></td><td>是否允许 HttpSession 属性覆盖（隐藏）控制器生成的同名模型属性。</td></tr><tr><td><code>spring.mustache.cache</code></td><td><code>false</code></td><td>是否启用模板缓存。</td></tr><tr><td><code>spring.mustache.charset</code></td><td><code>UTF-8</code></td><td>模板编码。</td></tr><tr><td><code>spring.mustache.check-template-location</code></td><td><code>true</code></td><td>是否检查模板位置是否存在。</td></tr><tr><td><code>spring.mustache.content-type</code></td><td><code>text/html</code></td><td>Content-Type 值。</td></tr><tr><td><code>spring.mustache.enabled</code></td><td><code>true</code></td><td>是否启用本技术的 MVC 视图解析。</td></tr><tr><td><code>spring.mustache.expose-request-attributes</code></td><td><code>false</code></td><td>是否应该在与模板合并之前将所有请求属性添加到模型中。</td></tr><tr><td><code>spring.mustache.expose-session-attributes</code></td><td><code>false</code></td><td>在与模板合并之前，是否应该将所有 HttpSession 属性添加到模型中。</td></tr><tr><td><code>spring.mustache.expose-spring-macro-helpers</code></td><td><code>true</code></td><td>是否以 “springMacroRequestContext “为名，公开一个 RequestContext 供 Spring 的宏库使用。</td></tr><tr><td><code>spring.mustache.prefix</code></td><td><code>classpath:/templates/</code></td><td>适用于模板名称的前缀。</td></tr><tr><td><code>spring.mustache.request-context-attribute</code></td><td></td><td>所有视图的 RequestContext 属性的名称。</td></tr><tr><td><code>spring.mustache.suffix</code></td><td><code>.mustache</code></td><td>适用于模板名称的后缀。</td></tr><tr><td><code>spring.mustache.view-names</code></td><td></td><td>查看可以解决的名字。</td></tr></tbody></table><h2 id="thymeleaf"><a href="#thymeleaf" class="headerlink" title="thymeleaf"></a>thymeleaf</h2><table><thead><tr><th><code>spring.thymeleaf.cache</code></th><th><code>true</code></th><th>是否启用模板缓存。</th></tr></thead><tbody><tr><td><code>spring.thymeleaf.check-template</code></td><td><code>true</code></td><td>是否在渲染前检查模板是否存在。</td></tr><tr><td><code>spring.thymeleaf.check-template-location</code></td><td><code>true</code></td><td>是否检查模板位置是否存在。</td></tr><tr><td><code>spring.thymeleaf.enable-spring-el-compiler</code></td><td><code>false</code></td><td>在 SpringEL 表达式中启用 SpringEL 编译器。</td></tr><tr><td><code>spring.thymeleaf.enabled</code></td><td><code>true</code></td><td>是否为 Web 框架启用 Thymeleaf 视图解析。</td></tr><tr><td><code>spring.thymeleaf.encoding</code></td><td><code>UTF-8</code></td><td>模板文件编码。</td></tr><tr><td><code>spring.thymeleaf.excluded-view-names</code></td><td></td><td>以逗号分隔的应排除在决议之外的视图名称列表（允许的模式）。</td></tr><tr><td><code>spring.thymeleaf.mode</code></td><td><code>HTML</code></td><td>应用于模板的模板模式。参见 Thymeleaf 的 TemplateMode 枚举。</td></tr><tr><td><code>spring.thymeleaf.prefix</code></td><td><code>classpath:/templates/</code></td><td>当建立一个 URL 时，前缀被添加到视图名称中。</td></tr><tr><td><code>spring.thymeleaf.reactive.chunked-mode-view-names</code></td><td></td><td>以逗号分隔的视图名称列表（允许的模式），当设置最大分块大小时，这些视图名称应该是在 CHUNKED 模式下唯一被执行的。</td></tr><tr><td><code>spring.thymeleaf.reactive.full-mode-view-names</code></td><td></td><td>以逗号分隔的视图名称列表（允许的模式），即使设置了最大分块大小，也应该在 FULL 模式下执行。</td></tr><tr><td><code>spring.thymeleaf.reactive.max-chunk-size</code></td><td><code>0B</code></td><td>用于写入响应的数据缓冲区的最大大小。如果设置了这个，模板将默认以 CHUNKED 模式执行。</td></tr><tr><td><code>spring.thymeleaf.reactive.media-types</code></td><td></td><td>视图技术支持的媒体类型。</td></tr><tr><td><code>spring.thymeleaf.render-hidden-markers-before-checkboxes</code></td><td><code>false</code></td><td>作为复选框标记的隐藏表单输入是否应该在复选框元素之前呈现。</td></tr><tr><td><code>spring.thymeleaf.servlet.content-type</code></td><td><code>text/html</code></td><td>写到 HTTP 响应的 Content-Type 值。</td></tr><tr><td><code>spring.thymeleaf.servlet.produce-partial-output-while-processing</code></td><td><code>true</code></td><td>Thymeleaf 是应该尽快开始写入部分输出，还是缓冲到模板处理完成。</td></tr><tr><td><code>spring.thymeleaf.suffix</code></td><td><code>.html</code></td><td>建立 URL 时附加到视图名称的后缀。</td></tr><tr><td><code>spring.thymeleaf.template-resolver-order</code></td><td></td><td>模板解析器在链中的顺序。默认情况下，模板解析器是链中的第一个。顺序从 1 开始，只有当你定义了额外的 “TemplateResolver “Bean 时才能设置。</td></tr><tr><td><code>spring.thymeleaf.view-names</code></td><td></td><td>以逗号分隔的可解析的视图名称列表（允许模式）。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络属性</title>
      <link href="/e877f7d30bd2.html"/>
      <url>/e877f7d30bd2.html</url>
      
        <content type="html"><![CDATA[<h2 id="hateoas"><a href="#hateoas" class="headerlink" title="hateoas"></a>hateoas</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.hateoas.use-hal-as-default-json-media-type</code></td><td><code>true</code></td><td>是否应该向接受申请/json 的请求发送申请/hal+json 响应。</td></tr></tbody></table><h2 id="jersey"><a href="#jersey" class="headerlink" title="jersey"></a>jersey</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.jersey.application-path</code></td><td></td><td>作为应用程序的基本 URI 的路径，如果指定，则覆盖”@ApplicationPath “的值。如果指定，则覆盖”@ApplicationPath “的值。</td></tr><tr><td><code>spring.jersey.filter.order</code></td><td><code>0.0</code></td><td>泽西滤链顺序。</td></tr><tr><td><code>spring.jersey.init.*</code></td><td></td><td>通过 servlet 或过滤器传递给 Jersey 的初始参数。</td></tr><tr><td><code>spring.jersey.servlet.load-on-startup</code></td><td><code>-1.0</code></td><td>加载在 Jersey servlet 的启动优先级上。</td></tr><tr><td><code>spring.jersey.type</code></td><td><code>servlet</code></td><td>泽西岛一体化类型。</td></tr></tbody></table><h2 id="mvc"><a href="#mvc" class="headerlink" title="mvc"></a>mvc</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.mvc.dispatch-options-request</code></td><td><code>true</code></td><td>是否向 FrameworkServlet doService 方法派遣 OPTIONS 请求。</td></tr><tr><td><code>spring.mvc.dispatch-trace-request</code></td><td><code>false</code></td><td>是否向 FrameworkServlet doService 方法发送 TRACE 请求。</td></tr><tr><td><code>spring.mvc.ignore-default-model-on-redirect</code></td><td><code>true</code></td><td>在重定向场景中是否应该忽略 “默认 “模型的内容。</td></tr><tr><td><code>spring.mvc.locale</code></td><td></td><td>要使用的语言环境。默认情况下，这个 locale 会被 “Accept-Language “头覆盖。</td></tr><tr><td><code>spring.mvc.locale-resolver</code></td><td><code>accept-header</code></td><td>定义如何解决定位问题。</td></tr><tr><td><code>spring.mvc.log-request-details</code></td><td><code>false</code></td><td>是否允许在 DEBUG 和 TRACE 级别记录（潜在的敏感）请求细节。</td></tr><tr><td><code>spring.mvc.log-resolved-exception</code></td><td><code>false</code></td><td>除 “DefaultHandlerExceptionResolver “外，是否启用 “HandlerExceptionResolver “解决的异常的警告记录。</td></tr><tr><td><code>spring.mvc.message-codes-resolver-format</code></td><td></td><td>信息代码的格式化策略。例如，`PREFIX_ERROR_CODE’。</td></tr><tr><td><code>spring.mvc.publish-request-handled-events</code></td><td><code>true</code></td><td>是否在每个请求结束时发布一个 ServletRequestHandledEvent。</td></tr><tr><td><code>spring.mvc.servlet.load-on-startup</code></td><td><code>-1.0</code></td><td>在调度器 servlet 的启动优先级上加载。</td></tr><tr><td><code>spring.mvc.servlet.path</code></td><td><code>/</code></td><td>调度器 servlet 的路径。</td></tr><tr><td><code>spring.mvc.static-path-pattern</code></td><td><code>/**</code></td><td>用于静态资源的路径模式。</td></tr><tr><td><code>spring.mvc.throw-exception-if-no-handler-found</code></td><td><code>false</code></td><td>如果没有找到处理程序来处理请求，是否应该抛出 “NoHandlerFoundException”。</td></tr><tr><td><code>spring.mvc.view.prefix</code></td><td></td><td>Spring MVC 视图前缀。</td></tr><tr><td><code>spring.mvc.view.suffix</code></td><td></td><td>Spring MVC 视图后缀。</td></tr></tbody></table><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.mvc.async.request-timeout</code></td><td></td><td>异步请求处理超时前的时间量。如果没有设置这个值，则使用底层实现的默认超时。</td></tr></tbody></table><h3 id="contentengotiation"><a href="#contentengotiation" class="headerlink" title="contentengotiation"></a>contentengotiation</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.mvc.contentnegotiation.favor-parameter</code></td><td><code>false</code></td><td>是否应该使用请求参数（默认为 “格式”）来确定请求的媒体类型。</td></tr><tr><td><code>spring.mvc.contentnegotiation.media-types.*</code></td><td></td><td>将文件扩展名映射到媒体类型，以便进行内容协商。例如，将 yml 映射为 text/yaml。</td></tr><tr><td><code>spring.mvc.contentnegotiation.parameter-name</code></td><td></td><td>启用 “favor-parameter “时要使用的查询参数名称。</td></tr></tbody></table><h3 id="converters"><a href="#converters" class="headerlink" title="converters"></a>converters</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.mvc.converters.preferred-json-mapper</code></td><td></td><td>首选用于 HTTP 消息转换的 JSON 映射器。默认情况下，根据环境自动检测。</td></tr></tbody></table><h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.mvc.format.date</code></td><td></td><td>要使用的日期格式，例如<code>dd/MM/yyyy</code>。</td></tr><tr><td><code>spring.mvc.format.date-time</code></td><td></td><td>要使用的日期-时间格式，例如<code>yyyy-MM-dd HH:mm:ss</code>。</td></tr><tr><td><code>spring.mvc.format.time</code></td><td></td><td>要使用的时间格式，例如 <code>HH:mm:ss</code>。</td></tr></tbody></table><h3 id="formcontent"><a href="#formcontent" class="headerlink" title="formcontent"></a>formcontent</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.mvc.formcontent.filter.enabled</code></td><td><code>true</code></td><td>是否启用 Spring 的 FormContentFilter。</td></tr></tbody></table><h3 id="hiddenmethod"><a href="#hiddenmethod" class="headerlink" title="hiddenmethod"></a>hiddenmethod</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.mvc.hiddenmethod.filter.enabled</code></td><td><code>false</code></td><td>是否启用 Spring 的 HiddenHttpMethodFilter。</td></tr></tbody></table><h2 id="resources"><a href="#resources" class="headerlink" title="resources"></a>resources</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.resources.add-mappings</code></td><td><code>true</code></td><td>是否启用默认资源处理。</td></tr><tr><td><code>spring.resources.static-locations</code></td><td><code>[classpath:/META-INF/resources/, classpath:/resources/, classpath:/static/, classpath:/public/]</code></td><td>静态资源的位置。默认为 classpath：[/META-INF/resources/, /resources/, /static/, /public/]。</td></tr></tbody></table><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.resources.cache.cachecontrol.cache-private</code></td><td></td><td>表示响应消息是为单个用户准备的，不得由共享缓存存储。</td></tr><tr><td><code>spring.resources.cache.cachecontrol.cache-public</code></td><td></td><td>表示任何缓存可以存储响应。</td></tr><tr><td><code>spring.resources.cache.cachecontrol.max-age</code></td><td></td><td>响应应该被缓存的最长时间，如果没有指定持续时间后缀，以秒为单位。</td></tr><tr><td><code>spring.resources.cache.cachecontrol.must-revalidate</code></td><td></td><td>表示一旦变质，在没有与服务器重新验证的情况下，缓存不得使用响应。</td></tr><tr><td><code>spring.resources.cache.cachecontrol.no-cache</code></td><td></td><td>表示缓存的响应只有在与服务器重新验证的情况下才能被重新使用。</td></tr><tr><td><code>spring.resources.cache.cachecontrol.no-store</code></td><td></td><td>表示在任何情况下都不要缓存响应。</td></tr><tr><td><code>spring.resources.cache.cachecontrol.no-transform</code></td><td></td><td>示意中间人（缓存和其他）不要转换响应内容。</td></tr><tr><td><code>spring.resources.cache.cachecontrol.proxy-revalidate</code></td><td></td><td>与 “must-revalidate “指令含义相同，只是它不适用于私有缓存。</td></tr><tr><td><code>spring.resources.cache.cachecontrol.s-max-age</code></td><td></td><td>如果没有指定持续时间后缀，响应应该被共享缓存的最大时间，单位是秒。</td></tr><tr><td><code>spring.resources.cache.cachecontrol.stale-if-error</code></td><td></td><td>遇到错误时，响应可以使用的最长时间，如果没有指定持续时间后缀，则以秒为单位。</td></tr><tr><td><code>spring.resources.cache.cachecontrol.stale-while-revalidate</code></td><td></td><td>如果没有指定持续时间后缀，则响应在变质后可以提供的最长时间，单位为秒。</td></tr><tr><td><code>spring.resources.cache.period</code></td><td></td><td>资源处理程序所服务的资源的缓存周期。如果没有指定持续时间后缀，则使用秒。可以被’spring.resources.cache.cachecontrol’属性重写。</td></tr><tr><td><code>spring.resources.chain.cache</code></td><td><code>true</code></td><td>是否启用资源链中的缓存。</td></tr><tr><td><code>spring.resources.chain.compressed</code></td><td><code>false</code></td><td>是否启用已压缩资源的解析(gzip, brotli)。检查资源名是否为’.gz’或’.br’文件扩展名。</td></tr><tr><td><code>spring.resources.chain.enabled</code></td><td></td><td>是否启用 Spring 资源处理链。默认情况下，禁用，除非至少有一个策略被启用。</td></tr><tr><td><code>spring.resources.chain.html-application-cache</code></td><td><code>false</code></td><td>是否启用 HTML5 应用缓存清单重写。</td></tr><tr><td><code>spring.resources.chain.strategy.content.enabled</code></td><td><code>false</code></td><td>是否启用内容版本策略。</td></tr><tr><td><code>spring.resources.chain.strategy.content.paths</code></td><td><code>[/**]</code></td><td>逗号分隔的模式列表，适用于内容版本策略。</td></tr><tr><td><code>spring.resources.chain.strategy.fixed.enabled</code></td><td><code>false</code></td><td>是否启用固定版本策略。</td></tr><tr><td><code>spring.resources.chain.strategy.fixed.paths</code></td><td><code>[/**]</code></td><td>逗号分隔的模式列表，适用于固定版本策略。</td></tr><tr><td><code>spring.resources.chain.strategy.fixed.version</code></td><td></td><td>用于固定版本策略的版本字符串。</td></tr></tbody></table><h2 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.servlet.multipart.enabled</code></td><td><code>true</code></td><td>是否启用支持多部分上传。</td></tr><tr><td><code>spring.servlet.multipart.file-size-threshold</code></td><td><code>0B</code></td><td>文件写入磁盘的阈值。</td></tr><tr><td><code>spring.servlet.multipart.location</code></td><td></td><td>上传文件的中间位置。</td></tr><tr><td><code>spring.servlet.multipart.max-file-size</code></td><td><code>1MB</code></td><td>最大文件大小。</td></tr><tr><td><code>spring.servlet.multipart.max-request-size</code></td><td><code>10MB</code></td><td>最大请求量。</td></tr><tr><td><code>spring.servlet.multipart.resolve-lazily</code></td><td><code>false</code></td><td>在文件或参数访问时，是否对多部分请求进行懒惰解析。</td></tr></tbody></table><h2 id="webflux"><a href="#webflux" class="headerlink" title="webflux"></a>webflux</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.webflux.base-path</code></td><td></td><td>所有网络处理程序的基本路径。</td></tr><tr><td><code>spring.webflux.format.date</code></td><td></td><td>要使用的日期格式，例如<code>dd/MM/yyyy</code>。</td></tr><tr><td><code>spring.webflux.format.date-time</code></td><td></td><td>要使用的日期-时间格式，例如<code>yyyy-MM-dd HH:mm:ss</code>。</td></tr><tr><td><code>spring.webflux.format.time</code></td><td></td><td>要使用的时间格式，例如 <code>HH:mm:ss</code>。</td></tr><tr><td><code>spring.webflux.hiddenmethod.filter.enabled</code></td><td><code>false</code></td><td>是否启用 Spring 的 HiddenHttpMethodFilter。</td></tr><tr><td><code>spring.webflux.static-path-pattern</code></td><td><code>/**</code></td><td>用于静态资源的路径模式。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集成属性</title>
      <link href="/b69418481828.html"/>
      <url>/b69418481828.html</url>
      
        <content type="html"><![CDATA[<h2 id="activemq"><a href="#activemq" class="headerlink" title="activemq"></a>activemq</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.activemq.broker-url</code></td><td></td><td>ActiveMQ broker 的 URL。默认情况下自动生成。</td></tr><tr><td><code>spring.activemq.close-timeout</code></td><td><code>15s</code></td><td>等到时间到了再考虑接近完整。</td></tr><tr><td><code>spring.activemq.in-memory</code></td><td><code>true</code></td><td>默认的 broker URL 是否应该在内存中。如果已经指定了显式经纪商，则忽略。</td></tr><tr><td><code>spring.activemq.non-blocking-redelivery</code></td><td><code>false</code></td><td>是否在从回滚的事务中重新传送消息之前停止消息传送。这意味着当启用该功能时，消息顺序不会被保留。</td></tr><tr><td><code>spring.activemq.packages.trust-all</code></td><td></td><td>是否信任所有的包。</td></tr><tr><td><code>spring.activemq.packages.trusted</code></td><td></td><td>以逗号分隔的特定软件包信任列表（当不信任所有软件包时）。</td></tr><tr><td><code>spring.activemq.password</code></td><td></td><td>经纪人的登录密码。</td></tr><tr><td><code>spring.activemq.pool.block-if-full</code></td><td><code>true</code></td><td>当请求连接且池已满时，是否要阻止。设置为 false，则会抛出一个 “JMSException”。</td></tr><tr><td><code>spring.activemq.pool.block-if-full-timeout</code></td><td><code>-1ms</code></td><td>如果池子仍然满了，在抛出异常之前的阻塞期。</td></tr><tr><td><code>spring.activemq.pool.enabled</code></td><td><code>false</code></td><td>是否应该创建一个 JmsPoolConnectionFactory，而不是一个普通的 ConnectionFactory。</td></tr><tr><td><code>spring.activemq.pool.idle-timeout</code></td><td><code>30s</code></td><td>连接闲置超时。</td></tr><tr><td><code>spring.activemq.pool.max-connections</code></td><td><code>1.0</code></td><td>集合连接的最大数量。</td></tr><tr><td><code>spring.activemq.pool.max-sessions-per-connection</code></td><td><code>500.0</code></td><td>池中每个连接的最大集合会话数。</td></tr><tr><td><code>spring.activemq.pool.time-between-expiration-check</code></td><td><code>-1ms</code></td><td>空闲连接驱逐线程运行之间的睡眠时间。为负值时，不运行空闲连接驱逐线程。</td></tr><tr><td><code>spring.activemq.pool.use-anonymous-producers</code></td><td><code>true</code></td><td>是否只使用一个匿名的 “MessageProducer “实例。设置为 false，每次需要创建一个 “MessageProducer “时，就会创建一个。</td></tr><tr><td><code>spring.activemq.send-timeout</code></td><td><code>0ms</code></td><td>消息发送后等待响应的时间。设置为 0 则永远等待。</td></tr><tr><td><code>spring.activemq.user</code></td><td></td><td>经纪人的登录用户。</td></tr></tbody></table><h2 id="artemis"><a href="#artemis" class="headerlink" title="artemis"></a>artemis</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.artemis.embedded.cluster-password</code></td><td></td><td>群集密码。默认情况下，在启动时随机生成。</td></tr><tr><td><code>spring.artemis.embedded.data-directory</code></td><td></td><td>日志文件目录。如果关闭了持久性，则不需要。</td></tr><tr><td><code>spring.artemis.embedded.enabled</code></td><td><code>true</code></td><td>如果 Artemis 服务器 API 可用，是否启用嵌入式模式。</td></tr><tr><td><code>spring.artemis.embedded.persistent</code></td><td><code>false</code></td><td>是否启用持久化存储。</td></tr><tr><td><code>spring.artemis.embedded.queues</code></td><td><code>[]</code></td><td>以逗号分隔的队列列表，以便在启动时创建。</td></tr><tr><td><code>spring.artemis.embedded.server-id</code></td><td><code>0.0</code></td><td>服务器 ID。默认情况下，使用自动递增的计数器</td></tr><tr><td><code>spring.artemis.embedded.topics</code></td><td><code>[]</code></td><td>逗号分隔的主题列表，在启动时创建。</td></tr><tr><td><code>spring.artemis.host</code></td><td><code>localhost</code></td><td>阿特米斯经纪公司主机。</td></tr><tr><td><code>spring.artemis.mode</code></td><td></td><td>Artemis 部署模式，默认为自动检测。</td></tr><tr><td><code>spring.artemis.password</code></td><td></td><td>经纪人的登录密码。</td></tr><tr><td><code>spring.artemis.pool.block-if-full</code></td><td><code>true</code></td><td>当请求连接且池已满时，是否要阻止。设置为 false，则会抛出一个 “JMSException”。</td></tr><tr><td><code>spring.artemis.pool.block-if-full-timeout</code></td><td><code>-1ms</code></td><td>如果池子仍然满了，在抛出异常之前的阻塞期。</td></tr><tr><td><code>spring.artemis.pool.enabled</code></td><td><code>false</code></td><td>是否应该创建一个 JmsPoolConnectionFactory，而不是一个普通的 ConnectionFactory。</td></tr><tr><td><code>spring.artemis.pool.idle-timeout</code></td><td><code>30s</code></td><td>连接闲置超时。</td></tr><tr><td><code>spring.artemis.pool.max-connections</code></td><td><code>1.0</code></td><td>集合连接的最大数量。</td></tr><tr><td><code>spring.artemis.pool.max-sessions-per-connection</code></td><td><code>500.0</code></td><td>池中每个连接的最大集合会话数。</td></tr><tr><td><code>spring.artemis.pool.time-between-expiration-check</code></td><td><code>-1ms</code></td><td>空闲连接驱逐线程运行之间的睡眠时间。为负值时，不运行空闲连接驱逐线程。</td></tr><tr><td><code>spring.artemis.pool.use-anonymous-producers</code></td><td><code>true</code></td><td>是否只使用一个匿名的 “MessageProducer “实例。设置为 false，每次需要创建一个 “MessageProducer “时，就会创建一个。</td></tr><tr><td><code>spring.artemis.port</code></td><td><code>61616.0</code></td><td>Artemis 经纪端口。</td></tr><tr><td><code>spring.artemis.user</code></td><td></td><td>经纪人的登录用户。</td></tr></tbody></table><h2 id="bacth"><a href="#bacth" class="headerlink" title="bacth"></a>bacth</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.batch.initialize-schema</code></td><td><code>embedded</code></td><td>数据库模式初始化模式。</td></tr><tr><td><code>spring.batch.job.enabled</code></td><td><code>true</code></td><td>启动时在上下文中执行所有 Spring Batch 作业。</td></tr><tr><td><code>spring.batch.job.names</code></td><td></td><td>要在启动时执行的以逗号分隔的工作名称列表（例如，<code>job1,job2</code>）。默认情况下，所有在上下文中找到的工作都会被执行。</td></tr><tr><td><code>spring.batch.schema</code></td><td><code>classpath:org/springframework/batch/core/schema-@@platform@@.sql</code></td><td>用于初始化数据库模式的 SQL 文件的路径。</td></tr><tr><td><code>spring.batch.table-prefix</code></td><td></td><td>所有批次元数据表的表前缀。</td></tr></tbody></table><h2 id="hazelcast"><a href="#hazelcast" class="headerlink" title="hazelcast"></a>hazelcast</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.hazelcast.config</code></td><td></td><td>用于初始化 Hazelcast 的配置文件的位置。</td></tr></tbody></table><h2 id="integration"><a href="#integration" class="headerlink" title="integration"></a>integration</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.integration.jdbc.initialize-schema</code></td><td><code>embedded</code></td><td>数据库模式初始化模式。</td></tr><tr><td><code>spring.integration.jdbc.schema</code></td><td><code>classpath:org/springframework/integration/jdbc/schema-@@platform@@.sql</code></td><td>用于初始化数据库模式的 SQL 文件的路径。</td></tr><tr><td><code>spring.integration.rsocket.client.host</code></td><td></td><td>要连接到的 TCP RSocket 服务器主机。</td></tr><tr><td><code>spring.integration.rsocket.client.port</code></td><td></td><td>要连接的 TCP RSocket 服务器端口。</td></tr><tr><td><code>spring.integration.rsocket.client.uri</code></td><td></td><td>要连接到的 WebSocket RSocket 服务器 uri。</td></tr><tr><td><code>spring.integration.rsocket.server.message-mapping-enabled</code></td><td><code>false</code></td><td>是否通过 Spring 集成处理 RSocket 的消息映射。</td></tr></tbody></table><h2 id="jms"><a href="#jms" class="headerlink" title="jms"></a>jms</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.jms.cache.consumers</code></td><td><code>false</code></td><td>是否缓存消息消费者。</td></tr><tr><td><code>spring.jms.cache.enabled</code></td><td><code>true</code></td><td>是否要缓存会话。</td></tr><tr><td><code>spring.jms.cache.producers</code></td><td><code>true</code></td><td>是否缓存消息生产者。</td></tr><tr><td><code>spring.jms.cache.session-cache-size</code></td><td><code>1.0</code></td><td>会话缓存的大小（每个 JMS 会话类型）。</td></tr><tr><td><code>spring.jms.jndi-name</code></td><td></td><td>连接工厂 JNDI 名称。设置后，优先于其他连接工厂的自动配置。</td></tr><tr><td><code>spring.jms.listener.acknowledge-mode</code></td><td></td><td>容器的确认模式。默认情况下，监听器是以自动确认的方式进行交易的。</td></tr><tr><td><code>spring.jms.listener.auto-startup</code></td><td><code>true</code></td><td>启动时自动启动容器。</td></tr><tr><td><code>spring.jms.listener.concurrency</code></td><td></td><td>同时消费的最低人数；</td></tr><tr><td><code>spring.jms.listener.max-concurrency</code></td><td></td><td>最大并发消费者数量。</td></tr><tr><td><code>spring.jms.listener.receive-timeout</code></td><td><code>1s</code></td><td>接收电话的超时时间，使用-1 表示无等待接收，0 表示无超时。使用-1 表示无等待接收，使用 0 表示完全没有超时。后者只有在不在事务管理器中运行的情况下才可行，而且一般不鼓励使用，因为它可以防止干净的关机。</td></tr><tr><td><code>spring.jms.pub-sub-domain</code></td><td><code>false</code></td><td>默认的目标类型是否为主题。</td></tr><tr><td><code>spring.jms.template.default-destination</code></td><td></td><td>在没有目的地参数的发送和接收操作中使用的默认目的地。</td></tr><tr><td><code>spring.jms.template.delivery-delay</code></td><td></td><td>送货延迟用于发送电话。</td></tr><tr><td><code>spring.jms.template.delivery-mode</code></td><td></td><td>交付模式。设置后启用 QoS（服务质量）。</td></tr><tr><td><code>spring.jms.template.priority</code></td><td></td><td>发送消息时的优先级。设置后启用 QoS（服务质量）。</td></tr><tr><td><code>spring.jms.template.qos-enabled</code></td><td></td><td>发送消息时是否启用显式 QoS（服务质量）。启用后，发送消息时将使用发送模式、优先级和存活时间属性。当至少有一项设置被自定义时，QoS 将自动启用。</td></tr><tr><td><code>spring.jms.template.receive-timeout</code></td><td></td><td>接听电话时使用的超时。</td></tr><tr><td><code>spring.jms.template.time-to-live</code></td><td></td><td>发送时信息的生存时间。设置时启用 QoS（服务质量）。</td></tr></tbody></table><h2 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.kafka.bootstrap-servers</code></td><td></td><td>用逗号分隔的主机：端口对列表，用于建立到 Kafka 集群的初始连接。除非被覆盖，否则适用于所有组件。</td></tr><tr><td><code>spring.kafka.client-id</code></td><td></td><td>发出请求时传递给服务器的 ID。用于服务器端的日志记录。</td></tr></tbody></table><h3 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.kafka.admin.client-id</code></td><td></td><td>发出请求时传递给服务器的 ID。用于服务器端的日志记录。</td></tr><tr><td><code>spring.kafka.admin.fail-fast</code></td><td><code>false</code></td><td>如果在启动时没有经纪人，是否要快速失败。</td></tr><tr><td><code>spring.kafka.admin.properties.*</code></td><td></td><td>用于配置客户端的其他管理员专用属性。</td></tr><tr><td><code>spring.kafka.admin.security.protocol</code></td><td></td><td>用于与经纪人通信的安全协议。</td></tr><tr><td><code>spring.kafka.admin.ssl.key-password</code></td><td></td><td>钥匙存储文件中私钥的密码。</td></tr><tr><td><code>spring.kafka.admin.ssl.key-store-location</code></td><td></td><td>钥匙存储文件的位置。</td></tr><tr><td><code>spring.kafka.admin.ssl.key-store-password</code></td><td></td><td>存储密钥存储文件的密码。</td></tr><tr><td><code>spring.kafka.admin.ssl.key-store-type</code></td><td></td><td>钥匙库的类型。</td></tr><tr><td><code>spring.kafka.admin.ssl.protocol</code></td><td></td><td>要使用的 SSL 协议。</td></tr><tr><td><code>spring.kafka.admin.ssl.trust-store-location</code></td><td></td><td>信任存储文件的位置。</td></tr><tr><td><code>spring.kafka.admin.ssl.trust-store-password</code></td><td></td><td>为信任存储文件存储密码。</td></tr><tr><td><code>spring.kafka.admin.ssl.trust-store-type</code></td><td></td><td>信托商店的类型。</td></tr></tbody></table><h3 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.kafka.consumer.auto-commit-interval</code></td><td></td><td>如果’enable.auto.commit’设置为 true，则消费者偏移量自动提交到 Kafka 的频率。</td></tr><tr><td><code>spring.kafka.consumer.auto-offset-reset</code></td><td></td><td>当 Kafka 中没有初始偏移量或者当前偏移量在服务器上已经不存在时，该怎么办。</td></tr><tr><td><code>spring.kafka.consumer.bootstrap-servers</code></td><td></td><td>用逗号分隔的主机:端口对列表，用于建立到 Kafka 集群的初始连接。对消费者而言，覆盖全局属性。</td></tr><tr><td><code>spring.kafka.consumer.client-id</code></td><td></td><td>出请求时传递给服务器的 ID。用于服务器端的日志记录。</td></tr><tr><td><code>spring.kafka.consumer.enable-auto-commit</code></td><td></td><td>消费者的抵偿是否定期在后台承诺。</td></tr><tr><td><code>spring.kafka.consumer.fetch-max-wait</code></td><td></td><td>如果没有足够的数据立即满足 “fetch-min-size “给出的要求，服务器在回应 fetch 请求前的最大阻塞时间。</td></tr><tr><td><code>spring.kafka.consumer.fetch-min-size</code></td><td></td><td>服务器为一个获取请求应返回的最小数据量。</td></tr><tr><td><code>spring.kafka.consumer.group-id</code></td><td></td><td>标识该消费者所属消费群体的唯一字符串。</td></tr><tr><td><code>spring.kafka.consumer.heartbeat-interval</code></td><td></td><td>消费者协调员的预期心跳间隔时间。</td></tr><tr><td><code>spring.kafka.consumer.isolation-level</code></td><td></td><td>读取以事务方式写入的消息的隔离级别。</td></tr><tr><td><code>spring.kafka.consumer.key-deserializer</code></td><td></td><td>密钥的解串器类。</td></tr><tr><td><code>spring.kafka.consumer.max-poll-records</code></td><td></td><td>单次调用 poll()时返回的最大记录数。</td></tr><tr><td><code>spring.kafka.consumer.properties.*</code></td><td></td><td>用于配置客户端的其他消费者特定属性。</td></tr><tr><td><code>spring.kafka.consumer.security.protocol</code></td><td></td><td>用于与经纪人通信的安全协议。</td></tr><tr><td><code>spring.kafka.consumer.ssl.key-password</code></td><td></td><td>钥匙存储文件中私钥的密码。</td></tr><tr><td><code>spring.kafka.consumer.ssl.key-store-location</code></td><td></td><td>钥匙存储文件的位置。</td></tr><tr><td><code>spring.kafka.consumer.ssl.key-store-password</code></td><td></td><td>存储密钥存储文件的密码。</td></tr><tr><td><code>spring.kafka.consumer.ssl.key-store-type</code></td><td></td><td>钥匙库的类型。</td></tr><tr><td><code>spring.kafka.consumer.ssl.protocol</code></td><td></td><td>要使用的 SSL 协议。</td></tr><tr><td><code>spring.kafka.consumer.ssl.trust-store-location</code></td><td></td><td>信任存储文件的位置。</td></tr><tr><td><code>spring.kafka.consumer.ssl.trust-store-password</code></td><td></td><td>为信任存储文件存储密码。</td></tr><tr><td><code>spring.kafka.consumer.ssl.trust-store-type</code></td><td></td><td>信托商店的类型。</td></tr><tr><td><code>spring.kafka.consumer.value-deserializer</code></td><td></td><td>值的解串器类。</td></tr></tbody></table><h3 id="jaas"><a href="#jaas" class="headerlink" title="jaas"></a>jaas</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.kafka.jaas.control-flag</code></td><td><code>required</code></td><td>登录配置的控制标志。</td></tr><tr><td><code>spring.kafka.jaas.enabled</code></td><td><code>false</code></td><td>是否启用 JAAS 配置。</td></tr><tr><td><code>spring.kafka.jaas.login-module</code></td><td><code>com.sun.security.auth.module.Krb5LoginModule</code></td><td>登录模块。</td></tr><tr><td><code>spring.kafka.jaas.options.*</code></td><td></td><td>额外的 JAAS 选项。</td></tr></tbody></table><h3 id="listener"><a href="#listener" class="headerlink" title="listener"></a>listener</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.kafka.listener.ack-count</code></td><td></td><td>ackMode 为 “COUNT “或 “COUNT_TIME “时，偏移提交之间的记录数。</td></tr><tr><td><code>spring.kafka.listener.ack-mode</code></td><td></td><td>Listener AckMode。参见 spring-kafka 文档。</td></tr><tr><td><code>spring.kafka.listener.ack-time</code></td><td></td><td>当 ackMode 为 “TIME “或 “COUNT_TIME “时，偏移提交之间的时间。</td></tr><tr><td><code>spring.kafka.listener.client-id</code></td><td></td><td>监听器的消费者 client.id 属性的前缀。</td></tr><tr><td><code>spring.kafka.listener.concurrency</code></td><td></td><td>在监听器容器中运行的线程数。</td></tr><tr><td><code>spring.kafka.listener.idle-event-interval</code></td><td></td><td>发布闲置消费者事件之间的时间（没有收到数据）。</td></tr><tr><td><code>spring.kafka.listener.log-container-config</code></td><td></td><td>是否在初始化期间记录容器配置（INFO 级别）。</td></tr><tr><td><code>spring.kafka.listener.missing-topics-fatal</code></td><td><code>false</code></td><td>如果至少一个配置的主题不存在于 broker 上，容器是否应该无法启动。</td></tr><tr><td><code>spring.kafka.listener.monitor-interval</code></td><td></td><td>对无反应的消费者进行检查的间隔时间。如果没有指定持续时间后缀，将使用秒。</td></tr><tr><td><code>spring.kafka.listener.no-poll-threshold</code></td><td></td><td>应用于 “pollTimeout “的乘数，以确定消费者是否不响应。</td></tr><tr><td><code>spring.kafka.listener.poll-timeout</code></td><td></td><td>对消费者进行投票时使用的超时。</td></tr><tr><td><code>spring.kafka.listener.type</code></td><td><code>single</code></td><td>倾听者类型。</td></tr></tbody></table><h3 id="producer"><a href="#producer" class="headerlink" title="producer"></a>producer</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.kafka.producer.acks</code></td><td></td><td>生产者要求领导在认为请求完成之前收到的确认数量。</td></tr><tr><td><code>spring.kafka.producer.batch-size</code></td><td></td><td>默认批次大小。批量小会使批处理不那么常见，并可能降低吞吐量（批量为零会使批处理完全失效）。</td></tr><tr><td><code>spring.kafka.producer.bootstrap-servers</code></td><td></td><td>用逗号分隔的主机:端口对列表，用于建立到 Kafka 集群的初始连接。覆盖全局属性，用于生产者。</td></tr><tr><td><code>spring.kafka.producer.buffer-memory</code></td><td></td><td>生产者可以用来缓冲等待发送到服务器的记录的总内存大小。</td></tr><tr><td><code>spring.kafka.producer.client-id</code></td><td></td><td>发出请求时传递给服务器的 ID。用于服务器端的日志记录。</td></tr><tr><td><code>spring.kafka.producer.compression-type</code></td><td></td><td>生产者生成的所有数据的压缩类型。</td></tr><tr><td><code>spring.kafka.producer.key-serializer</code></td><td></td><td>键的序列器类。</td></tr><tr><td><code>spring.kafka.producer.properties.*</code></td><td></td><td>用于配置客户端的附加生产者特定属性。</td></tr><tr><td><code>spring.kafka.producer.retries</code></td><td></td><td>当大于零时，启用重试发送失败。</td></tr><tr><td><code>spring.kafka.producer.security.protocol</code></td><td></td><td>用于与经纪人通信的安全协议。</td></tr><tr><td><code>spring.kafka.producer.ssl.key-password</code></td><td></td><td>钥匙存储文件中私钥的密码。</td></tr><tr><td><code>spring.kafka.producer.ssl.key-store-location</code></td><td></td><td>钥匙存储文件的位置。</td></tr><tr><td><code>spring.kafka.producer.ssl.key-store-password</code></td><td></td><td>存储密钥存储文件的密码。</td></tr><tr><td><code>spring.kafka.producer.ssl.key-store-type</code></td><td></td><td>钥匙库的类型。</td></tr><tr><td><code>spring.kafka.producer.ssl.protocol</code></td><td></td><td>要使用的 SSL 协议。</td></tr><tr><td><code>spring.kafka.producer.ssl.trust-store-location</code></td><td></td><td>信任存储文件的位置。</td></tr><tr><td><code>spring.kafka.producer.ssl.trust-store-password</code></td><td></td><td>为信任存储文件存储密码。</td></tr><tr><td><code>spring.kafka.producer.ssl.trust-store-type</code></td><td></td><td>信托商店的类型。</td></tr><tr><td><code>spring.kafka.producer.transaction-id-prefix</code></td><td></td><td>当非空时，启用对生产者的交易支持。</td></tr><tr><td><code>spring.kafka.producer.value-serializer</code></td><td></td><td>值的序列器类。</td></tr></tbody></table><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.kafka.properties.*</code></td><td></td><td>附加属性，生产者和消费者共有，用于配置客户端。</td></tr></tbody></table><h3 id="security"><a href="#security" class="headerlink" title="security"></a>security</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.kafka.security.protocol</code></td><td></td><td>用于与经纪人通信的安全协议。</td></tr></tbody></table><h3 id="ssl"><a href="#ssl" class="headerlink" title="ssl"></a>ssl</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.kafka.ssl.key-password</code></td><td></td><td>钥匙存储文件中私钥的密码。</td></tr><tr><td><code>spring.kafka.ssl.key-store-location</code></td><td></td><td>钥匙存储文件的位置。</td></tr><tr><td><code>spring.kafka.ssl.key-store-password</code></td><td></td><td>存储密钥存储文件的密码。</td></tr><tr><td><code>spring.kafka.ssl.key-store-type</code></td><td></td><td>钥匙库的类型。</td></tr><tr><td><code>spring.kafka.ssl.protocol</code></td><td></td><td>要使用的 SSL 协议。</td></tr><tr><td><code>spring.kafka.ssl.trust-store-location</code></td><td></td><td>信任存储文件的位置。</td></tr><tr><td><code>spring.kafka.ssl.trust-store-password</code></td><td></td><td>为信任存储文件存储密码。</td></tr><tr><td><code>spring.kafka.ssl.trust-store-type</code></td><td></td><td>信托商店的类型。</td></tr></tbody></table><h3 id="streams"><a href="#streams" class="headerlink" title="streams"></a>streams</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.kafka.streams.application-id</code></td><td></td><td>Kafka 流的 application.id 属性；默认为 spring.application.name。</td></tr><tr><td><code>spring.kafka.streams.auto-startup</code></td><td><code>true</code></td><td>是否自动启动流工厂豆。</td></tr><tr><td><code>spring.kafka.streams.bootstrap-servers</code></td><td></td><td>用逗号分隔的主机:端口对列表，用于建立到 Kafka 集群的初始连接。覆盖全局属性，用于流。</td></tr><tr><td><code>spring.kafka.streams.cache-max-size-buffering</code></td><td></td><td>用于所有线程缓冲的最大内存大小。</td></tr><tr><td><code>spring.kafka.streams.client-id</code></td><td></td><td>发出请求时传递给服务器的 ID。用于服务器端的日志记录。</td></tr><tr><td><code>spring.kafka.streams.properties.*</code></td><td></td><td>用于配置流的其他 Kafka 属性。</td></tr><tr><td><code>spring.kafka.streams.replication-factor</code></td><td></td><td>流处理应用程序创建的变更日志主题和重新分区主题的复制因子。</td></tr><tr><td><code>spring.kafka.streams.security.protocol</code></td><td></td><td>用于与经纪人通信的安全协议。</td></tr><tr><td><code>spring.kafka.streams.ssl.key-password</code></td><td></td><td>钥匙存储文件中私钥的密码。</td></tr><tr><td><code>spring.kafka.streams.ssl.key-store-location</code></td><td></td><td>钥匙存储文件的位置。</td></tr><tr><td><code>spring.kafka.streams.ssl.key-store-password</code></td><td></td><td>存储密钥存储文件的密码。</td></tr><tr><td><code>spring.kafka.streams.ssl.key-store-type</code></td><td></td><td>钥匙库的类型。</td></tr><tr><td><code>spring.kafka.streams.ssl.protocol</code></td><td></td><td>要使用的 SSL 协议。</td></tr><tr><td><code>spring.kafka.streams.ssl.trust-store-location</code></td><td></td><td>信任存储文件的位置。</td></tr><tr><td><code>spring.kafka.streams.ssl.trust-store-password</code></td><td></td><td>为信任存储文件存储密码。</td></tr><tr><td><code>spring.kafka.streams.ssl.trust-store-type</code></td><td></td><td>信托商店的类型。</td></tr><tr><td><code>spring.kafka.streams.state-dir</code></td><td></td><td>州店的目录位置。</td></tr></tbody></table><h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.kafka.template.default-topic</code></td><td></td><td>默认的邮件主题。</td></tr></tbody></table><h2 id="rabbitmq"><a href="#rabbitmq" class="headerlink" title="rabbitmq"></a>rabbitmq</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.rabbitmq.addresses</code></td><td></td><td>以逗号分隔的客户端应连接的地址列表。设置时，忽略主机和端口。</td></tr><tr><td><code>spring.rabbitmq.connection-timeout</code></td><td></td><td>连接超时。将其设置为零，以便永远等待。</td></tr><tr><td><code>spring.rabbitmq.dynamic</code></td><td><code>true</code></td><td>是否创建 AmqpAdmin bean。</td></tr><tr><td><code>spring.rabbitmq.host</code></td><td><code>localhost</code></td><td>RabbitMQ 主机。如果设置了地址，则忽略。</td></tr><tr><td><code>spring.rabbitmq.password</code></td><td><code>guest</code></td><td>登录对经纪人进行认证。</td></tr><tr><td><code>spring.rabbitmq.port</code></td><td></td><td>RabbitMQ 端口。如果设置了地址，则忽略。默认为 5672，如果启用了 SSL，则为 5671。</td></tr><tr><td><code>spring.rabbitmq.publisher-confirm-type</code></td><td></td><td>类型的发布者确认使用。</td></tr><tr><td><code>spring.rabbitmq.publisher-returns</code></td><td><code>false</code></td><td>是否启用发布者退货。</td></tr><tr><td><code>spring.rabbitmq.requested-channel-max</code></td><td><code>2047.0</code></td><td>客户端请求的每个连接的通道数。使用 0 表示无限制。</td></tr><tr><td><code>spring.rabbitmq.requested-heartbeat</code></td><td></td><td>要求的心跳超时；无心跳超时为零。如果没有指定持续时间后缀，将使用秒。</td></tr><tr><td><code>spring.rabbitmq.username</code></td><td><code>guest</code></td><td>登录用户来验证经纪人的身份。</td></tr><tr><td><code>spring.rabbitmq.virtual-host</code></td><td></td><td>连接到经纪人时要使用的虚拟主机。</td></tr></tbody></table><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.rabbitmq.cache.channel.checkout-timeout</code></td><td></td><td>如果缓存大小已经达到，等待获得通道的时间。如果为 0，则总是创建一个新的通道。</td></tr><tr><td><code>spring.rabbitmq.cache.channel.size</code></td><td></td><td>缓存中要保留的通道数，当 “check-timeout”&gt;0 时，每个连接的最大通道数。当 “check-timeout”&gt;0 时，每个连接的最大通道数。</td></tr><tr><td><code>spring.rabbitmq.cache.connection.mode</code></td><td><code>channel</code></td><td>连接工厂缓存模式。</td></tr><tr><td><code>spring.rabbitmq.cache.connection.size</code></td><td></td><td>缓存的连接数。仅适用于模式为 CONNECTION 时。</td></tr></tbody></table><h3 id="listener-1"><a href="#listener-1" class="headerlink" title="listener"></a>listener</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.rabbitmq.listener.direct.acknowledge-mode</code></td><td></td><td>容器的确认模式。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.auto-startup</code></td><td><code>true</code></td><td>是否在启动时自动启动容器。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.consumers-per-queue</code></td><td></td><td>每个队列的消费者人数。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.default-requeue-rejected</code></td><td></td><td>被拒绝的交付是否会被默认重新排队。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.idle-event-interval</code></td><td></td><td>闲置容器事件应该多久发布一次。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.missing-queues-fatal</code></td><td><code>false</code></td><td>如果容器声明的队列在经纪人上不可用，是否要失败。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.prefetch</code></td><td></td><td>在每个消费者那里可以未被确认的最大信息数量。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.retry.enabled</code></td><td><code>false</code></td><td>是否启用发布重试。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.retry.initial-interval</code></td><td><code>1000ms</code></td><td>第一次和第二次尝试传递信息之间的时间。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.retry.max-attempts</code></td><td><code>3.0</code></td><td>发送信息的最大尝试次数。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.retry.max-interval</code></td><td><code>10000ms</code></td><td>尝试之间的最大持续时间。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.retry.multiplier</code></td><td><code>1.0</code></td><td>适用于上一次重试间隔的倍数。</td></tr><tr><td><code>spring.rabbitmq.listener.direct.retry.stateless</code></td><td><code>true</code></td><td>重试是无状态还是有状态。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.acknowledge-mode</code></td><td></td><td>容器的确认模式。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.auto-startup</code></td><td><code>true</code></td><td>是否在启动时自动启动容器。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.batch-size</code></td><td></td><td>批量大小，以容器要使用的物理报文的数量表示。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.concurrency</code></td><td></td><td>监听器调用者线程的最少数量。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.default-requeue-rejected</code></td><td></td><td>被拒绝的交付是否会被默认重新排队。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.idle-event-interval</code></td><td></td><td>闲置容器事件应该多久发布一次。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.max-concurrency</code></td><td></td><td>监听者调用者线程的最大数量。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.missing-queues-fatal</code></td><td><code>true</code></td><td>如果容器声明的队列在 broker 上不可用，是否要失败，和/或如果一个或多个队列在运行时被删除，是否要停止容器。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.prefetch</code></td><td></td><td>在每个消费者那里可以未被确认的最大信息数量。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.retry.enabled</code></td><td><code>false</code></td><td>是否启用发布重试。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.retry.initial-interval</code></td><td><code>1000ms</code></td><td>第一次和第二次尝试传递信息之间的时间。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.retry.max-attempts</code></td><td><code>3.0</code></td><td>发送信息的最大尝试次数。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.retry.max-interval</code></td><td><code>10000ms</code></td><td>尝试之间的最大持续时间。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.retry.multiplier</code></td><td><code>1.0</code></td><td>适用于上一次重试间隔的倍数。</td></tr><tr><td><code>spring.rabbitmq.listener.simple.retry.stateless</code></td><td><code>true</code></td><td>重试是无状态还是有状态。</td></tr><tr><td><code>spring.rabbitmq.listener.type</code></td><td><code>simple</code></td><td>监听器容器类型。</td></tr></tbody></table><h3 id="ssl-1"><a href="#ssl-1" class="headerlink" title="ssl"></a>ssl</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.rabbitmq.ssl.algorithm</code></td><td></td><td>要使用的 SSL 算法。默认情况下，由 Rabbit 客户端库配置。</td></tr><tr><td><code>spring.rabbitmq.ssl.enabled</code></td><td></td><td>是否启用 SSL 支持。如果协议中提供了地址，则自动确定（amqp:// vs. amqps://）。</td></tr><tr><td><code>spring.rabbitmq.ssl.key-store</code></td><td></td><td>存放 SSL 证书的密钥库的路径。</td></tr><tr><td><code>spring.rabbitmq.ssl.key-store-password</code></td><td></td><td>用于访问钥匙库的密码。</td></tr><tr><td><code>spring.rabbitmq.ssl.key-store-type</code></td><td><code>PKCS12</code></td><td>钥匙库类型。</td></tr><tr><td><code>spring.rabbitmq.ssl.trust-store</code></td><td></td><td>持有 SSL 证书的信任商店。</td></tr><tr><td><code>spring.rabbitmq.ssl.trust-store-password</code></td><td></td><td>用于访问信托商店的密码。</td></tr><tr><td><code>spring.rabbitmq.ssl.trust-store-type</code></td><td><code>JKS</code></td><td>信任店型。</td></tr><tr><td><code>spring.rabbitmq.ssl.validate-server-certificate</code></td><td><code>true</code></td><td>是否启用服务器端证书验证。</td></tr><tr><td><code>spring.rabbitmq.ssl.verify-hostname</code></td><td><code>true</code></td><td>是否启用主机名验证。</td></tr></tbody></table><h3 id="template-1"><a href="#template-1" class="headerlink" title="template"></a>template</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.rabbitmq.template.default-receive-queue</code></td><td></td><td>当没有明确指定队列时，默认队列的名称。</td></tr><tr><td><code>spring.rabbitmq.template.exchange</code></td><td></td><td>用于发送操作的默认交易所的名称。</td></tr><tr><td><code>spring.rabbitmq.template.mandatory</code></td><td></td><td>是否启用强制消息。</td></tr><tr><td><code>spring.rabbitmq.template.receive-timeout</code></td><td></td><td><code>receive()</code>操作超时。</td></tr><tr><td><code>spring.rabbitmq.template.reply-timeout</code></td><td></td><td><code>sendAndReceive()</code>操作的超时。</td></tr><tr><td><code>spring.rabbitmq.template.retry.enabled</code></td><td><code>false</code></td><td>是否启用发布重试。</td></tr><tr><td><code>spring.rabbitmq.template.retry.initial-interval</code></td><td><code>1000ms</code></td><td>第一次和第二次尝试传递信息之间的时间。</td></tr><tr><td><code>spring.rabbitmq.template.retry.max-attempts</code></td><td><code>3.0</code></td><td>发送信息的最大尝试次数。</td></tr><tr><td><code>spring.rabbitmq.template.retry.max-interval</code></td><td><code>10000ms</code></td><td>尝试之间的最大持续时间。</td></tr><tr><td><code>spring.rabbitmq.template.retry.multiplier</code></td><td><code>1.0</code></td><td>适用于上一次重试间隔的倍数。</td></tr><tr><td><code>spring.rabbitmq.template.routing-key</code></td><td></td><td>用于发送操作的默认路由键的值。</td></tr></tbody></table><h2 id="webservices"><a href="#webservices" class="headerlink" title="webservices"></a>webservices</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.webservices.path</code></td><td><code>/services</code></td><td>作为服务的基本 URI 的路径。</td></tr><tr><td><code>spring.webservices.servlet.init.*</code></td><td></td><td>要传递给 Spring Web 服务的 Servlet init 参数。</td></tr><tr><td><code>spring.webservices.servlet.load-on-startup</code></td><td><code>-1.0</code></td><td>对 Spring Web 服务 servlet 的启动优先级进行加载。</td></tr><tr><td><code>spring.webservices.wsdl-locations</code></td><td></td><td>以逗号分隔的 WSDLs 和随附的 XSDs 的位置列表，这些 WSDLs 和 XSDs 将作为豆子暴露。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据迁移属性</title>
      <link href="/e337a70add48.html"/>
      <url>/e337a70add48.html</url>
      
        <content type="html"><![CDATA[<h2 id="flyway"><a href="#flyway" class="headerlink" title="flyway"></a>flyway</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.flyway.baseline-description</code></td><td><code>&lt;&lt; Flyway Baseline &gt;&gt;</code></td><td>在应用基线时，对现有模式进行标记的描述。</td></tr><tr><td><code>spring.flyway.baseline-on-migrate</code></td><td><code>false</code></td><td>迁移非空模式时是否自动调用基线。</td></tr><tr><td><code>spring.flyway.baseline-version</code></td><td><code>1</code></td><td>在执行基线时，对现有模式进行标记的版本。</td></tr><tr><td><code>spring.flyway.batch</code></td><td></td><td>执行 SQL 语句时，是否要批处理。需要 Flyway Pro 或 Flyway Enterprise。</td></tr><tr><td><code>spring.flyway.check-location</code></td><td><code>true</code></td><td>是否检查迁移脚本的位置是否存在。</td></tr><tr><td><code>spring.flyway.clean-disabled</code></td><td><code>false</code></td><td>是否禁止清理数据库。</td></tr><tr><td><code>spring.flyway.clean-on-validation-error</code></td><td><code>false</code></td><td>当发生验证错误时，是否自动调用 clean。</td></tr><tr><td><code>spring.flyway.connect-retries</code></td><td><code>0.0</code></td><td>试图连接到数据库时的最大重试次数。</td></tr><tr><td><code>spring.flyway.default-schema</code></td><td></td><td>由 Flyway 管理的默认模式名称（区分大小写）。</td></tr><tr><td><code>spring.flyway.enabled</code></td><td><code>true</code></td><td>是否启用飞道。</td></tr><tr><td><code>spring.flyway.encoding</code></td><td><code>UTF-8</code></td><td>SQL 迁移的编码。</td></tr><tr><td><code>spring.flyway.error-overrides</code></td><td></td><td>内置的错误处理规则，用于覆盖特定的 SQL 状态和错误代码。需要 Flyway Pro 或 Flyway Enterprise。</td></tr><tr><td><code>spring.flyway.group</code></td><td><code>false</code></td><td>在申请迁移时，是否将所有待处理的迁移集中在同一个事务中。</td></tr><tr><td><code>spring.flyway.ignore-future-migrations</code></td><td><code>true</code></td><td>读取模式历史表时是否忽略未来的迁移。</td></tr><tr><td><code>spring.flyway.ignore-ignored-migrations</code></td><td><code>false</code></td><td>读取模式历史表时是否忽略被忽略的迁移。</td></tr><tr><td><code>spring.flyway.ignore-missing-migrations</code></td><td><code>false</code></td><td>读取模式历史表时是否忽略缺失的迁移。</td></tr><tr><td><code>spring.flyway.ignore-pending-migrations</code></td><td><code>false</code></td><td>读取模式历史表时是否忽略待迁移。</td></tr><tr><td><code>spring.flyway.init-sqls</code></td><td></td><td>获得连接后，立即执行 SQL 语句来初始化连接。</td></tr><tr><td><code>spring.flyway.installed-by</code></td><td></td><td>在模式历史表中记录的应用迁移的用户名。</td></tr><tr><td><code>spring.flyway.license-key</code></td><td></td><td>Flyway Pro 或 Flyway Enterprise 的许可证密钥。</td></tr><tr><td><code>spring.flyway.locations</code></td><td><code>[classpath:db/migration]</code></td><td>迁移脚本的位置。可以包含特殊的”{vendor}”占位符，以使用特定供应商的位置。</td></tr><tr><td><code>spring.flyway.mixed</code></td><td><code>false</code></td><td>是否允许在同一迁移中混合事务性和非事务性语句。</td></tr><tr><td><code>spring.flyway.oracle-sqlplus</code></td><td></td><td>是否启用对 Oracle SQL*Plus 命令的支持。需要 Flyway Pro 或 Flyway Enterprise。</td></tr><tr><td><code>spring.flyway.oracle-sqlplus-warn</code></td><td></td><td>当遇到尚未支持的 Oracle SQL*Plus 语句时，是否要发出警告而不是错误。需要 Flyway Pro 或 Flyway Enterprise。</td></tr><tr><td><code>spring.flyway.out-of-order</code></td><td><code>false</code></td><td>是否允许迁移运行不正常。</td></tr><tr><td><code>spring.flyway.password</code></td><td></td><td>要迁移的数据库的登录密码。</td></tr><tr><td><code>spring.flyway.placeholder-prefix</code></td><td><code>$&#123;</code></td><td>迁移脚本中占位符的前缀。</td></tr><tr><td><code>spring.flyway.placeholder-replacement</code></td><td><code>true</code></td><td>在迁移脚本中执行占位符替换。</td></tr><tr><td><code>spring.flyway.placeholder-suffix</code></td><td><code>&#125;</code></td><td>迁移脚本中占位符的后缀。</td></tr><tr><td><code>spring.flyway.placeholders.*</code></td><td></td><td>占位符和它们的替换适用于 sql 迁移脚本。</td></tr><tr><td><code>spring.flyway.repeatable-sql-migration-prefix</code></td><td><code>R</code></td><td>可重复的 SQL 迁移的文件名前缀。</td></tr><tr><td><code>spring.flyway.schemas</code></td><td></td><td>由 Flyway 管理的计划名称（区分大小写）。</td></tr><tr><td><code>spring.flyway.skip-default-callbacks</code></td><td><code>false</code></td><td>是否跳过默认回调。如果为 true，则只使用自定义回调。</td></tr><tr><td><code>spring.flyway.skip-default-resolvers</code></td><td><code>false</code></td><td>是否跳过默认的解析器。如果为真，则只使用自定义解析器。</td></tr><tr><td><code>spring.flyway.sql-migration-prefix</code></td><td><code>V</code></td><td>SQL 迁移的文件名前缀。</td></tr><tr><td><code>spring.flyway.sql-migration-separator</code></td><td><code>__</code></td><td>SQL 迁移的文件名分隔符。</td></tr><tr><td><code>spring.flyway.sql-migration-suffixes</code></td><td><code>[.sql]</code></td><td>SQL 迁移的文件名后缀。</td></tr><tr><td><code>spring.flyway.stream</code></td><td></td><td>执行 SQL 迁移时是否要流式迁移。需要 Flyway Pro 或 Flyway Enterprise。</td></tr><tr><td><code>spring.flyway.table</code></td><td><code>flyway_schema_history</code></td><td>Flyway 将使用的模式历史表的名称。</td></tr><tr><td><code>spring.flyway.tablespace</code></td><td></td><td>创建模式历史表的表空间。当使用不支持表空间的数据库时，忽略。默认为 Flyway 使用的连接的默认表空间。</td></tr><tr><td><code>spring.flyway.target</code></td><td></td><td>应考虑向其迁移的目标版本。</td></tr><tr><td><code>spring.flyway.url</code></td><td></td><td>要迁移的数据库的 JDBC url，如果没有设置，则使用主要配置的数据源。如果没有设置，则使用主要配置的数据源。</td></tr><tr><td><code>spring.flyway.user</code></td><td></td><td>要迁移的数据库的登录用户。</td></tr><tr><td><code>spring.flyway.validate-migration-naming</code></td><td><code>false</code></td><td>是否验证那些脚本不遵守正确命名惯例的迁移和回调。</td></tr><tr><td><code>spring.flyway.validate-on-migrate</code></td><td><code>true</code></td><td>是否在进行迁移时自动调用验证。</td></tr></tbody></table><h2 id="liquibase"><a href="#liquibase" class="headerlink" title="liquibase"></a>liquibase</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.liquibase.change-log</code></td><td><code>classpath:/db/changelog/db.changelog-master.yaml</code></td><td>更改日志配置路径。</td></tr><tr><td><code>spring.liquibase.clear-checksums</code></td><td><code>false</code></td><td>是否清除当前变更日志中的所有校验和，以便在下次更新时重新计算。</td></tr><tr><td><code>spring.liquibase.contexts</code></td><td></td><td>以逗号分隔的运行时上下文列表。</td></tr><tr><td><code>spring.liquibase.database-change-log-lock-table</code></td><td><code>DATABASECHANGELOGLOCK</code></td><td>用来跟踪同时使用 Liquibase 的表的名称。</td></tr><tr><td><code>spring.liquibase.database-change-log-table</code></td><td><code>DATABASECHANGELOG</code></td><td>用于跟踪变更历史的表的名称。</td></tr><tr><td><code>spring.liquibase.default-schema</code></td><td></td><td>默认的数据库模式。</td></tr><tr><td><code>spring.liquibase.drop-first</code></td><td><code>false</code></td><td>是否先放弃数据库模式。</td></tr><tr><td><code>spring.liquibase.enabled</code></td><td><code>true</code></td><td>是否启用 Liquibase 支持。</td></tr><tr><td><code>spring.liquibase.labels</code></td><td></td><td>用逗号分隔的运行时标签列表。</td></tr><tr><td><code>spring.liquibase.liquibase-schema</code></td><td></td><td>用于 Liquibase 对象的模式。</td></tr><tr><td><code>spring.liquibase.liquibase-tablespace</code></td><td></td><td>用于 Liquibase 对象的表空间。</td></tr><tr><td><code>spring.liquibase.parameters.*</code></td><td></td><td>更改日志参数。</td></tr><tr><td><code>spring.liquibase.password</code></td><td></td><td>要迁移的数据库的登录密码。</td></tr><tr><td><code>spring.liquibase.rollback-file</code></td><td></td><td>执行更新时，回滚 SQL 被写入的文件。</td></tr><tr><td><code>spring.liquibase.tag</code></td><td></td><td>应用数据库更改时要使用的标记名称，也可以与 “rollbackFile “一起使用，为与该标记相关的所有现有更改生成回滚脚本。也可与 “rollbackFile “一起使用，为与该标记相关联的所有现有更改生成回滚脚本。</td></tr><tr><td><code>spring.liquibase.test-rollback-on-update</code></td><td><code>false</code></td><td>更新前是否要进行回滚测试。</td></tr><tr><td><code>spring.liquibase.url</code></td><td></td><td>要迁移的数据库的 JDBC URL，如果没有设置，则使用主要配置的数据源。如果没有设置，则使用主要配置的数据源。</td></tr><tr><td><code>spring.liquibase.user</code></td><td></td><td>要迁移的数据库的登录用户。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交易属性</title>
      <link href="/69f998dd7524.html"/>
      <url>/69f998dd7524.html</url>
      
        <content type="html"><![CDATA[<h2 id="jta"><a href="#jta" class="headerlink" title="jta"></a>jta</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.jta.enabled</code></td><td><code>true</code></td><td>是否启用 JTA 支持。</td></tr><tr><td><code>spring.jta.log-dir</code></td><td></td><td>交易日志目录。</td></tr><tr><td><code>spring.jta.transaction-manager-id</code></td><td></td><td>交易管理人唯一标识符。</td></tr></tbody></table><h3 id="atomikos"><a href="#atomikos" class="headerlink" title="atomikos"></a>atomikos</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.jta.atomikos.connectionfactory.borrow-connection-timeout</code></td><td><code>30.0</code></td><td>从池中借用连接的超时时间，以秒为单位。</td></tr><tr><td><code>spring.jta.atomikos.connectionfactory.ignore-session-transacted-flag</code></td><td><code>true</code></td><td>创建会话时是否忽略 transacted 标志。</td></tr><tr><td><code>spring.jta.atomikos.connectionfactory.local-transaction-mode</code></td><td><code>false</code></td><td>是否需要本地交易。</td></tr><tr><td><code>spring.jta.atomikos.connectionfactory.maintenance-interval</code></td><td><code>60.0</code></td><td>池的维护线程运行之间的时间，以秒为单位。</td></tr><tr><td><code>spring.jta.atomikos.connectionfactory.max-idle-time</code></td><td><code>60.0</code></td><td>从池中清理连接的时间，以秒为单位。</td></tr><tr><td><code>spring.jta.atomikos.connectionfactory.max-lifetime</code></td><td><code>0.0</code></td><td>一个连接在被破坏之前可以被池化的时间，以秒为单位。0 表示没有限制。</td></tr><tr><td><code>spring.jta.atomikos.connectionfactory.max-pool-size</code></td><td><code>1.0</code></td><td>泳池的最大尺寸。</td></tr><tr><td><code>spring.jta.atomikos.connectionfactory.min-pool-size</code></td><td><code>1.0</code></td><td>泳池的最小尺寸.</td></tr><tr><td><code>spring.jta.atomikos.connectionfactory.reap-timeout</code></td><td><code>0.0</code></td><td>借用连接的 Reap 超时，以秒为单位。0 表示没有限制。</td></tr><tr><td><code>spring.jta.atomikos.connectionfactory.unique-resource-name</code></td><td><code>jmsConnectionFactory</code></td><td>在恢复期间用于识别资源的唯一名称。</td></tr><tr><td><code>spring.jta.atomikos.connectionfactory.xa-connection-factory-class-name</code></td><td></td><td>XAConnectionFactory 的特定供应商实现。</td></tr><tr><td><code>spring.jta.atomikos.connectionfactory.xa-properties</code></td><td></td><td>供应商特有的 XA 属性。</td></tr><tr><td><code>spring.jta.atomikos.datasource.borrow-connection-timeout</code></td><td><code>30.0</code></td><td>从池中借用连接的超时时间，以秒为单位。</td></tr><tr><td><code>spring.jta.atomikos.datasource.concurrent-connection-validation</code></td><td><code>true</code></td><td>是否使用并发连接验证。</td></tr><tr><td><code>spring.jta.atomikos.datasource.default-isolation-level</code></td><td></td><td>池提供的连接的默认隔离级别。</td></tr><tr><td><code>spring.jta.atomikos.datasource.login-timeout</code></td><td><code>0.0</code></td><td>建立数据库连接的超时时间，以秒为单位。</td></tr><tr><td><code>spring.jta.atomikos.datasource.maintenance-interval</code></td><td><code>60.0</code></td><td>池的维护线程运行之间的时间，以秒为单位。</td></tr><tr><td><code>spring.jta.atomikos.datasource.max-idle-time</code></td><td><code>60.0</code></td><td>从池中清理连接的时间，以秒为单位。</td></tr><tr><td><code>spring.jta.atomikos.datasource.max-lifetime</code></td><td><code>0.0</code></td><td>一个连接在被破坏之前可以被池化的时间，以秒为单位。0 表示没有限制。</td></tr><tr><td><code>spring.jta.atomikos.datasource.max-pool-size</code></td><td><code>1.0</code></td><td>泳池的最大尺寸。</td></tr><tr><td><code>spring.jta.atomikos.datasource.min-pool-size</code></td><td><code>1.0</code></td><td>泳池的最小尺寸。</td></tr><tr><td><code>spring.jta.atomikos.datasource.reap-timeout</code></td><td><code>0.0</code></td><td>借用连接的 Reap 超时，以秒为单位。0 表示没有限制。</td></tr><tr><td><code>spring.jta.atomikos.datasource.test-query</code></td><td></td><td>在返回连接之前，用于验证连接的 SQL 查询或语句。</td></tr><tr><td><code>spring.jta.atomikos.datasource.unique-resource-name</code></td><td><code>dataSource</code></td><td>在恢复期间用于识别资源的唯一名称。</td></tr><tr><td><code>spring.jta.atomikos.datasource.xa-data-source-class-name</code></td><td></td><td>XAConnectionFactory 的特定供应商实现。</td></tr><tr><td><code>spring.jta.atomikos.datasource.xa-properties</code></td><td></td><td>供应商特有的 XA 属性。</td></tr><tr><td><code>spring.jta.atomikos.properties.allow-sub-transactions</code></td><td><code>true</code></td><td>指定是否允许子交易。</td></tr><tr><td><code>spring.jta.atomikos.properties.checkpoint-interval</code></td><td><code>500.0</code></td><td>检查点之间的间隔，用两个检查点之间的日志写入次数表示。检查点可以减少日志文件的大小，但代价是在运行时增加一些开销。</td></tr><tr><td><code>spring.jta.atomikos.properties.default-jta-timeout</code></td><td><code>10000ms</code></td><td>JTA 交易的默认超时。</td></tr><tr><td><code>spring.jta.atomikos.properties.default-max-wait-time-on-shutdown</code></td><td></td><td>正常关机(不强制)应该等多长时间才能完成交易。</td></tr><tr><td><code>spring.jta.atomikos.properties.enable-logging</code></td><td><code>true</code></td><td>是否启用磁盘日志记录。</td></tr><tr><td><code>spring.jta.atomikos.properties.force-shutdown-on-vm-exit</code></td><td><code>false</code></td><td>虚拟机关机是否应该触发事务核心的强制关机。</td></tr><tr><td><code>spring.jta.atomikos.properties.log-base-dir</code></td><td></td><td>存储日志文件的目录。默认为当前工作目录。</td></tr><tr><td><code>spring.jta.atomikos.properties.log-base-name</code></td><td><code>tmlog</code></td><td>交易日志文件基础名称。</td></tr><tr><td><code>spring.jta.atomikos.properties.max-actives</code></td><td><code>50.0</code></td><td>活动交易的最大数量。</td></tr><tr><td><code>spring.jta.atomikos.properties.max-timeout</code></td><td><code>300000ms</code></td><td>可允许交易的最大超时。</td></tr><tr><td><code>spring.jta.atomikos.properties.recovery.delay</code></td><td><code>10000ms</code></td><td>两次恢复扫描之间的延迟。</td></tr><tr><td><code>spring.jta.atomikos.properties.recovery.forget-orphaned-log-entries-delay</code></td><td><code>86400000ms</code></td><td>延迟恢复清理待处理（”孤儿”）日志条目。</td></tr><tr><td><code>spring.jta.atomikos.properties.recovery.max-retries</code></td><td><code>5.0</code></td><td>抛出异常前提交事务的重试次数。</td></tr><tr><td><code>spring.jta.atomikos.properties.recovery.retry-interval</code></td><td><code>10000ms</code></td><td>重试之间的延迟。</td></tr><tr><td><code>spring.jta.atomikos.properties.serial-jta-transactions</code></td><td><code>true</code></td><td>在可能的情况下，是否应该加入子交易。</td></tr><tr><td><code>spring.jta.atomikos.properties.service</code></td><td></td><td>应该开始实施的事务管理器。</td></tr><tr><td><code>spring.jta.atomikos.properties.threaded-two-phase-commit</code></td><td><code>false</code></td><td>是否使用不同（和并发）线程对参与资源进行两阶段提交。</td></tr><tr><td><code>spring.jta.atomikos.properties.transaction-manager-unique-name</code></td><td></td><td>交易管理器的唯一名称。默认为机器的 IP 地址。如果你计划对一个数据库运行多个事务管理器，你必须将此属性设置为唯一值。</td></tr></tbody></table><h3 id="bitronix"><a href="#bitronix" class="headerlink" title="bitronix"></a>bitronix</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.jta.bitronix.connectionfactory.acquire-increment</code></td><td><code>1.0</code></td><td>增长池时要创建的连接数。</td></tr><tr><td><code>spring.jta.bitronix.connectionfactory.acquisition-interval</code></td><td><code>1.0</code></td><td>获取无效连接后，再次尝试获取连接前的等待时间，以秒为单位。</td></tr><tr><td><code>spring.jta.bitronix.connectionfactory.acquisition-timeout</code></td><td><code>30.0</code></td><td>从池中获取连接的超时时间，以秒为单位。</td></tr><tr><td><code>spring.jta.bitronix.connectionfactory.allow-local-transactions</code></td><td><code>false</code></td><td>交易管理人是否应允许混合 XA 和非 XA 交易。</td></tr><tr><td><code>spring.jta.bitronix.connectionfactory.apply-transaction-timeout</code></td><td><code>false</code></td><td>在 XAResource 入库时，是否要对其设置交易超时。</td></tr><tr><td><code>spring.jta.bitronix.connectionfactory.automatic-enlisting-enabled</code></td><td><code>true</code></td><td>资源是否应该自动入列和除名。</td></tr><tr><td><code>spring.jta.bitronix.connectionfactory.cache-producers-consumers</code></td><td><code>true</code></td><td>生产者和消费者是否应该缓存。</td></tr><tr><td><code>spring.jta.bitronix.connectionfactory.class-name</code></td><td></td><td>XA 资源的基本执行类名称。</td></tr><tr><td><code>spring.jta.bitronix.connectionfactory.defer-connection-release</code></td><td><code>true</code></td><td>提供商是否可以在同一连接上运行许多事务，并支持事务交错。</td></tr><tr><td><code>spring.jta.bitronix.connectionfactory.disabled</code></td><td><code>false</code></td><td>该资源是否被禁用，即暂时禁止从其池中获取连接。</td></tr><tr><td><code>spring.jta.bitronix.connectionfactory.driver-properties</code></td><td></td><td>应在底层执行中设置的属性。</td></tr><tr><td><code>spring.jta.bitronix.connectionfactory.failed</code></td><td></td><td></td></tr><tr><td><code>spring.jta.bitronix.connectionfactory.ignore-recovery-failures</code></td><td><code>false</code></td><td>是否应该忽略恢复故障。</td></tr><tr><td><code>spring.jta.bitronix.connectionfactory.max-idle-time</code></td><td><code>60.0</code></td><td>从池中清理连接的时间，以秒为单位。</td></tr><tr><td><code>spring.jta.bitronix.connectionfactory.max-pool-size</code></td><td><code>0.0</code></td><td>池的最大尺寸。0 表示没有限制。</td></tr><tr><td><code>spring.jta.bitronix.connectionfactory.min-pool-size</code></td><td><code>0.0</code></td><td>泳池的最小尺寸。</td></tr><tr><td><code>spring.jta.bitronix.connectionfactory.password</code></td><td></td><td>连接到 JMS 提供者的密码。</td></tr><tr><td><code>spring.jta.bitronix.connectionfactory.share-transaction-connections</code></td><td><code>false</code></td><td>ACCESSIBLE 状态下的连接是否可以在事务的上下文中共享。</td></tr><tr><td><code>spring.jta.bitronix.connectionfactory.test-connections</code></td><td><code>false</code></td><td>当从池中获取连接时，是否应该进行测试。</td></tr><tr><td><code>spring.jta.bitronix.connectionfactory.two-pc-ordering-position</code></td><td><code>1.0</code></td><td>这个资源在两阶段提交中应该占据的位置（总是第一个是 Integer.MIN_VALUE，最后一个是 Integer.MAX_VALUE）。</td></tr><tr><td><code>spring.jta.bitronix.connectionfactory.unique-name</code></td><td><code>jmsConnectionFactory</code></td><td>在恢复期间用于识别资源的唯一名称。</td></tr><tr><td><code>spring.jta.bitronix.connectionfactory.use-tm-join</code></td><td><code>true</code></td><td>在启动 XAResources 时是否应该使用 TMJOIN。</td></tr><tr><td><code>spring.jta.bitronix.connectionfactory.user</code></td><td></td><td>用于连接到 JMS 提供者的用户。</td></tr><tr><td><code>spring.jta.bitronix.datasource.acquire-increment</code></td><td><code>1.0</code></td><td>增长池时要创建的连接数。</td></tr><tr><td><code>spring.jta.bitronix.datasource.acquisition-interval</code></td><td><code>1.0</code></td><td>获取无效连接后，再次尝试获取连接前的等待时间，以秒为单位。</td></tr><tr><td><code>spring.jta.bitronix.datasource.acquisition-timeout</code></td><td><code>30.0</code></td><td>从池中获取连接的超时时间，以秒为单位。</td></tr><tr><td><code>spring.jta.bitronix.datasource.allow-local-transactions</code></td><td><code>false</code></td><td>交易管理人是否应允许混合 XA 和非 XA 交易。</td></tr><tr><td><code>spring.jta.bitronix.datasource.apply-transaction-timeout</code></td><td><code>false</code></td><td>在 XAResource 入库时，是否要对其设置交易超时。</td></tr><tr><td><code>spring.jta.bitronix.datasource.automatic-enlisting-enabled</code></td><td><code>true</code></td><td>资源是否应该自动入列和除名。</td></tr><tr><td><code>spring.jta.bitronix.datasource.class-name</code></td><td></td><td>XA 资源的基本执行类名称。</td></tr><tr><td><code>spring.jta.bitronix.datasource.cursor-holdability</code></td><td></td><td>默认的光标可保持连接。</td></tr><tr><td><code>spring.jta.bitronix.datasource.defer-connection-release</code></td><td><code>true</code></td><td>数据库是否可以在同一连接上运行多个事务，是否支持事务交错。</td></tr><tr><td><code>spring.jta.bitronix.datasource.disabled</code></td><td><code>false</code></td><td>该资源是否被禁用，即暂时禁止从其池中获取连接。</td></tr><tr><td><code>spring.jta.bitronix.datasource.driver-properties</code></td><td></td><td>应在底层执行中设置的属性。</td></tr><tr><td><code>spring.jta.bitronix.datasource.enable-jdbc4-connection-test</code></td><td><code>false</code></td><td>从池中获取连接时是否调用 Connection.isValid()。</td></tr><tr><td><code>spring.jta.bitronix.datasource.failed</code></td><td></td><td></td></tr><tr><td><code>spring.jta.bitronix.datasource.ignore-recovery-failures</code></td><td><code>false</code></td><td>是否应该忽略恢复故障。</td></tr><tr><td><code>spring.jta.bitronix.datasource.isolation-level</code></td><td></td><td>连接的默认隔离级别。</td></tr><tr><td><code>spring.jta.bitronix.datasource.local-auto-commit</code></td><td></td><td>本地交易的默认自动提交模式。</td></tr><tr><td><code>spring.jta.bitronix.datasource.login-timeout</code></td><td></td><td>建立数据库连接的超时时间，以秒为单位。</td></tr><tr><td><code>spring.jta.bitronix.datasource.max-idle-time</code></td><td><code>60.0</code></td><td>从池中清理连接的时间，以秒为单位。</td></tr><tr><td><code>spring.jta.bitronix.datasource.max-pool-size</code></td><td><code>0.0</code></td><td>池的最大尺寸。0 表示没有限制。</td></tr><tr><td><code>spring.jta.bitronix.datasource.min-pool-size</code></td><td><code>0.0</code></td><td>泳池的最小尺寸。</td></tr><tr><td><code>spring.jta.bitronix.datasource.prepared-statement-cache-size</code></td><td><code>0.0</code></td><td>准备好的语句缓存的目标大小。0 禁用缓存。</td></tr><tr><td><code>spring.jta.bitronix.datasource.share-transaction-connections</code></td><td><code>false</code></td><td>ACCESSIBLE 状态下的连接是否可以在事务的上下文中共享。</td></tr><tr><td><code>spring.jta.bitronix.datasource.test-query</code></td><td></td><td>在返回连接之前，用于验证连接的 SQL 查询或语句。</td></tr><tr><td><code>spring.jta.bitronix.datasource.two-pc-ordering-position</code></td><td><code>1.0</code></td><td>这个资源在两阶段提交中应该占据的位置（总是第一个是 Integer.MIN_VALUE，最后一个是 Integer.MAX_VALUE）。</td></tr><tr><td><code>spring.jta.bitronix.datasource.unique-name</code></td><td><code>dataSource</code></td><td>在恢复期间用于识别资源的唯一名称。</td></tr><tr><td><code>spring.jta.bitronix.datasource.use-tm-join</code></td><td><code>true</code></td><td>在启动 XAResources 时是否应该使用 TMJOIN。</td></tr></tbody></table><h2 id="transaction"><a href="#transaction" class="headerlink" title="transaction"></a>transaction</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.transaction.default-timeout</code></td><td></td><td>默认交易超时。如果没有指定持续时间后缀，将使用秒。</td></tr><tr><td><code>spring.transaction.rollback-on-commit-failure</code></td><td></td><td>是否对提交失败进行回滚。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据属性</title>
      <link href="/837862e41b91.html"/>
      <url>/837862e41b91.html</url>
      
        <content type="html"><![CDATA[<h2 id="couchbase"><a href="#couchbase" class="headerlink" title="couchbase"></a>couchbase</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.couchbase.connection-string</code></td><td></td><td>用于定位 Couchbase 集群的连接字符串。</td></tr><tr><td><code>spring.couchbase.env.io.idle-http-connection-timeout</code></td><td><code>4500ms</code></td><td>一个 HTTP 连接在被关闭和从池中移除之前可能保持空闲的时间长度。</td></tr><tr><td><code>spring.couchbase.env.io.max-endpoints</code></td><td><code>12.0</code></td><td>每个节点的最大套接字数。</td></tr><tr><td><code>spring.couchbase.env.io.min-endpoints</code></td><td><code>1.0</code></td><td>每个节点的最低套接字数。</td></tr><tr><td><code>spring.couchbase.env.ssl.enabled</code></td><td></td><td>是否启用 SSL 支持。如果提供了 “keyStore”，则自动启用，除非另有规定。</td></tr><tr><td><code>spring.couchbase.env.ssl.key-store</code></td><td></td><td>通往存放证书的 JVM 密钥库的路径。</td></tr><tr><td><code>spring.couchbase.env.ssl.key-store-password</code></td><td></td><td>用于访问钥匙库的密码。</td></tr><tr><td><code>spring.couchbase.env.timeouts.analytics</code></td><td><code>75s</code></td><td>分析服务超时。</td></tr><tr><td><code>spring.couchbase.env.timeouts.connect</code></td><td><code>10s</code></td><td>桶连接超时。</td></tr><tr><td><code>spring.couchbase.env.timeouts.disconnect</code></td><td><code>10s</code></td><td>料桶断开超时。</td></tr><tr><td><code>spring.couchbase.env.timeouts.key-value</code></td><td><code>2500ms</code></td><td>对特定键值的操作超时。</td></tr><tr><td><code>spring.couchbase.env.timeouts.key-value-durable</code></td><td><code>10s</code></td><td>对某一特定键值进行操作的超时，其耐久性等级。</td></tr><tr><td><code>spring.couchbase.env.timeouts.management</code></td><td><code>75s</code></td><td>管理业务的超时。</td></tr><tr><td><code>spring.couchbase.env.timeouts.query</code></td><td><code>75s</code></td><td>N1QL 查询操作超时。</td></tr><tr><td><code>spring.couchbase.env.timeouts.search</code></td><td><code>75s</code></td><td>搜索服务超时。</td></tr><tr><td><code>spring.couchbase.env.timeouts.view</code></td><td><code>75s</code></td><td>常规和地理空间视图操作超时。</td></tr><tr><td><code>spring.couchbase.password</code></td><td></td><td>集群密码。</td></tr><tr><td><code>spring.couchbase.username</code></td><td></td><td>群组用户名。</td></tr></tbody></table><h2 id="dao"><a href="#dao" class="headerlink" title="dao"></a>dao</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.dao.exceptiontranslation.enabled</code></td><td><code>true</code></td><td>是否启用 PersistenceExceptionTranslationPostProcessor。</td></tr></tbody></table><h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><h3 id="cassandra"><a href="#cassandra" class="headerlink" title="cassandra"></a>cassandra</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.data.cassandra.compression</code></td><td><code>none</code></td><td>Cassandra 二进制协议支持的压缩。</td></tr><tr><td><code>spring.data.cassandra.connection.connect-timeout</code></td><td><code>5s</code></td><td>建立驱动程序连接时使用的超时。</td></tr><tr><td><code>spring.data.cassandra.connection.init-query-timeout</code></td><td><code>500ms</code></td><td>超时用于内部查询，作为初始化过程的一部分，就在连接打开后运行。</td></tr><tr><td><code>spring.data.cassandra.contact-points</code></td><td><code>[127.0.0.1:9042]</code></td><td>集群节点地址的形式为’host:port’，或者简单的’host’来使用配置的端口。</td></tr><tr><td><code>spring.data.cassandra.keyspace-name</code></td><td></td><td>要使用的关键空间名称。</td></tr><tr><td><code>spring.data.cassandra.local-datacenter</code></td><td></td><td>被认为是 “本地 “的数据中心。联络点应来自该数据中心。</td></tr><tr><td><code>spring.data.cassandra.password</code></td><td></td><td>服务器的登录密码。</td></tr><tr><td><code>spring.data.cassandra.pool.heartbeat-interval</code></td><td><code>30s</code></td><td>心跳间隔，在此间隔之后，在空闲连接上发送消息，以确保它仍然活着。如果没有指定持续时间后缀，将使用秒。</td></tr><tr><td><code>spring.data.cassandra.pool.idle-timeout</code></td><td><code>120s</code></td><td>移除空闲连接前的闲置时间。如果没有指定持续时间后缀，将使用秒。</td></tr><tr><td><code>spring.data.cassandra.port</code></td><td><code>9042.0</code></td><td>如果联络点没有指定端口，则使用该端口。</td></tr><tr><td><code>spring.data.cassandra.repositories.type</code></td><td><code>auto</code></td><td>要启用的 Cassandra 资源库类型。</td></tr><tr><td><code>spring.data.cassandra.request.consistency</code></td><td></td><td>查询一致性水平。</td></tr><tr><td><code>spring.data.cassandra.request.page-size</code></td><td><code>5000.0</code></td><td>一次网络往返将同时检索多少行。</td></tr><tr><td><code>spring.data.cassandra.request.serial-consistency</code></td><td></td><td>查询序列一致性级别。</td></tr><tr><td><code>spring.data.cassandra.request.throttler.drain-interval</code></td><td><code>10ms</code></td><td>节制器尝试去 queue 请求的频率。将此值设置为足够高，使每次尝试都能处理队列中的多个条目，但不会使请求延迟太多。</td></tr><tr><td><code>spring.data.cassandra.request.throttler.max-concurrent-requests</code></td><td><code>10000.0</code></td><td>允许并行执行的最大请求数。</td></tr><tr><td><code>spring.data.cassandra.request.throttler.max-queue-size</code></td><td><code>10000.0</code></td><td>当超过节流阈值时，可以被 enqueued 的最大请求数。</td></tr><tr><td><code>spring.data.cassandra.request.throttler.max-requests-per-second</code></td><td><code>10000.0</code></td><td>最大允许请求率。</td></tr><tr><td><code>spring.data.cassandra.request.throttler.type</code></td><td><code>none</code></td><td>请求节制类型。</td></tr><tr><td><code>spring.data.cassandra.request.timeout</code></td><td><code>2s</code></td><td>司机等待请求完成的时间。</td></tr><tr><td><code>spring.data.cassandra.schema-action</code></td><td><code>none</code></td><td>启动时要采取的模式动作。</td></tr><tr><td><code>spring.data.cassandra.session-name</code></td><td></td><td>Cassandra 会话的名称。</td></tr><tr><td><code>spring.data.cassandra.ssl</code></td><td><code>false</code></td><td>启用 SSL 支持。</td></tr><tr><td><code>spring.data.cassandra.username</code></td><td></td><td>服务器的登录用户。</td></tr><tr><td><code>spring.data.couchbase.auto-index</code></td><td><code>false</code></td><td>自动创建视图和索引。使用”@ViewIndexed”、”@N1qlPrimaryIndexed “和”@N1qlSecondaryIndexed “提供的元数据。</td></tr><tr><td><code>spring.data.couchbase.bucket-name</code></td><td></td><td>要连接的桶的名称。</td></tr><tr><td><code>spring.data.couchbase.field-naming-strategy</code></td><td></td><td>要使用的 FieldNamingStrategy 的全称。</td></tr><tr><td><code>spring.data.couchbase.repositories.type</code></td><td><code>auto</code></td><td>启用 Couchbase 仓库的类型。</td></tr><tr><td><code>spring.data.couchbase.scope-name</code></td><td></td><td>用于所有收集访问的范围名称。</td></tr><tr><td><code>spring.data.couchbase.type-key</code></td><td><code>_class</code></td><td>使用 “MappingCouchbaseConverter “时，存储复杂类型的类型信息的字段名称。</td></tr></tbody></table><h3 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.data.elasticsearch.client.reactive.connection-timeout</code></td><td></td><td>连接超时。</td></tr><tr><td><code>spring.data.elasticsearch.client.reactive.endpoints</code></td><td></td><td>以逗号分隔的 Elasticsearch 端点连接列表。</td></tr><tr><td><code>spring.data.elasticsearch.client.reactive.max-in-memory-size</code></td><td></td><td>每当输入流需要聚合时，可以缓冲的字节数限制。</td></tr><tr><td><code>spring.data.elasticsearch.client.reactive.password</code></td><td></td><td>凭证密码。</td></tr><tr><td><code>spring.data.elasticsearch.client.reactive.socket-timeout</code></td><td></td><td>读写 Socket 超时。</td></tr><tr><td><code>spring.data.elasticsearch.client.reactive.use-ssl</code></td><td><code>false</code></td><td>客户端是否应该使用 SSL 连接到端点。</td></tr><tr><td><code>spring.data.elasticsearch.client.reactive.username</code></td><td></td><td>凭证用户名。</td></tr><tr><td><code>spring.data.elasticsearch.repositories.enabled</code></td><td><code>true</code></td><td>是否启用 Elasticsearch 仓库。</td></tr></tbody></table><h3 id="jdbc"><a href="#jdbc" class="headerlink" title="jdbc"></a>jdbc</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.data.jdbc.repositories.enabled</code></td><td><code>true</code></td><td>是否启用 JDBC 资源库。</td></tr></tbody></table><h3 id="jpa"><a href="#jpa" class="headerlink" title="jpa"></a>jpa</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.data.jpa.repositories.bootstrap-mode</code></td><td><code>deferred</code></td><td>JPA 仓库的 Bootstrap 模式。</td></tr><tr><td><code>spring.data.jpa.repositories.enabled</code></td><td><code>true</code></td><td>是否启用 JPA 存储库。</td></tr></tbody></table><h3 id="ldap"><a href="#ldap" class="headerlink" title="ldap"></a>ldap</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.data.ldap.repositories.enabled</code></td><td><code>true</code></td><td>是否启用 LDAP 存储库。</td></tr></tbody></table><h3 id="mongodb"><a href="#mongodb" class="headerlink" title="mongodb"></a>mongodb</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.data.mongodb.authentication-database</code></td><td></td><td>认证数据库名称。</td></tr><tr><td><code>spring.data.mongodb.auto-index-creation</code></td><td></td><td>是否启用自动创建索引。</td></tr><tr><td><code>spring.data.mongodb.database</code></td><td></td><td>数据库名称。</td></tr><tr><td><code>spring.data.mongodb.field-naming-strategy</code></td><td></td><td>要使用的 FieldNamingStrategy 的全称。</td></tr><tr><td><code>spring.data.mongodb.grid-fs-database</code></td><td></td><td>GridFS 数据库名称。</td></tr><tr><td><code>spring.data.mongodb.host</code></td><td></td><td>Mongo 服务器主机。不能用 URI 设置。</td></tr><tr><td><code>spring.data.mongodb.password</code></td><td></td><td>mongo 服务器的登录密码。不能用 URI 设置。</td></tr><tr><td><code>spring.data.mongodb.port</code></td><td></td><td>Mongo 服务器端口。不能用 URI 设置。</td></tr><tr><td><code>spring.data.mongodb.replica-set-name</code></td><td></td><td>群集所需的副本集名称。不能用 URI 设置。</td></tr><tr><td><code>spring.data.mongodb.repositories.type</code></td><td><code>auto</code></td><td>启用 Mongo 存储库的类型。</td></tr><tr><td><code>spring.data.mongodb.uri</code></td><td><code>mongodb://localhost/test</code></td><td>Mongo 数据库 URI。不能与主机、端口、证书和副本集名称一起设置。</td></tr><tr><td><code>spring.data.mongodb.username</code></td><td></td><td>mongo 服务器的登录用户。不能用 URI 设置。</td></tr><tr><td><code>spring.data.mongodb.uuid-representation</code></td><td><code>java-legacy</code></td><td>将 UUID 转换为 BSON 二进制值时要使用的表示方法。</td></tr></tbody></table><h3 id="neo4j"><a href="#neo4j" class="headerlink" title="neo4j"></a>neo4j</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.data.neo4j.auto-index</code></td><td><code>none</code></td><td>自动索引模式。</td></tr><tr><td><code>spring.data.neo4j.embedded.enabled</code></td><td><code>true</code></td><td>如果有嵌入式驱动程序，是否启用嵌入式模式。</td></tr><tr><td><code>spring.data.neo4j.open-in-view</code></td><td><code>false</code></td><td>注册 OpenSessionInViewInterceptor，将 Neo4j Session 绑定到线程上，以便处理整个请求。</td></tr><tr><td><code>spring.data.neo4j.password</code></td><td></td><td>服务器的登录密码。</td></tr><tr><td><code>spring.data.neo4j.repositories.enabled</code></td><td><code>true</code></td><td>是否启用 Neo4j 资源库。</td></tr><tr><td><code>spring.data.neo4j.uri</code></td><td></td><td>驱动程序使用的 URI。默认为自动检测。</td></tr><tr><td><code>spring.data.neo4j.use-native-types</code></td><td><code>false</code></td><td>是否尽可能的使用 Neo4j 本地类型。</td></tr><tr><td><code>spring.data.neo4j.username</code></td><td></td><td>服务器的登录用户。</td></tr></tbody></table><h3 id="r2dbc"><a href="#r2dbc" class="headerlink" title="r2dbc"></a>r2dbc</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.data.r2dbc.repositories.enabled</code></td><td><code>true</code></td><td>是否启用 R2DBC 资源库。</td></tr></tbody></table><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.data.redis.repositories.enabled</code></td><td><code>true</code></td><td>是否启用 Redis 存储库。</td></tr></tbody></table><h3 id="rest"><a href="#rest" class="headerlink" title="rest"></a>rest</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.data.rest.base-path</code></td><td></td><td>Spring Data REST 用于暴露存储库资源的基本路径。</td></tr><tr><td><code>spring.data.rest.default-media-type</code></td><td></td><td>当没有指定内容类型时，将其作为默认类型。</td></tr><tr><td><code>spring.data.rest.default-page-size</code></td><td></td><td>默认页数。</td></tr><tr><td><code>spring.data.rest.detection-strategy</code></td><td><code>default</code></td><td>用来确定哪些存储库被暴露的策略。</td></tr><tr><td><code>spring.data.rest.enable-enum-translation</code></td><td></td><td>是否通过 Spring Data REST 默认资源捆绑启用枚举值转换。</td></tr><tr><td><code>spring.data.rest.limit-param-name</code></td><td></td><td>URL 查询字符串参数的名称，表示一次要返回多少结果。</td></tr><tr><td><code>spring.data.rest.max-page-size</code></td><td></td><td>最大页数。</td></tr><tr><td><code>spring.data.rest.page-param-name</code></td><td></td><td>URL 查询字符串参数的名称，表示要返回什么页面。</td></tr><tr><td><code>spring.data.rest.return-body-on-create</code></td><td></td><td>创建实体后是否返回响应体。</td></tr><tr><td><code>spring.data.rest.return-body-on-update</code></td><td></td><td>更新实体后是否返回响应体。</td></tr><tr><td><code>spring.data.rest.sort-param-name</code></td><td></td><td>URL 查询字符串参数的名称，表示对结果进行排序的方向。</td></tr></tbody></table><h3 id="solr"><a href="#solr" class="headerlink" title="solr"></a>solr</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.data.solr.host</code></td><td><code>[http://127.0.0.1:8983/solr](http://127.0.0.1:8983/solr)</code></td><td>Solr 主机。如果设置了 “zk-host “则忽略。</td></tr><tr><td><code>spring.data.solr.repositories.enabled</code></td><td><code>true</code></td><td>是否启用 Solr 资源库。</td></tr><tr><td><code>spring.data.solr.zk-host</code></td><td></td><td>ZooKeeper 主机地址的形式为 HOST:PORT。</td></tr></tbody></table><h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.data.web.pageable.default-page-size</code></td><td><code>20.0</code></td><td>默认页面大小。</td></tr><tr><td><code>spring.data.web.pageable.max-page-size</code></td><td><code>2000.0</code></td><td>可接受的最大页面尺寸。</td></tr><tr><td><code>spring.data.web.pageable.one-indexed-parameters</code></td><td><code>false</code></td><td>是否暴露并假设基于 1 的页码索引。默认为 “false”，即请求中页码为 0 的页面等于第一页。</td></tr><tr><td><code>spring.data.web.pageable.page-parameter</code></td><td><code>page</code></td><td>页面索引参数名称。</td></tr><tr><td><code>spring.data.web.pageable.prefix</code></td><td></td><td>G 页码和页面大小参数的前缀。</td></tr><tr><td><code>spring.data.web.pageable.qualifier-delimiter</code></td><td><code>_</code></td><td>在限定符与实际页码和尺寸属性之间使用的分隔符。</td></tr><tr><td><code>spring.data.web.pageable.size-parameter</code></td><td><code>size</code></td><td>页面大小参数名称。</td></tr><tr><td><code>spring.data.web.sort.sort-parameter</code></td><td><code>sort</code></td><td>排序参数名称。</td></tr></tbody></table><h2 id="datasource"><a href="#datasource" class="headerlink" title="datasource"></a>datasource</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.datasource.continue-on-error</code></td><td><code>false</code></td><td>如果在初始化数据库时发生错误，是否要停止。</td></tr><tr><td><code>spring.datasource.data</code></td><td></td><td>数据（DML）脚本资源引用。</td></tr><tr><td><code>spring.datasource.data-password</code></td><td></td><td>执行 DML 脚本的数据库密码（如果不同）。</td></tr><tr><td><code>spring.datasource.data-username</code></td><td></td><td>U 要执行 DML 脚本的数据库名称（如果不同）。</td></tr><tr><td><code>spring.datasource.dbcp2.abandoned-usage-tracking</code></td><td><code>spring.datasource.dbcp2.access-to-underlying-connection-allowed</code></td><td>绑定到 DBCP2 的 BasicDataSource 实例的 Commons DBCP2 特定设置。</td></tr><tr><td><code>spring.datasource.driver-class-name</code></td><td></td><td>JDBC 驱动的全称。默认情况下，根据 URL 自动检测。</td></tr><tr><td><code>spring.datasource.generate-unique-name</code></td><td><code>true</code></td><td>是否随机生成一个数据源名称。</td></tr><tr><td><code>spring.datasource.hikari.allow-pool-suspension</code></td><td><code>spring.datasource.hikari.auto-commit</code></td><td>绑定到 Hikari 的 HikariDataSource 实例的 Hikari 特定设置。</td></tr><tr><td><code>spring.datasource.initialization-mode</code></td><td><code>embedded</code></td><td>用可用的 DDL 和 DML 脚本初始化数据源。</td></tr><tr><td><code>spring.datasource.jndi-name</code></td><td></td><td>数据源的 JNDI 位置。设置时，类、url、用户名和密码会被忽略。</td></tr><tr><td><code>spring.datasource.name</code></td><td></td><td>数据源的名称，使用嵌入式数据库时，默认为 “testdb”。使用嵌入式数据库时，默认为 “testdb”。</td></tr><tr><td><code>spring.datasource.password</code></td><td></td><td>数据库的登录密码。</td></tr><tr><td><code>spring.datasource.platform</code></td><td><code>all</code></td><td>在 DDL 或 DML 脚本中使用的平台（如 schema-${platform}.sql或data-${platform}.sql）。</td></tr><tr><td><code>spring.datasource.schema</code></td><td></td><td>Schema（DDL）脚本资源引用。</td></tr><tr><td><code>spring.datasource.schema-password</code></td><td></td><td>执行 DDL 脚本的数据库密码（如果不同）。</td></tr><tr><td><code>spring.datasource.schema-username</code></td><td></td><td>执行 DDL 脚本的数据库的用户名（如果不同）。</td></tr><tr><td><code>spring.datasource.separator</code></td><td><code>;</code></td><td>SQL 初始化脚本中的语句分隔符。</td></tr><tr><td><code>spring.datasource.sql-script-encoding</code></td><td></td><td>SQL 脚本编码。</td></tr><tr><td><code>spring.datasource.tomcat.abandon-when-percentage-full</code></td><td><code>spring.datasource.tomcat.access-to-underlying-connection-allowed</code></td><td>绑定到 Tomcat JDBC’s DataSource 实例的 Tomcat 数据源特定设置。</td></tr><tr><td><code>spring.datasource.type</code></td><td></td><td>要使用的连接池实现的全称。默认情况下，它是由 classpath 自动检测的。</td></tr><tr><td><code>spring.datasource.url</code></td><td></td><td>数据库的 JDBC URL。</td></tr><tr><td><code>spring.datasource.username</code></td><td></td><td>数据库的登录用户名。</td></tr><tr><td><code>spring.datasource.xa.data-source-class-name</code></td><td></td><td>XA 数据源完全限定名称。</td></tr><tr><td><code>spring.datasource.xa.properties.*</code></td><td></td><td>要传递给 XA 数据源的属性。</td></tr></tbody></table><h2 id="elasticsearch-1"><a href="#elasticsearch-1" class="headerlink" title="elasticsearch"></a>elasticsearch</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.elasticsearch.rest.connection-timeout</code></td><td><code>1s</code></td><td>连接超时。</td></tr><tr><td><code>spring.elasticsearch.rest.password</code></td><td></td><td>凭证密码。</td></tr><tr><td><code>spring.elasticsearch.rest.read-timeout</code></td><td><code>30s</code></td><td>读取超时。</td></tr><tr><td><code>spring.elasticsearch.rest.uris</code></td><td><code>[http://localhost:9200]</code></td><td>以逗号分隔的 Elasticsearch 实例列表。</td></tr><tr><td><code>spring.elasticsearch.rest.username</code></td><td></td><td>凭证用户名。</td></tr></tbody></table><h2 id="h2"><a href="#h2" class="headerlink" title="h2"></a>h2</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.h2.console.enabled</code></td><td><code>false</code></td><td>是否启用控制台。</td></tr><tr><td><code>spring.h2.console.path</code></td><td><code>/h2-console</code></td><td>控制台所在的路径。</td></tr><tr><td><code>spring.h2.console.settings.trace</code></td><td><code>false</code></td><td>是否启用跟踪输出。</td></tr><tr><td><code>spring.h2.console.settings.web-allow-others</code></td><td><code>false</code></td><td>是否启用远程访问。</td></tr></tbody></table><h2 id="influx"><a href="#influx" class="headerlink" title="influx"></a>influx</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.influx.password</code></td><td></td><td>登录密码。</td></tr><tr><td><code>spring.influx.url</code></td><td></td><td>要连接的 InfluxDB 实例的 URL。</td></tr><tr><td><code>spring.influx.user</code></td><td></td><td>登录用户。</td></tr></tbody></table><h2 id="jdbc-1"><a href="#jdbc-1" class="headerlink" title="jdbc"></a>jdbc</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.jdbc.template.fetch-size</code></td><td><code>-1.0</code></td><td>当需要更多的行时，应该从数据库中获取的行数。使用-1 来使用 JDBC 驱动程序的默认配置。</td></tr><tr><td><code>spring.jdbc.template.max-rows</code></td><td><code>-1.0</code></td><td>最大行数。使用-1 来使用 JDBC 驱动程序的默认配置。</td></tr><tr><td><code>spring.jdbc.template.query-timeout</code></td><td></td><td>查询超时。默认使用 JDBC 驱动程序的默认配置。如果没有指定持续时间后缀，将使用秒。</td></tr></tbody></table><h2 id="jooq"><a href="#jooq" class="headerlink" title="jooq"></a>jooq</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.jooq.sql-dialect</code></td><td></td><td>要使用的 SQL 方言。默认情况下自动检测。</td></tr></tbody></table><h2 id="jpa-1"><a href="#jpa-1" class="headerlink" title="jpa"></a>jpa</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.jpa.database</code></td><td></td><td>要操作的目标数据库，默认为自动检测。也可以使用 “databasePlatform “属性进行设置。</td></tr><tr><td><code>spring.jpa.database-platform</code></td><td></td><td>要操作的目标数据库的名称，默认为自动检测。也可以使用 “数据库 “枚举来设置。</td></tr><tr><td><code>spring.jpa.generate-ddl</code></td><td><code>false</code></td><td>是否在启动时初始化模式。</td></tr><tr><td><code>spring.jpa.hibernate.ddl-auto</code></td><td></td><td>DDL 模式。这实际上是 “hibernate.hbm2ddl.auto “属性的快捷方式。当使用嵌入式数据库且没有检测到模式管理器时，默认为 “create-drop”。否则，默认为 “none”。</td></tr><tr><td><code>spring.jpa.hibernate.naming.implicit-strategy</code></td><td></td><td>隐式命名策略的完全限定名称。</td></tr><tr><td><code>spring.jpa.hibernate.naming.physical-strategy</code></td><td></td><td>物理命名策略的完全限定名称。</td></tr><tr><td><code>spring.jpa.hibernate.use-new-id-generator-mappings</code></td><td></td><td>是否对 AUTO、TABLE 和 SEQUENCE 使用 Hibernate 较新的 IdentifierGenerator。这实际上是 “hibernate.id.new_generator_mappings “属性的快捷方式。当不指定时将默认为 “true”。</td></tr><tr><td><code>spring.jpa.mapping-resources</code></td><td></td><td>映射资源（相当于 persistence.xml 中的 “mapping-file “条目）。</td></tr><tr><td><code>spring.jpa.open-in-view</code></td><td><code>true</code></td><td>注册 OpenEntityManagerInViewInterceptor。将 JPA EntityManager 绑定到线程中，以完成整个请求的处理。</td></tr><tr><td><code>spring.jpa.properties.*</code></td><td></td><td>要在 JPA 提供者上设置的其他本地属性。</td></tr><tr><td><code>spring.jpa.show-sql</code></td><td><code>false</code></td><td>是否启用 SQL 语句的日志记录。</td></tr></tbody></table><h2 id="mongodb-1"><a href="#mongodb-1" class="headerlink" title="mongodb"></a>mongodb</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.mongodb.embedded.features</code></td><td><code>[sync_delay]</code></td><td>逗号分隔的要启用的功能列表。默认使用配置版本的默认值。</td></tr><tr><td><code>spring.mongodb.embedded.storage.database-dir</code></td><td></td><td>用于数据存储的目录。</td></tr><tr><td><code>spring.mongodb.embedded.storage.oplog-size</code></td><td></td><td>oplog 的最大尺寸。</td></tr><tr><td><code>spring.mongodb.embedded.storage.repl-set-name</code></td><td></td><td>复制品套装的名称。</td></tr><tr><td><code>spring.mongodb.embedded.version</code></td><td><code>3.5.5</code></td><td>要使用 Mongo 的版本。</td></tr></tbody></table><h2 id="r2dbc-1"><a href="#r2dbc-1" class="headerlink" title="r2dbc"></a>r2dbc</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.r2dbc.generate-unique-name</code></td><td><code>false</code></td><td>是否随机生成数据库名称。启用后忽略任何配置的名称。</td></tr><tr><td><code>spring.r2dbc.name</code></td><td></td><td>数据库名称。如果在 url 中没有指定名称，则设置。当使用嵌入式数据库时，默认为 “testdb”。</td></tr><tr><td><code>spring.r2dbc.password</code></td><td></td><td>数据库的登录密码。如果在 url 中没有指定密码，则设置。</td></tr><tr><td><code>spring.r2dbc.pool.enabled</code></td><td></td><td>是否启用了池化功能，如果 “r2dbc-pool “在 classpath 上，则自动启用。如果 “r2dbc-pool “在 classpath 上，则自动启用。</td></tr><tr><td><code>spring.r2dbc.pool.initial-size</code></td><td><code>10.0</code></td><td>初始连接池大小。</td></tr><tr><td><code>spring.r2dbc.pool.max-idle-time</code></td><td><code>30m</code></td><td>允许一个连接在池中闲置的最大时间。</td></tr><tr><td><code>spring.r2dbc.pool.max-size</code></td><td><code>10.0</code></td><td>最大连接池大小。</td></tr><tr><td><code>spring.r2dbc.pool.validation-query</code></td><td></td><td>查询验证。</td></tr><tr><td><code>spring.r2dbc.properties.*</code></td><td></td><td>额外的 R2DBC 选项。</td></tr><tr><td><code>spring.r2dbc.url</code></td><td></td><td>数据库名称、用户名、密码和 url 中指定的池选项优先于单个选项。</td></tr><tr><td><code>spring.r2dbc.username</code></td><td></td><td>数据库的登录用户名。如果在 url 中没有指定用户名，则设置。</td></tr></tbody></table><h2 id="redis-1"><a href="#redis-1" class="headerlink" title="redis"></a>redis</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.redis.client-name</code></td><td></td><td>用 CLIENT SETNAME 设置连接的客户端名称。</td></tr><tr><td><code>spring.redis.cluster.max-redirects</code></td><td></td><td>在整个集群中执行命令时要遵循的最大重定向数量。</td></tr><tr><td><code>spring.redis.cluster.nodes</code></td><td></td><td>逗号分隔的 “host:port “对列表，用于引导。这代表了集群节点的 “初始 “列表，需要至少有一个条目。</td></tr><tr><td><code>spring.redis.database</code></td><td><code>0.0</code></td><td>连接工厂使用的数据库索引。</td></tr><tr><td><code>spring.redis.host</code></td><td><code>localhost</code></td><td>Redis 服务器主机。</td></tr><tr><td><code>spring.redis.jedis.pool.max-active</code></td><td><code>8.0</code></td><td>池在特定时间内可分配的最大连接数。使用负值表示没有限制。</td></tr><tr><td><code>spring.redis.jedis.pool.max-idle</code></td><td><code>8.0</code></td><td>池中 “空闲 “连接的最大数量。使用负值表示无限制的空闲连接数。</td></tr><tr><td><code>spring.redis.jedis.pool.max-wait</code></td><td><code>-1ms</code></td><td>连接分配在池用尽时抛出异常前应阻塞的最大时间。使用负值来无限期阻塞。</td></tr><tr><td><code>spring.redis.jedis.pool.min-idle</code></td><td><code>0.0</code></td><td>池中要保持的空闲连接数的最小目标。只有当它和驱逐运行之间的时间都为正值时，这个设置才有效果。</td></tr><tr><td><code>spring.redis.jedis.pool.time-between-eviction-runs</code></td><td></td><td>空闲对象驱逐线程运行的间隔时间。当为正值时，空闲对象驱逐线程启动，否则不执行空闲对象驱逐。</td></tr><tr><td><code>spring.redis.lettuce.cluster.refresh.adaptive</code></td><td><code>false</code></td><td>是否应该使用所有可用的刷新触发器进行自适应拓扑刷新。</td></tr><tr><td><code>spring.redis.lettuce.cluster.refresh.period</code></td><td></td><td>集群拓扑刷新周期。</td></tr><tr><td><code>spring.redis.lettuce.pool.max-active</code></td><td><code>8.0</code></td><td>池在特定时间内可分配的最大连接数。使用负值表示没有限制。</td></tr><tr><td><code>spring.redis.lettuce.pool.max-idle</code></td><td><code>8.0</code></td><td>池中 “空闲 “连接的最大数量。使用负值表示无限制的空闲连接数。</td></tr><tr><td><code>spring.redis.lettuce.pool.max-wait</code></td><td><code>-1ms</code></td><td>连接分配在池用尽时抛出异常前应阻塞的最大时间。使用负值来无限期阻塞。</td></tr><tr><td><code>spring.redis.lettuce.pool.min-idle</code></td><td><code>0.0</code></td><td>池中要保持的空闲连接数的最小目标。只有当它和驱逐运行之间的时间都为正值时，这个设置才有效果。</td></tr><tr><td><code>spring.redis.lettuce.pool.time-between-eviction-runs</code></td><td></td><td>空闲对象驱逐线程运行的间隔时间。当为正值时，空闲对象驱逐线程启动，否则不执行空闲对象驱逐。</td></tr><tr><td><code>spring.redis.lettuce.shutdown-timeout</code></td><td><code>100ms</code></td><td>关机超时。</td></tr><tr><td><code>spring.redis.password</code></td><td></td><td>Redis 服务器的登录密码。</td></tr><tr><td><code>spring.redis.port</code></td><td><code>6379.0</code></td><td>Redis 服务器端口。</td></tr><tr><td><code>spring.redis.sentinel.master</code></td><td></td><td>Redis 服务器的名称。</td></tr><tr><td><code>spring.redis.sentinel.nodes</code></td><td></td><td>以逗号分隔的 “host:port “对列表。</td></tr><tr><td><code>spring.redis.sentinel.password</code></td><td></td><td>用于验证哨兵的密码。</td></tr><tr><td><code>spring.redis.ssl</code></td><td><code>false</code></td><td>是否启用 SSL 支持。</td></tr><tr><td><code>spring.redis.timeout</code></td><td></td><td>连接超时。</td></tr><tr><td><code>spring.redis.url</code></td><td></td><td>连接 URL。覆盖主机、端口和密码。用户被忽略。例如：redis://user:<a href="mailto:password@example.com">password@example.com</a>:6379</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON 属性</title>
      <link href="/091f0d83f102.html"/>
      <url>/091f0d83f102.html</url>
      
        <content type="html"><![CDATA[<h2 id="gson"><a href="#gson" class="headerlink" title="gson"></a>gson</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.gson.date-format</code></td><td></td><td>序列化 Date 对象时使用的格式。</td></tr><tr><td><code>spring.gson.disable-html-escaping</code></td><td></td><td>是否禁用 HTML 字符的转义，如’&lt;’、’&gt;’等。</td></tr><tr><td><code>spring.gson.disable-inner-class-serialization</code></td><td></td><td>是否在序列化过程中排除内部类。</td></tr><tr><td><code>spring.gson.enable-complex-map-key-serialization</code></td><td></td><td>是否启用复杂映射键（即非基元）的序列化。</td></tr><tr><td><code>spring.gson.exclude-fields-without-expose-annotation</code></td><td></td><td>是否将没有 “暴露 “注解的所有字段排除在序列化或反序列化的考虑范围之外。</td></tr><tr><td><code>spring.gson.field-naming-policy</code></td><td></td><td>在序列化和反序列化过程中应适用于对象字段的命名策略。</td></tr><tr><td><code>spring.gson.generate-non-executable-json</code></td><td></td><td>是否在输出前加上一些特殊的文字，生成不可执行的 JSON。</td></tr><tr><td><code>spring.gson.lenient</code></td><td></td><td>是否要对不符合 RFC 4627 的 JSON 进行宽松的解析。</td></tr><tr><td><code>spring.gson.long-serialization-policy</code></td><td></td><td>Long 和 long 类型的序列化策略。</td></tr><tr><td><code>spring.gson.pretty-printing</code></td><td></td><td>是否输出适合页面的序列化 JSON，以实现漂亮的打印。</td></tr><tr><td><code>spring.gson.serialize-nulls</code></td><td></td><td>是否序列化空字段。</td></tr></tbody></table><h2 id="jackson"><a href="#jackson" class="headerlink" title="jackson"></a>jackson</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.jackson.date-format</code></td><td></td><td>日期格式字符串或完全限定的日期格式类名称。例如，<code>yyyy-MM-dd HH:mm:ss</code>。</td></tr><tr><td><code>spring.jackson.default-property-inclusion</code></td><td></td><td>控制序列化过程中对属性的包含。用 Jackson 的 JsonInclude.Include 枚举中的一个值进行配置。</td></tr><tr><td><code>spring.jackson.deserialization.*</code></td><td></td><td>Jackson 开启/关闭影响 Java 对象反序列化方式的功能。</td></tr><tr><td><code>spring.jackson.generator.*</code></td><td></td><td>杰克逊发电机的开/关功能。</td></tr><tr><td><code>spring.jackson.locale</code></td><td></td><td>用于格式化的地域。</td></tr><tr><td><code>spring.jackson.mapper.*</code></td><td></td><td>杰克逊通用开/关功能。</td></tr><tr><td><code>spring.jackson.parser.*</code></td><td></td><td>解析器的杰克逊开/关功能。</td></tr><tr><td><code>spring.jackson.property-naming-strategy</code></td><td></td><td>Jackson 的 PropertyNamingStrategy 的常量之一。也可以是 PropertyNamingStrategy 子类的全限定类名。</td></tr><tr><td><code>spring.jackson.serialization.*</code></td><td></td><td>Jackson 开启/关闭影响 Java 对象序列化方式的功能。</td></tr><tr><td><code>spring.jackson.time-zone</code></td><td></td><td>格式化日期时使用的时区。例如，”America/Los_Angeles “或 “GMT+10”。</td></tr><tr><td><code>spring.jackson.visibility.*</code></td><td></td><td>杰克逊可见性阈值，可用于限制哪些方法（和字段）被自动检测。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>邮件属性</title>
      <link href="/8193ae6cfd9c.html"/>
      <url>/8193ae6cfd9c.html</url>
      
        <content type="html"><![CDATA[<h2 id="mail"><a href="#mail" class="headerlink" title="mail"></a>mail</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.mail.default-encoding</code></td><td><code>UTF-8</code></td><td>默认的 MimeMessage 编码。</td></tr><tr><td><code>spring.mail.host</code></td><td></td><td>SMTP 服务器主机。例如，<code>smtp.example.com</code>。</td></tr><tr><td><code>spring.mail.jndi-name</code></td><td></td><td>会话 JNDI 名称。设置后，优先于其他会话设置。</td></tr><tr><td><code>spring.mail.password</code></td><td></td><td>SMTP 服务器的登录密码。</td></tr><tr><td><code>spring.mail.port</code></td><td></td><td>SMTP 服务器端口。</td></tr><tr><td><code>spring.mail.properties.*</code></td><td></td><td>附加的 JavaMail 会话属性。</td></tr><tr><td><code>spring.mail.protocol</code></td><td><code>smtp</code></td><td>SMTP 服务器使用的协议。</td></tr><tr><td><code>spring.mail.test-connection</code></td><td><code>false</code></td><td>是否要测试邮件服务器在启动时是否可用。</td></tr><tr><td><code>spring.mail.username</code></td><td></td><td>SMTP 服务器的登录用户。</td></tr></tbody></table><h2 id="sendgrid"><a href="#sendgrid" class="headerlink" title="sendgrid"></a>sendgrid</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.sendgrid.api-key</code></td><td></td><td>SendGrid API 密钥。</td></tr><tr><td><code>spring.sendgrid.proxy.host</code></td><td></td><td>SendGrid 代理主机。</td></tr><tr><td><code>spring.sendgrid.proxy.port</code></td><td></td><td>SendGrid 代理端口。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存属性</title>
      <link href="/cfa84fd74626.html"/>
      <url>/cfa84fd74626.html</url>
      
        <content type="html"><![CDATA[<h2 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.cache.cache-names</code></td><td></td><td>逗号分隔的缓存名称列表，如果底层缓存管理器支持的话，可以创建。通常情况下，这将禁用创建额外缓存的功能。</td></tr><tr><td><code>spring.cache.caffeine.spec</code></td><td></td><td>用来创建缓存的规格。关于规格格式的更多细节请参见 CaffeineSpec。</td></tr><tr><td><code>spring.cache.couchbase.expiration</code></td><td></td><td>条目过期。默认情况下，条目永不过期。请注意，这个值最终会换算成秒。</td></tr><tr><td><code>spring.cache.ehcache.config</code></td><td></td><td>用于初始化 EhCache 的配置文件的位置。</td></tr><tr><td><code>spring.cache.infinispan.config</code></td><td></td><td>用于初始化 Infinispan 的配置文件的位置。</td></tr><tr><td><code>spring.cache.jcache.config</code></td><td></td><td>用于初始化缓存管理器的配置文件的位置。配置文件的位置取决于底层的缓存实现。</td></tr><tr><td><code>spring.cache.jcache.provider</code></td><td></td><td>CachingProvider 实现的完全限定名称，用于检索符合 JSR-107 的缓存管理器。只有当 classpath 上有多个 JSR-107 实现时才需要。</td></tr><tr><td><code>spring.cache.redis.cache-null-values</code></td><td><code>true</code></td><td>允许缓存空值。</td></tr><tr><td><code>spring.cache.redis.key-prefix</code></td><td></td><td>键前缀。</td></tr><tr><td><code>spring.cache.redis.time-to-live</code></td><td></td><td>条目过期。默认情况下，条目永不过期。</td></tr><tr><td><code>spring.cache.redis.use-key-prefix</code></td><td><code>true</code></td><td>写入 Redis 时是否使用键前缀。</td></tr><tr><td><code>spring.cache.type</code></td><td></td><td>缓存类型。默认情况下，根据环境自动检测。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>核心属性</title>
      <link href="/f5ec6e6d230c.html"/>
      <url>/f5ec6e6d230c.html</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>debug</code></td><td><code>false</code></td><td>启用调试日志。</td></tr><tr><td><code>info.*</code></td><td></td><td>要添加到信息的任意属性。</td></tr><tr><td><code>trace</code></td><td><code>false</code></td><td>启用追踪日志。</td></tr></tbody></table><h2 id="loggin"><a href="#loggin" class="headerlink" title="loggin"></a>loggin</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>logging.config</code></td><td></td><td>日志配置文件的位置。例如，<code>classpath:logback.xml</code>代表 Logback。</td></tr><tr><td><code>logging.exception-conversion-word</code></td><td><code>%wEx</code></td><td>记录异常时使用的转换词。</td></tr><tr><td><code>logging.file.clean-history-on-start</code></td><td><code>false</code></td><td>是否在启动时清理存档日志文件。仅支持默认的 logback 设置。</td></tr><tr><td><code>logging.file.max-history</code></td><td><code>7.0</code></td><td>存档日志文件的最大保存天数。仅支持默认的 logback 设置。</td></tr><tr><td><code>logging.file.max-size</code></td><td><code>10MB</code></td><td>最大日志文件大小。仅支持默认的 logback 设置。</td></tr><tr><td><code>logging.file.name</code></td><td></td><td>文件名（例如，<code>myapp.log</code>）。名称可以是确切的位置，也可以是当前目录的相对位置。</td></tr><tr><td><code>logging.file.path</code></td><td></td><td>日志文件的位置。例如，<code>/var/log</code>。</td></tr><tr><td><code>logging.file.total-size-cap</code></td><td><code>0B</code></td><td>要保存的日志备份的总大小。仅支持默认的 logback 设置。</td></tr><tr><td><code>logging.group.*</code></td><td></td><td>日志组可以同时快速删除多个记录器。例如，<code>logging.group.db=org.hibernate,org.springframework.jdbc</code>。</td></tr><tr><td><code>logging.level.*</code></td><td></td><td>等级严重性映射。例如，<code>logging.level.org.springframework=DEBUG</code>。</td></tr><tr><td><code>logging.pattern.console</code></td><td><code>%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;</code></td><td>输出到衰减日志的格式。</td></tr><tr><td><code>logging.pattern.dateformat</code></td><td><code>yyyy-MM-dd HH:mm:ss.SSS</code></td><td>日志中日期的起始日期。仅支持默认的 logback 设置。</td></tr><tr><td><code>logging.pattern.file</code></td><td><code>%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125; $&#123;LOG_LEVEL_PATTERN:-%5p&#125; $&#123;PID:- &#125; --- [%t] %-40.40logger&#123;39&#125; : %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;</code></td><td>输出到文件日志的格式。</td></tr><tr><td><code>logging.pattern.level</code></td><td><code>%5p</code></td><td>日志级别的应用者模式。仅支持默认的 logback 设置。</td></tr><tr><td><code>logging.pattern.rolling-file-name</code></td><td><code>$&#123;LOG_FILE&#125;.%d&#123;yyyy-MM-dd&#125;.%i.gz</code></td><td>滚动日志文件名的模式。仅支持默认的 logback 设置。</td></tr><tr><td><code>logging.register-shutdown-hook</code></td><td><code>false</code></td><td>在初始化日志系统时，你自己注册了一个关闭钩子。</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="aop"><a href="#aop" class="headerlink" title="aop"></a>aop</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.aop.auto</code></td><td><code>true</code></td><td>添加@EnableAspectJAutoProxy。</td></tr><tr><td><code>spring.aop.proxy-target-class</code></td><td><code>true</code></td><td>是否要创建基于子类的（CGLIB）代理（true），而不是基于标准 Java 接口的代理（false）。</td></tr></tbody></table><h2 id="application"><a href="#application" class="headerlink" title="application"></a>application</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.application.admin.enabled</code></td><td><code>false</code></td><td>是否可以应用程序的管理功能。</td></tr><tr><td><code>spring.application.admin.jmx-name</code></td><td><code>org.springframework.boot:type=Admin,name=SpringApplication</code></td><td>应用管理 MBean 的 JMX 名称。</td></tr><tr><td><code>spring.application.name</code></td><td></td><td>应用名称。</td></tr></tbody></table><h2 id="autoconfigure"><a href="#autoconfigure" class="headerlink" title="autoconfigure"></a>autoconfigure</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.autoconfigure.exclude</code></td><td></td><td>要排除的自动配置类。</td></tr></tbody></table><h2 id="banner"><a href="#banner" class="headerlink" title="banner"></a>banner</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.banner.charset</code></td><td><code>UTF-8</code></td><td>横幅文件编码。</td></tr><tr><td><code>spring.banner.image.bitdepth</code></td><td><code>4.0</code></td><td>支持的值为 4（16 色）或 8（256 色）。</td></tr><tr><td><code>spring.banner.image.height</code></td><td></td><td>图像横幅的高度，单位为 chars（默认基于图像高度）。</td></tr><tr><td><code>spring.banner.image.invert</code></td><td><code>false</code></td><td>暗终端主题的图片是否应该倒置。</td></tr><tr><td><code>spring.banner.image.location</code></td><td><code>classpath:banner.gif</code></td><td>横幅图片文件位置（也可使用 jpg 或 png）。</td></tr><tr><td><code>spring.banner.image.margin</code></td><td><code>2.0</code></td><td>左手图像边距，单位为字符。</td></tr><tr><td><code>spring.banner.image.pixelmode</code></td><td><code>TEXT</code></td><td>渲染图像时要使用像素模式。</td></tr><tr><td><code>spring.banner.image.width</code></td><td><code>76.0</code></td><td>图片横幅的宽度，单位为字符。</td></tr><tr><td><code>spring.banner.location</code></td><td><code>classpath:banner.txt</code></td><td>横幅文字资源位置。</td></tr><tr><td><code>spring.beaninfo.ignore</code></td><td><code>true</code></td><td>是否跳过对 BeanInfo 类的搜索。</td></tr></tbody></table><h2 id="codec"><a href="#codec" class="headerlink" title="codec"></a>codec</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.codec.log-request-details</code></td><td><code>false</code></td><td>否在 DEBUG 级别记录表格数据，在 TRACE 级别记录标题。</td></tr><tr><td><code>spring.codec.max-in-memory-size</code></td><td></td><td>一组需要聚合输入流时，可以缓冲的字节数的限制。这仅适用于自动配置的 WebFlux 服务器和 WebClient 实例。默认情况下，该选项设置设置，在这种情况下，适用于各编解码器的默认值。大多数解码器默认限制为 256K。</td></tr></tbody></table><h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.config.additional-location</code></td><td></td><td>除默认值外，还使用的配置文件位置。</td></tr><tr><td><code>spring.config.location</code></td><td></td><td>替换默认值的配置文件位置。</td></tr><tr><td><code>spring.config.name</code></td><td><code>application</code></td><td>配置文件名。</td></tr></tbody></table><h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.info.build.encoding</code></td><td><code>UTF-8</code></td><td>文件编码。</td></tr><tr><td><code>spring.info.build.location</code></td><td><code>classpath:META-INF/build-info.properties</code></td><td>生成的 build-info.properties 文件的位置。</td></tr><tr><td><code>spring.info.git.encoding</code></td><td><code>UTF-8</code></td><td>文件编码。</td></tr><tr><td><code>spring.info.git.location</code></td><td><code>classpath:git.properties</code></td><td>生成的 git.properties 文件的位置。</td></tr></tbody></table><h2 id="jmx"><a href="#jmx" class="headerlink" title="jmx"></a>jmx</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.jmx.default-domain</code></td><td></td><td>JMX 域名。</td></tr><tr><td><code>spring.jmx.enabled</code></td><td><code>false</code></td><td>将管理 Bean 暴露给 JMX 域。</td></tr><tr><td><code>spring.jmx.server</code></td><td><code>mbeanServer</code></td><td>MBeanServer bean 名称。</td></tr><tr><td><code>spring.jmx.unique-names</code></td><td><code>false</code></td><td>是否应保证运行时对象名称唯一。</td></tr></tbody></table><h2 id="lifecycle"><a href="#lifecycle" class="headerlink" title="lifecycle"></a>lifecycle</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.lifecycle.timeout-per-shutdown-phase</code></td><td><code>30s</code></td><td>任何阶段（“阶段”值的 SmartLifecycle beans 组）的关闭超时。</td></tr></tbody></table><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.main.allow-bean-definition-overriding</code></td><td><code>false</code></td><td>是否允许 bean 定义覆盖，通过注册和现有定义同名的定义。</td></tr><tr><td><code>spring.main.banner-mode</code></td><td><code>console</code></td><td>应用程序运行时用于显示横幅的模式。</td></tr><tr><td><code>spring.main.cloud-platform</code></td><td></td><td>覆盖云平台自动检测。</td></tr><tr><td><code>spring.main.lazy-initialization</code></td><td><code>false</code></td><td>是否应该懒惰地进行初始化。</td></tr><tr><td><code>spring.main.log-startup-info</code></td><td><code>true</code></td><td>是否在启动时记录应用程序的信息。</td></tr><tr><td><code>spring.main.register-shutdown-hook</code></td><td><code>true</code></td><td>应用程序应该注册一个朝鲜钩。</td></tr><tr><td><code>spring.main.sources</code></td><td></td><td>要包含在 ApplicationContext 中的源（类名、包名或 XML 资源位置）。</td></tr><tr><td><code>spring.main.web-application-type</code></td><td></td><td>用于显式请求特定类型的 Web 应用程序的标志，如果没有设置，则根据类路径自动检测。如果没有设置，则根据类路径自动检测。</td></tr></tbody></table><h2 id="mandatory-flie-encoding"><a href="#mandatory-flie-encoding" class="headerlink" title="mandatory-flie-encoding"></a>mandatory-flie-encoding</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.mandatory-file-encoding</code></td><td></td><td>应用程序必须使用的预期字符编码。</td></tr></tbody></table><h2 id="messages"><a href="#messages" class="headerlink" title="messages"></a>messages</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.messages.always-use-message-format</code></td><td><code>false</code></td><td>是否总是应用 MessageFormat 规则，甚至解析没有参数的消息。</td></tr><tr><td><code>spring.messages.basename</code></td><td><code>messages</code></td><td>（以治疗伤害的基名列表位置本质上是一个完全限定的类路径），每个基名位置都遵循资源边界，但对基于斜杠的包的支持。如果它不包含修饰符（如”org.mypackage”），可以生成类路径根目录解析。</td></tr><tr><td><code>spring.messages.cache-duration</code></td><td></td><td>加载的资源捆绑文件缓存时间。未设置时间，捆绑文件将被永久缓存。如果没有指定持续时间的后缀，将使用秒。</td></tr><tr><td><code>spring.messages.encoding</code></td><td><code>UTF-8</code></td><td>信息捆绑编码。</td></tr><tr><td><code>spring.messages.fallback-to-system-locale</code></td><td><code>true</code></td><td>如果关闭了这个功能，唯一的回退将是默认文件（例如“messages “基名的”messages.properties”）。</td></tr><tr><td><code>spring.messages.use-code-as-default-message</code></td><td><code>false</code></td><td>是否使用消息代码作为默认消息，而不是抛出“NoSuchMessageException”。仅在开发过程中推荐使用。</td></tr></tbody></table><h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.output.ansi.enabled</code></td><td><code>detect</code></td><td>配置 ANSI 输出。</td></tr></tbody></table><h2 id="pid"><a href="#pid" class="headerlink" title="pid"></a>pid</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.pid.fail-on-write-error</code></td><td></td><td>如果使用 ApplicationPidFileWriter 但不能写入 PID 文件，则失败。</td></tr><tr><td><code>spring.pid.file</code></td><td></td><td>要写入的 PID 文件的位置（如果使用 ApplicationPidFileWriter）。</td></tr></tbody></table><h2 id="profiles"><a href="#profiles" class="headerlink" title="profiles"></a>profiles</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.profiles</code></td><td></td><td>以采取措施的配置文件表达式列表，至少有一个应接匹配，将文件包含时间。</td></tr><tr><td><code>spring.profiles.active</code></td><td></td><td>手动命令行开关检测。</td></tr><tr><td><code>spring.profiles.include</code></td><td></td><td>无条件激活指定的以故障排除的配置文件列表（如果使用 YAML，则激活配置文件列表）。</td></tr></tbody></table><h2 id="quartz"><a href="#quartz" class="headerlink" title="quartz"></a>quartz</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.quartz.auto-startup</code></td><td><code>true</code></td><td>是否在初始化后自动启动调度器。</td></tr><tr><td><code>spring.quartz.jdbc.comment-prefix</code></td><td><code>[#, --]</code></td><td>SQL 初始化脚本中单行注释的前缀。</td></tr><tr><td><code>spring.quartz.jdbc.initialize-schema</code></td><td><code>embedded</code></td><td>数据库模式初始化模式。</td></tr><tr><td><code>spring.quartz.jdbc.schema</code></td><td><code>classpath:org/quartz/impl/jdbcjobstore/tables_@@platform@@.sql</code></td><td>用于初始化数据库模式的 SQL 文件的路径。</td></tr><tr><td><code>spring.quartz.job-store-type</code></td><td><code>memory</code></td><td>石英工作店型。</td></tr><tr><td><code>spring.quartz.overwrite-existing-jobs</code></td><td><code>false</code></td><td>配置的作业是否应该覆盖现有的作业定义。</td></tr><tr><td><code>spring.quartz.properties.*</code></td><td></td><td>额外的 Quartz Scheduler 属性。</td></tr><tr><td><code>spring.quartz.scheduler-name</code></td><td><code>quartzScheduler</code></td><td>调度器的名称。</td></tr><tr><td><code>spring.quartz.startup-delay</code></td><td><code>0s</code></td><td>初始化完成后调度器启动的延迟时间。如果在整个应用程序启动之前不需要运行任何作业，那么设置这个属性是有意义的。</td></tr><tr><td><code>spring.quartz.wait-for-jobs-to-complete-on-shutdown</code></td><td><code>false</code></td><td>是否在关机时等待运行的工作完成。</td></tr></tbody></table><h2 id="reactor"><a href="#reactor" class="headerlink" title="reactor"></a>reactor</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.reactor.debug-agent.enabled</code></td><td><code>true</code></td><td>反应堆调试代理是否应该在反应堆工具存在时启用。</td></tr></tbody></table><h2 id="task"><a href="#task" class="headerlink" title="task"></a>task</h2><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>spring.task.execution.pool.allow-core-thread-timeout</code></td><td><code>true</code></td><td>是否允许核心线程超时。这样可以实现池的动态增长和收缩。</td></tr><tr><td><code>spring.task.execution.pool.core-size</code></td><td><code>8.0</code></td><td>核心线程数。</td></tr><tr><td><code>spring.task.execution.pool.keep-alive</code></td><td><code>60s</code></td><td>线程在被终止前可以保持空闲的时间限制。</td></tr><tr><td><code>spring.task.execution.pool.max-size</code></td><td></td><td>允许的最大线程数。如果任务占满了队列，池可以扩展到该大小以适应负载。如果队列是无约束的，则忽略。</td></tr><tr><td><code>spring.task.execution.pool.queue-capacity</code></td><td></td><td>队列容量。无限制的容量不会增加队列池，因此忽略了 “最大容量 “属性。</td></tr><tr><td><code>spring.task.execution.shutdown.await-termination</code></td><td><code>false</code></td><td>执行者是否应该在关机时等待预定任务完成。</td></tr><tr><td><code>spring.task.execution.shutdown.await-termination-period</code></td><td></td><td>执行者应等待剩余任务完成的最长时间。</td></tr><tr><td><code>spring.task.execution.thread-name-prefix</code></td><td><code>task-</code></td><td>用于新创建的线程名称的前缀。</td></tr><tr><td><code>spring.task.scheduling.pool.size</code></td><td><code>1.0</code></td><td>允许的最大线程数。</td></tr><tr><td><code>spring.task.scheduling.shutdown.await-termination</code></td><td><code>false</code></td><td>执行者是否应该在关机时等待预定任务完成。</td></tr><tr><td><code>spring.task.scheduling.shutdown.await-termination-period</code></td><td></td><td>执行者应等待剩余任务完成的最长时间。</td></tr><tr><td><code>spring.task.scheduling.thread-name-prefix</code></td><td><code>scheduling-</code></td><td>用于新创建的线程名称的前缀。</td></tr></tbody></table><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动配置原理入门</title>
      <link href="/18ac9d961f0b.html"/>
      <url>/18ac9d961f0b.html</url>
      
        <content type="html"><![CDATA[<p>在 SpringBoot 中启动类我们都会标注</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br></pre></td></tr></table></figure><p>而这个注解是一个合并注解</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br></pre></td></tr></table></figure><p>而这个注解中 除了 元注解 (@Target/@Retention/@Documented/@Inherited) 还剩下了三个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br></pre></td></tr></table></figure><h2 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = Configuration.class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 元注解 只有 <code>@Configuration</code> 这个表明这是个配置类</p><h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h2><p>指定扫描</p><h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启用自动配置时可用于覆盖的环境属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String ENABLED_OVERRIDE_PROPERTY = <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排除特定的自动配置类，以便它们永远不会被应用。</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> * 要排除的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排除特定的自动配置类名称，以便它们永远不会被应用。</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> * 要排除的类名</span></span><br><span class="line"><span class="comment"> * 因为：</span></span><br><span class="line"><span class="comment"> * 1.3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个注解中除了元注解还有两个特别的注解<code>@AutoConfigurationPackage</code>和<code>@Import(AutoConfigurationImportSelector.class)</code></p><p>其中<code>@Import</code> 是用来导入配置类或者一些需要前置加载的类</p><h3 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个注解中 除了元注解 也是导入了一个配置类<br>那么应该可以肯定 在 SpringBoot 启动过程中所有的加载 都在这两个类中</p><p>让我们先来看看<code>AutoConfigurationPackages.Registrar.class</code> 这里面到底导入了什么</p><h4 id="AutoConfigurationPackages-Registrar-class"><a href="#AutoConfigurationPackages-Registrar-class" class="headerlink" title="AutoConfigurationPackages.Registrar.class"></a>AutoConfigurationPackages.Registrar.class</h4><p>进入端点<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/241578/1625650563370-e6f7c534-45bc-486d-8c77-bfd7a1118cec.png#align=left&display=inline&height=555&margin=%5Bobject%20Object%5D&name=image.png&originHeight=555&originWidth=1195&size=93522&status=done&style=none&width=1195" alt="image.png" referrerpolicy="no-referrer"><br>预估表达式<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/241578/1625650595010-0358a342-74e1-497b-941b-a09663c21776.png#align=left&display=inline&height=949&margin=%5Bobject%20Object%5D&name=image.png&originHeight=949&originWidth=593&size=47121&status=done&style=none&width=593" alt="image.png" referrerpolicy="no-referrer"><br>这个不就是我自身的包名称吗<br>根据名称 差不多也猜出来了 配置 application.java 下所有的文件<br>入门这里就差不多了 还想的自己打断点<br>来我们换一个看看</p><h2 id="AutoConfigurationImportSelector"><a href="#AutoConfigurationImportSelector" class="headerlink" title="AutoConfigurationImportSelector"></a>AutoConfigurationImportSelector</h2><p>看这里面又导入了什么东西</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line"><span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">&#125;</span><br><span class="line">AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">    <span class="comment">//预估计算</span></span><br><span class="line">List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">configurations = removeDuplicates(configurations);</span><br><span class="line">Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">checkExcludedClasses(configurations, exclusions);</span><br><span class="line">configurations.removeAll(exclusions);</span><br><span class="line">configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/241578/1625651864226-ecc95e73-bc3d-4379-ac36-daf9abeb3c70.png#align=left&display=inline&height=949&margin=%5Bobject%20Object%5D&name=image.png&originHeight=949&originWidth=1192&size=195323&status=done&style=none&width=1192" alt="image.png" referrerpolicy="no-referrer"><br>看看这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">getBeanClassLoader());</span><br><span class="line">Assert.notEmpty(configurations, <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span></span><br><span class="line">+ <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再往下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用给定的类加载器从&quot;META-INF/spring.factories&quot;加载给定类型的工厂实现的完全限定类名。</span></span><br><span class="line"><span class="comment"> * 参数：</span></span><br><span class="line"><span class="comment"> * factoryType – 代表工厂的接口或抽象类</span></span><br><span class="line"><span class="comment"> * classLoader – 用于加载资源的 ClassLoader； 可以为null以使用默认值</span></span><br><span class="line"><span class="comment"> * 顶：</span></span><br><span class="line"><span class="comment"> * IllegalArgumentException – 如果在加载工厂名称时发生错误</span></span><br><span class="line"><span class="comment"> * 请参见：</span></span><br><span class="line"><span class="comment"> * loadFactories</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">String factoryTypeName = factoryType.getName();</span><br><span class="line"><span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确实文件都是从<code>META-INF/spring.factories</code>文件中加载的<br>而 SpringBoot 的大部分都在<code>spring-boot-autoconfigure-2.*.*.RELEASE.jar</code>下的<code>META-INF/spring.factories</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span><br><span class="line"></span><br><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Listeners</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Filters</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnBeanCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnClassCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition</span><br><span class="line"></span><br><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br></pre></td></tr></table></figure><p>当然这些文件不是都加载的<br>都加载了内存会炸的<br>而选择性加载全靠<code>@Conditional</code>和他相似的注解</p>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js安装</title>
      <link href="/cfd6d46b475d.html"/>
      <url>/cfd6d46b475d.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h1><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://nodejs.org/en/</span><br></pre></td></tr></table></figure><h1 id><a href="#" class="headerlink" title></a><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/241578/1625556470719-f9200f9f-01cf-4d2b-8ecb-b196aba8e461.png#align=left&display=inline&height=778&margin=%5Bobject%20Object%5D&name=image.png&originHeight=778&originWidth=919&size=71908&status=done&style=none&width=919" alt="image.png" referrerpolicy="no-referrer"></h1><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/241578/1625556441033-6aba2928-e991-4e70-a124-2fe968081159.png#align=left&display=inline&height=646&margin=%5Bobject%20Object%5D&name=image.png&originHeight=646&originWidth=1543&size=209317&status=done&style=none&width=1543" alt="image.png" referrerpolicy="no-referrer"></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="双击安装包就好了"><a href="#双击安装包就好了" class="headerlink" title="双击安装包就好了"></a>双击安装包就好了</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/241578/1625556501316-3e4a9514-4554-47d7-b78c-e21eb3280b54.png#align=left&display=inline&height=387&margin=%5Bobject%20Object%5D&name=image.png&originHeight=387&originWidth=495&size=67170&status=done&style=none&width=495" alt="image.png" referrerpolicy="no-referrer"></p><h2 id="勾选"><a href="#勾选" class="headerlink" title="勾选"></a>勾选</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/241578/1625556539659-ee1591d1-4c19-4b9d-9a5a-576812c52db3.png#align=left&display=inline&height=387&margin=%5Bobject%20Object%5D&name=image.png&originHeight=387&originWidth=495&size=54377&status=done&style=none&width=495" alt="image.png" referrerpolicy="no-referrer"></p><h2 id="安装盘"><a href="#安装盘" class="headerlink" title="安装盘"></a>安装盘</h2><p>默认是 C 盘 根据自己情况选择<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/241578/1625556568852-1ab8e6fc-3e2d-4401-92d5-d0444464b3d7.png#align=left&display=inline&height=387&margin=%5Bobject%20Object%5D&name=image.png&originHeight=387&originWidth=495&size=23674&status=done&style=none&width=495" alt="image.png" referrerpolicy="no-referrer"></p><h2 id="选择安装"><a href="#选择安装" class="headerlink" title="选择安装"></a>选择安装</h2><p>可以自己选择 我这里就全部了 最后一个是环境变量 没有变成红色叉叉的盒子就是要安装<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/241578/1625556623778-e97b02e2-27c5-4179-909e-35c70d7608f1.png#align=left&display=inline&height=387&margin=%5Bobject%20Object%5D&name=image.png&originHeight=387&originWidth=495&size=42814&status=done&style=none&width=495" alt="image.png" referrerpolicy="no-referrer"></p><h2 id="安装-Python-和-VS-build-tools"><a href="#安装-Python-和-VS-build-tools" class="headerlink" title="安装 Python 和 VS build tools"></a>安装 Python 和 VS build tools</h2><p>这个也说清楚了 就是在一些模块的编译的时候需要这两个东西 避免到时候出现奇奇怪怪的问题 我还是勾上了 毕竟 前端我确实不太行<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/241578/1625556759661-c3ced1c3-85b3-43ad-94f2-77fa0533bda5.png#align=left&display=inline&height=387&margin=%5Bobject%20Object%5D&name=image.png&originHeight=387&originWidth=495&size=39533&status=done&style=none&width=495" alt="image.png" referrerpolicy="no-referrer"></p><h2 id="然后就是一路-Next"><a href="#然后就是一路-Next" class="headerlink" title="然后就是一路 Next"></a>然后就是一路 Next</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/241578/1625556866835-b2ddfc58-5f38-4169-ac2b-a9d7d5156755.png#align=left&display=inline&height=387&margin=%5Bobject%20Object%5D&name=image.png&originHeight=387&originWidth=495&size=26915&status=done&style=none&width=495" alt="image.png" referrerpolicy="no-referrer"></p><h2 id="最后点-Finish"><a href="#最后点-Finish" class="headerlink" title="最后点 Finish"></a>最后点 Finish</h2><p>出现 这个愿意是因为勾选那个 安装 Python 和 VS build tools<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/241578/1625556927852-721fdecb-67dc-4b67-8b20-98a41ff70e6a.png#align=left&display=inline&height=512&margin=%5Bobject%20Object%5D&name=image.png&originHeight=512&originWidth=979&size=32924&status=done&style=none&width=979" alt="image.png" referrerpolicy="no-referrer"></p><h2 id="任意键继续"><a href="#任意键继续" class="headerlink" title="任意键继续"></a>任意键继续</h2><p>我就一路回车了<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/241578/1625557103400-6c8140ad-e933-4539-b8ca-0dfc8a2bc4b5.png#align=left&display=inline&height=600&margin=%5Bobject%20Object%5D&name=image.png&originHeight=600&originWidth=840&size=63149&status=done&style=none&width=840" alt="image.png" referrerpolicy="no-referrer"><br>等这个安装<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/241578/1625558068499-8b24e999-1d39-4d38-8eea-54f0625c04da.png#align=left&display=inline&height=600&margin=%5Bobject%20Object%5D&name=image.png&originHeight=600&originWidth=840&size=60392&status=done&style=none&width=840" alt="image.png" referrerpolicy="no-referrer"></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/241578/1625558102318-1ea68c86-0216-42f1-bd49-2551dd876801.png#align=left&display=inline&height=411&margin=%5Bobject%20Object%5D&name=image.png&originHeight=411&originWidth=713&size=60670&status=done&style=none&width=713" alt="image.png" referrerpolicy="no-referrer"></p><h1 id="输入-CMD"><a href="#输入-CMD" class="headerlink" title="输入 CMD"></a>输入 CMD</h1><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/241578/1625558133555-a401a26e-c58e-4287-90cc-07b6e5fc07e8.png#align=left&display=inline&height=397&margin=%5Bobject%20Object%5D&name=image.png&originHeight=397&originWidth=752&size=66295&status=done&style=none&width=752" alt="image.png" referrerpolicy="no-referrer"></p><h1 id="查看版本和安装情况"><a href="#查看版本和安装情况" class="headerlink" title="查看版本和安装情况"></a>查看版本和安装情况</h1><p>为什么我这个颜色不一样 因为在<code>node -v</code>的时候权限不够 就开了管理员模式<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/241578/1625558313071-95499bb7-9f3b-47e7-b95f-1a100e322352.png#align=left&display=inline&height=600&margin=%5Bobject%20Object%5D&name=image.png&originHeight=600&originWidth=960&size=20090&status=done&style=none&width=960" alt="image.png" referrerpolicy="no-referrer"></p><h1 id="npm-安装文件地址修改"><a href="#npm-安装文件地址修改" class="headerlink" title="npm 安装文件地址修改"></a>npm 安装文件地址修改</h1><p>这是安装后的地址 明显不对 不想把这个东西装到 C 盘 我想的时候和 nodejs 在一起<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/241578/1625558438615-1b324558-b240-4a13-96a1-83f9e55109ac.png#align=left&display=inline&height=363&margin=%5Bobject%20Object%5D&name=image.png&originHeight=363&originWidth=761&size=77514&status=done&style=none&width=761" alt="image.png" referrerpolicy="no-referrer"><br>我们先回到安装 nodejs 的文件夹 创建两个文件夹 cache 目录要使用后才会生成 所以在上面的目录种没有<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/241578/1625558566981-0cf38ff9-abf7-4d6a-8b8f-09d898d894a9.png#align=left&display=inline&height=429&margin=%5Bobject%20Object%5D&name=image.png&originHeight=429&originWidth=819&size=74286&status=done&style=none&width=819" alt="image.png" referrerpolicy="no-referrer"><br>修改命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">&quot;D:\Program Files\nodejs\node_global&quot;</span></span><br><span class="line">npm config <span class="built_in">set</span> cache <span class="string">&quot;D:\Program Files\nodejs\node_cache&quot;</span></span><br></pre></td></tr></table></figure><p>检查 <code>npm list -global</code><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/241578/1625558793640-59dc44fe-db15-479a-b450-2efce779876d.png#align=left&display=inline&height=600&margin=%5Bobject%20Object%5D&name=image.png&originHeight=600&originWidth=960&size=25996&status=done&style=none&width=960" alt="image.png" referrerpolicy="no-referrer"></p><h1 id="更换镜像-自己选择"><a href="#更换镜像-自己选择" class="headerlink" title="更换镜像(自己选择)"></a>更换镜像(自己选择)</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry=http://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h1 id="查看所有配置"><a href="#查看所有配置" class="headerlink" title="查看所有配置"></a>查看所有配置</h1><p>目录<code>C:\Users\Bells\.npmrc</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config list</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/241578/1625559034344-9e212c8e-f656-4e3c-a4cd-508a2838727c.png#align=left&display=inline&height=280&margin=%5Bobject%20Object%5D&name=image.png&originHeight=280&originWidth=512&size=14988&status=done&style=none&width=512" alt="image.png" referrerpolicy="no-referrer"></p>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 配置 (备份文件方便复制)</title>
      <link href="/a911b7f249e6.html"/>
      <url>/a911b7f249e6.html</url>
      
        <content type="html"><![CDATA[<p>路径:<code>/conf/settings.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\develop\repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">proxies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">proxies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Java </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Contos 7 开放端口(Firewall-Cmd)</title>
      <link href="/b2be80fe9e8f.html"/>
      <url>/b2be80fe9e8f.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看状态</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止</span></span><br><span class="line">systemctl disable firewalld</span><br><span class="line"><span class="meta">#</span><span class="bash"> 禁用</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开机时启用一个服务</span></span><br><span class="line">systemctl enable firewalld.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开机时禁用一个服务</span></span><br><span class="line">systemctl disable firewalld.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看服务是否开机启动</span></span><br><span class="line">systemctl is-enable firewalld.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看以启动的服务列表</span></span><br><span class="line">systemctl list-unit-files|grep enable</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看启动失败的服务列表</span></span><br><span class="line">systemctl-failed</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="配置-firewalld"><a href="#配置-firewalld" class="headerlink" title="配置 firewalld"></a>配置 firewalld</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line">firewall-cmd --version</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看帮助</span></span><br><span class="line">firewall-cmd --help</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示状态</span></span><br><span class="line">firewall-cmd --state</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看防火墙规则</span></span><br><span class="line">firewall-cmd --list-all</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有打开的端口</span></span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新防火墙规则</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看区域信息</span></span><br><span class="line">firewall-cmd --get-active-zones</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看只当接口所属区域</span></span><br><span class="line">firewall-cmd --get-zone-of-interface=eth0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拒绝所有包</span></span><br><span class="line">firewall-cmd --panic-on</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消拒绝状态</span></span><br><span class="line">firewall-cmd --panic-off</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看是否拒绝</span></span><br><span class="line">firewall-cmd --query-panic</span><br></pre></td></tr></table></figure><h1 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开放端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=8088/tcp --add-port=8089-8099/tcp --permanent</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开放的服务时http协议</span></span><br><span class="line">firewall-cmd --zone=public --add-service=http --permanent</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看端口是否生效</span></span><br><span class="line">firewall-cmd --zone=public --query-post=8088/tcp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除开启端口</span></span><br><span class="line">firewall-cmd --zone=public --remove-port=8088/tcp --permanent</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生效配置</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Linux </tag>
            
            <tag> Contos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos 7 更新Yum</title>
      <link href="/da07fbdb9fd0.html"/>
      <url>/da07fbdb9fd0.html</url>
      
        <content type="html"><![CDATA[<h1 id="进入-yum-源目录"><a href="#进入-yum-源目录" class="headerlink" title="进入 yum 源目录"></a>进入 yum 源目录</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 进入yum源目录</span><br><span class="line">cd /etc/yum.repos.d/</span><br><span class="line">2. 查看目录文件</span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line">[root@localhost shiyi]# cd /etc/yum.repos.d</span><br><span class="line">[root@localhost yum.repos.d]# ls</span><br><span class="line">CentOS-Base.repo  CentOS-Debuginfo.repo  CentOS-Media.repo    CentOS-Vault.repo</span><br><span class="line">CentOS-CR.repo    CentOS-fasttrack.repo  CentOS-Sources.repo  CentOS-x86_64-kernel.repo</span><br><span class="line">[root@localhost yum.repos.d]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="将“CentOS-Base-repo”重命名备份为“CentOS-Base-repo-old”"><a href="#将“CentOS-Base-repo”重命名备份为“CentOS-Base-repo-old”" class="headerlink" title="将“CentOS-Base.repo”重命名备份为“CentOS-Base.repo.old”"></a>将“CentOS-Base.repo”重命名备份为“CentOS-Base.repo.old”</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 备份文件</span><br><span class="line">mv CentOS-Base.repo CentOS-Base.repo.old</span><br><span class="line">2. 查看文件</span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line">[root@localhost yum.repos.d]# mv CentOS-Base.repo CentOS-Base.repo.old</span><br><span class="line">[root@localhost yum.repos.d]# ls</span><br><span class="line">CentOS-Base.repo.old  CentOS-Debuginfo.repo  CentOS-Media.repo    CentOS-Vault.repo</span><br><span class="line">CentOS-CR.repo        CentOS-fasttrack.repo  CentOS-Sources.repo  CentOS-x86_64-kernel.repo</span><br><span class="line">[root@localhost yum.repos.d]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="从阿里云下载-yum-源"><a href="#从阿里云下载-yum-源" class="headerlink" title="从阿里云下载 yum 源"></a>从阿里云下载 yum 源</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1. 下载源 (具体版本去wget http://mirrors.aliyun.com/repo/查看自身需要的版本)</span><br><span class="line">wget http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">2. 查看文件</span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line">[root@localhost yum.repos.d]# wget http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">--2021-06-27 16:15:23--  http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">正在解析主机 mirrors.aliyun.com (mirrors.aliyun.com)... 219.153.35.240, 61.128.152.12, 61.128.152.8, ...</span><br><span class="line">正在连接 mirrors.aliyun.com (mirrors.aliyun.com)|219.153.35.240|:80... 已连接。</span><br><span class="line">已发出 HTTP 请求，正在等待回应... 200 OK</span><br><span class="line">长度：2523 (2.5K) [application/octet-stream]</span><br><span class="line">正在保存至: “Centos-7.repo”</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">100%</span><span class="bash">[==============================================================&gt;] 2,523       --.-K/s 用时 0.002s</span></span><br><span class="line"></span><br><span class="line">2021-06-27 16:15:23 (1.10 MB/s) - 已保存 “Centos-7.repo” [2523/2523])</span><br><span class="line"></span><br><span class="line">[root@localhost yum.repos.d]# ls</span><br><span class="line">Centos-7.repo         CentOS-Debuginfo.repo  CentOS-Sources.repo</span><br><span class="line">CentOS-Base.repo.old  CentOS-fasttrack.repo  CentOS-Vault.repo</span><br><span class="line">CentOS-CR.repo        CentOS-Media.repo      CentOS-x86_64-kernel.repo</span><br><span class="line">[root@localhost yum.repos.d]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="将新的源改名为“CentOS-Base-repo”"><a href="#将新的源改名为“CentOS-Base-repo”" class="headerlink" title="将新的源改名为“CentOS-Base.repo”"></a>将新的源改名为“CentOS-Base.repo”</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 修改源</span><br><span class="line">mv Centos-7.repo CentOS-Base.repo</span><br><span class="line">2. 查看文件</span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line">[root@localhost yum.repos.d]# mv Centos-7.repo CentOS-Base.repo</span><br><span class="line">[root@localhost yum.repos.d]# ls</span><br><span class="line">CentOS-Base.repo      CentOS-Debuginfo.repo  CentOS-Sources.repo</span><br><span class="line">CentOS-Base.repo.old  CentOS-fasttrack.repo  CentOS-Vault.repo</span><br><span class="line">CentOS-CR.repo        CentOS-Media.repo      CentOS-x86_64-kernel.repo</span><br><span class="line">[root@localhost yum.repos.d]#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="让-yum-重新缓存新的数据"><a href="#让-yum-重新缓存新的数据" class="headerlink" title="让 yum 重新缓存新的数据"></a>让 yum 重新缓存新的数据</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 更新</span><br><span class="line">yum update -y</span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line">[root@localhost yum.repos.d]# yum update -y</span><br><span class="line">已加载插件：fastestmirror, langpacks</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.aliyun.com</span><br><span class="line"> * extras: mirrors.aliyun.com</span><br><span class="line"> * updates: mirrors.aliyun.com</span><br><span class="line">No packages marked for update</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前我这个是不用更新了,需要更新的,需要等待一段时间,最后会出现<span class="string">&quot;完毕!&quot;</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Linux </tag>
            
            <tag> Contos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 20.04安装配置过程</title>
      <link href="/6f2cd147c9da.html"/>
      <url>/6f2cd147c9da.html</url>
      
        <content type="html"><![CDATA[<h1 id="背-景-简-介"><a href="#背-景-简-介" class="headerlink" title="背 景 简 介"></a><strong>背 景 简 介</strong></h1><p>放了好久的 Ubuntu18.04 没打开使用，最近打开发现有些文件找不到路径，也懒得去找哪里错了，刚好最新的 Ubuntu20.04 已经出来了，干脆重新装一个最新版本的得了。<br>   话不多说，开干！</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li><p>Windows 10 专业版，64 位操作系统；</p></li><li><p>VMware15 Pro，版本：15.0.0 build-10134415；</p></li><li><p>Ubuntu 版本：ubuntu-20.04.1-desktop-amd64.iso</p></li></ul><h1 id="安装过程记录"><a href="#安装过程记录" class="headerlink" title="安装过程记录"></a>安装过程记录</h1><h3 id="打开-VMware15-软件，选择创建新的虚拟机；"><a href="#打开-VMware15-软件，选择创建新的虚拟机；" class="headerlink" title="打开 VMware15 软件，选择创建新的虚拟机；"></a>打开 VMware15 软件，选择创建新的虚拟机；</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/webp/241578/1606200129183-aa2e1835-de0e-4ef7-a911-dc47c689460d.webp#align=left&display=inline&height=427&margin=%5Bobject%20Object%5D&originHeight=427&originWidth=947&size=0&status=done&style=none&width=947" referrerpolicy="no-referrer"></p><h3 id="默认选择自定义配置，下一步"><a href="#默认选择自定义配置，下一步" class="headerlink" title="默认选择自定义配置，下一步"></a>默认选择自定义配置，下一步</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/webp/241578/1606200129159-a1a2b330-059f-4d87-925f-07fcfbb37c7c.webp#align=left&display=inline&height=424&margin=%5Bobject%20Object%5D&originHeight=424&originWidth=497&size=0&status=done&style=none&width=497" referrerpolicy="no-referrer"></p><h3 id="虚拟机硬件兼容性，直接使用默认即可，然后下一步"><a href="#虚拟机硬件兼容性，直接使用默认即可，然后下一步" class="headerlink" title="虚拟机硬件兼容性，直接使用默认即可，然后下一步"></a>虚拟机硬件兼容性，直接使用默认即可，然后下一步</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/webp/241578/1606200129159-4eea0890-9955-4674-86db-e2e2a6fdada9.webp#align=left&display=inline&height=433&margin=%5Bobject%20Object%5D&originHeight=433&originWidth=499&size=0&status=done&style=none&width=499" referrerpolicy="no-referrer"></p><h3 id="选择：稍后安装操作系统，然后下一步"><a href="#选择：稍后安装操作系统，然后下一步" class="headerlink" title="选择：稍后安装操作系统，然后下一步"></a>选择：稍后安装操作系统，然后下一步</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1606200129153-c3244dd4-670e-45f2-9ed9-d98822d8c5c4.png#align=left&display=inline&height=433&margin=%5Bobject%20Object%5D&originHeight=433&originWidth=499&size=0&status=done&style=none&width=499" referrerpolicy="no-referrer"></p><h3 id="系统选择：Linux，Ubuntu-64-位，然后下一步"><a href="#系统选择：Linux，Ubuntu-64-位，然后下一步" class="headerlink" title="系统选择：Linux，Ubuntu 64 位，然后下一步"></a>系统选择：Linux，Ubuntu 64 位，然后下一步</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/webp/241578/1606200129167-2ef3b562-4331-41af-9f0a-c07241c0da2c.webp#align=left&display=inline&height=433&margin=%5Bobject%20Object%5D&originHeight=433&originWidth=499&size=0&status=done&style=none&width=499" referrerpolicy="no-referrer"></p><h3 id="虚拟机名称可以根据自己需要修改，安装路径也可以自定义，不建议放-C-盘，然后下一步"><a href="#虚拟机名称可以根据自己需要修改，安装路径也可以自定义，不建议放-C-盘，然后下一步" class="headerlink" title="虚拟机名称可以根据自己需要修改，安装路径也可以自定义，不建议放 C 盘，然后下一步"></a>虚拟机名称可以根据自己需要修改，安装路径也可以自定义，不建议放 C 盘，然后下一步</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/webp/241578/1606200129141-0d01887e-05bd-446b-aee6-501492e41a60.webp#align=left&display=inline&height=433&margin=%5Bobject%20Object%5D&originHeight=433&originWidth=499&size=0&status=done&style=none&width=499" referrerpolicy="no-referrer"></p><h3 id="处理器配置需要根据自己电脑实际情况，进行配置（PS：内核总数越多，可以加快编译速度，提高效率）。配置完成后点击下一步"><a href="#处理器配置需要根据自己电脑实际情况，进行配置（PS：内核总数越多，可以加快编译速度，提高效率）。配置完成后点击下一步" class="headerlink" title="处理器配置需要根据自己电脑实际情况，进行配置（PS：内核总数越多，可以加快编译速度，提高效率）。配置完成后点击下一步"></a>处理器配置需要根据自己电脑实际情况，进行配置（PS：内核总数越多，可以加快编译速度，提高效率）。配置完成后点击下一步</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/webp/241578/1606200129163-cf9f782b-ee45-454b-b35f-ae05c72cf107.webp#align=left&display=inline&height=433&margin=%5Bobject%20Object%5D&originHeight=433&originWidth=499&size=0&status=done&style=none&width=499" referrerpolicy="no-referrer"></p><h3 id="虚拟机分配的内存，根据实际情况来，当然越大越好，系统运行速度什么的会更快。然后下一步"><a href="#虚拟机分配的内存，根据实际情况来，当然越大越好，系统运行速度什么的会更快。然后下一步" class="headerlink" title="虚拟机分配的内存，根据实际情况来，当然越大越好，系统运行速度什么的会更快。然后下一步"></a>虚拟机分配的内存，根据实际情况来，当然越大越好，系统运行速度什么的会更快。然后下一步</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/webp/241578/1606200129242-973b1145-5446-440e-898c-1a1319aa533e.webp#align=left&display=inline&height=433&margin=%5Bobject%20Object%5D&originHeight=433&originWidth=499&size=0&status=done&style=none&width=499" referrerpolicy="no-referrer"></p><h3 id="网络类型使用默认，然后下一步。"><a href="#网络类型使用默认，然后下一步。" class="headerlink" title="网络类型使用默认，然后下一步。"></a>网络类型使用默认，然后下一步。</h3><ul><li>（PS：如果后续想要给 Ubuntu 设置静态 IP 地址，可以参考：<a href="https://blog.csdn.net/Fighting_Boom/article/details/102755385">https://blog.csdn.net/Fighting_Boom/article/details/102755385</a></li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/webp/241578/1606200129182-1ba46526-264a-4c37-90e2-942e076000a9.webp#align=left&display=inline&height=433&margin=%5Bobject%20Object%5D&originHeight=433&originWidth=499&size=0&status=done&style=none&width=499" referrerpolicy="no-referrer"></p><h3 id="I-O-控制器类型，默认即可，下一步"><a href="#I-O-控制器类型，默认即可，下一步" class="headerlink" title="I/O 控制器类型，默认即可，下一步"></a>I/O 控制器类型，默认即可，下一步</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/webp/241578/1606200129205-f5ace47b-6028-4fd9-9f63-b15fae95f6c6.webp#align=left&display=inline&height=433&margin=%5Bobject%20Object%5D&originHeight=433&originWidth=499&size=0&status=done&style=none&width=499" referrerpolicy="no-referrer"></p><h3 id="磁盘类型，默认即可，下一步"><a href="#磁盘类型，默认即可，下一步" class="headerlink" title="磁盘类型，默认即可，下一步"></a>磁盘类型，默认即可，下一步</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1606200129194-abb2d9dc-f684-4d83-af4d-d7b87a583572.png#align=left&display=inline&height=433&margin=%5Bobject%20Object%5D&originHeight=433&originWidth=499&size=0&status=done&style=none&width=499" referrerpolicy="no-referrer"></p><h3 id="选择磁盘：默认即可，下一步"><a href="#选择磁盘：默认即可，下一步" class="headerlink" title="选择磁盘：默认即可，下一步"></a>选择磁盘：默认即可，下一步</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/webp/241578/1606200129196-cd880bf4-903b-42f3-ae02-acab802d6ca8.webp#align=left&display=inline&height=433&margin=%5Bobject%20Object%5D&originHeight=433&originWidth=499&size=0&status=done&style=none&width=499" referrerpolicy="no-referrer"></p><h3 id="磁盘大小，根据需要，不过由于这个是虚拟大小"><a href="#磁盘大小，根据需要，不过由于这个是虚拟大小" class="headerlink" title="磁盘大小，根据需要，不过由于这个是虚拟大小"></a>磁盘大小，根据需要，不过由于这个是虚拟大小</h3><ul><li>（虚拟大小：你给 Ubuntu 分配这么多内存，实际可能用不到这么多，会以实际使用的内存大小为准，虚拟大小就相当于一个上限），因此可以适当大一点也无所谓。</li><li>其他使用默认即可，下一步</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/webp/241578/1606200129199-102eb3c0-219f-4563-a412-8771fdbb711d.webp#align=left&display=inline&height=433&margin=%5Bobject%20Object%5D&originHeight=433&originWidth=499&size=0&status=done&style=none&width=499" referrerpolicy="no-referrer"></p><h3 id="文件名使用默认，路径与之前安装虚拟机的路径保持一致，然后下一步"><a href="#文件名使用默认，路径与之前安装虚拟机的路径保持一致，然后下一步" class="headerlink" title="文件名使用默认，路径与之前安装虚拟机的路径保持一致，然后下一步"></a>文件名使用默认，路径与之前安装虚拟机的路径保持一致，然后下一步</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/webp/241578/1606200129256-9a5622d8-5e95-4ab9-985a-09ab9078ca94.webp#align=left&display=inline&height=433&margin=%5Bobject%20Object%5D&originHeight=433&originWidth=499&size=0&status=done&style=none&width=499" referrerpolicy="no-referrer"></p><h3 id="都设置完成后，可以再确认一遍信息，有问题点击-“自定义硬件”-进行修改，若无问题，点击-“完成”-。"><a href="#都设置完成后，可以再确认一遍信息，有问题点击-“自定义硬件”-进行修改，若无问题，点击-“完成”-。" class="headerlink" title="都设置完成后，可以再确认一遍信息，有问题点击 “自定义硬件” 进行修改，若无问题，点击 “完成” 。"></a>都设置完成后，可以再确认一遍信息，有问题点击 “自定义硬件” 进行修改，若无问题，点击 “完成” 。</h3>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装Ubuntu</title>
      <link href="/c5e01090a818.html"/>
      <url>/c5e01090a818.html</url>
      
        <content type="html"><![CDATA[<p>准备工作</p><ul><li>需要 VMware</li></ul><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><p>Ubuntu 下载地址:<a href="http://releases.ubuntu.com/">http://releases.ubuntu.com/</a></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1599040136643-2bdf1374-b38b-4157-bd87-90693b620088.png#align=left&display=inline&height=404&margin=%5Bobject%20Object%5D&name=image-20200403154017477.png&originHeight=404&originWidth=1101&size=211638&status=done&style=none&width=1101" alt="image-20200403154017477.png" referrerpolicy="no-referrer"><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1599040177477-7f99bf31-43f9-40b4-91ec-d9e508dc36cb.png#align=left&display=inline&height=729&margin=%5Bobject%20Object%5D&name=image-20200403155024305.png&originHeight=729&originWidth=1183&size=176892&status=done&style=none&width=1183" alt="image-20200403155024305.png" referrerpolicy="no-referrer"></p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1599040183821-52f75162-72b7-4b03-969c-c52caf59fcb2.png#align=left&display=inline&height=433&margin=%5Bobject%20Object%5D&name=image-20200403154049421.png&originHeight=433&originWidth=530&size=21557&status=done&style=none&width=530" alt="image-20200403154049421.png" referrerpolicy="no-referrer"></p><h2 id="准备虚拟机"><a href="#准备虚拟机" class="headerlink" title="准备虚拟机"></a>准备虚拟机</h2><p>在下载的时候，现在 VMware 里面准备好虚拟机</p><h3 id="创建新的虚拟机"><a href="#创建新的虚拟机" class="headerlink" title="创建新的虚拟机"></a>创建新的虚拟机</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1599040198076-ee0f3a17-6adf-4f9a-81ca-22caf3e80202.png#align=left&display=inline&height=401&margin=%5Bobject%20Object%5D&name=image-20200403154231003.png&originHeight=401&originWidth=846&size=17684&status=done&style=none&width=846" alt="image-20200403154231003.png" referrerpolicy="no-referrer"></p><h4 id="创建典型的即可"><a href="#创建典型的即可" class="headerlink" title="创建典型的即可"></a>创建典型的即可</h4><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1599040216586-83783de6-f5e0-401a-983a-7914185fe360.png#align=left&display=inline&height=435&margin=%5Bobject%20Object%5D&name=image-20200403154423758.png&originHeight=435&originWidth=500&size=35323&status=done&style=none&width=500" alt="image-20200403154423758.png" referrerpolicy="no-referrer"></p><h4 id="创建一个空的虚拟机"><a href="#创建一个空的虚拟机" class="headerlink" title="创建一个空的虚拟机"></a>创建一个空的虚拟机</h4><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1599040231549-e065865f-0f7c-49d8-b4df-0818d163f478.png#align=left&display=inline&height=433&margin=%5Bobject%20Object%5D&name=image-20200403154528596.png&originHeight=433&originWidth=496&size=17032&status=done&style=none&width=496" alt="image-20200403154528596.png" referrerpolicy="no-referrer"></p><h4 id="创建-64-位的虚拟机"><a href="#创建-64-位的虚拟机" class="headerlink" title="创建 64 位的虚拟机"></a>创建 64 位的虚拟机</h4><p>因为默认下载的为 64 位的<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1599040244266-53eaf6dc-b74b-49db-bfc2-2dd742ca585a.png#align=left&display=inline&height=437&margin=%5Bobject%20Object%5D&name=image-20200403154642694.png&originHeight=437&originWidth=533&size=25230&status=done&style=none&width=533" alt="image-20200403154642694.png" referrerpolicy="no-referrer"><br>所在在选择系统的时候选择 64 位的系统<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1599040261176-c9fad022-696f-49c6-88d7-943b6ba748ce.png#align=left&display=inline&height=437&margin=%5Bobject%20Object%5D&name=image-20200403154754885.png&originHeight=437&originWidth=496&size=15956&status=done&style=none&width=496" alt="image-20200403154754885.png" referrerpolicy="no-referrer"></p><h4 id="安装的位置"><a href="#安装的位置" class="headerlink" title="安装的位置"></a>安装的位置</h4><p>找自己电脑比较空旷的磁盘安装（预估一下差不多 40G~60G）</p><table><thead><tr><th><strong>挂载点(目录)</strong></th><th><strong>建议大小</strong></th><th><strong>格式</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>/</td><td>20G 左右</td><td>ext4</td><td>根目录</td></tr><tr><td>/home</td><td>越大越好</td><td>ext4</td><td>用户工作目录，用户存储的数据，文件，安装的软件都存放在这儿</td></tr><tr><td>/boot</td><td>300M 左右</td><td>ext4</td><td>一般几百 M，主要存放 linux 内核及一些引导文件</td></tr><tr><td>/tmp</td><td>10G 左右</td><td>ext4</td><td>系统的一些临时文件</td></tr><tr><td>/swap</td><td>8G 左右</td><td>swap 交换空间</td><td>相当于虚拟内存</td></tr></tbody></table><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1599040297954-996f08b2-a2ea-4aad-bef7-76966763624c.png#align=left&display=inline&height=434&margin=%5Bobject%20Object%5D&name=image-20200403154918626.png&originHeight=434&originWidth=499&size=12992&status=done&style=none&width=499" alt="image-20200403154918626.png" referrerpolicy="no-referrer"></p><h3 id="选择磁盘容量"><a href="#选择磁盘容量" class="headerlink" title="选择磁盘容量"></a>选择磁盘容量</h3><p>这个根据自己的电脑和需求来选择，越大越好，推荐使用多个文件<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1599040312928-1c342206-6187-4c65-b7c1-b33bf61e2fb6.png#align=left&display=inline&height=429&margin=%5Bobject%20Object%5D&name=image-20200403155511139.png&originHeight=429&originWidth=500&size=15687&status=done&style=none&width=500" alt="image-20200403155511139.png" referrerpolicy="no-referrer"><br>然后下一步，就好了</p>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请不要再泥淖中停留</title>
      <link href="/ed9501b8d471.html"/>
      <url>/ed9501b8d471.html</url>
      
        <content type="html"><![CDATA[<p>喂？你还有什么没说完的吗<br>我说的是真的！没有跟你开玩笑，我们不要联系了<br>我已经考虑过了<br>哎呀！<br>我说了我已经想好了，我早就想好了，别墨迹了求求你，行不行<br>对，我是说过我们可以做朋友<br>但你是不是不懂什么叫礼貌啊<br>你表白的时候说的那么诚恳那么深情，你觉得我能说什么<br>你对我特别好，真的挺谢谢你的<br>前段时间我也比较困难，多亏了有你帮我<br>我只是觉得不太好，再这么拖着你不好<br>已经太久了，你不觉得吗<br>我都替你觉得累</p><p>我说过了，你应该有你自己的幸福，我给不了你<br>我？这个用不着你担心吧，我有我自己的生活，过的挺好的<br>你能不能想想你自己，你不觉得很可怜吗<br>你这是什么问题？你没有自己的事情吗<br>你能不能不要每天就知道问我吃什么穿什么冷不冷开不开心难不难过啊<br>还有一大堆你自己的大事小事<br>你很闲吗？<br>我跟你说我根本就不关心，我不想再听你叨叨了可以吗<br>你自己看看聊天记录，我一天回你几条<br>你没有朋友劝过你吗</p><p>呼~<br>我实话给你说了，其实你发的消息，我当时就收到了<br>现在什么年代啊<br>哪有那么多人，哪有那么忙的工作，连看手机消息的时间都没有啊<br>我就是不想回，就直接点掉划出去了<br>结果你还在还在说，真的看不下去<br>手机一直响，那就回你一下<br>我关静音，我还得收别人消息啊<br>我说什么忙啊，累啊，睡着了，你自己心里没数吗<br>还一句一句回我等你，你是不是觉得自己特别温柔、特别体贴<br>你烦不烦啊？烦不烦啊？<br>哎！你为什么要拿我说的那些话当什么证据<br>你不觉得你现在的语气挺可笑的吗</p><p>“我也挺关心你的”<br>“我不想你难过”<br>“我们还是好朋友吧”<br>“你是我很重要的人啊”<br>啊！这些……是，是我说的，那又如何<br>我不认，我现在不认，你怎么办呢<br>我只是不想伤你心伤的太狠<br>我不想把事情做绝，我不想我们之间没有余地，我才那样说的<br>你连礼貌客套和真心话都分不清，你怎么跟人谈恋爱啊</p><p>我为什么现在跟你说这些，呵，因为……因为我发现我没有必要在乎你怎么想<br>对吧，我再在乎下去，你会一直一直一直一直一直烦我啊<br>跟我聊那些没有意义的狗屁天，能当饭吃吗<br>唉！你该不会以为这样下去总有一天我会发现你的好，被你感动，我会发现你是这个世界上对我最好的人，我会喜欢上你，我会跟你在一起吧<br>你是不是有这种念头，有这种希望<br>你真挺有意思，我发现你们这些男的都挺有意思<br>很难理解吗，你换位思考一下一个女的你看不<br>她天天缠着你说一些你不感兴趣的事，还要管你的日常生活，你会喜欢上她<br>你少看点电视剧吧<br>你对我？重要啊<br>也没那么一无是处，你对我，当然是很重要的存在</p><p>那既然话都说到这份上了，你就当我在支教吧<br>我是怎么想的<br>我看你跟在我屁股后面，像条狗一样，我叫便来，还就挺高兴的<br>这就说明我还是很招人喜欢，是有魅力的<br>啊，那天晚上我是跟你说的多了点<br>那是因为我当时看上的小哥对我有点冷淡，心情很低落<br>但跟你聊几句吧，我就觉得能量又回上来了<br>我又有勇气继续对他主动了<br>你明白我的意思吗？<br>这…..你不过是我的血包罢了<br>我想聊天了、想上分了、想找个人吃饭了、想听点夸夸、想被供着了就打几个字就行了<br>谁知道你这么好上钩啊<br>都没没怎么费力气，日常的一些相处你就开始说喜欢什么的了<br>甚至我越不理你，你越来劲，怎么<br>是没人对你好过吗</p><p>我对谁都那样<br>我跟谁都那样<br>跟你是谁没关系<br>这就是我和一个人熟悉的流程<br>我也不是故意的啊，那交朋友不就是要多接触吗<br>谁知道跟你打几天游戏，连几天麦，你就动心了啊<br>我跟你说几句晚安，然后说一些私事，什么都代表不了<br>你清楚吗<br>如果当时和我聊天的不是你，是别人，我还是会说同样的话<br>因为我就是想这样表达，想这样说，和你是谁没关系，能听懂吗<br>是你，是我微信新加一天的人，还是我随便揪一个老同学，都一样的<br>你明白吗<br>我根本就不在乎跟谁说这些事情<br>所以我说，所以我说你们这些小男生是真挺有意思的</p><p>呵呵，你自己想一想<br>你觉得你在我这像个人吗<br>你看看自己卑微的样子，正常人有像你这样的吗<br>你是温柔是体贴是为我着想，我用你呢？<br>你这副失去自我的样子，你觉的还有个人样吗？你觉的还有个人样吗？<br>我要跟一个完整的人谈恋爱，我再问你一遍，你觉得你在我这里，你像个人吗</p><p>哎…..我跟你废话那么多干什么<br>你人真的挺好的，你还是找个真心对你好的人吧，啊<br>我不值得，好不好<br>真心为你好的人，怎么舍得看你这样子啊<br>天天失魂落魄，自己的事情都做不好，满脑子都是别人，时间都等着别人安排<br>没有这样的，啊<br>行了，行了行了<br>别再找我了<br>好吧<br>就当是我积德了<br>你不要再找我了<br>对大家都好<br>祝你幸福啊</p>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL Server数据库修改字符集</title>
      <link href="/d620a8aa8580.html"/>
      <url>/d620a8aa8580.html</url>
      
        <content type="html"><![CDATA[<ol><li>修改为单用户模式<ol><li><code> ALTER DATABASE 数据库名称 SET SINGLE_USER WITH ROLLBACK IMMEDIATE</code></li></ol></li><li>关闭所有查询窗口,修改 Options 的 Collocation 属性为 Chinese_PRC_90_CI_AS</li><li>修改回多用户模式<ol><li><code>ALTER DATABASE 数据库名称 SET MULTI_USER</code></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> SQL Server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>让一个Eclipse项目在Idea上跑起来</title>
      <link href="/e6323226da63.html"/>
      <url>/e6323226da63.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天是项目的环境搭建和初始化项目（就是让一个项目跑起来）</p></blockquote><p>原来项目的环境是</p><ul><li>Java 环境：jdk1.8</li><li>数据库：Sql Server2008</li><li>开发环境：Eclipse</li></ul><p>需要转移的是</p><ul><li>数据库：本机上搭建</li><li>开发环境：IDEA</li></ul><h1 id="第一步：把-Eclipse-的项目替换到-IDEA"><a href="#第一步：把-Eclipse-的项目替换到-IDEA" class="headerlink" title="第一步：把 Eclipse 的项目替换到 IDEA"></a>第一步：把 Eclipse 的项目替换到 IDEA</h1><h2 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h2><p>直接<code>open flie or preject</code><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597837596621-04d4bd86-425a-40ff-a37f-d7657901579b.png#align=left&display=inline&height=739&margin=%5Bobject%20Object%5D&name=image.png&originHeight=739&originWidth=332&size=27639&status=done&style=none&width=332" alt="image.png" referrerpolicy="no-referrer"><br>选中你要导入的项目<br>直接导入就好了<br>导入的时候可能会提示没有当前的 jdk 版本<br>不管他</p><h2 id="设置项目"><a href="#设置项目" class="headerlink" title="设置项目"></a>设置项目</h2><p>下一步设置项目中必要的东西<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597837727237-7578812c-676e-45cb-8d25-3c3ba701baaa.png#align=left&display=inline&height=53&margin=%5Bobject%20Object%5D&name=image.png&originHeight=53&originWidth=652&size=7476&status=done&style=none&width=652" alt="image.png" referrerpolicy="no-referrer"><br>下面就是一些要更改的地方</p><h3 id="当前系统的-JDK-版本"><a href="#当前系统的-JDK-版本" class="headerlink" title="当前系统的 JDK 版本"></a>当前系统的 JDK 版本</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597837945609-71379509-ee73-42d1-af1f-32c224313787.png#align=left&display=inline&height=1042&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1042&originWidth=1280&size=82116&status=done&style=none&width=1280" alt="image.png" referrerpolicy="no-referrer"></p><h3 id="设置运行环境"><a href="#设置运行环境" class="headerlink" title="设置运行环境"></a>设置运行环境</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597837997572-6caccd57-df2d-4c56-80b8-8fdbd9c96303.png#align=left&display=inline&height=1042&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1042&originWidth=1280&size=87564&status=done&style=none&width=1280" alt="image.png" referrerpolicy="no-referrer"></p><blockquote><p>1 设置 JDK<br>2、3、4 直接删除</p></blockquote><h3 id="加载-bin"><a href="#加载-bin" class="headerlink" title="加载 bin"></a>加载 bin</h3><p>找到<code>WebContent\WEB-INF\lib</code>把全部的 jar 包导入到项目里面</p><h3 id="加载-Web"><a href="#加载-Web" class="headerlink" title="加载 Web"></a>加载 Web</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597838247546-9cbf39cf-1a75-4599-9529-ac18812acd4d.png#align=left&display=inline&height=1042&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1042&originWidth=1280&size=83516&status=done&style=none&width=1280" alt="image.png" referrerpolicy="no-referrer"><br>选中项目，点击 web 的位置，找到 WebContent 选中，然后点击右下角的<code>CREATE ARTIFACT</code><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597838375338-7134dcee-3fa6-42fc-9e5e-739545a99bad.png#align=left&display=inline&height=1042&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1042&originWidth=1280&size=96253&status=done&style=none&width=1280" alt="image.png" referrerpolicy="no-referrer"><br>然后<code>APPLY</code></p><h3 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h3><p>选着也是 Build<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597838536592-5c1afad7-df11-4012-ac84-5bb639223528.png#align=left&display=inline&height=350&margin=%5Bobject%20Object%5D&name=image.png&originHeight=350&originWidth=387&size=15232&status=done&style=none&width=387" alt="image.png" referrerpolicy="no-referrer"></p><h2 id="第一个问题出现了"><a href="#第一个问题出现了" class="headerlink" title="第一个问题出现了"></a>第一个问题出现了</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597838626238-10c847d5-1d93-424c-8387-6c463d6afd9f.png#align=left&display=inline&height=48&margin=%5Bobject%20Object%5D&name=image.png&originHeight=48&originWidth=365&size=4409&status=done&style=none&width=365" alt="image.png" referrerpolicy="no-referrer"><br>Build 后并没有通过出现了个奇怪的错误<br>找到文件后发现第一个位置并有显示的问题<br>解决办法<del>没遇到过也想不到方法</del>百度</p><h3 id="开始解决"><a href="#开始解决" class="headerlink" title="开始解决"></a>开始解决</h3><p>找到设置<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597838778401-511a7923-aaf5-4ff3-99fc-29a3ff83f5ac.png#align=left&display=inline&height=651&margin=%5Bobject%20Object%5D&name=image.png&originHeight=651&originWidth=311&size=22403&status=done&style=none&width=311" alt="image.png" referrerpolicy="no-referrer"><br>找到 Settings-&gt; Build,Execution… -&gt; Compiler -&gt; Java Compiler 把 <code>javac</code>修改成<code>Eclipse</code>，保存，再 Build 一下<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597838860474-2e9f65a2-d3ae-409e-abab-445391cc1827.png#align=left&display=inline&height=875&margin=%5Bobject%20Object%5D&name=image.png&originHeight=875&originWidth=1216&size=95704&status=done&style=none&width=1216" alt="image.png" referrerpolicy="no-referrer"></p><h3 id="新问题"><a href="#新问题" class="headerlink" title="新问题"></a>新问题</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597839073742-70d68e47-da6c-4c1c-9a5b-e9231dbdf3a9.png#align=left&display=inline&height=32&margin=%5Bobject%20Object%5D&name=image.png&originHeight=32&originWidth=533&size=3682&status=done&style=none&width=533" alt="image.png" referrerpolicy="no-referrer"><br>这个问题应该是前面处理的时候遗留下来的<br>这时候找找原因看看</p><h3 id="解决新问题"><a href="#解决新问题" class="headerlink" title="解决新问题"></a>解决新问题</h3><ol><li><p>原因是<code>eclipse和idea对同样编码utf-8的细节不一致</code>，一个有 BOM，一个没有。</p></li><li><p>什么是 BOM 呢？</p><blockquote><p>BOM 的全称是：Byte Order Mark(字节顺序标记)。<code>UTF-8以字节为编码单元，没有字节序的问题</code>。UTF-16 以两个字节为编码单元，在解析一个 UTF-16 文本前，首先要弄清楚每个编码单元的<code>字节序</code>。例如：收到一个“奎”的 Unicode 编码是 594E，“乙”的 Unicode 编码是 4E59。如果我们收到 UTF-16 字节流“594E”，那么这是“奎”还是“乙”？<br>  <code>Unicode规范中推荐的标记字节顺序的方法是BOM</code>。BOM 不是“Bill Of Material”的 BOM 表，而是 Byte Order Mark(字节顺序标记)。在 UCS 编码中有一个叫做”ZERO WIDTH NO-BREAK SPACE”的字符，它的编码是 FEFF。而 FFFE 在 UCS 中是不存在的字符，所以不应该出现在实际传输中。UCS 规范建议我们在传输字节流前，先传输字符”ZERO WIDTH NO-BREAK SPACE”。这样如果接收者收到 FEFF，就表明这个字节流是 Big-Endian 的；如果收到 FFFE，就表明这个字节流是 Little-Endian 的。因此字符”ZERO WIDTH NO-BREAK SPACE”又被称作 BOM。</p></blockquote></li><li><p><code>UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式</code>。字符”ZERO WIDTH NO-BREAK SPACE”的 UTF-8 编码是 EF BB BF。所以如果接收者收到以 EF BB BF 开头的字节流，就知道这是 UTF-8 编码了。</p></li><li><p>通过<code>UE查看文件的16进制形式</code>，发现开头包含 EF BB BF 串，<code>eclipse不对其做识别而作为普通的字符处理，因此报错</code>。</p></li></ol><p>解决方法如下：</p><ol><li>使用 UE 或者其他文本工具，将有问题的 java 文件另存为 UTF-8，无 BOM 编码的格式，替换原来的 java 文件。</li><li>使用 eclipse 自建的文件编码，尽量不要从其他地方拷贝代码，手写要复制的代码。</li></ol><p>这两个毫无疑问都需要手动，一两个类就算了，这个项目少说都有一百多个类<br>如果我不想原地去世就要想想别的办法，Java 嘛，应该有代码能解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Reader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOM_SIZE = <span class="number">4</span>;</span><br><span class="line">    PushbackInputStream internalIn;<span class="comment">//回退流对象</span></span><br><span class="line">    InputStreamReader internalIn2 = <span class="keyword">null</span>;</span><br><span class="line">    String defaultEnc;<span class="comment">//格式</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in         inputstream to be read</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> defaultEnc default encoding if stream does not have</span></span><br><span class="line"><span class="comment">     *                   BOM marker. Give NULL to use system-level default.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Test(InputStream in, String defaultEnc) &#123;</span><br><span class="line">        internalIn = <span class="keyword">new</span> PushbackInputStream(in, BOM_SIZE);</span><br><span class="line">        <span class="keyword">this</span>.defaultEnc = defaultEnc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readContentAndSaveWithEncoding</span><span class="params">(String filePath, String readEncoding, String saveEncoding)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        saveContent(filePath, readContent(filePath, readEncoding), saveEncoding);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveContent</span><span class="params">(String filePath, String content, String encoding)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(filePath);</span><br><span class="line">        OutputStreamWriter w = <span class="keyword">new</span> OutputStreamWriter(fos, encoding);</span><br><span class="line">        w.write(content);</span><br><span class="line">        w.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readContent</span><span class="params">(String filePath, String encoding)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FileInputStream file = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(filePath));</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> Test(file, encoding));</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        String fileContent = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fileContent = fileContent + line;</span><br><span class="line">            fileContent += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fileContent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getPerlineFileName</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FileInputStream file = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(filePath));</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(file, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(line);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取某个目录下所有的文件路径</span></span><br><span class="line"><span class="comment">     * 使用递归</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePaths</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getAllFilePaths</span><span class="params">(File filePath, List&lt;String&gt; filePaths)</span> </span>&#123;</span><br><span class="line">        File[] files = filePath.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (files == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> filePaths;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                filePaths.add(f.getPath());</span><br><span class="line">                getAllFilePaths(f, filePaths);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                filePaths.add(f.getPath());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> filePaths;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String suffix = <span class="string">&quot;.java&quot;</span>;</span><br><span class="line">        List&lt;String&gt; paths = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        paths = getAllFilePaths(<span class="keyword">new</span> File(<span class="string">&quot;src的路径&quot;</span>), paths);</span><br><span class="line">        List&lt;String&gt; pathList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String path : paths) &#123;</span><br><span class="line">            <span class="keyword">if</span> (path.endsWith(suffix)) &#123;</span><br><span class="line">                pathList.add(path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String path : pathList) &#123;</span><br><span class="line">            readContentAndSaveWithEncoding(path, <span class="string">&quot;UTF-8&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(path + <span class="string">&quot;转换成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDefaultEncoding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defaultEnc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get stream encoding or NULL if stream is uninitialized.</span></span><br><span class="line"><span class="comment">     * Call init() or read() method to initialize it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEncoding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (internalIn2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> internalIn2.getEncoding();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read-ahead four bytes and check for BOM marks. Extra bytes are</span></span><br><span class="line"><span class="comment">     * unread back to the stream, only BOM bytes are skipped.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (internalIn2 != <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        String encoding;</span><br><span class="line">        <span class="keyword">byte</span> bom[] = <span class="keyword">new</span> <span class="keyword">byte</span>[BOM_SIZE];</span><br><span class="line">        <span class="keyword">int</span> n, unread;</span><br><span class="line">        n = internalIn.read(bom, <span class="number">0</span>, bom.length);</span><br><span class="line">        <span class="keyword">if</span> ((bom[<span class="number">0</span>] == (<span class="keyword">byte</span>) <span class="number">0x00</span>) &amp;&amp; (bom[<span class="number">1</span>] == (<span class="keyword">byte</span>) <span class="number">0x00</span>) &amp;&amp;</span><br><span class="line">                (bom[<span class="number">2</span>] == (<span class="keyword">byte</span>) <span class="number">0xFE</span>) &amp;&amp; (bom[<span class="number">3</span>] == (<span class="keyword">byte</span>) <span class="number">0xFF</span>)) &#123;</span><br><span class="line">            encoding = <span class="string">&quot;UTF-32BE&quot;</span>;</span><br><span class="line">            unread = n - <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((bom[<span class="number">0</span>] == (<span class="keyword">byte</span>) <span class="number">0xFF</span>) &amp;&amp; (bom[<span class="number">1</span>] == (<span class="keyword">byte</span>) <span class="number">0xFE</span>) &amp;&amp;</span><br><span class="line">                (bom[<span class="number">2</span>] == (<span class="keyword">byte</span>) <span class="number">0x00</span>) &amp;&amp; (bom[<span class="number">3</span>] == (<span class="keyword">byte</span>) <span class="number">0x00</span>)) &#123;</span><br><span class="line">            encoding = <span class="string">&quot;UTF-32LE&quot;</span>;</span><br><span class="line">            unread = n - <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((bom[<span class="number">0</span>] == (<span class="keyword">byte</span>) <span class="number">0xEF</span>) &amp;&amp; (bom[<span class="number">1</span>] == (<span class="keyword">byte</span>) <span class="number">0xBB</span>) &amp;&amp;</span><br><span class="line">                (bom[<span class="number">2</span>] == (<span class="keyword">byte</span>) <span class="number">0xBF</span>)) &#123;</span><br><span class="line">            encoding = <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">            unread = n - <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((bom[<span class="number">0</span>] == (<span class="keyword">byte</span>) <span class="number">0xFE</span>) &amp;&amp; (bom[<span class="number">1</span>] == (<span class="keyword">byte</span>) <span class="number">0xFF</span>)) &#123;</span><br><span class="line">            encoding = <span class="string">&quot;UTF-16BE&quot;</span>;</span><br><span class="line">            unread = n - <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((bom[<span class="number">0</span>] == (<span class="keyword">byte</span>) <span class="number">0xFF</span>) &amp;&amp; (bom[<span class="number">1</span>] == (<span class="keyword">byte</span>) <span class="number">0xFE</span>)) &#123;</span><br><span class="line">            encoding = <span class="string">&quot;UTF-16LE&quot;</span>;</span><br><span class="line">            unread = n - <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Unicode BOM mark not found, unread all bytes</span></span><br><span class="line">            encoding = defaultEnc;</span><br><span class="line">            unread = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(&quot;read=&quot; + n + &quot;, unread=&quot; + unread);</span></span><br><span class="line">        <span class="keyword">if</span> (unread &gt; <span class="number">0</span>) internalIn.unread(bom, (n - unread), unread);</span><br><span class="line">        <span class="comment">// Use given encoding</span></span><br><span class="line">        <span class="keyword">if</span> (encoding == <span class="keyword">null</span>) &#123;</span><br><span class="line">            internalIn2 = <span class="keyword">new</span> InputStreamReader(internalIn);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            internalIn2 = <span class="keyword">new</span> InputStreamReader(internalIn, encoding);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        internalIn2.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">return</span> internalIn2.read(cbuf, off, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码有了下一步直接运行就好了哈哈哈（当时确实是这么想的）<br>首先不能放到….<br>算了直接编译算了<br><code>javac Test.java -encoding utf-8</code><br>成功<br><code>java Test</code><br>失败<br>嗯，失败<br>嗯？失败？</p><h3 id="第三个问题"><a href="#第三个问题" class="headerlink" title="第三个问题"></a>第三个问题</h3><p>javac 没问题 java 运行失败<br>不用想环境变量的问题<br>找一下是那个龟孙出的问题<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597845079862-45562bfb-3fb9-4fbe-9d3f-5603769094cb.png#align=left&display=inline&height=28&margin=%5Bobject%20Object%5D&name=image.png&originHeight=28&originWidth=355&size=2086&status=done&style=none&width=355" alt="image.png" referrerpolicy="no-referrer"><br>这个就是这个<br>把 java 的环境上移到这个上面<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597845123599-22b9cc83-3f48-4883-8757-51aa5e7a334d.png#align=left&display=inline&height=66&margin=%5Bobject%20Object%5D&name=image.png&originHeight=66&originWidth=366&size=4379&status=done&style=none&width=366" alt="image.png" referrerpolicy="no-referrer"><br>解决</p><p>下面就是<br>运行（这个没问题）<br>创建 Tomecat（这个没问题）</p><h2 id="VM-安装-Sql-Server（细说）"><a href="#VM-安装-Sql-Server（细说）" class="headerlink" title="VM 安装 Sql Server（细说）"></a>VM 安装 Sql Server（细说）</h2><p>下一步下一步的安装就不说了</p><h3 id="第一个：远程访问"><a href="#第一个：远程访问" class="headerlink" title="第一个：远程访问"></a>第一个：远程访问</h3><p>（一）首先是要检查 SQLServer 数据库服务器中是否允许远程链接。其具体操作为：<br>（1）打开数据库，用本地帐户登录，右击第一个选项，选择属性：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/jpeg/241578/1597846167183-b4e8b27c-8b36-4342-9cb8-669ec64fc67c.jpeg#align=left&display=inline&height=411&margin=%5Bobject%20Object%5D&originHeight=411&originWidth=314&size=0&status=done&style=none&width=314" referrerpolicy="no-referrer"><br>（2）在打开的属性窗口，在其右边点击“连接”，然后再左侧勾上“允许远程连接到此服务器”：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597846167140-74d21ab1-427d-42db-809a-dfa333715f53.png#align=left&display=inline&height=722&margin=%5Bobject%20Object%5D&originHeight=722&originWidth=898&size=0&status=done&style=none&width=898" referrerpolicy="no-referrer">：</p><p>(二)为微软 SQL 服务器（MSSQLServer）配置相应协议。<br> （1）依次选择：开始-〉所有程序-〉Microsoft SQL Server 2008-〉配置工具-〉SQL Server 配置管理器，如下图所示：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597846167101-1a0b9041-6f70-4944-b4d8-46fe98ed3ca5.png#align=left&display=inline&height=281&margin=%5Bobject%20Object%5D&originHeight=281&originWidth=252&size=0&status=done&style=none&width=252" referrerpolicy="no-referrer"><br>（2）打开 SQL Server 配置管理器后，选择 SQL Server 网络配置下面的 MSSQLSERVER，然后看右边里面的 TCP/IP 是否为“已启用”，如下图所示：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597846167214-f1a1f848-a96e-4dbe-b263-0d47f1723715.png#align=left&display=inline&height=721&margin=%5Bobject%20Object%5D&originHeight=721&originWidth=956&size=0&status=done&style=none&width=956" referrerpolicy="no-referrer"></p><p>（三）检查 SQL 服务器防火墙设置 （快捷步骤-直接关闭防火墙（不安全））<br>（1）在进行完上两步操作后，用户需要做的是对 SQL 服务器防火墙进行重新配置。在进行这一步操作时，首先找到 SQL 服务器上那个端口支持 TCP/IP 协议。用户可以在 SQL 服务器防火墙已经处于运行状态下，右击“TCP/IP 协议”选择“属性”:<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597846167148-93a0f22d-7957-48f2-9d5f-c8287c653c28.png#align=left&display=inline&height=723&margin=%5Bobject%20Object%5D&originHeight=723&originWidth=956&size=0&status=done&style=none&width=956" referrerpolicy="no-referrer"><br>从上图中我们可以看出，这台 SQL 服务器上支持 TCP/IP 协议的是 1433 端口。下一步要做的是在防火墙的配置中允许 1433 端口支持 TCP/IP 协议即可。如果服务器上运行的是 Windows 7 操作系统，其配置步骤为（其他微软操作系统的做法类似），打开“控制面板”选择“Windows 防火墙”选项，然后点击高级选项，如下图所示：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597846167082-39d6abf5-350d-4327-8196-88dc58fc652d.png#align=left&display=inline&height=597&margin=%5Bobject%20Object%5D&originHeight=597&originWidth=851&size=0&status=done&style=none&width=851" referrerpolicy="no-referrer"><br>（2）选择“高级设置”后，在右边菜单栏中找出“具有高级安全选项的 Windows 防火墙”并将其打开。打开后会发现在左边菜单栏中有“入站规则（Inboud Rules）”选项。将该选项打开，并在右边菜单栏中选择“新建规则（New Rule）”选项：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597846167131-1c88ee3c-6c65-4d1f-af99-e9487f4de1e6.png#align=left&display=inline&height=727&margin=%5Bobject%20Object%5D&originHeight=727&originWidth=1061&size=0&status=done&style=none&width=1061" referrerpolicy="no-referrer"><br>（3）打开“新建规则”选项后，利用“新内置绑定规则向导”为 1433 端口配置“内部绑定协议”配置为适用于 TCP/IP 协议即可。（前提是，需要完成该步骤以前所述的所有步骤），根据下面的几幅图为 1433 端口配置适用于 1433 端口即可：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597846167129-72905e53-f20d-4eba-bc2c-d63e41205c7f.png#align=left&display=inline&height=543&margin=%5Bobject%20Object%5D&originHeight=543&originWidth=727&size=0&status=done&style=none&width=727" referrerpolicy="no-referrer"><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597846167237-b9e5dde3-58cb-4610-868a-9ea8336e1b27.png#align=left&display=inline&height=544&margin=%5Bobject%20Object%5D&originHeight=544&originWidth=726&size=0&status=done&style=none&width=726" referrerpolicy="no-referrer"><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597846167125-557dbb5d-0bb8-4c65-8ed5-5e15440b9eb8.png#align=left&display=inline&height=546&margin=%5Bobject%20Object%5D&originHeight=546&originWidth=724&size=0&status=done&style=none&width=724" referrerpolicy="no-referrer"><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597846167234-44a1d794-c850-43e0-91c3-44393b80df02.png#align=left&display=inline&height=545&margin=%5Bobject%20Object%5D&originHeight=545&originWidth=726&size=0&status=done&style=none&width=726" referrerpolicy="no-referrer"><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597846167127-2befd3b2-dbce-40b7-87ca-d2a705cdc333.png#align=left&display=inline&height=545&margin=%5Bobject%20Object%5D&originHeight=545&originWidth=726&size=0&status=done&style=none&width=726" referrerpolicy="no-referrer"><br>最后点击“完成”即可。<br>最后的最后记得重启 SqlServer，要不不会生效<br><code>net stop mssqlserver</code><br><code>net start mssqlserver</code></p><h3 id="第二个：数据库还原"><a href="#第二个：数据库还原" class="headerlink" title="第二个：数据库还原"></a>第二个：数据库还原</h3><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><h6 id="数据库上右击，选择还原文件和文件组"><a href="#数据库上右击，选择还原文件和文件组" class="headerlink" title="数据库上右击，选择还原文件和文件组"></a>数据库上右击，选择还原文件和文件组</h6><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597846407557-870444f9-3f43-487b-ab8e-1b0d2446016e.png#align=left&display=inline&height=397&margin=%5Bobject%20Object%5D&name=image.png&originHeight=397&originWidth=340&size=25894&status=done&style=none&width=340" alt="image.png" referrerpolicy="no-referrer"></p><h6 id="选择目标数据库，选择-bak-文件，确定即可还原数据库"><a href="#选择目标数据库，选择-bak-文件，确定即可还原数据库" class="headerlink" title="选择目标数据库，选择 bak 文件，确定即可还原数据库"></a>选择目标数据库，选择 bak 文件，确定即可还原数据库</h6><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597846487046-932a23f1-33ff-4b71-8705-493f4cc44ca8.png#align=left&display=inline&height=717&margin=%5Bobject%20Object%5D&name=image.png&originHeight=717&originWidth=857&size=37592&status=done&style=none&width=857" alt="image.png" referrerpolicy="no-referrer"><br>一般情况下这样就可以还原数据库了，但有时会报一个错<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/241578/1597846356410-cda0e692-01a6-4605-b653-bb72ebc75932.png#align=left&display=inline&height=170&margin=%5Bobject%20Object%5D&originHeight=170&originWidth=607&size=0&status=done&style=none&width=607" referrerpolicy="no-referrer"><br>出现这种情况，就说明第一种方式不能还原数据库了<br>接下来用第二种方式即可</p><h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><p>在数据库里用代码直接还原</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE [数据库名] <span class="keyword">SET</span> OFFLINE <span class="keyword">WITH</span> <span class="keyword">ROLLBACK</span> IMMEDIATE  <span class="comment">--断开其他用户与数据库的连接</span></span><br><span class="line">USE MASTER <span class="comment">--这里注意要使用MASTER，以免出现待还原库被占用的情况</span></span><br><span class="line">RESTORE DATABASE [数据库名] <span class="comment">--为待还原库名</span></span><br><span class="line"><span class="keyword">FROM</span> DISK <span class="operator">=</span> <span class="string">&#x27;C:\xxx.bak&#x27;</span> <span class="comment">---备份文件名</span></span><br><span class="line"><span class="keyword">WITH</span> MOVE <span class="string">&#x27;数据库名&#x27;</span> <span class="keyword">TO</span> <span class="string">&#x27;C:\bakeup\数据库名.mdf&#x27;</span>,  <span class="comment">---指定数据文件路径</span></span><br><span class="line">MOVE <span class="string">&#x27;数据库名_LOG&#x27;</span> <span class="keyword">TO</span> <span class="string">&#x27;C:\bakeup\数据库名_log.ldf&#x27;</span>, <span class="comment">---指定日志文件路径</span></span><br><span class="line">STATS <span class="operator">=</span> <span class="number">10</span>, REPLACE</span><br><span class="line">GO</span><br><span class="line"><span class="keyword">ALTER</span>  database  [数据库名]  <span class="keyword">set</span>   online</span><br></pre></td></tr></table></figure><p>完</p>]]></content>
      
      
      <categories>
          
          <category> 语雀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
            <tag> Java </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/8aea8b702ec9.html"/>
      <url>/8aea8b702ec9.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p><strong>递归</strong>：指在当前方法内调用自己的这种现象。</p></li><li><p><strong>递归的分类:</strong></p><ul><li>递归分为两种，直接递归和间接递归。</li><li>直接递归称为方法自身调用自己。</li><li>间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。</li></ul></li><li><p><strong>注意事项</strong>：</p><ul><li>递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。</li><li>在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</li><li>构造方法，禁止递归</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01DiGui</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// a();</span></span><br><span class="line">b(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 3.构造方法,禁止递归</span></span><br><span class="line"><span class="comment"> * 编译报错:构造方法是创建对象使用的,不能让对象一直创建下去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo01DiGui</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//Demo01DiGui();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2.在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</span></span><br><span class="line"><span class="comment"> * 4993</span></span><br><span class="line"><span class="comment"> * Exception in thread &quot;main&quot; java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line"><span class="comment">//添加一个递归结束的条件,i==5000的时候结束</span></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">5000</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//结束方法</span></span><br><span class="line">&#125;</span><br><span class="line">b(++i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。 Exception in thread &quot;main&quot;</span></span><br><span class="line"><span class="comment"> * java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a方法&quot;</span>);</span><br><span class="line">a();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归累加求和"><a href="#递归累加求和" class="headerlink" title="递归累加求和"></a>递归累加求和</h2><h3 id="计算1-n的和"><a href="#计算1-n的和" class="headerlink" title="计算1 ~ n的和"></a>计算1 ~ n的和</h3><p><strong>分析</strong>：num的累和 = num + (num-1)的累和，所以可以把累和的操作定义成一个方法，递归调用。</p><p><strong>实现代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//计算1~num的和，使用递归完成</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">      <span class="comment">// 调用求和的方法</span></span><br><span class="line"><span class="keyword">int</span> sum = getSum(num);</span><br><span class="line">      <span class="comment">// 输出结果</span></span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    通过递归算法实现.</span></span><br><span class="line"><span class="comment">    参数列表:int </span></span><br><span class="line"><span class="comment">    返回值类型: int </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/* </span></span><br><span class="line"><span class="comment">         num为1时,方法返回1,</span></span><br><span class="line"><span class="comment">         相当于是方法的出口,num总有是1的情况</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"><span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">          num不为1时,方法返回 num +(num-1)的累和</span></span><br><span class="line"><span class="comment">          递归调用getSum方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="keyword">return</span> num + getSum(num-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码执行图解"><a href="#代码执行图解" class="headerlink" title="代码执行图解"></a>代码执行图解</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/8aea8b702ec9/day08_01_%E9%80%92%E5%BD%92%E7%B4%AF%E5%92%8C.jpg"></p><blockquote><p>递归一定要有条件限定，保证递归能够停止下来，次数不要太多，否则会发生栈内存溢出。</p></blockquote><h2 id="递归求阶乘"><a href="#递归求阶乘" class="headerlink" title="递归求阶乘"></a>递归求阶乘</h2><ul><li><strong>阶乘</strong>：所有小于及等于该数的正整数的积。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n的阶乘：n! = n * (n-<span class="number">1</span>) *...* <span class="number">3</span> * <span class="number">2</span> * <span class="number">1</span> </span><br></pre></td></tr></table></figure><p><strong>分析</strong>：这与累和类似,只不过换成了乘法运算，学员可以自己练习，需要注意阶乘值符合int类型的范围。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">推理得出：n! = n * (n-1)!</span><br></pre></td></tr></table></figure><p><strong>代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">//计算n的阶乘，使用递归完成</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">      <span class="comment">// 调用求阶乘的方法</span></span><br><span class="line">        <span class="keyword">int</span> value = getValue(n);</span><br><span class="line">      <span class="comment">// 输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;阶乘为:&quot;</span>+ value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    通过递归算法实现.</span></span><br><span class="line"><span class="comment">    参数列表:int </span></span><br><span class="line"><span class="comment">    返回值类型: int </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 1的阶乘为1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        n不为1时,方法返回 n! = n*(n-1)!</span></span><br><span class="line"><span class="comment">          递归调用getValue方法</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        <span class="keyword">return</span> n * getValue(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归打印多级目录"><a href="#递归打印多级目录" class="headerlink" title="递归打印多级目录"></a>递归打印多级目录</h2><p><strong>分析</strong>：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。</p><p><strong>代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 创建File对象</span></span><br><span class="line">        File dir  = <span class="keyword">new</span> File(<span class="string">&quot;D:\\aaa&quot;</span>);</span><br><span class="line">      <span class="comment">// 调用打印目录方法</span></span><br><span class="line">        printDir(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">printDir</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 获取子文件和目录</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">      <span class="comment">// 循环打印</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        判断:</span></span><br><span class="line"><span class="comment">        当是文件时,打印绝对路径.</span></span><br><span class="line"><span class="comment">        当是目录时,继续调用打印目录的方法,形成递归调用.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">              <span class="comment">// 是文件,输出文件绝对路径</span></span><br><span class="line">                System.out.println(<span class="string">&quot;文件名:&quot;</span>+ file.getAbsolutePath());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 是目录,输出目录绝对路径</span></span><br><span class="line">                System.out.println(<span class="string">&quot;目录:&quot;</span>+file.getAbsolutePath());</span><br><span class="line">              <span class="comment">// 继续遍历,调用printDir,形成递归</span></span><br><span class="line">                printDir(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>File类</title>
      <link href="/da89cd139d26.html"/>
      <url>/da89cd139d26.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li><code>public File(String pathname) </code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。  </li><li><code>public File(String parent, String child) </code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。</li><li><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。  </li></ul><ul><li>构造举例，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line">String pathname = <span class="string">&quot;D:\\aaa.txt&quot;</span>;</span><br><span class="line">File file1 = <span class="keyword">new</span> File(pathname); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line">String pathname2 = <span class="string">&quot;D:\\aaa\\bbb.txt&quot;</span>;</span><br><span class="line">File file2 = <span class="keyword">new</span> File(pathname2); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line"> String parent = <span class="string">&quot;d:\\aaa&quot;</span>;</span><br><span class="line"> String child = <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"> File file3 = <span class="keyword">new</span> File(parent, child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line">File parentDir = <span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line">String child = <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line">File file4 = <span class="keyword">new</span> File(parentDir, child);</span><br></pre></td></tr></table></figure><blockquote><ol><li>一个File对象代表硬盘中实际存在的一个文件或者目录。</li><li>无论该路径下是否存在文件或者目录，都不影响File对象的创建。</li></ol></blockquote><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h3><ul><li><p><code>public String getAbsolutePath() </code> ：返回此File的绝对路径名字符串。</p></li><li><p><code>public String getPath()</code> ：将此File转换为路径名字符串。 </p></li><li><p><code>public String getName()</code>  ：返回由此File表示的文件或目录的名称。  </p></li><li><p><code>public long length()</code>  ：返回由此File表示的文件的长度。 </p><p>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileGet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:/aaa/bbb.java&quot;</span>);     </span><br><span class="line">        System.out.println(<span class="string">&quot;文件绝对路径:&quot;</span>+f.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件构造路径:&quot;</span>+f.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件名称:&quot;</span>+f.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件长度:&quot;</span>+f.length()+<span class="string">&quot;字节&quot;</span>);</span><br><span class="line"></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;d:/aaa&quot;</span>);     </span><br><span class="line">        System.out.println(<span class="string">&quot;目录绝对路径:&quot;</span>+f2.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录构造路径:&quot;</span>+f2.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录名称:&quot;</span>+f2.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录长度:&quot;</span>+f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">文件绝对路径:d:\aaa\bbb.java</span><br><span class="line">文件构造路径:d:\aaa\bbb.java</span><br><span class="line">文件名称:bbb.java</span><br><span class="line">文件长度:<span class="number">636</span>字节</span><br><span class="line"></span><br><span class="line">目录绝对路径:d:\aaa</span><br><span class="line">目录构造路径:d:\aaa</span><br><span class="line">目录名称:aaa</span><br><span class="line">目录长度:<span class="number">4096</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。</p></blockquote><h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><ul><li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li><li><strong>相对路径</strong>：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilePath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// D盘下的bbb.java文件</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;D:\\bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 项目下的bbb.java文件</span></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">D:\bbb.java</span><br><span class="line">D:\idea_project_test4\bbb.java</span><br></pre></td></tr></table></figure><h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><ul><li><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</li><li><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</li><li><code>public boolean isFile()</code> ：此File表示的是否为文件。</li></ul><p>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa\\bbb.java&quot;</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line">      <span class="comment">// 判断是否存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa\\bbb.java 是否存在:&quot;</span>+f.exists());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 是否存在:&quot;</span>+f2.exists());</span><br><span class="line">      <span class="comment">// 判断是文件还是目录</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 文件?:&quot;</span>+f2.isFile());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 目录?:&quot;</span>+f2.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">d:\aaa\bbb.java 是否存在:<span class="keyword">true</span></span><br><span class="line">d:\aaa 是否存在:<span class="keyword">true</span></span><br><span class="line">d:\aaa 文件?:<span class="keyword">false</span></span><br><span class="line">d:\aaa 目录?:<span class="keyword">true</span></span><br></pre></td></tr></table></figure><h3 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h3><ul><li><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </li><li><code>public boolean delete()</code> ：删除由此File表示的文件或目录。  </li><li><code>public boolean mkdir()</code> ：创建由此File表示的目录。</li><li><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</li></ul><p>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCreateDelete</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 文件的创建</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;aaa.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f.createNewFile()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 目录的创建</span></span><br><span class="line">      File f2= <span class="keyword">new</span> File(<span class="string">&quot;newDir&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f2.mkdir());<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建多级目录</span></span><br><span class="line">      File f3= <span class="keyword">new</span> File(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdir());<span class="comment">// false</span></span><br><span class="line">        File f4= <span class="keyword">new</span> File(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f4.mkdirs());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 文件的删除</span></span><br><span class="line">       System.out.println(f.delete());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 目录的删除</span></span><br><span class="line">        System.out.println(f2.delete());<span class="comment">// true</span></span><br><span class="line">        System.out.println(f4.delete());<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。</p></blockquote><h2 id="目录的遍历"><a href="#目录的遍历" class="headerlink" title="目录的遍历"></a>目录的遍历</h2><ul><li><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</li></ul><ul><li><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">&quot;d:\\java_code&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取当前目录下的文件以及文件夹的名称。</span></span><br><span class="line">String[] names = dir.list();</span><br><span class="line"><span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式</title>
      <link href="/0380823323ea.html"/>
      <url>/0380823323ea.html</url>
      
        <content type="html"><![CDATA[<h2 id="函数式编程思想概述"><a href="#函数式编程思想概述" class="headerlink" title="函数式编程思想概述"></a>函数式编程思想概述</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0380823323ea/03-Overview.png"></p><p>在数学中，<strong>函数</strong>就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong>。</p><p>面向对象的思想:</p><p>​    做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</p><p>函数式编程思想:</p><p>​    只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p><h2 id="冗余的Runnable代码"><a href="#冗余的Runnable代码" class="headerlink" title="冗余的Runnable代码"></a>冗余的Runnable代码</h2><h3 id="传统写法"><a href="#传统写法" class="headerlink" title="传统写法"></a>传统写法</h3><p>当需要启动一个线程去完成任务时，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使用<code>java.lang.Thread</code>类来启动该线程。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Runnable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 匿名内部类</span></span><br><span class="line">Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 覆盖重写抽象方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Thread(task).start(); <span class="comment">// 启动线程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p><ul><li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li><li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li><li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li><li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li><li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li></ul><h2 id="编程思想转换"><a href="#编程思想转换" class="headerlink" title="编程思想转换"></a>编程思想转换</h2><h3 id="做什么，而不是怎么做"><a href="#做什么，而不是怎么做" class="headerlink" title="做什么，而不是怎么做"></a>做什么，而不是怎么做</h3><p>我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而<strong>不得不</strong>创建一个对象。我们真正希望做的事情是：将<code>run</code>方法体内的代码传递给<code>Thread</code>类知晓。</p><p><strong>传递一段代码</strong>——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。</p><h3 id="生活举例"><a href="#生活举例" class="headerlink" title="生活举例"></a>生活举例</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0380823323ea/01-%E4%BA%A4%E9%80%9A%E6%96%B9%E5%BC%8F.png"></p><p>当我们需要从北京到上海时，可以选择高铁、汽车、骑行或是徒步。我们的真正目的是到达上海，而如何才能到达上海的形式并不重要，所以我们一直在探索有没有比高铁更好的方式——搭乘飞机。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0380823323ea/02-Lambda.png"></p><p>而现在这种飞机（甚至是飞船）已经诞生：2014年3月Oracle所发布的Java 8（JDK 1.8）中，加入了<strong>Lambda表达式</strong>的重量级新特性，为我们打开了新世界的大门。</p><h2 id="体验Lambda的更优写法"><a href="#体验Lambda的更优写法" class="headerlink" title="体验Lambda的更优写法"></a>体验Lambda的更优写法</h2><p>借助Java 8的全新语法，上述<code>Runnable</code>接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02LambdaRunnable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>)).start(); <span class="comment">// 启动线程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。</p><p>不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！</p><h2 id="回顾匿名内部类"><a href="#回顾匿名内部类" class="headerlink" title="回顾匿名内部类"></a>回顾匿名内部类</h2><p>Lambda是怎样击败面向对象的？在上例中，核心代码其实只是如下所示的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>)</span><br></pre></td></tr></table></figure><p>为了理解Lambda的语义，我们需要从传统的代码起步。</p><h3 id="使用实现类"><a href="#使用实现类" class="headerlink" title="使用实现类"></a>使用实现类</h3><p>要启动一个线程，需要创建一个<code>Thread</code>类的对象并调用<code>start</code>方法。而为了指定线程执行的内容，需要调用<code>Thread</code>类的构造方法：</p><ul><li><code>public Thread(Runnable target)</code></li></ul><p>为了获取<code>Runnable</code>接口的实现对象，可以为该接口定义一个实现类<code>RunnableImpl</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建该实现类的对象作为<code>Thread</code>类的构造参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03ThreadInitParam</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Runnable task = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line"><span class="keyword">new</span> Thread(task).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用匿名内部类"><a href="#使用匿名内部类" class="headerlink" title="使用匿名内部类"></a>使用匿名内部类</h3><p>这个<code>RunnableImpl</code>类只是为了实现<code>Runnable</code>接口而存在的，而且仅被使用了唯一一次，所以使用匿名内部类的语法即可省去该类的单独定义，即匿名内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04ThreadNameless</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名内部类的好处与弊端"><a href="#匿名内部类的好处与弊端" class="headerlink" title="匿名内部类的好处与弊端"></a>匿名内部类的好处与弊端</h3><p>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>；另一方面，匿名内部类的语法——<strong>确实太复杂了！</strong></p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>仔细分析该代码中的语义，<code>Runnable</code>接口只有一个<code>run</code>方法的定义：</p><ul><li><code>public abstract void run();</code></li></ul><p>即制定了一种做事情的方案（其实就是一个函数）：</p><ul><li><strong>无参数</strong>：不需要任何条件即可执行该方案。</li><li><strong>无返回值</strong>：该方案不产生任何结果。</li><li><strong>代码块</strong>（方法体）：该方案的具体执行步骤。</li></ul><p>同样的语义体现在<code>Lambda</code>语法中，要更加简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>前面的一对小括号即<code>run</code>方法的参数（无），代表不需要任何条件；</li><li>中间的一个箭头代表将前面的参数传递给后面的代码；</li><li>后面的输出语句即业务逻辑代码。</li></ul><h2 id="Lambda标准格式"><a href="#Lambda标准格式" class="headerlink" title="Lambda标准格式"></a>Lambda标准格式</h2><p>Lambda省去面向对象的条条框框，格式由<strong>3个部分</strong>组成：</p><ul><li>一些参数</li><li>一个箭头</li><li>一段代码</li></ul><p>Lambda表达式的<strong>标准格式</strong>为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数类型 参数名称) -&gt; &#123; 代码语句 &#125;</span><br></pre></td></tr></table></figure><p>格式说明：</p><ul><li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li><li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li><li>大括号内的语法与传统方法体要求基本一致。</li></ul><h2 id="练习：使用Lambda标准格式（无参无返回）"><a href="#练习：使用Lambda标准格式（无参无返回）" class="headerlink" title="练习：使用Lambda标准格式（无参无返回）"></a>练习：使用Lambda标准格式（无参无返回）</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个厨子<code>Cook</code>接口，内含唯一的抽象方法<code>makeFood</code>，且无参数、无返回值。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeFood</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code>invokeCook</code>方法，打印输出“吃饭啦！”字样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05InvokeCook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 请在此使用Lambda【标准格式】调用invokeCook方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeCook</span><span class="params">(Cook cook)</span> </span>&#123;</span><br><span class="line">        cook.makeFood();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    invokeCook(() -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;吃饭啦！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>备注：小括号代表<code>Cook</code>接口<code>makeFood</code>抽象方法的参数为空，大括号代表<code>makeFood</code>的方法体。</p></blockquote><h2 id="Lambda的参数和返回值"><a href="#Lambda的参数和返回值" class="headerlink" title="Lambda的参数和返回值"></a>Lambda的参数和返回值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">需求:</span><br><span class="line">    使用数组存储多个Person对象</span><br><span class="line">    对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序</span><br></pre></td></tr></table></figure><p>下面举例演示<code>java.util.Comparator&lt;T&gt;</code>接口的使用场景代码，其中的抽象方法定义为：</p><ul><li><code>public abstract int compare(T o1, T o2);</code></li></ul><p>当需要对一个对象数组进行排序时，<code>Arrays.sort</code>方法需要一个<code>Comparator</code>接口实例来指定排序的规则。假设有一个<code>Person</code>类，含有<code>String name</code>和<code>int age</code>两个成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略构造器、toString方法与Getter Setter </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传统写法-1"><a href="#传统写法-1" class="headerlink" title="传统写法"></a>传统写法</h3><p>如果使用传统的代码对<code>Person[]</code>数组进行排序，写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06Comparator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 本来年龄乱序的对象数组</span></span><br><span class="line">        Person[] array = &#123;</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">&quot;古力娜扎&quot;</span>, <span class="number">19</span>),</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">18</span>),</span><br><span class="line">       <span class="keyword">new</span> Person(<span class="string">&quot;马尔扎哈&quot;</span>, <span class="number">20</span>) &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 匿名内部类</span></span><br><span class="line">        Comparator&lt;Person&gt; comp = <span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(array, comp); <span class="comment">// 第二个参数为排序规则，即Comparator接口实例</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : array) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法在面向对象的思想中，似乎也是“理所当然”的。其中<code>Comparator</code>接口的实例（使用了匿名内部类）代表了“按照年龄从小到大”的排序规则。</p><h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><p>下面我们来搞清楚上述代码真正要做什么事情。</p><ul><li>为了排序，<code>Arrays.sort</code>方法需要排序规则，即<code>Comparator</code>接口的实例，抽象方法<code>compare</code>是关键；</li><li>为了指定<code>compare</code>的方法体，<strong>不得不</strong>需要<code>Comparator</code>接口的实现类；</li><li>为了省去定义一个<code>ComparatorImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li><li>必须覆盖重写抽象<code>compare</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li><li>实际上，<strong>只有参数和方法体才是关键</strong>。</li></ul><h3 id="Lambda写法"><a href="#Lambda写法" class="headerlink" title="Lambda写法"></a>Lambda写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07ComparatorLambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person[] array = &#123;</span><br><span class="line">          <span class="keyword">new</span> Person(<span class="string">&quot;古力娜扎&quot;</span>, <span class="number">19</span>),</span><br><span class="line">          <span class="keyword">new</span> Person(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">18</span>),</span><br><span class="line">          <span class="keyword">new</span> Person(<span class="string">&quot;马尔扎哈&quot;</span>, <span class="number">20</span>) &#125;;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(array, (Person a, Person b) -&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> a.getAge() - b.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : array) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习：使用Lambda标准格式（有参有返回）"><a href="#练习：使用Lambda标准格式（有参有返回）" class="headerlink" title="练习：使用Lambda标准格式（有参有返回）"></a>练习：使用Lambda标准格式（有参有返回）</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个计算器<code>Calculator</code>接口，内含抽象方法<code>calc</code>可以将两个int数字相加得到和值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code>invokeCalc</code>方法，完成120和130的相加计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08InvokeCalc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 请在此使用Lambda【标准格式】调用invokeCalc方法来计算120+130的结果ß</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeCalc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Calculator calculator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = calculator.calc(a, b);</span><br><span class="line">        System.out.println(<span class="string">&quot;结果是：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    invokeCalc(<span class="number">120</span>, <span class="number">130</span>, (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>备注：小括号代表<code>Calculator</code>接口<code>calc</code>抽象方法的参数，大括号代表<code>calc</code>的方法体。</p></blockquote><h2 id="Lambda省略格式"><a href="#Lambda省略格式" class="headerlink" title="Lambda省略格式"></a>Lambda省略格式</h2><h3 id="可推导即可省略"><a href="#可推导即可省略" class="headerlink" title="可推导即可省略"></a>可推导即可省略</h3><p>Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用Lambda的省略写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  invokeCalc(<span class="number">120</span>, <span class="number">130</span>, (a, b) -&gt; a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h3><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p><ol><li>小括号内参数的类型可以省略；</li><li>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</li><li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li></ol><blockquote><p>备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。</p></blockquote><h2 id="练习：使用Lambda省略格式"><a href="#练习：使用Lambda省略格式" class="headerlink" title="练习：使用Lambda省略格式"></a>练习：使用Lambda省略格式</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>仍然使用前文含有唯一<code>makeFood</code>抽象方法的厨子<code>Cook</code>接口，在下面的代码中，请使用Lambda的<strong>省略格式</strong>调用<code>invokeCook</code>方法，打印输出“吃饭啦！”字样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo09InvokeCook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 请在此使用Lambda【省略格式】调用invokeCook方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeCook</span><span class="params">(Cook cook)</span> </span>&#123;</span><br><span class="line">        cook.makeFood();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  invokeCook(() -&gt; System.out.println(<span class="string">&quot;吃饭啦！&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lambda的使用前提"><a href="#Lambda的使用前提" class="headerlink" title="Lambda的使用前提"></a>Lambda的使用前提</h2><p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p><ol><li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li><li>使用Lambda必须具有<strong>上下文推断</strong>。<br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li></ol><blockquote><p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/aaafb3b4b102.html"/>
      <url>/aaafb3b4b102.html</url>
      
        <content type="html"><![CDATA[<h2 id="线程池思想概述"><a href="#线程池思想概述" class="headerlink" title="线程池思想概述"></a>线程池思想概述</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/aaafb3b4b102/%E6%B8%B8%E6%B3%B3%E6%B1%A0.jpg"></p><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：</p><p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p><p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</p><p>在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池。</p><h2 id="线程池概念"><a href="#线程池概念" class="headerlink" title="线程池概念"></a>线程池概念</h2><ul><li><strong>线程池：</strong>其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li></ul><p>由于线程池中有很多操作都是与优化资源相关的，我们在这里就不多赘述。我们通过一张图来了解线程池的工作原理：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/aaafb3b4b102/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86.bmp"></p><p>合理利用线程池能够带来三个好处：</p><ol><li>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li></ol><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p><p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code>java.util.concurrent.Executors</code>线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。</p><p>Executors类中有个创建线程池的方法如下：</p><ul><li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)</li></ul><p>获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：</p><ul><li><p><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</p><blockquote><p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。</p></blockquote></li></ul><p>使用线程池中线程对象的步骤：</p><ol><li>创建线程池对象。</li><li>创建Runnable接口子类对象。(task)</li><li>提交Runnable接口子类对象。(take task)</li><li>关闭线程池(一般不做)。</li></ol><p>Runnable实现类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我要一个教练&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;教练来了： &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;教我游泳,交完后，教练回到了游泳池&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程池对象</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);<span class="comment">//包含2个线程对象</span></span><br><span class="line">        <span class="comment">// 创建Runnable实例对象</span></span><br><span class="line">        MyRunnable r = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自己创建线程对象的方式</span></span><br><span class="line">        <span class="comment">// Thread t = new Thread(r);</span></span><br><span class="line">        <span class="comment">// t.start(); ---&gt; 调用MyRunnable中的run()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从线程池中获取线程对象,然后调用MyRunnable中的run()</span></span><br><span class="line">        service.submit(r);</span><br><span class="line">        <span class="comment">// 再获取个线程对象，调用MyRunnable中的run()</span></span><br><span class="line">        service.submit(r);</span><br><span class="line">        service.submit(r);</span><br><span class="line">        <span class="comment">// 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。</span></span><br><span class="line">        <span class="comment">// 将使用完的线程又归还到了线程池中</span></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        <span class="comment">//service.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>等待唤醒机制</title>
      <link href="/5a25eafad98e.html"/>
      <url>/5a25eafad98e.html</url>
      
        <content type="html"><![CDATA[<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p><strong>概念：</strong>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。</p><p>比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/5a25eafad98e/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.bmp"></p><p><strong>为什么要处理线程间通信：</strong></p><p>多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p><p><strong>如何保证线程间通信有效利用资源：</strong></p><p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— <strong>等待唤醒机制。</strong></p><h2 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h2><p><strong>什么是等待唤醒机制</strong></p><p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。</p><p>就是在一个线程进行了规定操作后，就进入等待状态（**wait()<strong>）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（</strong>notify()**）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。</p><p>wait/notify 就是线程间的一种协作机制。</p><p><strong>等待唤醒中的方法</strong></p><p>等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p><ol><li>wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是“<strong>通知（notify）</strong>”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中</li><li>notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。</li><li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li></ol><blockquote><p>注意：</p><p>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p><p>总结如下：</p><ul><li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；</li><li>否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态</li></ul></blockquote><p><strong>调用wait和notify方法需要注意的细节</strong></p><ol><li>wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li><li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li><li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</li></ol><h2 id="生产者与消费者问题"><a href="#生产者与消费者问题" class="headerlink" title="生产者与消费者问题"></a>生产者与消费者问题</h2><p>等待唤醒机制其实就是经典的“生产者与消费者”的问题。</p><p>就拿生产包子消费包子来说等待唤醒机制如何有效利用资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">包子铺线程生产包子，吃货线程消费包子。</span><br><span class="line">  当包子没有时（包子状态为<span class="keyword">false</span>），</span><br><span class="line">  吃货线程等待，</span><br><span class="line">  包子铺线程生产包子（即包子状态为<span class="keyword">true</span>），</span><br><span class="line">  并通知吃货线程（解除吃货的等待状态）,</span><br><span class="line">因为已经有包子了，那么包子铺线程进入等待状态。</span><br><span class="line">  接下来，吃货线程能否进一步执行则取决于锁的获取情况。</span><br><span class="line">  如果吃货获取到锁，那么就执行吃包子动作，</span><br><span class="line">  包子吃完（包子状态为<span class="keyword">false</span>），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。</span><br><span class="line">  包子铺线程能否进一步执行则取决于锁的获取情况。</span><br></pre></td></tr></table></figure><p><strong>代码演示：</strong></p><p>包子资源类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZi</span> </span>&#123;</span><br><span class="line">     String  pier ;</span><br><span class="line">     String  xianer ;</span><br><span class="line">     <span class="keyword">boolean</span>  flag = <span class="keyword">false</span> ;<span class="comment">//包子资源 是否存在  包子资源状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>吃货线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChiHuo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChiHuo</span><span class="params">(String name,BaoZi bz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (bz)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bz.flag == <span class="keyword">false</span>)&#123;<span class="comment">//没包子</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;吃货正在吃&quot;</span>+bz.pier+bz.xianer+<span class="string">&quot;包子&quot;</span>);</span><br><span class="line">                bz.flag = <span class="keyword">false</span>;</span><br><span class="line">                bz.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包子铺线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZiPu</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaoZiPu</span><span class="params">(String name,BaoZi bz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//造包子</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (bz)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bz.flag == <span class="keyword">true</span>)&#123;<span class="comment">//包子资源  存在</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        bz.wait();</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 没有包子  造包子</span></span><br><span class="line">                System.out.println(<span class="string">&quot;包子铺开始做包子&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 冰皮  五仁</span></span><br><span class="line">                    bz.pier = <span class="string">&quot;冰皮&quot;</span>;</span><br><span class="line">                    bz.xianer = <span class="string">&quot;五仁&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 薄皮  牛肉大葱</span></span><br><span class="line">                    bz.pier = <span class="string">&quot;薄皮&quot;</span>;</span><br><span class="line">                    bz.xianer = <span class="string">&quot;牛肉大葱&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line"></span><br><span class="line">                bz.flag=<span class="keyword">true</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;包子造好了：&quot;</span>+bz.pier+bz.xianer);</span><br><span class="line">                System.out.println(<span class="string">&quot;吃货来吃吧&quot;</span>);</span><br><span class="line">                <span class="comment">//唤醒等待线程 （吃货）</span></span><br><span class="line">                bz.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//等待唤醒案例</span></span><br><span class="line">        BaoZi bz = <span class="keyword">new</span> BaoZi();</span><br><span class="line"></span><br><span class="line">        ChiHuo ch = <span class="keyword">new</span> ChiHuo(<span class="string">&quot;吃货&quot;</span>,bz);</span><br><span class="line">        BaoZiPu bzp = <span class="keyword">new</span> BaoZiPu(<span class="string">&quot;包子铺&quot;</span>,bz);</span><br><span class="line"></span><br><span class="line">        ch.start();</span><br><span class="line">        bzp.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">包子铺开始做包子</span><br><span class="line">包子造好了：冰皮五仁</span><br><span class="line">吃货来吃吧</span><br><span class="line">吃货正在吃冰皮五仁包子</span><br><span class="line">包子铺开始做包子</span><br><span class="line">包子造好了：薄皮牛肉大葱</span><br><span class="line">吃货来吃吧</span><br><span class="line">吃货正在吃薄皮牛肉大葱包子</span><br><span class="line">包子铺开始做包子</span><br><span class="line">包子造好了：冰皮五仁</span><br><span class="line">吃货来吃吧</span><br><span class="line">吃货正在吃冰皮五仁包子</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程状态</title>
      <link href="/14f35b3a6d64.html"/>
      <url>/14f35b3a6d64.html</url>
      
        <content type="html"><![CDATA[<h2 id="线程状态概述"><a href="#线程状态概述" class="headerlink" title="线程状态概述"></a>线程状态概述</h2><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，有几种状态呢？在API中 <code>java.lang.Thread.State</code> 这个枚举中给出了六种线程状态：<br>这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析</p><table><thead><tr><th><strong>线程状态</strong></th><th><strong>导致状态发生条件</strong></th></tr></thead><tbody><tr><td>NEW(新建)</td><td>线程刚被创建，但是并未启动。还没调用start方法。</td></tr><tr><td>Runnable(可运行)</td><td>线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。</td></tr><tr><td>Blocked(锁阻塞)</td><td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。</td></tr><tr><td>Waiting(无限等待)</td><td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。</td></tr><tr><td>Timed Waiting(计时等待)</td><td>同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。</td></tr><tr><td>Teminated(被终止)</td><td>因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</td></tr></tbody></table><p>我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几个状态呢，新建与被终止还是很容易理解的，我们就研究一下线程从Runnable（可运行）状态与非运行状态之间<br>的转换问题。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/14f35b3a6d64/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE.png" alt="线程状态图"></p><h2 id="Timed-Waiting（计时等待）"><a href="#Timed-Waiting（计时等待）" class="headerlink" title="Timed Waiting（计时等待）"></a>Timed Waiting（计时等待）</h2><p>Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。单独的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？</p><p>在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。</p><p>其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等待)，那么我们通过一个案例加深对该状态的一个理解。</p><p>实现一个计数器，计数到100，在每个数字之间暂停1秒，每隔10个数字输出一个字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTimedWaiting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span> ; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">10</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过案例可以发现，sleep方法的使用还是很简单的。我们需要记住下面几点：</p><blockquote><p>进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协<br>作关系。</p><p>为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程<br>中会睡眠</p><p>sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。</p></blockquote><blockquote><p> sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。</p></blockquote><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/14f35b3a6d64/%E8%AE%A1%E6%97%B6%E7%AD%89%E5%BE%85.png" alt="计时等待"></p><h2 id="BLOCKED（锁阻塞）"><a href="#BLOCKED（锁阻塞）" class="headerlink" title="BLOCKED（锁阻塞）"></a>BLOCKED（锁阻塞）</h2><p>Blocked状态在API中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。</p><p>我们已经知道同步机制，那么这个状态是非常好理解的了。比如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/14f35b3a6d64/%E9%94%81%E9%98%BB%E5%A1%9E.png" alt="锁阻塞"></p><h2 id="Waiting（无限等待）"><a href="#Waiting（无限等待）" class="headerlink" title="Waiting（无限等待）"></a>Waiting（无限等待）</h2><p>Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWaiting</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 演示waiting</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println( Thread.currentThread().getName() +<span class="string">&quot;=== 获取到锁对象，调用wait方法，进入waiting状态，释放锁对象&quot;</span>);</span><br><span class="line">                            obj.wait(); <span class="comment">//无限等待</span></span><br><span class="line">                            <span class="comment">//obj.wait(5000);</span></span><br><span class="line">                            <span class="comment">// 计时等待, 5秒 时间到，自动醒来</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println( Thread.currentThread().getName() + <span class="string">&quot;=== 从waiting状态醒来，获取到锁对象，继续执行了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;等待线程&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// while (true)&#123; //每隔3秒 唤醒一次</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println( Thread.currentThread().getName() +<span class="string">&quot;‐‐‐‐‐ 等待3秒钟&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                    System.out.println( Thread.currentThread().getName() +<span class="string">&quot;‐‐‐‐‐ 获取到锁对象,调用notify方法，释放锁对象&quot;</span>);</span><br><span class="line">                            obj.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">        &#125;,<span class="string">&quot;唤醒线程&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的Object.notify()方法 或 Object.notifyAll()方法。</p><p>其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司里你和你的同事们，你们可能存在晋升时的竞<br>争，但更多时候你们更多是一起合作以完成某些任务。</p><p>当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用notify()方法，那么就会将无限等待的A线程唤醒。</p><p>注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/14f35b3a6d64/%E6%97%A0%E9%99%90%E7%AD%89%E5%BE%85.png" alt="无限等待"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全</title>
      <link href="/b18884c315bf.html"/>
      <url>/b18884c315bf.html</url>
      
        <content type="html"><![CDATA[<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。<br>以下将会以卖票作为示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread_Safe_Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;<span class="comment">//共100张票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在卖,第&quot;</span>+ticket+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;```</span><br><span class="line"></span><br><span class="line">在main方法中开启两个线程，同时抢<span class="number">100</span>张票：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line">Thread_Safe_Demo thread_safe_demo = <span class="keyword">new</span> Thread_Safe_Demo();</span><br><span class="line"><span class="keyword">new</span> Thread(thread_safe_demo).start();</span><br><span class="line"><span class="keyword">new</span> Thread(thread_safe_demo).start();</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/b18884c315bf/image-20200415161132979.png" alt="image-20200415161132979"></p><p>发现同一张票反复售卖，这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。</p><blockquote><p>线程安全问题都是由全局变量及静态变量引起的。</p><p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；</p><p>若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p></blockquote><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。</p><p>要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制(synchronized)来解决。</p><p>为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。</p><p>那么怎么去使用呢？有三种方式完成同步操作：</p><ul><li>同步代码块</li><li>同步方法</li><li>锁机制</li></ul><h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><ul><li><p>同步代码块： synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</p></li><li><p>格式:</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步锁：</p><p>对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁.</p><ul><li>锁对象 可以是任意类型。</li><li>多个线程对象 要使用同一把锁。</li></ul><blockquote><p>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread_Safe_Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在卖,第&quot;</span>+ticket+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                        ticket--;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，第一次的问题得以解决。</p><h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p>同步方法:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同步锁是谁?<br>对于非static方法,同步锁就是this。<br>对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。</p></blockquote><p>使用同步方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread_Safe_Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">   <span class="comment">//使用代码同步方法实现线程同步控制</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">payTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在卖,第&quot;</span>+ticket+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    payTicket();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2><p><code>java.util.concurrent.locks.Lock</code> 机制提供了比<code>synchronized</code>代码块和<code>synchronized</code>方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。<br>Lock锁也称同步锁，加锁与释放锁方法化了，如下：</p><ul><li><code>public void lock()</code> :加同步锁。</li><li><code>public void unlock()</code> :释放同步锁。</li></ul><p>使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread_Safe_Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在卖,第&quot;</span>+ticket+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程</title>
      <link href="/d4fe7f53dfd9.html"/>
      <url>/d4fe7f53dfd9.html</url>
      
        <content type="html"><![CDATA[<h2 id="多线程的原理"><a href="#多线程的原理" class="headerlink" title="多线程的原理"></a>多线程的原理</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/d4fe7f53dfd9/%E7%BA%BF%E7%A8%8B%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="线程流程图"></p><p>程序启动运行main时候，java虚拟机启动一个进程，主线程main在main（）调用时候被创建。</p><p>随着调用mt的对象的start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。</p><p>通过这张图我们可以很清晰的看到多线程的执行流程，那么为什么可以完成并发执行呢？</p><p>我们再来讲一讲原理。</p><p>多线程执行时，到底在内存中是如何运行的呢？以上个程序为例，进行图解说明：</p><p>多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。</p><p>进行方法的压栈和弹栈。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/d4fe7f53dfd9/image-20200415155230943.png" alt="image-20200415155230943"></p><p>当执行线程的任务结束了，线程自动在栈内存中释放了。</p><p>但是当所有的执行线程都结束了，那么进程就结束了。</p><h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><p>构造方法：</p><ul><li><p><code>public Thread()</code>：分配一个新的线程对象。</p></li><li><p><code>public Thread(string name)</code>：分配一个指定名字的新的线程对象。</p></li><li><p><code>public Thread(Runnable target)</code>：分配一个带有指定目标新的线程对象。</p></li><li><p><code>public Thread(Runnable target,string name)</code>：分配一个带有指定目标新的线程对象并指定名字。</p></li></ul><p>常用方法：</p><ul><li><code>public String getName()</code>：获取当前线程名称</li><li><code>public void start()</code>：导致此线程开始执行；Java虚拟机调用此线程的run方法。</li><li><code>public void run()</code>：此线程要执行的任务在此处定义代码。</li><li><code>public static void sleep(long millis)</code>：使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）</li><li><code>public static Thread currentThread()</code>：返回对当前正在执行的线程对象的引用。</li></ul><h2 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h2><p>步骤：</p><ul><li>定义Runnable接口的实现类,并重写该接口的run()方法,该run()方法的方法体同样是该线程的线程执行体</li><li>创建Runnable实现类的实例,并以此实例作为Thread的target来创建Thread对象,该Thread对象才是真正的线程对象</li><li>调用线程对象的start()方法来启动线程</li></ul><p>通过实现Runnable接口，使得该类有了多线程类的特征run()方法是多线程程序的一个执行目标。</p><p>所有的多线程代码都在run方法里面。</p><p>Thread类实际上也是实现了Runnable接口的类。</p><p>在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target)构造出对象，然后调用Thread对象的start()方法来运行多线程代码。</p><p>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。</p><p>因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。</p><h2 id="Thread和Runnable的区别"><a href="#Thread和Runnable的区别" class="headerlink" title="Thread和Runnable的区别"></a>Thread和Runnable的区别</h2><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runnable接口的话，则很容易的实现资源共享。<br>总结：<br>实现Runnable接口比继承Thread类所具有的优势：</p><ul><li>适合多个相同的程序代码的线程去共享同一个资源。</li><li>可以避免Java中的单继承的局限性。</li><li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li><li>线程池只能放入实现Runnable或Callable类线程，不能直接放入继承Thread的类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/b1fbbb5bc700.html"/>
      <url>/b1fbbb5bc700.html</url>
      
        <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？</p><p>要解决上述问题,咱们得使用多进程或者多线程来解决.</p><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><ul><li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</li><li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/b1fbbb5bc700/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91.bmp"></p><p>在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</p><p>而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。</p><blockquote><p>注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。</p></blockquote><h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><ul><li><p><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p></li><li><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 </p><p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 </p></li></ul><p>我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程：</p><p><strong>进程</strong></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/b1fbbb5bc700/%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5.png"></p><p><strong>线程</strong></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/b1fbbb5bc700/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5.png"></p><p><strong>线程调度:</strong></p><ul><li><p>分时调度</p><p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p></li><li><p>抢占式调度</p><p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p><ul><li>设置线程的优先级</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/b1fbbb5bc700/%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7.bmp" alt="设置线程优先级"></p><ul><li><p>抢占式调度详解</p><p> 大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。</p><p> 实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。<br> 其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。</p><p> <img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/b1fbbb5bc700/%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6.bmp" alt="抢占式调度"></p></li></ul></li></ul><h2 id="创建线程类"><a href="#创建线程类" class="headerlink" title="创建线程类"></a>创建线程类</h2><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p><ol><li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li><li>创建Thread子类的实例，即创建了线程对象</li><li>调用线程对象的start()方法来启动该线程</li></ol><p>代码如下：</p><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建自定义线程对象</span></span><br><span class="line">MyThread mt = <span class="keyword">new</span> MyThread(<span class="string">&quot;新的线程！&quot;</span>);</span><br><span class="line"><span class="comment">//开启新线程</span></span><br><span class="line">mt.start();</span><br><span class="line"><span class="comment">//在主方法中执行for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;main线程！&quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义指定线程名称的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用父类的String参数的构造方法，指定线程的名称</span></span><br><span class="line"><span class="keyword">super</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写run方法，完成该线程执行的逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">System.out.println(getName()+<span class="string">&quot;：正在执行！&quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义异常</title>
      <link href="/17f5eb8bcc0d.html"/>
      <url>/17f5eb8bcc0d.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>为什么需要自定义异常类:</strong></p><p>我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。</p><p>在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？</p><p><strong>什么是自定义异常类:</strong></p><p>在开发中根据自己业务的异常情况来定义异常类.</p><p>自定义一个业务逻辑异常: <strong>RegisterException</strong>。一个注册异常类。</p><p><strong>异常类如何定义:</strong></p><ol><li>自定义一个编译期异常: 自定义类 并继承于<code>java.lang.Exception</code>。</li><li>自定义一个运行时期的异常类:自定义类 并继承于<code>java.lang.RuntimeException</code>。</li></ol><h2 id="自定义异常的练习"><a href="#自定义异常的练习" class="headerlink" title="自定义异常的练习"></a>自定义异常的练习</h2><p>要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。</p><p>首先定义一个登陆异常类RegisterException：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务逻辑异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空参构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 表示异常提示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟数据库中已存在账号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] names = &#123;<span class="string">&quot;bill&quot;</span>,<span class="string">&quot;hill&quot;</span>,<span class="string">&quot;jill&quot;</span>&#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">              <span class="comment">// 可能出现异常的代码</span></span><br><span class="line">            checkUsername(<span class="string">&quot;nill&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;注册成功&quot;</span>);<span class="comment">//如果没有异常就是注册成功</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(RegisterException e)&#123;</span><br><span class="line">            <span class="comment">//处理异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前注册账号是否存在</span></span><br><span class="line">    <span class="comment">//因为是编译期异常，又想调用者去处理 所以声明该异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(String uname)</span> <span class="keyword">throws</span> LoginException</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            <span class="keyword">if</span>(name.equals(uname))&#123;<span class="comment">//如果名字在这里面 就抛出登陆异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RegisterException(<span class="string">&quot;亲&quot;</span>+name+<span class="string">&quot;已经被注册了！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常的处理</title>
      <link href="/144f3d359cd3.html"/>
      <url>/144f3d359cd3.html</url>
      
        <content type="html"><![CDATA[<p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p><h2 id="抛出异常throw"><a href="#抛出异常throw" class="headerlink" title="抛出异常throw"></a>抛出异常throw</h2><p>在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。</p><p>在java中，提供了一个<strong>throw</strong>关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？</p><ol><li><p>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</p></li><li><p>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。</p><p>throw<strong>用在方法内</strong>，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p></li></ol><p><strong>使用格式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new 异常类名(参数);</span><br></pre></td></tr></table></figure><p> 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;要访问的arr数组不存在&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;该索引在数组中不存在，已超出范围&quot;</span>);</span><br></pre></td></tr></table></figure><p>学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个数组 </span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">52</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">//根据索引找对应的元素 </span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> element = getElement(arr, index);</span><br><span class="line"></span><br><span class="line">        System.out.println(element);</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 根据 索引找到数组中对应的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index)</span></span>&#123; </span><br><span class="line">       <span class="comment">//判断  索引是否越界</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。</span></span><br><span class="line"><span class="comment">             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 </span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;哥们，角标越界了~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> element = arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。</p><p>那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。</p></blockquote><h2 id="Objects非空判断"><a href="#Objects非空判断" class="headerlink" title="Objects非空判断"></a>Objects非空判断</h2><p>还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。</p><ul><li><code>public static &lt;T&gt; T requireNonNull(T obj)</code>:查看指定引用对象不是null。</li></ul><p>查看源码发现这里对为null的进行了抛出异常操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明异常throws"><a href="#声明异常throws" class="headerlink" title="声明异常throws"></a>声明异常throws</h2><p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p><p>关键字<strong>throws</strong>运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).</p><p><strong>声明异常格式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123;   &#125;</span><br></pre></td></tr></table></figure><p>声明异常的代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        read(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        read(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span><span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;b.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="捕获异常try…catch"><a href="#捕获异常try…catch" class="headerlink" title="捕获异常try…catch"></a>捕获异常try…catch</h2><p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p><ol><li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li><li>在方法中使用try-catch的语句块来处理异常。</li></ol><p><strong>try-catch</strong>的方式就是捕获异常。</p><ul><li><strong>捕获异常</strong>：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li></ul><p>捕获异常语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  e)&#123;</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>try：</strong>该代码块中编写可能产生异常的代码。</p><p><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p><blockquote><p>注意:try和catch都不能单独使用,必须连用。</p></blockquote><p>演示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">// 当产生异常时，必须有处理方式。要么捕获，要么声明。</span></span><br><span class="line">            read(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;<span class="comment">// 括号中需要定义什么呢？</span></span><br><span class="line">          <span class="comment">//try中抛出的是什么异常，在括号中就定义什么异常类型</span></span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我们 当前的这个方法中 有异常  有编译期异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何获取异常信息：</p><p>Throwable类中定义了一些查看方法:</p><ul><li><code>public String getMessage()</code>:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。</li></ul><ul><li><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</li><li><code>public void printStackTrace()</code>:打印异常的跟踪栈信息并输出到控制台。</li></ul><p>​            <em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p><h2 id="finally-代码块"><a href="#finally-代码块" class="headerlink" title="finally 代码块"></a>finally 代码块</h2><p><strong>finally</strong>：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p><p>什么时候的代码必须最终执行？</p><p>当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。</p><p>finally的语法:</p><p> try…catch….finally:自身需要处理异常,最终还得关闭资源。</p><blockquote><p>注意:finally不能单独使用。</p></blockquote><p>比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。</p><p>finally代码参考如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            read(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">//抓取到的是编译期异常  抛出去的是运行期 </span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不管程序怎样，这里都将会被执行。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我们 当前的这个方法中 有异常  有编译期异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。</p></blockquote><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/144f3d359cd3/%E6%AD%BB%E4%BA%86%E9%83%BD%E8%A6%81try.bmp"></p><h2 id="异常注意事项"><a href="#异常注意事项" class="headerlink" title="异常注意事项"></a>异常注意事项</h2><ul><li><p>多个异常使用捕获又该如何处理呢？</p><ol><li>多个异常分别处理。</li><li>多个异常一次捕获，多次处理。</li><li>多个异常一次捕获一次处理。</li></ol><p>一般我们是使用一次捕获多次处理方式，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型A  e)&#123;  当<span class="keyword">try</span>中出现A类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型B  e)&#123;  当<span class="keyword">try</span>中出现B类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</p></blockquote></li><li><p>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</p></li><li><p>如果finally有return语句,永远返回finally中的结果,避免该情况. </p></li><li><p>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</p></li><li><p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="/01c00fab19d5.html"/>
      <url>/01c00fab19d5.html</url>
      
        <content type="html"><![CDATA[<h2 id="异常概念"><a href="#异常概念" class="headerlink" title="异常概念"></a>异常概念</h2><p>异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：</p><ul><li><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</li></ul><p>在Java等面向对象的编程语言中，<strong>异常本身是一个类</strong>，<strong>产生异常就是创建异常对象并抛出了一个异常对象</strong>。Java处理异常的方式是中断处理。</p><blockquote><p>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.</p></blockquote><h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><p>异常机制其实是帮助我们<strong>找到</strong>程序中的问题，异常的根类是<code>java.lang.Throwable</code>，其下有两个子类：<code>java.lang.Error</code>与<code>java.lang.Exception</code>，平常所说的异常指<code>java.lang.Exception</code>。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/01c00fab19d5/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png"></p><p><strong>Throwable体系：</strong></p><ul><li><strong>Error</strong>:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。</li><li><strong>Exception</strong>:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。</li></ul><p><strong>Throwable中的常用方法：</strong></p><ul><li><p><code>public void printStackTrace()</code>:打印异常的详细信息。</p><p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p></li><li><p><code>public String getMessage()</code>:获取发生异常的原因。</p><p><em>提示给用户的时候,就提示错误原因。</em></p></li><li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p></li></ul><p><em><strong>出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。</strong></em></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/01c00fab19d5/%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%82%E5%B8%B8%E6%9F%A5%E7%9C%8B.bmp"></p><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p>我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。</p><p><strong>异常(Exception)的分类</strong>:根据在编译时期还是运行时期去检查异常?</p><ul><li><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)</li><li><strong>运行时期异常</strong>:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)</li></ul><p>​    <img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/01c00fab19d5/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB.png"></p><h2 id="异常的产生过程解析"><a href="#异常的产生过程解析" class="headerlink" title="异常的产生过程解析"></a>异常的产生过程解析</h2><p>先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。</p><p> 工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTools</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对给定的数组通过给定的角标获取元素。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> element = arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">34</span>, <span class="number">12</span>, <span class="number">67</span> &#125;;</span><br><span class="line">        intnum = ArrayTools.getElement(arr, <span class="number">4</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;num=&quot;</span> + num);</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序执行过程图解：</p><p> <img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/01c00fab19d5/%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E8%BF%87%E7%A8%8B.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Debug追踪</title>
      <link href="/be1395c7d0f0.html"/>
      <url>/be1395c7d0f0.html</url>
      
        <content type="html"><![CDATA[<h2 id="Debug追踪"><a href="#Debug追踪" class="headerlink" title="Debug追踪"></a>Debug追踪</h2><p><strong>使用IDEA的断点调试功能，查看程序的运行过程</strong></p><ol><li><p>在有效代码行，点击行号右边的空白区域，设置断点，程序执行到断点将停止，我们可以手动来运行程序     </p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/be1395c7d0f0/debug1.png"></p></li><li><p>点击Debug运行模式       <img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/be1395c7d0f0/debug2.png">                                                                                                                                                                      </p></li><li><p>程序停止在断点上不再执行，而IDEA最下方打开了Debug调试窗口  </p><p>  <img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/be1395c7d0f0/debug3.png"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/be1395c7d0f0/debug4.png"></p></li><li><p>Debug调试窗口介绍</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/be1395c7d0f0/debug5.png"></p></li><li><p>快捷键F8，代码向下执行一行,第九行执行完毕，执行到第10行（第10行还未执行）</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/be1395c7d0f0/debug6.png"></p></li><li><p>切换到控制台面板，控制台显示 请录入一个字符串： 并且等待键盘录入</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/be1395c7d0f0/debug7.png"></p></li><li><p>快捷键F8，程序继续向后执行，执行键盘录入操作，在控制台录入数据 ababcea</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/be1395c7d0f0/debug8.png"></p><p>回车之后效果：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/be1395c7d0f0/debug9.png"></p><p>调试界面效果：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/be1395c7d0f0/debug0.png"></p></li><li><p>此时到达findChar方法，快捷键F7，进入方法findChar</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/be1395c7d0f0/debug11.png"></p></li><li><p>快捷键F8 接续执行，创建了map对象，变量区域显示</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/be1395c7d0f0/debug12.png"></p></li><li><p>快捷键F8 接续执行，进入到循环中，循环变量i为 0,F8再继续执行，就获取到变量c赋值为字符‘a’ 字节值97</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/be1395c7d0f0/debug13.png"></p></li><li><p>快捷键F8 接续执行，进入到判断语句中，因为该字符 不在Map集合键集中，再按F8执行，进入该判断中</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/be1395c7d0f0/debug14.png"></p></li><li><p>快捷键F8 接续执行，循环结束，进入下次循环，此时map中已经添加一对儿元素</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/be1395c7d0f0/debug15.png"></p></li><li><p>快捷键F8 接续执行，进入下次循环，再继续上面的操作，我们就可以看到代码每次是如何执行的了</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/be1395c7d0f0/debug16.png"></p></li><li><p>如果不想继续debug,那么可以使用快捷键F9,程序正常执行到结束，程序结果在控制台显示</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Map集合</title>
      <link href="/d7751bc6745e.html"/>
      <url>/d7751bc6745e.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p><p>我们通过查看<code>Map</code>接口描述，发现<code>Map</code>接口下的集合与<code>Collection</code>接口下的集合，它们存储数据的形式不同，如下图。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/d7751bc6745e/Collection%E4%B8%8EMap.bmp"></p><ul><li><code>Collection</code>中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li><li><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li><li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li><li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li></ul><h2 id="Map常用子类"><a href="#Map常用子类" class="headerlink" title="Map常用子类"></a>Map常用子类</h2><p>通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。</p><ul><li>**HashMap&lt;K,V&gt;**：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。<ul><li><strong>HashMap集合底层是哈希表：查询的速度特别的快</strong></li><li><strong>JDK1.8之前：数组+单向链表</strong></li><li><strong>JDK1.8之后：数组+单向链表/红黑树（链表的长度超过8）：提高查询的速度</strong></li><li><strong>HashMap集合是一个无序的集合，存储元素和取出元素的顺序有可能一致</strong></li></ul></li><li>**LinkedHashMap&lt;K,V&gt;**：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。<ul><li><strong>LinkedHashMap集合底层是哈希表+链表（报增迭代的顺序）</strong></li><li><strong>LinkedHashMap去和是一个有序的集合，存储元素和取出元素的顺序一致的</strong></li></ul></li></ul><blockquote><p>Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。</p></blockquote><h2 id="Map接口中的常用方法"><a href="#Map接口中的常用方法" class="headerlink" title="Map接口中的常用方法"></a>Map接口中的常用方法</h2><p>Map接口中定义了很多方法，常用的如下：</p><ul><li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li><li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li><li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li><li><code>boolean containsKey(Object key)  </code> 判断集合中是否包含指定的键。</li><li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><p>Map接口的方法演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建 map对象</span></span><br><span class="line">        HashMap&lt;String, String&gt;  map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素到集合</span></span><br><span class="line">        map.put(<span class="string">&quot;黄晓明&quot;</span>, <span class="string">&quot;杨颖&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;文章&quot;</span>, <span class="string">&quot;马伊琍&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;邓超&quot;</span>, <span class="string">&quot;孙俪&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String remove(String key)</span></span><br><span class="line">        System.out.println(map.remove(<span class="string">&quot;邓超&quot;</span>));</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 想要查看 黄晓明的媳妇 是谁</span></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;黄晓明&quot;</span>));</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;邓超&quot;</span>));    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </p><p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 </p></blockquote><h2 id="Map集合遍历键找值方式"><a href="#Map集合遍历键找值方式" class="headerlink" title="Map集合遍历键找值方式"></a>Map集合遍历键找值方式</h2><p>键找值方式：即通过元素中的键，获取键所对应的值</p><p>分析步骤：</p><ol><li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:<code>keyset()</code></li><li>遍历键的Set集合，得到每一个键。</li><li>根据键，获取键所对应的值。方法提示:<code>get(K key)</code></li></ol><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象 </span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">//添加元素到集合 </span></span><br><span class="line">        map.put(<span class="string">&quot;胡歌&quot;</span>, <span class="string">&quot;霍建华&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;郭德纲&quot;</span>, <span class="string">&quot;于谦&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;薛之谦&quot;</span>, <span class="string">&quot;大张伟&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有的键  获取键集</span></span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="comment">// 遍历键集 得到 每一个键</span></span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">          <span class="comment">//key  就是键</span></span><br><span class="line">            <span class="comment">//获取对应值</span></span><br><span class="line">            String value = map.get(key);</span><br><span class="line">            System.out.println(key+<span class="string">&quot;的CP是：&quot;</span>+value);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历图解：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/d7751bc6745e/Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%B8%80.bmp"></p><h2 id="Entry键值对对象"><a href="#Entry键值对对象" class="headerlink" title="Entry键值对对象"></a>Entry键值对对象</h2><p>我们已经知道，<code>Map</code>中存放的是两种对象，一种称为<strong>key</strong>(键)，一种称为<strong>value</strong>(值)，它们在在<code>Map</code>中是一一对应关系，这一对对象又称做<code>Map</code>中的一个<code>Entry(项)</code>。<code>Entry</code>将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历<code>Map</code>集合时，就可以从每一个键值对（<code>Entry</code>）对象中获取对应的键与对应的值。</p><p> 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</p><ul><li><code>public K getKey()</code>：获取Entry对象中的键。</li><li><code>public V getValue()</code>：获取Entry对象中的值。</li></ul><p>在Map集合中也提供了获取所有Entry对象的方法：</p><ul><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><h2 id="Map集合遍历键值对方式"><a href="#Map集合遍历键值对方式" class="headerlink" title="Map集合遍历键值对方式"></a>Map集合遍历键值对方式</h2><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p><p>操作步骤与图解：</p><ol><li><p> 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</p></li><li><p> 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</p></li><li><p> 通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code>     </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Map集合对象 </span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">// 添加元素到集合 </span></span><br><span class="line">        map.put(<span class="string">&quot;胡歌&quot;</span>, <span class="string">&quot;霍建华&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;郭德纲&quot;</span>, <span class="string">&quot;于谦&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;薛之谦&quot;</span>, <span class="string">&quot;大张伟&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 所有的 entry对象  entrySet</span></span><br><span class="line">        Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历得到每一个entry对象</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">           <span class="comment">// 解析 </span></span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();  </span><br><span class="line">            System.out.println(key+<span class="string">&quot;的CP是:&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历图解：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/d7751bc6745e/Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%BA%8C.bmp"></p><blockquote><p>Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</p></blockquote><h2 id="HashMap存储自定义类型键值"><a href="#HashMap存储自定义类型键值" class="headerlink" title="HashMap存储自定义类型键值"></a>HashMap存储自定义类型键值</h2><p>练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。</p><blockquote><p>注意，学生姓名相同并且年龄相同视为同一名学生。</p></blockquote><p>编写学生类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp; Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1,创建Hashmap集合对象。</span></span><br><span class="line">        Map&lt;Student,String&gt;map = <span class="keyword">new</span> HashMap&lt;Student,String&gt;();</span><br><span class="line">        <span class="comment">//2,添加元素。</span></span><br><span class="line">        map.put(newStudent(<span class="string">&quot;lisi&quot;</span>,<span class="number">28</span>), <span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;wangwu&quot;</span>,<span class="number">22</span>), <span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;zhaoliu&quot;</span>,<span class="number">24</span>), <span class="string">&quot;成都&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;zhouqi&quot;</span>,<span class="number">25</span>), <span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;wangwu&quot;</span>,<span class="number">22</span>), <span class="string">&quot;南京&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3,取出元素。键找值方式</span></span><br><span class="line">        Set&lt;Student&gt;keySet = map.keySet();</span><br><span class="line">        <span class="keyword">for</span>(Student key: keySet)&#123;</span><br><span class="line">            Stringvalue = map.get(key);</span><br><span class="line">            System.out.println(key.toString()+<span class="string">&quot;.....&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。</li><li>如果要保证map中存放的key和取出的顺序一致，可以使用<code>java.util.LinkedHashMap</code>集合来存放。</li></ul><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？</p><p>在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap&lt;String, String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;邓超&quot;</span>, <span class="string">&quot;孙俪&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;李晨&quot;</span>, <span class="string">&quot;范冰冰&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;刘德华&quot;</span>, <span class="string">&quot;朱丽倩&quot;</span>);</span><br><span class="line">        Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;  &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">邓超  孙俪</span><br><span class="line">李晨  范冰冰</span><br><span class="line">刘德华  朱丽倩</span><br></pre></td></tr></table></figure><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>底层也是一个哈希表</p><p>线程安全</p><p>不能存储null值</p><p>但是HashTable的子类Properties一样很常用</p><p>Properties是唯一和IO流结合的集合</p><h2 id="Map集合练习"><a href="#Map集合练习" class="headerlink" title="Map集合练习"></a>Map集合练习</h2><p><strong>需求：</strong></p><p>计算一个字符串中每个字符出现次数。</p><p><strong>分析：</strong></p><ol><li> 获取一个字符串对象</li><li> 创建一个Map集合，键代表字符，值代表次数。</li><li> 遍历字符串得到每个字符。</li><li> 判断Map中是否有该键。</li><li> 如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。     </li><li> 打印最终结果</li></ol><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//友情提示</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请录入一个字符串:&quot;</span>);</span><br><span class="line">        String line = <span class="keyword">new</span> Scanner(System.in).nextLine();</span><br><span class="line">        <span class="comment">// 定义 每个字符出现次数的方法</span></span><br><span class="line">        findChar(line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findChar</span><span class="params">(String line)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1:创建一个集合 存储  字符 以及其出现的次数</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="comment">//2:遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; line.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = line.charAt(i);</span><br><span class="line">            <span class="comment">//判断 该字符 是否在键集中</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(c)) &#123;<span class="comment">//说明这个字符没有出现过</span></span><br><span class="line">                <span class="comment">//那就是第一次</span></span><br><span class="line">                map.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//先获取之前的次数</span></span><br><span class="line">                Integer count = map.get(c);</span><br><span class="line">                <span class="comment">//count++;</span></span><br><span class="line">                <span class="comment">//再次存入  更新</span></span><br><span class="line">                map.put(c, ++count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Collections类</title>
      <link href="/fb3dac0e46f1.html"/>
      <url>/fb3dac0e46f1.html</url>
      
        <content type="html"><![CDATA[<h2 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h2><ul><li><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</li></ul><ul><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)  </code>:往集合中添加一些元素。</li><li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li></ul><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//原来写法</span></span><br><span class="line">        <span class="comment">//list.add(12);</span></span><br><span class="line">        <span class="comment">//list.add(14);</span></span><br><span class="line">        <span class="comment">//list.add(15);</span></span><br><span class="line">        <span class="comment">//list.add(1000);</span></span><br><span class="line">        <span class="comment">//采用工具类 完成 往集合中添加元素  </span></span><br><span class="line">        Collections.addAll(list, <span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>，<span class="number">2</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//排序方法 </span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">[<span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">222</span>]</span><br></pre></td></tr></table></figure><p>代码演示之后 ，发现我们的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序那该怎么办呢？</p><p>我们发现还有个方法没有讲，<code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。接下来讲解一下指定规则的排列。</p><h2 id="Comparator比较器"><a href="#Comparator比较器" class="headerlink" title="Comparator比较器"></a>Comparator比较器</h2><p>我们还是先研究这个方法</p><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p><p>不过这次存储的是字符串类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt;  list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;cba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;aba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;sba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;nba&quot;</span>);</span><br><span class="line">        <span class="comment">//排序方法</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[aba, cba, nba, sba]</span><br></pre></td></tr></table></figure><p>我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？</p><p>说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用<code>java.lang.Comparable</code>接口去实现，一种是灵活的当我需要做排序的时候在去选择的<code>java.util.Comparator</code>接口完成。</p><p>那么我们采用的<code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用</p><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：</p><ul><li><p><code> public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</p><blockquote><p>两个对象比较的结果有三种：大于，等于，小于。</p><p>如果要按照升序排序，<br>则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）<br>如果要按照降序排序<br>则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）</p></blockquote></li></ul><p>操作如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;cba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;aba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;sba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;nba&quot;</span>);</span><br><span class="line">        <span class="comment">//排序方法  按照第一个单词的降序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.charAt(<span class="number">0</span>) - o1.charAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[sba, nba, cba, aba]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, (i, j) -&gt; j.getAge() - i.getAge());</span><br><span class="line">可以替换成</span><br><span class="line">list.sort((i, j) -&gt; j.getAge() - i.getAge());</span><br></pre></td></tr></table></figure><h2 id="简述Comparable和Comparator两个接口的区别。"><a href="#简述Comparable和Comparator两个接口的区别。" class="headerlink" title="简述Comparable和Comparator两个接口的区别。"></a>简述Comparable和Comparator两个接口的区别。</h2><p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p><p><strong>Comparator</strong>强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>创建一个学生类，存储到ArrayList集合中完成指定排序操作。</p><p>Student 初始类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">               <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">               <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">               <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建四个学生对象 存储到集合中</span></span><br><span class="line">        ArrayList&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;rose&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;jack&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;abc&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;ace&quot;</span>,<span class="number">17</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;mark&quot;</span>,<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          让学生 按照年龄排序 升序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        Collections.sort(list);//要求 该list中元素类型  必须实现比较器Comparable接口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现，当我们调用Collections.sort()方法的时候 程序报错了。</p><p>原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。</p><p>于是我们就完成了Student类的一个实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age-o.age;<span class="comment">//升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次测试，代码就OK 了效果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student&#123;name=<span class="string">&#x27;jack&#x27;</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;abc&#x27;</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;mark&#x27;</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;ace&#x27;</span>, age=<span class="number">17</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;rose&#x27;</span>, age=<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>如果在使用的时候，想要独立的定义规则去使用 可以采用Collections.sort(List list,Comparetor<T> c)方式，自己定义规则：</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2.getAge()-o1.getAge();<span class="comment">//以学生的年龄降序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student&#123;name=&#x27;rose&#x27;, age=18&#125;</span><br><span class="line">Student&#123;name=&#x27;ace&#x27;, age=17&#125;</span><br><span class="line">Student&#123;name=&#x27;jack&#x27;, age=16&#125;</span><br><span class="line">Student&#123;name=&#x27;abc&#x27;, age=16&#125;</span><br><span class="line">Student&#123;name=&#x27;mark&#x27;, age=16&#125;</span><br></pre></td></tr></table></figure><p>如果想要规则更多一些，可以参考下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 年龄降序</span></span><br><span class="line">                <span class="keyword">int</span> result = o2.getAge()-o1.getAge();<span class="comment">//年龄降序</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(result==<span class="number">0</span>)&#123;<span class="comment">//第一个规则判断完了 下一个规则 姓名的首字母 升序</span></span><br><span class="line">                    result = o1.getName().charAt(<span class="number">0</span>)-o2.getName().charAt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student&#123;name=&#x27;rose&#x27;, age=18&#125;</span><br><span class="line">Student&#123;name=&#x27;ace&#x27;, age=17&#125;</span><br><span class="line">Student&#123;name=&#x27;abc&#x27;, age=16&#125;</span><br><span class="line">Student&#123;name=&#x27;jack&#x27;, age=16&#125;</span><br><span class="line">Student&#123;name=&#x27;mark&#x27;, age=16&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Set接口</title>
      <link href="/7371f7e698bd.html"/>
      <url>/7371f7e698bd.html</url>
      
        <content type="html"><![CDATA[<p><code>java.util.Set</code>接口和<code>java.util.List</code>接口一样，同样继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p><p><code>Set</code>集合有多个子类，这里我们介绍其中的<code>java.util.HashSet</code>、<code>java.util.LinkedHashSet</code>这两个集合</p><p>Set接口的特点：</p><ul><li>不允许存储重复的元素</li><li>没有索引，没有带索引的方法，也不能使用普通的for循环遍历</li></ul><blockquote><p>Set集合取出元素的方式可以采用：迭代器、增强for。</p></blockquote><h2 id="HashSet集合介绍"><a href="#HashSet集合介绍" class="headerlink" title="HashSet集合介绍"></a>HashSet集合介绍</h2><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持。</p><p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p><p>HashSet特点：</p><ul><li>不允许存储重复的元素</li><li>没有索引，没有带索引的方法，也不能使用普通的for循环遍历</li><li>是一个无序的集合，存储元素和取出元素的顺序有可能不一致</li><li>底层是一个哈希表结构（查询的速度非常的快）</li></ul><p>我们先来使用一下Set集合存储，看下现象，再进行原理的讲解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建 Set集合</span></span><br><span class="line">        HashSet&lt;String&gt;  set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        set.add(<span class="keyword">new</span> String(<span class="string">&quot;cba&quot;</span>));</span><br><span class="line">        set.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;bac&quot;</span>); </span><br><span class="line">        set.add(<span class="string">&quot;cba&quot;</span>);  </span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (String name : set) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下，说明集合中不能存储重复元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cba</span><br><span class="line">abc</span><br><span class="line">bac</span><br></pre></td></tr></table></figure><blockquote><p>根据结果我们发现字符串”cba”只存储了一个，也就是说重复的元素set集合不存储。</p></blockquote><h2 id="HashSet集合存储数据的结构（哈希表）"><a href="#HashSet集合存储数据的结构（哈希表）" class="headerlink" title="HashSet集合存储数据的结构（哈希表）"></a>HashSet集合存储数据的结构（哈希表）</h2><p>哈希值：是一个十进制的整数，由系统随机给出（就是对象的地址值，是一个逻辑地址，是模拟出来的地址，不是数据实际存储的物理地址）</p><p>在<code>Object</code>类有一个方法，可以获取对象的哈希值</p><p><code>int hashCode() 返回该对象的哈希码值</code></p><p>hashCode方法的源码：</p><ul><li><code>public native int hashCode();</code></li><li><code>native</code>：表示用的是其他语言编写的代码</li></ul><p>什么是哈希表呢？</p><p>在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p><p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/7371f7e698bd/%E5%93%88%E5%B8%8C%E8%A1%A8.png"></p><p>看到这张图就有人要问了，这个是怎么存储的呢？</p><p>为了方便大家的理解我们结合一个存储流程图来说明一下：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/7371f7e698bd/%E5%93%88%E5%B8%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p><p>总而言之，<strong>JDK1.8</strong>引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</p><h2 id="HashSet存储自定义类型元素"><a href="#HashSet存储自定义类型元素" class="headerlink" title="HashSet存储自定义类型元素"></a>HashSet存储自定义类型元素</h2><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一</p><p>创建自定义Student类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp;</span><br><span class="line">               Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建集合对象   该集合中存储 Student类型对象</span></span><br><span class="line">        HashSet&lt;Student&gt; stuSet = <span class="keyword">new</span> HashSet&lt;Student&gt;();</span><br><span class="line">        <span class="comment">//存储 </span></span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">&quot;于谦&quot;</span>, <span class="number">43</span>);</span><br><span class="line">        stuSet.add(stu);</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">&quot;郭德纲&quot;</span>, <span class="number">44</span>));</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">&quot;于谦&quot;</span>, <span class="number">43</span>));</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">&quot;郭麒麟&quot;</span>, <span class="number">23</span>));</span><br><span class="line">        stuSet.add(stu);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Student stu2 : stuSet) &#123;</span><br><span class="line">            System.out.println(stu2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">Student [name=郭德纲, age=<span class="number">44</span>]</span><br><span class="line">Student [name=于谦, age=<span class="number">43</span>]</span><br><span class="line">Student [name=郭麒麟, age=<span class="number">23</span>]</span><br></pre></td></tr></table></figure><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？</p><p>在HashSet下面有一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。</p><p>演示代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSetDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</span><br><span class="line">set.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;bbc&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">  bbb</span><br><span class="line">  aaa</span><br><span class="line">  abc</span><br><span class="line">  bbc</span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure><p>其实这个书写完全等价与</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型[] 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure><p>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。</p><p><strong>JDK1.5</strong>以后。出现了简化操作。**…** 用在参数上，称之为可变参数。</p><p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p><p>代码演示：    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">62</span>, <span class="number">431</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> sum = getSum(arr);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        <span class="comment">//  6  7  2 12 2121</span></span><br><span class="line">        <span class="comment">// 求 这几个元素和 6  7  2 12 2121</span></span><br><span class="line">        <span class="keyword">int</span> sum2 = getSum(<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">2121</span>);</span><br><span class="line">        System.out.println(sum2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 完成数组  所有元素的求和 原始写法</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">      public static int getSum(int[] arr)&#123;</span></span><br><span class="line"><span class="comment">        int sum = 0;</span></span><br><span class="line"><span class="comment">        for(int a : arr)&#123;</span></span><br><span class="line"><span class="comment">            sum += a;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        return sum;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//可变参数写法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>... arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性</p><p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List的子类</title>
      <link href="/6fe7860f08d4.html"/>
      <url>/6fe7860f08d4.html</url>
      
        <content type="html"><![CDATA[<h2 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h2><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p><p>许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。</p><h2 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h2><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p><blockquote><p>LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下</p></blockquote><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/6fe7860f08d4/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png"></p><p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：</p><ul><li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li><li><code>public E getFirst()</code>:返回此列表的第一个元素。</li><li><code>public E getLast()</code>:返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li><li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li></ul><p>LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可）</p><p>方法演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; link = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        link.addFirst(<span class="string">&quot;abc1&quot;</span>);</span><br><span class="line">        link.addFirst(<span class="string">&quot;abc2&quot;</span>);</span><br><span class="line">        link.addFirst(<span class="string">&quot;abc3&quot;</span>);</span><br><span class="line">        System.out.println(link);</span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        System.out.println(link.getFirst());</span><br><span class="line">        System.out.println(link.getLast());</span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line">        System.out.println(link.removeFirst());</span><br><span class="line">        System.out.println(link.removeLast());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!link.isEmpty()) &#123; <span class="comment">//判断集合是否为空</span></span><br><span class="line">            System.out.println(link.pop()); <span class="comment">//弹出集合中的栈顶元素</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(link);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vector集合"><a href="#Vector集合" class="headerlink" title="Vector集合"></a>Vector集合</h2><p>Vector类可以实现可增长的对象数组,与数组一样，它包含可以使用整数索引进行访问的组件。但是，Vector的大小可以根据需要增大或缩小，以适应创建Vector后进行添加或移除项的操作。</p><p>Vector是同步方法</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List集合</title>
      <link href="/ab4774b19476.html"/>
      <url>/ab4774b19476.html</url>
      
        <content type="html"><![CDATA[<p>Collection中的常用几个子类（<code>java.util.List</code>集合、<code>java.util.Set</code>集合）。</p><h2 id="List接口介绍"><a href="#List接口介绍" class="headerlink" title="List接口介绍"></a>List接口介绍</h2><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p><p>看完API，我们总结一下：</p><p>List接口特点：</p><ol><li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li><li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li><li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li></ol><h2 id="List接口中常用方法"><a href="#List接口中常用方法" class="headerlink" title="List接口中常用方法"></a>List接口中常用方法</h2><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p><ul><li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li><li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li><li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li><li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li></ul><p>List集合特有的方法都是跟索引相关，我们在基础班都学习过，那么我们再来复习一遍吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建List集合对象</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 往 尾部添加 指定元素</span></span><br><span class="line">    list.add(<span class="string">&quot;图图&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;小美&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;不高兴&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(list);</span><br><span class="line">    <span class="comment">// add(int index,String s) 往指定位置添加</span></span><br><span class="line">    list.add(<span class="number">1</span>,<span class="string">&quot;没头脑&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(list);</span><br><span class="line">    <span class="comment">// String remove(int index) 删除指定位置元素  返回被删除元素</span></span><br><span class="line">    <span class="comment">// 删除索引位置为2的元素 </span></span><br><span class="line">    System.out.println(<span class="string">&quot;删除索引位置为2的元素&quot;</span>);</span><br><span class="line">    System.out.println(list.remove(<span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    System.out.println(list);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// String set(int index,String s)</span></span><br><span class="line">    <span class="comment">// 在指定位置 进行 元素替代（改） </span></span><br><span class="line">    <span class="comment">// 修改指定位置元素</span></span><br><span class="line">    list.set(<span class="number">0</span>, <span class="string">&quot;三毛&quot;</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// String get(int index)  获取指定位置元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 跟size() 方法一起用  来 遍历的 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//还可以使用增强for</span></span><br><span class="line">    <span class="keyword">for</span> (String string : list) &#123;</span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>操作素引的时候，一定要防止素引越界异常</p><ul><li>IndexoutofBoundsExceptfon：索引越界异常,集合会报</li><li>ArrayIndexoutofBoundsExcept ion：数组索引越界异常</li><li>StringIndexoutofBoundsException：字行串索引越界异常</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/fcf19d075d62.html"/>
      <url>/fcf19d075d62.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构有什么用？"><a href="#数据结构有什么用？" class="headerlink" title="数据结构有什么用？"></a>数据结构有什么用？</h2><p>当你用着java里面的容器类很爽的时候，你有没有想过，怎么ArrayList就像一个无限扩充的数组，也好像链表之类的。好用吗？好用，这就是数据结构的用处，只不过你在不知不觉中使用了。</p><p>现实世界的存储，我们使用的工具和建模。每种数据结构有自己的优点和缺点，想想如果Google的数据用的是数组的存储，我们还能方便地查询到所需要的数据吗？而算法，在这么多的数据中如何做到最快的插入，查找，删除，也是在追求更快。</p><p>我们java是面向对象的语言，就好似自动档轿车，C语言好似手动档吉普。数据结构呢？是变速箱的工作原理。你完全可以不知道变速箱怎样工作，就把自动档的车子从 A点 开到 B点，而且未必就比懂得的人慢。写程序这件事，和开车一样，经验可以起到很大作用，但如果你不知道底层是怎么工作的，就永远只能开车，既不会修车，也不能造车。当然了，数据结构内容比较多，细细的学起来也是相对费功夫的，不可能达到一蹴而就。我们将常见的数据结构：堆栈、队列、数组、链表和红黑树 这几种给大家介绍一下，作为数据结构的入门，了解一下它们的特点即可。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/fcf19d075d62/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%AF%94%E5%96%BB.png"></p><h2 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h2><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树。我们分别来了解一下：</p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul><li><strong>栈</strong>：<strong>stack</strong>,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</li></ul><p>简单的说：采用该结构的集合，对元素的存取有如下的特点</p><ul><li><p>先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</p></li><li><p>栈的入口、出口的都是栈的顶端位置。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/fcf19d075d62/%E5%A0%86%E6%A0%88.png"></p></li></ul><p>这里两个名词需要注意：</p><ul><li><strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li><li><strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul><li><strong>队列</strong>：<strong>queue</strong>,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</li></ul><p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p><ul><li>先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。</li><li>队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/fcf19d075d62/%E9%98%9F%E5%88%97%E5%9B%BE.bmp"></p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li><strong>数组</strong>:<strong>Array</strong>,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</li></ul><p>简单的说,采用该结构的集合，对元素的存取有如下的特点：</p><ul><li><p>查找元素快：通过索引，可以快速访问指定位置的元素</p><p> <img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/fcf19d075d62/%E6%95%B0%E7%BB%84%E6%9F%A5%E8%AF%A2%E5%BF%AB.png"></p></li><li><p>增删元素慢</p><ul><li><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/fcf19d075d62/%E6%95%B0%E7%BB%84%E6%B7%BB%E5%8A%A0.png"></li><li><strong>指定索引位置删除元素：</strong>需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/fcf19d075d62/%E6%95%B0%E7%BB%84%E5%88%A0%E9%99%A4.png"></li></ul></li></ul><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul><li><p><strong>链表</strong>:<strong>linked list</strong>,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是<strong>单向链表</strong>。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/fcf19d075d62/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%89%B9%E7%82%B9.png"></p></li></ul><p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p><ul><li><p>多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/fcf19d075d62/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png"></p></li><li><p>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p></li><li><p>增删元素快：</p><ul><li><p>增加元素：只需要修改连接下个元素的地址即可。</p><p> <img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/fcf19d075d62/%E5%A2%9E%E5%8A%A0%E7%BB%93%E7%82%B9.png"></p></li><li><p>删除元素：只需要修改连接下个元素的地址即可。</p><p> <img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/fcf19d075d62/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9.bmp"></p></li></ul></li></ul><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><ul><li><strong>二叉树</strong>：<strong>binary tree</strong> ,是每个结点不超过2的有序<strong>树（tree）</strong> 。</li></ul><p>简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。</p><p>二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。</p><p>如图：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/fcf19d075d62/%E4%BA%8C%E5%8F%89%E6%A0%91.bmp"></p><p>我们要说的是二叉树的一种比较有意思的叫做<strong>红黑树</strong>，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。</p><p>红黑树的约束:</p><ol><li>节点可以是红色的或者黑色的</li></ol><ol start="2"><li>根节点是黑色的</li></ol><ol start="3"><li>叶子节点(特指空节点)是黑色的</li><li>每个红色节点的子节点都是黑色的</li><li>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</li></ol><p>红黑树的特点:</p><p>​    速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/e5ad37bd9e65.html"/>
      <url>/e5ad37bd9e65.html</url>
      
        <content type="html"><![CDATA[<h2 id="泛型概述"><a href="#泛型概述" class="headerlink" title="泛型概述"></a>泛型概述</h2><p>集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p><p>大家观察下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">coll.add(<span class="number">5</span>);<span class="comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span></span><br><span class="line">Iterator it = coll.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line"><span class="comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span></span><br><span class="line">String str = (String) it.next();</span><br><span class="line">System.out.println(str.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序在运行时发生了问题<strong>java.lang.ClassCastException</strong>。                                                                                             为什么会发生类型转换异常呢？                                                                                                                                       我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。                                                                                                                                                       怎么来解决这个问题呢？                                                                                                                                                           Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p><ul><li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li></ul><blockquote><p>一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p></blockquote><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e5ad37bd9e65/03_%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%A6%82%E5%BF%B5.bmp" alt="03_泛型的概念"></p><h2 id="使用泛型的好处"><a href="#使用泛型的好处" class="headerlink" title="使用泛型的好处"></a>使用泛型的好处</h2><p>上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？</p><ul><li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li><li>避免了类型强转的麻烦。</li></ul><p>通过我们如下代码体验一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        <span class="comment">// list.add(5);//当集合明确类型后，存放类型不一致就会编译报错</span></span><br><span class="line">        <span class="comment">// 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            String str = it.next();</span><br><span class="line">            <span class="comment">//当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span></span><br><span class="line">            System.out.println(str.length());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</p></blockquote><h2 id="泛型的定义与使用"><a href="#泛型的定义与使用" class="headerlink" title="泛型的定义与使用"></a>泛型的定义与使用</h2><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</p><p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p><h3 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h3><p>定义格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 类名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，API中的ArrayList集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123; &#125;</span><br><span class="line">   ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用泛型： 即什么时候确定泛型。</p><p><strong>在创建对象的时候确定泛型</strong></p><p> 例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p><p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt;</span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(String e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再例如，<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p><p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">Integer</span>&gt; </span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Integer e)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例自定义泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericClass</span>&lt;<span class="title">MVP</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span></span><br><span class="line"><span class="keyword">private</span> MVP mvp;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMVP</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mvp = mvp;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MVP <span class="title">getMVP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClassDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">         <span class="comment">// 创建一个泛型为String的类</span></span><br><span class="line">         MyGenericClass&lt;String&gt; my = <span class="keyword">new</span> MyGenericClass&lt;String&gt;();    </span><br><span class="line">         <span class="comment">// 调用setMVP</span></span><br><span class="line">         my.setMVP(<span class="string">&quot;大胡子登登&quot;</span>);</span><br><span class="line">         <span class="comment">// 调用getMVP</span></span><br><span class="line">         String mvp = my.getMVP();</span><br><span class="line">         System.out.println(mvp);</span><br><span class="line">         <span class="comment">//创建一个泛型为Integer的类</span></span><br><span class="line">         MyGenericClass&lt;Integer&gt; my2 = <span class="keyword">new</span> MyGenericClass&lt;Integer&gt;(); </span><br><span class="line">         my2.setMVP(<span class="number">123</span>);     </span><br><span class="line">         Integer mvp2 = my2.getMVP();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericMethod</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">    System.out.println(mvp.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function">MVP <span class="title">show2</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        MyGenericMethod mm = <span class="keyword">new</span> MyGenericMethod();</span><br><span class="line">        <span class="comment">// 演示看方法提示</span></span><br><span class="line">        mm.show(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        mm.show(<span class="number">123</span>);</span><br><span class="line">        mm.show(<span class="number">12.45</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface接口名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title">getE</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用格式：</p><p><strong>1、定义类时确定泛型的类型</strong></p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp1</span> <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，泛型E的值就是String类型。</p><p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p><p> 例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp2</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确定泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyImp2&lt;String&gt;  my = <span class="keyword">new</span> MyImp2&lt;String&gt;();  </span><br><span class="line">        my.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p><h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p><p>此时只能接受数据,不能往该集合中存储数据。</p><p>举个例子大家理解使用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Intger&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    getElement(list1);</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    getElement(list2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//？代表可以接收任意类型</span></span><br></pre></td></tr></table></figure><blockquote><p>泛型不存在继承关系 Collection<Object> list = new ArrayList<String>();这种是错误的。</String></Object></p></blockquote><h4 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h4><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p><p><strong>泛型的上限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li></ul><p><strong>泛型的下限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li></ul><p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Collection&lt;Number&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">    Collection&lt;Object&gt; list4 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    </span><br><span class="line">    getElement(list1);</span><br><span class="line">    getElement(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement(list3);</span><br><span class="line">    getElement(list4);<span class="comment">//报错</span></span><br><span class="line">  </span><br><span class="line">    getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list3);</span><br><span class="line">    getElement2(list4);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement2</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote class="blockquote-center" id="guard"></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Iterator迭代器</title>
      <link href="/4b9608333997.html"/>
      <url>/4b9608333997.html</url>
      
        <content type="html"><![CDATA[<h2 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h2><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p><p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p><ul><li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li></ul><p>下面介绍一下迭代的概念：</p><ul><li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li></ul><p>Iterator接口的常用方法如下：</p><ul><li><code>public E next()</code>:返回迭代的下一个元素。</li><li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li></ul><p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用多态方式 创建对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        coll.add(<span class="string">&quot;串串星人&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;吐槽星人&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;汪星人&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//使用迭代器 遍历   每个集合对象都有自己的迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="comment">//  泛型指的是 迭代出 元素的数据类型</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">            String s = it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p></blockquote><h2 id="迭代器的实现原理"><a href="#迭代器的实现原理" class="headerlink" title="迭代器的实现原理"></a>迭代器的实现原理</h2><p>我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p><p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/4b9608333997/02_%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86(1).bmp"></p><p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p><h2 id="2-3-增强for"><a href="#2-3-增强for" class="headerlink" title="2.3 增强for"></a>2.3 增强for</h2><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; </span><br><span class="line">  <span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p><h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBForDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">87</span>&#125;;</span><br><span class="line">       <span class="comment">//使用增强for遍历数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;<span class="comment">//a代表数组中的每个元素</span></span><br><span class="line">System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">    Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    coll.add(<span class="string">&quot;小河神&quot;</span>);</span><br><span class="line">    coll.add(<span class="string">&quot;老河神&quot;</span>);</span><br><span class="line">    coll.add(<span class="string">&quot;神婆&quot;</span>);</span><br><span class="line">    <span class="comment">//使用增强for遍历</span></span><br><span class="line">    <span class="keyword">for</span>(String s :coll)&#123;<span class="comment">//接收变量s代表 代表被遍历到的集合元素</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Collection集合</title>
      <link href="/2ce74a09c8f3.html"/>
      <url>/2ce74a09c8f3.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>集合到底是什么呢?</p><ul><li><strong>集合</strong>：集合是Java中提供的一种容器，可以用来存储多个数据。</li></ul><p>集合和数组既然都是容器，它们有啥区别呢？</p><ul><li>数组的长度是固定的。集合的长度是可变的。</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li></ul><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>JavaSE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p><p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code>，今天我们主要学习<code>Collection</code>集合，<code>Map</code>集合。</p><ul><li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。<ul><li>其中，<code>List</code>的特点是元素有序、元素可重复。</li><li><code>Set</code>的特点是元素无序，而且不可重复。</li><li><code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，</li><li><code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</li></ul></li></ul><p>从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2ce74a09c8f3/01_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.bmp" alt="01_集合框架介绍"></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2ce74a09c8f3/image-20200412180201258.png" alt="image-20200412180201258"></p><p>其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。</p><p>集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p><h2 id="Collection-常用功能"><a href="#Collection-常用功能" class="headerlink" title="Collection 常用功能"></a>Collection 常用功能</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p><ul><li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> :清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li></ul><p>方法演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1Collection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建集合对象 </span></span><br><span class="line">    <span class="comment">// 使用多态形式</span></span><br><span class="line">    Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 使用方法</span></span><br><span class="line">    <span class="comment">// 添加功能  boolean  add(String s)</span></span><br><span class="line">    coll.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">    coll.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">    coll.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line">    System.out.println(coll);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// boolean contains(E e) 判断o是否在集合中存在</span></span><br><span class="line">    System.out.println(<span class="string">&quot;判断  扫地僧 是否在集合中&quot;</span>+coll.contains(<span class="string">&quot;扫地僧&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean remove(E e) 删除在集合中的o元素</span></span><br><span class="line">    System.out.println(<span class="string">&quot;删除石破天：&quot;</span>+coll.remove(<span class="string">&quot;石破天&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;操作之后集合中元素:&quot;</span>+coll);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// size() 集合中有几个元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;集合中有&quot;</span>+coll.size()+<span class="string">&quot;个元素&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object[] toArray()转换成一个Object数组</span></span><br><span class="line">    Object[] objects = coll.toArray();</span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">System.out.println(objects[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void  clear() 清空集合</span></span><br><span class="line">coll.clear();</span><br><span class="line">System.out.println(<span class="string">&quot;集合中内容为：&quot;</span>+coll);</span><br><span class="line"><span class="comment">// boolean  isEmpty()  判断是否为空</span></span><br><span class="line">System.out.println(coll.isEmpty());  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>包装类</title>
      <link href="/b3946cdad917.html"/>
      <url>/b3946cdad917.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p><table><thead><tr><th>基本类型</th><th>对应的包装类（位于java.lang包中）</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td><strong>Integer</strong></td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td><strong>Character</strong></td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/b3946cdad917/02_%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5.bmp" alt="02_包装类的概念"></p><h2 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h2><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p><ul><li><p><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</p></li><li><p><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</p></li></ul><p>用Integer与 int为例：（看懂代码即可）</p><p>基本数值—-&gt;包装对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">4</span>);<span class="comment">//使用构造函数函数</span></span><br><span class="line">Integer iii = Integer.valueOf(<span class="number">4</span>);<span class="comment">//使用包装类中的valueOf方法</span></span><br></pre></td></tr></table></figure><p>包装对象—-&gt;基本数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = i.intValue();</span><br></pre></td></tr></table></figure><h2 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h2><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p><p>自动拆箱：Integer时包装类，无法直接参与运算，可以自动转换为基本类型的数据，在计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">4</span>;<span class="comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span></span><br><span class="line">i = i + <span class="number">5</span>;<span class="comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span></span><br><span class="line"><span class="comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span></span><br></pre></td></tr></table></figure><h2 id="基本类型与字符串之间的转换"><a href="#基本类型与字符串之间的转换" class="headerlink" title="基本类型与字符串之间的转换"></a>基本类型与字符串之间的转换</h2><h3 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h3><p>   基本类型转换String总共有三种方式，这里只讲最简单的一种方式： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本类型直接与””相连接即可；如：34+&quot;&quot;</span><br></pre></td></tr></table></figure><p>String转换成对应的基本类型 </p><p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p><ul><li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li><li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li><li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li><li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li><li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li><li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li><li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li></ul><p>代码使用（仅以Integer类的静态方法parseXxx为例）如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo18WrapperParse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StringBuilder类</title>
      <link href="/a8e99b664015.html"/>
      <url>/a8e99b664015.html</url>
      
        <content type="html"><![CDATA[<h2 id="字符串拼接问题"><a href="#字符串拼接问题" class="headerlink" title="字符串拼接问题"></a>字符串拼接问题</h2><p>由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        s += <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。</p><p>根据这句话分析我们的代码，其实总共产生了三个字符串，即<code>&quot;Hello&quot;</code>、<code>&quot;World&quot;</code>和<code>&quot;HelloWorld&quot;</code>。引用变量s首先指向<code>Hello</code>对象，最终指向拼接出来的新字符串对象，即<code>HelloWord</code> 。</p><p>由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用<code>java.lang.StringBuilder</code>类。</p><h2 id="StringBuilder概述"><a href="#StringBuilder概述" class="headerlink" title="StringBuilder概述"></a>StringBuilder概述</h2><p>查阅<code>java.lang.StringBuilder</code>的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p><p>原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p><p>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/a8e99b664015/01_StringBuilder%E7%9A%84%E5%8E%9F%E7%90%86.bmp" alt="01_StringBuilder的原理"></p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>根据StringBuilder的API文档，常用构造方法有2个：</p><ul><li><code>public StringBuilder()</code>：构造一个空的StringBuilder容器。</li><li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        System.out.println(sb1); <span class="comment">// (空白)</span></span><br><span class="line">        <span class="comment">// 使用带参构造</span></span><br><span class="line">        StringBuilder sb2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        System.out.println(sb2); <span class="comment">// itcast</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>StringBuilder常用的方法有2个：</p><ul><li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</li><li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</li></ul><h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><p>append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02StringBuilder</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">//public StringBuilder append(任意类型)</span></span><br><span class="line">StringBuilder builder2 = builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//对比一下</span></span><br><span class="line">System.out.println(<span class="string">&quot;builder:&quot;</span>+builder);</span><br><span class="line">System.out.println(<span class="string">&quot;builder2:&quot;</span>+builder2);</span><br><span class="line">System.out.println(builder == builder2); <span class="comment">//true</span></span><br><span class="line">    <span class="comment">// 可以添加 任何类型</span></span><br><span class="line">builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">builder.append(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">builder.append(<span class="keyword">true</span>);</span><br><span class="line">builder.append(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。</span></span><br><span class="line">        <span class="comment">// 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下</span></span><br><span class="line"><span class="comment">//链式编程</span></span><br><span class="line">builder.append(<span class="string">&quot;hello&quot;</span>).append(<span class="string">&quot;world&quot;</span>).append(<span class="keyword">true</span>).append(<span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;builder:&quot;</span>+builder);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>StringBuilder已经覆盖重写了Object当中的toString方法。</p></blockquote><h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo16StringBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 链式创建</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Hello&quot;</span>).append(<span class="string">&quot;World&quot;</span>).append(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        String str = sb.toString();</span><br><span class="line">        System.out.println(str); <span class="comment">// HelloWorldJava</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>System类</title>
      <link href="/ca04d468491e.html"/>
      <url>/ca04d468491e.html</url>
      
        <content type="html"><![CDATA[<p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：</p><ul><li><code>public static long currentTimeMillis()</code>：返回以毫秒为单位的当前时间。</li><li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li></ul><h2 id="currentTimeMillis方法"><a href="#currentTimeMillis方法" class="headerlink" title="currentTimeMillis方法"></a>currentTimeMillis方法</h2><p>实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//获取当前时间毫秒值</span></span><br><span class="line">        System.out.println(System.currentTimeMillis()); <span class="comment">// 1516090531144</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>验证for循环打印数字1-9999所需要使用的时间（毫秒）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;共耗时毫秒：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="arraycopy方法"><a href="#arraycopy方法" class="headerlink" title="arraycopy方法"></a>arraycopy方法</h2><ul><li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li></ul><p>数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：</p><table><thead><tr><th>参数序号</th><th>参数名称</th><th>参数类型</th><th>参数含义</th></tr></thead><tbody><tr><td>1</td><td>src</td><td>Object</td><td>源数组</td></tr><tr><td>2</td><td>srcPos</td><td>int</td><td>源数组索引起始位置</td></tr><tr><td>3</td><td>dest</td><td>Object</td><td>目标数组</td></tr><tr><td>4</td><td>destPos</td><td>int</td><td>目标数组索引起始位置</td></tr><tr><td>5</td><td>length</td><td>int</td><td>复制元素个数</td></tr></tbody></table><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo11SystemArrayCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] src = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dest = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        System.arraycopy( src, <span class="number">0</span>, dest, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">/*代码运行后：两个数组中的元素发生了变化</span></span><br><span class="line"><span class="comment">         src数组元素[1,2,3,4,5]</span></span><br><span class="line"><span class="comment">         dest数组元素[1,2,3,9,10]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日期时间类</title>
      <link href="/e43d8e1e85d5.html"/>
      <url>/e43d8e1e85d5.html</url>
      
        <content type="html"><![CDATA[<h2 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code> java.util.Date</code>类 表示特定的瞬间，精确到毫秒（1000毫秒=1秒）。</p><p>继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。</p><ul><li><code>public Date()</code>：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</li><li><code>public Date(long date)</code>：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即<code>1970年1月1日00:00:00 GMT</code>）以来的指定毫秒数。</li></ul><blockquote><p>由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。</p></blockquote><p>简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   test1();</span><br><span class="line">   test2();</span><br><span class="line">   test3();</span><br><span class="line">   test4();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * getTime()</span></span><br><span class="line"><span class="comment"> * 成员方法</span></span><br><span class="line"><span class="comment"> * 把日期转换为毫秒数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> Date(<span class="number">0L</span>).getTime());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * new Date(0L);</span></span><br><span class="line"><span class="comment"> * 有参构造方法 OL为毫秒数</span></span><br><span class="line"><span class="comment"> * 获取OL的日期和时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> Date(<span class="number">0L</span>));</span><br><span class="line">    <span class="comment">// Thu Jan 01 08:00:00 CST 1970</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * new Date();</span></span><br><span class="line"><span class="comment"> * 空构造方法</span></span><br><span class="line"><span class="comment"> * 获取当前系统日期和时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * System.currentTimeMillis();</span></span><br><span class="line"><span class="comment"> * 获取当前时间的毫秒数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(System.currentTimeMillis());</span><br><span class="line">    <span class="comment">//获取当前系统时间到1970年1月1日00:00:00经历了多少毫秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。</p></blockquote><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>Date类中的多数方法已经过时，常用的方法有：</p><ul><li><code>public long getTime()</code> 把日期对象转换成对应的时间毫秒值。</li></ul><h2 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h2><p><code>java.text.DateFormat</code> 是日期/时间格式化子类的<strong>抽象类</strong>，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。</p><ul><li><strong>格式化</strong>：按照指定的格式，从Date对象转换为String对象。</li><li><strong>解析</strong>：按照指定的格式，从String对象转换为Date对象。</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>由于DateFormat为抽象类，不能直接使用，所以需要常用的子类<code>java.text.SimpleDateFormat</code>。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：</p><ul><li><code>public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。</li></ul><p>参数pattern是一个字符串，代表日期时间的自定义格式。</p><h3 id="格式规则"><a href="#格式规则" class="headerlink" title="格式规则"></a>格式规则</h3><p>常用的格式规则为：</p><table><thead><tr><th>标识字母（区分大小写）</th><th>含义</th></tr></thead><tbody><tr><td>y</td><td>年</td></tr><tr><td>M</td><td>月</td></tr><tr><td>d</td><td>日</td></tr><tr><td>H</td><td>时</td></tr><tr><td>m</td><td>分</td></tr><tr><td>s</td><td>秒</td></tr></tbody></table><blockquote><p>更详细的格式规则，可以参考SimpleDateFormat类的API文档 </p></blockquote><p>创建SimpleDateFormat对象的代码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02SimpleDateFormat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对应的日期格式如：2018-01-16 15:06:38</span></span><br><span class="line">        DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>DateFormat类的常用方法有：</p><ul><li><code>public String format(Date date)</code>：将Date对象格式化为字符串。</li><li><code>public Date parse(String source)</code>：将字符串解析为Date对象。</li></ul><h4 id="format方法"><a href="#format方法" class="headerlink" title="format方法"></a>format方法</h4><p>使用format方法的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 把Date对象转换成String</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03DateFormatMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">// 创建日期格式化对象,在获取格式化对象时可以指定风格</span></span><br><span class="line">        DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">        String str = df.format(date);</span><br><span class="line">        System.out.println(str); <span class="comment">// 2008年1月23日</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="parse方法"><a href="#parse方法" class="headerlink" title="parse方法"></a>parse方法</h4><p>使用parse方法的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 把String转换成Date对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04DateFormatMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">        String str = <span class="string">&quot;2018年12月11日&quot;</span>;</span><br><span class="line">        Date date = df.parse(str);</span><br><span class="line">        System.out.println(date); <span class="comment">// Tue Dec 11 00:00:00 CST 2018</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>java.util.Calendar</code>是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。</p><h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><p>Calendar为<strong>抽象类</strong>，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：</p><p>Calendar静态方法</p><ul><li><code>public static Calendar getInstance()</code>：使用默认时区和语言环境获得一个日历</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06CalendarInit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance(); <span class="comment">// 多态</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><p>根据Calendar类的API文档，常用方法有：</p><ul><li><code>public int get(int field)</code>：返回给定日历字段的值。</li><li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。</li><li><code>public abstract void add(int field, int amount)</code>：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li><li><code>public Date getTime()</code>：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</li></ul><p>Calendar类中提供很多成员常量，代表给定的日历字段：</p><table><thead><tr><th>字段值</th><th>含义</th></tr></thead><tbody><tr><td>YEAR</td><td>年</td></tr><tr><td>MONTH</td><td>月（从0开始，可以+1使用）</td></tr><tr><td>DAY_OF_MONTH</td><td>月中的天（几号）</td></tr><tr><td>HOUR</td><td>时（12小时制）</td></tr><tr><td>HOUR_OF_DAY</td><td>时（24小时制）</td></tr><tr><td>MINUTE</td><td>分</td></tr><tr><td>SECOND</td><td>秒</td></tr><tr><td>DAY_OF_WEEK</td><td>周中的天（周几，周日为1，可以-1使用）</td></tr></tbody></table><h4 id="get-set方法"><a href="#get-set方法" class="headerlink" title="get/set方法"></a>get/set方法</h4><p>get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Calendar对象</span></span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 设置年 </span></span><br><span class="line">        <span class="keyword">int</span> year = cal.get(Calendar.YEAR);</span><br><span class="line">        <span class="comment">// 设置月</span></span><br><span class="line">        <span class="keyword">int</span> month = cal.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 设置日</span></span><br><span class="line">        <span class="keyword">int</span> dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07CalendarMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        cal.set(Calendar.YEAR, <span class="number">2020</span>);</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2020年1月17日</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08CalendarMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2018年1月17日</span></span><br><span class="line">        <span class="comment">// 使用add方法</span></span><br><span class="line">        cal.add(Calendar.DAY_OF_MONTH, <span class="number">2</span>); <span class="comment">// 加2天</span></span><br><span class="line">        cal.add(Calendar.YEAR, -<span class="number">3</span>); <span class="comment">// 减3年</span></span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2015年1月18日; </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getTime方法"><a href="#getTime方法" class="headerlink" title="getTime方法"></a>getTime方法</h4><p>Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo09CalendarMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        Date date = cal.getTime();</span><br><span class="line">        System.out.println(date); <span class="comment">// Tue Jan 16 16:03:09 CST 2018</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>​    西方星期的开始为周日，中国为周一。</p><p>​     在Calendar类中，月份的表示是以0-11代表1-12月。</p><p>​     日期是有大小关系的，时间靠后，时间越大。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object类</title>
      <link href="/675ab52ded3d.html"/>
      <url>/675ab52ded3d.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>java.lang.Object</code>类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。</p><p>如果一个类没有特别指定父类，那么默认则继承自Object类。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> /*<span class="keyword">extends</span> <span class="title">Object</span>*/ </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h2><h3 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li></ul><p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</p><p>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p><h3 id="覆盖重写"><a href="#覆盖重写" class="headerlink" title="覆盖重写"></a>覆盖重写</h3><p>如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略构造器与Getter Setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。</p></blockquote><h2 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h2><h3 id="方法摘要-1"><a href="#方法摘要-1" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><p>调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。</p><h3 id="默认地址比较"><a href="#默认地址比较" class="headerlink" title="默认地址比较"></a>默认地址比较</h3><p>如果没有覆盖重写equals方法，那么Object类中默认进行<code>==</code>运算符的对象<strong>地址比较</strong>，只要不是同一个对象，结果必然为false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且隐含着一个多态</p><p><code>Object obj = new 对象类();</code></p><p>多态的弊端：无法受用子类特有的内容</p><p>解决：向下转型</p><h3 id="对象内容比较"><a href="#对象内容比较" class="headerlink" title="对象内容比较"></a>对象内容比较</h3><p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果对象地址一样，则认为相同</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果参数为空，或者类型信息不一样，则认为不同</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 转换为当前类型</span></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span></span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。 </p><h2 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h2><p>自动重写equals代码中，使用到了<code>java.util.Objects</code>类</p><p>在<strong>JDK7</strong>添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是<strong>null-save</strong>（空指针安全的）或<strong>null-tolerant</strong>（容忍空指针的），用于计算对象的hashCode、返回对象的字符串表示形式、比较两个对象。</p><p>在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：</p><ul><li><code>public static boolean equals(Object a, Object b)</code>:判断两个对象是否相等。</li></ul><p>我们可以查看一下源码，学习一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内部类</title>
      <link href="/0cc7ddcf0032.html"/>
      <url>/0cc7ddcf0032.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>内部类：将一个类A定义再另外一个类B里面，里面的那个类A就称为内部类，B则程为外部类</p><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><ul><li>成员内部类：定义再类中方法外的类</li><li>格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 外部类</span>&#123;</span><br><span class="line"> 修饰符 <span class="class"><span class="keyword">class</span> 内部类</span>&#123;</span><br><span class="line">   </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>访问特点<ul><li>内部类可以直接访问外部类的成员，包括私有成员</li><li>外部类要访问内部类的成员，必须要简历内部类的对象</li><li>格式：<code>外部类名.内部类名 对象名 = new 外部类型().new 内部类型();</code></li></ul></li></ul><blockquote><p>内部类依然是一个独立的类，再编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号</p></blockquote><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ul><li>局部内部类：只有当前所属的方法才能使用它，除了这个方法外面就不能用了</li><li>格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 外部类名称</span>&#123;</span><br><span class="line"> 修饰符 返回值类型 外部类方法名称(参数列表)&#123;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> 局部内部类名称</span>&#123;</span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>访问<ul><li>在局部内部类中实现类的初始化</li></ul></li></ul><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><ul><li>匿名内部类：是内部类的简化写法。它的本质是一个<code>带具体实现的</code> <code>父类或者父接口的</code> <code>匿名的</code>子类对象。</li><li>前提<ul><li>匿名内部类必须继承一个父类或者实现一个父接口</li></ul></li><li>格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类名或者接口名()&#123;</span><br><span class="line">  <span class="comment">// 方法重写</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 执行语句</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>格式解析<ul><li>new代表创建对象的动作</li><li>接口名称就是匿名内部类需要实现那些接口</li><li>{…}这才是匿名内部类的内容</li></ul></li><li>注意<ul><li>匿名内部类，在创建对象的时候，只能使用唯一一次</li><li>如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类</li><li>匿名对象，在调用方法的时候，只能调用唯一一次</li><li>如果希望同一个对象，调用多次方法，那么必须给对象起个名字</li><li>匿名内部类是省略了实现类、子类名称，但是匿名对象是省略了对象名称<ul><li>匿名内部类和匿名对象不是一回事</li></ul></li></ul></li></ul><h2 id="类的特点"><a href="#类的特点" class="headerlink" title="类的特点"></a>类的特点</h2><ul><li>权限修饰符<ul><li>外部类：public、default</li><li>成员内部类：public、protected、default、private</li><li>局部内部类：上面都不能写</li></ul></li><li>局部内部类：如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】<ul><li>从Java 8+开始，只要局部变量事实不变，那么final关键字可以忽略</li><li>原因<ul><li>new出来的对象在堆内存当中</li><li>局部变量是跟着方法走的，在栈内存当中</li><li>方法运行结束之后，立刻出栈，局部变量就会立刻消失</li><li>但是new出来的对象会在对当中持续存在，知道垃圾回收消失</li></ul></li></ul></li></ul><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Outer&#123;</span><br><span class="line">  <span class="comment">// 外部类的成员变量</span></span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    <span class="comment">// 内部类的成员变量</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// 内部类方法的局部变量</span></span><br><span class="line">      <span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">      <span class="comment">// 局部变量，就近原则</span></span><br><span class="line">      System.out.print(num);</span><br><span class="line">      <span class="comment">// 内部类的成员变量</span></span><br><span class="line">      System.out.print(<span class="keyword">this</span>.num);</span><br><span class="line">      <span class="comment">// 外部类的成员变量</span></span><br><span class="line">      System.out.print(Outer.<span class="keyword">this</span>.num);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权限修饰符</title>
      <link href="/af0c06af727c.html"/>
      <url>/af0c06af727c.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限</p><ul><li>public：公共的。</li><li>protected：受保护的</li><li>default：默认的</li><li>private：私有的</li></ul><h2 id="不同权限的访问能力"><a href="#不同权限的访问能力" class="headerlink" title="不同权限的访问能力"></a>不同权限的访问能力</h2><table><thead><tr><th></th><th>public</th><th>protected</th><th>default</th><th>private</th></tr></thead><tbody><tr><td>同一类中</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>同一包中（子类于无关类）</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>不同包的子类</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>不同包中的无关类</td><td>√</td><td></td><td></td><td></td></tr></tbody></table><p>编写代码时，如果没有特殊的考虑，建议这样使用权限：</p><ul><li>成员变量使用private，隐藏细节。</li><li>构造方法使用public，方便创建对象。</li><li>成员方法使用public，方便调用方法。</li></ul><blockquote><p>不加权限修饰符，其访问能力与default修饰符相同</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Final关键字</title>
      <link href="/546c10072d86.html"/>
      <url>/546c10072d86.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>为了避免随意改写的情况，Java提供了<code>final</code>关键字，用于修饰<strong>不可变内容</strong></p><ul><li>final：不可以改变，可以用于修饰类、方法和变量<ul><li>类：被修饰的类，不能被继承</li><li>方法：被修饰的方法，不能被重写</li><li>变量：被修饰的变量，不能被重新赋值</li></ul></li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul><li>修饰类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修饰方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">final</span> 返回值类型 方法名(参数列表)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于类、方法来说，abstract和final关键字不能同时使用</p><ul><li><p>修饰变量</p><ul><li><p>局部变量：基本类型</p><ul><li><p>只能赋值一次，第二次赋值就会报错</p></li><li><p>```java<br>final 基本类型 名称;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 局部变量：引用类型</span><br><span class="line"></span><br><span class="line">  - 不能修改引用对象的地址，但是可以修改对象内部的成员变量</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    final 类名 对象名 = new 类名();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>成员变量</p><ul><li>因为成员变量具有默认值，所以使用final关键字之后必须手动赋值，不会再给默认值了</li><li>对于final的成员变量，只能初始化完成<ul><li>显示初始化</li><li>构造方法初始化</li></ul></li><li></li></ul></li></ul></li></ul><blockquote><p>被final修饰的常量名称，一般都有书写规范，所有字母都大写</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware虚拟机系统Ubuntu安装VMware Tools工具</title>
      <link href="/7b851fc8c287.html"/>
      <url>/7b851fc8c287.html</url>
      
        <content type="html"><![CDATA[<h1 id="VMware虚拟机系统Ubuntu安装VMware-tools工具"><a href="#VMware虚拟机系统Ubuntu安装VMware-tools工具" class="headerlink" title="VMware虚拟机系统Ubuntu安装VMware tools工具"></a>VMware虚拟机系统Ubuntu安装VMware tools工具</h1><p>在VMware Workstation虚拟机中，如果虚拟Ubuntu系统未安装vmware tools工具，鼠标操作起来将不是很方便，需要使用热键Ctrl+Alt热键切换出来。下面，介绍一下如何在ubuntu虚拟机中安装vmware tools工具。</p><p>启动vmware workstation软件，运行ubuntu虚拟操作系统，登陆进入ubuntu桌面。选择“虚拟机”-&gt;“安装vmware tools”VMware tools</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/7b851fc8c287/image-20200403172358617.png" alt="image-20200403172358617"></p><p>双击桌面的“vmware tools”,打开vmware tools安装介质。右键选择vmwaretools的gz压缩包，</p><p>将该文件复制到<code>下载文件夹</code>，<code>至于复制到什么文件夹。大家可以自行选择</code>。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/7b851fc8c287/image-20200403172438473.png" alt="image-20200403172438473"></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/7b851fc8c287/image-20200403173538440.png" alt="image-20200403173538440"></p><p>右键点击该文件，选择“提取到此处”</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/7b851fc8c287/image-20200403173638585.png" alt="image-20200403173638585"></p><p>打开解压后的vmwaretools文件夹，右键点击vmware-tools-distrib文件夹，选择“在终端打开”</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/7b851fc8c287/image-20200403173732626.png" alt="image-20200403173732626"></p><p>在终端的命令窗口当中，输入<code>sudo ./vmware-tools-distrib/vmware-install.pl</code>命令。输入用户密码回车开始安装。出现第一个画面时，选择“<code>y</code>”回车。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/7b851fc8c287/image-20200403174051861.png" alt="image-20200403174051861"></p><p>一路回车进行安装，出现以下的画面，安装完成。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/7b851fc8c287/image-20200403174218198.png" alt="image-20200403174218198"></p><p><code>重启电脑，重新进入，安装vmware tools即生效。鼠标和复制粘贴就生效了。</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改Ubuntu分辨率</title>
      <link href="/b28bf5bb0dae.html"/>
      <url>/b28bf5bb0dae.html</url>
      
        <content type="html"><![CDATA[<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/b28bf5bb0dae/image-20200403165720339.png" alt="image-20200403165720339"></p><h2 id="点设备"><a href="#点设备" class="headerlink" title="点设备"></a>点设备</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/b28bf5bb0dae/image-20200403165813924.png" alt="image-20200403165813924"></p><h2 id="修改分辨率"><a href="#修改分辨率" class="headerlink" title="修改分辨率"></a>修改分辨率</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/b28bf5bb0dae/image-20200403165857456.png" alt="image-20200403165857456"></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/b28bf5bb0dae/image-20200403165934815.png" alt="image-20200403165934815"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改Ubuntu的系统源</title>
      <link href="/de53a68554c4.html"/>
      <url>/de53a68554c4.html</url>
      
        <content type="html"><![CDATA[<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/de53a68554c4/image-20200403171326693.png" alt="image-20200403171326693"></p><p>点击软件和更新</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/de53a68554c4/image-20200403171359402.png" alt="image-20200403171359402"></p><p>点击中国的服务器</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/de53a68554c4/image-20200403171423549.png" alt="image-20200403171423549"></p><p>点击其他站点</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/de53a68554c4/image-20200403171516801.png" alt="image-20200403171516801"></p><p>测试或者选择你觉得可以快一点的镜像</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/de53a68554c4/image-20200403171608393.png" alt="image-20200403171608393"></p><p>点击确定输入用户密码就好</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/de53a68554c4/image-20200403171637121.png" alt="image-20200403171637121"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装Ubuntu</title>
      <link href="/f144d956d9c0.html"/>
      <url>/f144d956d9c0.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装Ubuntu"><a href="#安装Ubuntu" class="headerlink" title="安装Ubuntu"></a>安装Ubuntu</h1><p>准备工作</p><ul><li>需要VMware</li></ul><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><p>Ubuntu下载地址:<a href="http://releases.ubuntu.com/">http://releases.ubuntu.com/</a></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/f144d956d9c0/image-20200403154017477.png" alt="image-20200403154017477"></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/f144d956d9c0/image-20200403155024305.png" alt="image-20200403155024305"></p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/f144d956d9c0/image-20200403154049421.png" alt="image-20200403154049421"></p><h2 id="准备虚拟机"><a href="#准备虚拟机" class="headerlink" title="准备虚拟机"></a>准备虚拟机</h2><p>在下载的时候，现在VMware里面准备好虚拟机</p><h3 id="创建新的虚拟机"><a href="#创建新的虚拟机" class="headerlink" title="创建新的虚拟机"></a>创建新的虚拟机</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/f144d956d9c0/image-20200403154231003.png" alt="image-20200403154231003"></p><h4 id="创建典型的即可"><a href="#创建典型的即可" class="headerlink" title="创建典型的即可"></a>创建典型的即可</h4><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/f144d956d9c0/image-20200403154423758.png" alt="image-20200403154423758"></p><h4 id="创建一个空的虚拟机"><a href="#创建一个空的虚拟机" class="headerlink" title="创建一个空的虚拟机"></a>创建一个空的虚拟机</h4><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/f144d956d9c0/image-20200403154528596.png" alt="image-20200403154528596"></p><h4 id="创建64位的虚拟机"><a href="#创建64位的虚拟机" class="headerlink" title="创建64位的虚拟机"></a>创建64位的虚拟机</h4><p>因为默认下载的为64位的</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/f144d956d9c0/image-20200403154642694.png" alt="image-20200403154642694"></p><p>所在在选择系统的时候选择64位的系统</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/f144d956d9c0/image-20200403154754885.png" alt="image-20200403154754885"></p><h4 id="安装的位置"><a href="#安装的位置" class="headerlink" title="安装的位置"></a>安装的位置</h4><p>找自己电脑比较空旷的磁盘安装（预估一下差不多40G~60G）</p><table><thead><tr><th><strong>挂载点(目录)</strong></th><th><strong>建议大小</strong></th><th><strong>格式</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>/</td><td>20G左右</td><td>ext4</td><td>根目录</td></tr><tr><td>/home</td><td>越大越好</td><td>ext4</td><td>用户工作目录，用户存储的数据，文件，安装的软件都存放在这儿</td></tr><tr><td>/boot</td><td>300M左右</td><td>ext4</td><td>一般几百M，主要存放linux内核及一些引导文件</td></tr><tr><td>/tmp</td><td>10G左右</td><td>ext4</td><td>系统的一些临时文件</td></tr><tr><td>/swap</td><td>8G左右</td><td>swap交换空间</td><td>相当于虚拟内存</td></tr></tbody></table><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/f144d956d9c0/image-20200403154918626.png" alt="image-20200403154918626"></p><h3 id="选择磁盘容量"><a href="#选择磁盘容量" class="headerlink" title="选择磁盘容量"></a>选择磁盘容量</h3><p>这个根据自己的电脑和需求来选择，越大越好，推荐使用多个文件</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/f144d956d9c0/image-20200403155511139.png" alt="image-20200403155511139"></p><p>然后下一步，就好了</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/f144d956d9c0/image-20200403155616418.png" alt="image-20200403155616418"></p><h2 id="虚拟机配置"><a href="#虚拟机配置" class="headerlink" title="虚拟机配置"></a>虚拟机配置</h2><p>编辑虚拟机的设置</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/f144d956d9c0/image-20200403155721067.png" alt="image-20200403155721067"></p><p>修改内存、处理器和ISO镜像的位置（等文件下载完成就可以选择了）</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/f144d956d9c0/image-20200403160005254.png" alt="image-20200403160005254"></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/f144d956d9c0/image-20200403160112674.png" alt="image-20200403160112674"></p><p>然后点开启虚拟机就等待了</p><h2 id="安装Ubuntu-1"><a href="#安装Ubuntu-1" class="headerlink" title="安装Ubuntu"></a>安装Ubuntu</h2><p>开始的页面最下面有中文（还是比较友好的）</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/f144d956d9c0/image-20200403160327152.png" alt="image-20200403160327152"></p><p>点安装Ubuntu</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/f144d956d9c0/image-20200403160409883.png" alt="image-20200403160409883"></p><p>点继续，这个就看自己的需求了（推荐，正常安装+取消安装Ubuntu时下载更新）</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/f144d956d9c0/image-20200403160543542.png" alt="image-20200403160543542"></p><p>点继续</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/f144d956d9c0/image-20200403160734500.png" alt="image-20200403160734500"></p><p>点现在安装，有对话框直接点继续，注意这里时点击中国的图片</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/f144d956d9c0/image-20200403160847663.png" alt="image-20200403160847663"></p><p>点继续，这个很明白，给你自己写一个用户名和密码</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/f144d956d9c0/image-20200403160922375.png" alt="image-20200403160922375"></p><p>输入好后点，继续，然后等待安装，安装文成后最好重启</p><p>友情提式：·<code>Ctrl+Alt</code>切换出鼠标</p><p>关闭虚拟机后，修改镜像</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/f144d956d9c0/image-20200403165402354.png" alt="image-20200403165402354"></p><p>到此就完成安装了</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态</title>
      <link href="/672524809abe.html"/>
      <url>/672524809abe.html</url>
      
        <content type="html"><![CDATA[<p>多态：一个对象拥有多种形态</p><p>面向对象三大特征：封装性，继承性，多态性</p><p>extends继承或者implements实现，是多态的前提</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/672524809abe/03-%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E8%BF%B0.png" alt="03-多态的概述"></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>定义<ul><li>是指同一行为，具有多个不同表现形式</li></ul></li><li>前提<ul><li>继承或者实现</li><li>方法的重写【不重写，无意义】</li><li>父类引用指向子类对象【格式体现】</li></ul></li></ul><h2 id="多态的体现"><a href="#多态的体现" class="headerlink" title="多态的体现"></a>多态的体现</h2><ul><li>格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">父类类型 对象名 = <span class="keyword">new</span> 子类对象();</span><br><span class="line">或者</span><br><span class="line">接口名称 对象名 = <span class="keyword">new</span> 实现类名称();</span><br></pre></td></tr></table></figure><blockquote><p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型。 </p></blockquote><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">f.method();</span><br></pre></td></tr></table></figure><p><strong>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。</strong></p><ul><li>注意<ul><li>成员变量<ul><li>直接通过对象名称访问成员变量，看等号左边是谁，优先用谁，没有则向上找</li><li>间接通过成员方法访问成员变量，看该方法属于谁，优先用谁，没有则向上找<ul><li>子类没有覆盖重写，就是父类的成员变量</li><li>子类如果覆盖重写，就是子类的成员变量</li></ul></li><li>编译看左边，运行看左边</li></ul></li><li>成员方法<ul><li>看new的是谁，就优先用谁，没有则向上找</li><li>编译看左边，运行看右边</li></ul></li></ul></li></ul><h2 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h2><p>好处：无论右边new的时候换成哪个子类对象，等号左边调用方法都不会变化</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/672524809abe/04-%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%80%81%E7%9A%84%E5%A5%BD%E5%A4%84.png" alt="04-使用多态的好处"></p><h2 id="引用类型转换"><a href="#引用类型转换" class="headerlink" title="引用类型转换"></a>引用类型转换</h2><p>多态的转型分为向上转型与向下转型两种：</p><h3 id="向上转型（就是多态写法）"><a href="#向上转型（就是多态写法）" class="headerlink" title="向上转型（就是多态写法）"></a>向上转型（就是多态写法）</h3><ul><li><strong>向上转型</strong>：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的</li></ul><p>当父类引用指向一个子类对象时，便是向上转型</p><ul><li>格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类类型 对象名 = <span class="keyword">new</span> 子类对象();</span><br></pre></td></tr></table></figure><ul><li>注意<ul><li>向上转型一定是安全的，从小范围转向了大范围，从小范围到大范围</li><li>对象一旦向上转型为父类，那么就无法调用子类原本特有的内容</li></ul></li></ul><h3 id="向下转型（还原）"><a href="#向下转型（还原）" class="headerlink" title="向下转型（还原）"></a>向下转型（还原）</h3><ul><li>向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的</li></ul><p>一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型</p><ul><li>格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子类类型 对象名 = (子类类型) 父类变量名;</span><br></pre></td></tr></table></figure><ul><li>注意<ul><li>必须保证对象本来创建的时候，就是子类对象，才能向下转型成子类对象</li><li>如果对象创建的时候本来就不是子类对象，现在非要向下转型为子类对象，就会报错(ClasCastException)</li></ul></li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/672524809abe/05-%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%8A%E4%B8%8B%E8%BD%AC%E5%9E%8B.png" alt="05-对象的上下转型"></p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>为了避免ClassCastException的发生，Java提供了<code>instanceof</code>关键字，给应用比那辆做类型的校验</p><ul><li>格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变量名 <span class="keyword">instanceof</span> 数据类型</span><br><span class="line">如果变量属于输入该数据类型，返回<span class="keyword">true</span></span><br><span class="line">如果变量不属于该数据类型，返回<span class="keyword">false</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口</title>
      <link href="/df52bcc43c75.html"/>
      <url>/df52bcc43c75.html</url>
      
        <content type="html"><![CDATA[<ul><li>接口就是一种<strong>公共的规范标准</strong></li><li>只要符合规范标准，就可以通用</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/df52bcc43c75/01-%E7%94%9F%E6%B4%BB%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%B8%BE%E4%BE%8B.png" alt="01-生活中接口的举例"></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>接口，是Java语言中一种引用类型，是方法的集合</p><p>如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是<strong>封装了方法</strong></p><p>包含<strong>抽象方法</strong>（JDK 7及以前），<strong>默认方法和静态方法</strong>（JDK 8），<strong>私有方法</strong>（JDK9）</p><p>接口的定义，它与定义类方式相似，但是使用<code>interface</code>关键字</p><p>它也会被编译成class件，但一定要明确它并不是类，而是另外一种引用数据类型</p><blockquote><p>引用数据类型：数组，类，接口。</p></blockquote><p>接口的使用，它不能创建对象，但是可以被实现（<code>implements</code>，类似于被继承）</p><p>一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。</p><ul><li>接口就是多个类的公共规范</li><li>接口是一种引用数据类型，最重要的内容就是其中的：抽象方法</li></ul><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名称</span>&#123;</span><br><span class="line">  <span class="comment">// 常量</span></span><br><span class="line">  <span class="comment">// 抽象方法</span></span><br><span class="line">  <span class="comment">// 默认方法</span></span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含有抽象方法（JDK-7及以前）"><a href="#含有抽象方法（JDK-7及以前）" class="headerlink" title="含有抽象方法（JDK 7及以前）"></a>含有抽象方法（JDK 7及以前）</h3><ul><li>抽象方法：使用<code>abstract</code>关键字修饰，可以省略，没有方法体。该类方法提供子类实现使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口当中的抽象方法，修饰符必须是两个固定的关键字：<code>public abstract</code></li><li>这两个关键字修饰符，可以选择性地省略</li></ul><h3 id="含有默认方法和静态方法（JDK-8）"><a href="#含有默认方法和静态方法（JDK-8）" class="headerlink" title="含有默认方法和静态方法（JDK 8）"></a>含有默认方法和静态方法（JDK 8）</h3><ul><li>默认方法：使用<code>default</code>修饰，不可省略，供子类调用或者子类重写。</li><li>静态方法：使用<code>static</code>修饰，供接口直接调用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 执行语句</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 执行语句</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含有私有方法和私有静态方法（JDK-9）"><a href="#含有私有方法和私有静态方法（JDK-9）" class="headerlink" title="含有私有方法和私有静态方法（JDK 9）"></a>含有私有方法和私有静态方法（JDK 9）</h3><ul><li>私有方法：使用<code>private</code>修饰，供接口中的默认方法或者静态方法调用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 执行语句</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本的实现"><a href="#基本的实现" class="headerlink" title="基本的实现"></a>基本的实现</h2><p>类与接口的关系为实现关系，即<strong>类实现接口</strong>，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用<strong>implements</strong>关键字。<br>非抽象子类实现接口：</p><ol><li>必须重写接口中所有抽象方法。</li><li>继承了接口的默认方法，即可以直接调用，也可以重写。</li></ol><ul><li>格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 <span class="keyword">implements</span> 接口类</span>&#123;</span><br><span class="line">  <span class="comment">// 重写接口中抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象方法的使用"><a href="#抽象方法的使用" class="headerlink" title="抽象方法的使用"></a>抽象方法的使用</h3><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo demo = <span class="keyword">new</span> Test();</span><br><span class="line">        demo.run();</span><br><span class="line">        demo.test();</span><br><span class="line">        Demo.test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface 默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：<ul><li>不能实例化接口，必须用实现类来引用</li><li>抽象方法必须全部实现，如果没有全部实现，那么这个实现类必须是抽象类</li><li>默认方法，可以继承，可以重写（可以解决接口升级的问题）</li><li>静态和<code>.class</code>文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用</li><li>私有方法：只有默认方法可以调用</li><li>私有静态方法：默认方法和静态方法可以调用</li><li>上面两个配合默认方法使用</li></ul></li></ul><h2 id="接口的多实现"><a href="#接口的多实现" class="headerlink" title="接口的多实现"></a>接口的多实现</h2><p>一个类可以实现多个接口，这也叫做接口的多实现。</p><ul><li>格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 [<span class="keyword">extends</span> 父类名] <span class="keyword">implements</span> 接口一,接口二,接口三...</span>&#123;</span><br><span class="line"> <span class="comment">// 重写接口中的抽象方法 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意：</p><ul><li>如果抽象方法有重名的，只需要重写一次</li><li>如果默认方法有重名，必须重写一次</li><li>接口中，存在同名的静态方法并不会冲突，原因是只能通过各自接口访问静态方法</li></ul></li><li><p>优先级问题</p><ul><li>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法</li></ul></li><li><p>实现</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Demo</span>, <span class="title">Demo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo demo = <span class="keyword">new</span> Test();</span><br><span class="line">        demo.run();</span><br><span class="line">        demo.test();</span><br><span class="line">        Demo.test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test interface 默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface 默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface 默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>接口中也可以定义<code>成员变量</code>，但是必须使用<code>public static final</code>三个关键字进行修饰</p><p>其实就是接口的<strong>常量</strong></p><ul><li>格式</li></ul><p><code>public staitc final 数据类型 常量名称 = 数据值;</code></p><ul><li><code>public</code>：作用的范围为全部</li><li><code>static</code>：为静态</li><li><code>final</code>：不可变</li><li>接口中的常量，可以不写<code>public static final</code>，默认就是这样的</li><li>接口中的常量，必须赋值</li><li>常量推荐用：大写加下划线分割单词</li></ul><h2 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h2><p>一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。就扣的继承使用<code>extends</code>关键字，子接口继承父接口的方法。<strong>如果父接口中的默认方法又重名，那么子接口需要重写一次。</strong></p><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A 接口&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 接口&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C 接口&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>子接口重写默认方法时，default关键字可以保留。</p><p>子类重写默认方法时，default关键字不可以保留。</p></blockquote><h2 id="其他成员特点"><a href="#其他成员特点" class="headerlink" title="其他成员特点"></a>其他成员特点</h2><ul><li>接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用<code>public static final</code>修饰.</li><li>接口中，没有构造方法，不能创建对象。</li><li>接口中，没有静态代码块。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>成员变量其实是常量：<ul><li>格式：<code>[public] [static] [final] 数据类型 常量名称 = 数据值;</code></li><li>注意：<ul><li>常量必须进行赋值，而且一旦赋值不能改变</li><li>常量名称完全大写，用下划线进行分隔</li></ul></li></ul></li><li>接口中最重要的就是抽象方法<ul><li>格式：<code>[public] [abstract] 返回值类型 方法名称(参数列表)</code></li><li>注意：<ul><li>实现类必须覆盖重写接口所有的抽象方法，除非实现英是抽象类</li></ul></li></ul></li><li>从Java 8开始，接口里允许定义默认方法<ul><li>格式：<code>[public] default 返回值类型 方法名称(参数列表) &#123;方法体&#125;</code></li><li>注意：<ul><li>默认方法也可以被覆盖重写</li></ul></li></ul></li><li>从Java 8开始，接口里允许定义静态方法<ul><li>格式：<code>[public] static 返回值类型 方法名称(参数列表) &#123;方法体&#125;</code></li><li>注意：<ul><li>应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法</li></ul></li></ul></li><li>从Java 9开始，接口里允许定义私有很乏，<ul><li>格式：<ul><li>普通私有方法：<code>private 返回值类型 方法名称(参数列表) &#123; 方法体 &#125;</code></li><li>静态私有方法：<code>private static 返回值类型 方法名称(参数列表) &#123; 方法体 &#125;</code></li></ul></li><li>注意：<ul><li>private的方法只有接口自己才能调用，不能被实现类或别人使用。</li></ul></li></ul></li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p>接口没有静态代码块和构造方法</p></li><li><p>一个类的直接父类时唯一的，但是要一个类可以同时实现多个接口</p></li><li><p>如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可</p></li><li><p>如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类</p></li><li><p>如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写</p></li><li><p>一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法</p></li><li><p>接口与接口之间是多继承的</p><ul><li>同名抽象没问题，同名默认有冲突，需要重写默认方法，而且需要带着<code>default</code>关键字</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类</title>
      <link href="/201854ea4b36.html"/>
      <url>/201854ea4b36.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是抽象类"><a href="#什么是抽象类" class="headerlink" title="什么是抽象类"></a>什么是抽象类</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/201854ea4b36/05-%E6%8A%BD%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5.png" alt="05-抽象的概念"></p><h3 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h3><p>父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。</p><p>那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。</p><p>我们把没有方法主体的方法称为<strong>抽象方法</strong>。Java语法规定，包含抽象方法的类就是<strong>抽象类</strong>。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><strong>抽象方法</strong>：没有方法体的方法。</li><li><strong>抽象类</strong>：包含抽象方法的类。</li></ul><h2 id="abstract使用格式"><a href="#abstract使用格式" class="headerlink" title="abstract使用格式"></a>abstract使用格式</h2><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>使用<code>abstract</code>关键字修饰方法,该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体</p><ul><li>格式：</li></ul><p><code>修饰符 abstract 返回值类型 方法名(参数列表);</code></p><ul><li>实现</li></ul><p><code>public abstract void run();</code></p><ul><li>注意<ul><li>抽象方法所在的类，必须是抽象类才行</li></ul></li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>如果一个类包含抽象方法，那么该类必须是抽象类。</p><ul><li>格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;abstract实现类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意<ul><li>抽象类里面是可以定义普通的成员方法</li></ul></li></ul><h3 id="抽象类和抽象方法的使用"><a href="#抽象类和抽象方法的使用" class="headerlink" title="抽象类和抽象方法的使用"></a>抽象类和抽象方法的使用</h3><p>继承抽象类的子类<strong>必须重写父类所有的抽象方法</strong></p><p>否则，该子类也必须声明为抽象类</p><p>最终，必须有子类实现该父类的抽象方法</p><p>否则，从最初的父类到最终的子类都不能创建对象，失去意义</p><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo demo = <span class="keyword">new</span> Test();</span><br><span class="line">        demo.run();</span><br><span class="line">        demo.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;abstract实现类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意<ul><li>不能直接创建new抽象类对象</li><li>必须用一个子类来继承抽象父类</li><li>子类必须覆盖重写抽象父类房中所有的抽象方法<ul><li>覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后不上方法体大括号</li></ul></li><li>创建子类对象进行使用</li></ul></li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。<ul><li>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</li></ul></li><li>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。<ul><li>理解：子类的构造方法中，有默认的<code>super()</code>，需要访问父类构造方法。</li></ul></li><li>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。（设计模式：适配器模式）<ul><li>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</li></ul></li><li>抽象类的子类，必须重写抽象父类中<strong>所有的抽象方法</strong>，否则，编译无法通过而报错。除非该子类也是抽象类。<ul><li>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承</title>
      <link href="/28d125e258a1.html"/>
      <url>/28d125e258a1.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。如图所示：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/28d125e258a1/image-20200406161705307.png" alt="image-20200406161705307"></p><p>其中，多个类可以称为<strong>子类</strong>，单独那一个类称为<strong>父类、超类（superclass）</strong>或者<strong>基类</strong>。</p><p>继承描述的是事物之间的所属关系，这种关系是：<code>is-a</code>的关系。例如，图中兔子属于食草动物，食草动物属于动物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li><strong>继承</strong>：就是子类继承父类的<strong>属性和行为</strong>，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的<strong>非私有</strong>的属性和行为。</li></ul><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ol><li>提高<strong>代码的复用性</strong>（共性抽取）</li><li>类与类之间产生了关系，是<strong>多态的前提</strong>（没有继承，就没有多态）</li></ol><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/28d125e258a1/01-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png" alt="01-继承的基本概念"></p><h2 id="继承的格式"><a href="#继承的格式" class="headerlink" title="继承的格式"></a>继承的格式</h2><ul><li><p>通过<code>extends</code>关键字，可以声明一个子类继承另外一个父类</p></li><li><p>格式</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父类</span>&#123;</span><br><span class="line">  <span class="comment">// 代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类</span>&#123;</span><br><span class="line">  <span class="comment">// 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.lectures();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lectures</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在给学生讲课&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Teacher</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承后的特点–成员变量"><a href="#继承后的特点–成员变量" class="headerlink" title="继承后的特点–成员变量"></a>继承后的特点–成员变量</h2><h3 id="成员变量不重名"><a href="#成员变量不重名" class="headerlink" title="成员变量不重名"></a>成员变量不重名</h3><p>如果子类父类中出现不重名的成员变量，这时的访问是没有影响的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu fu = <span class="keyword">new</span> Fu();</span><br><span class="line">        System.out.println(fu.numfu);</span><br><span class="line">        Zi zi = <span class="keyword">new</span> Zi();</span><br><span class="line">        System.out.println(zi.mumzi+<span class="string">&quot;:&quot;</span>+zi.numfu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numfu = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mumzi = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员变量重名"><a href="#成员变量重名" class="headerlink" title="成员变量重名"></a>成员变量重名</h3><p>子类父类中出现重名的成员变量，访问有两种方式</p><ol><li>直接通过子类对象访问成员变量<ul><li>规则：等号左边是谁，就优先用谁，如果没有则向上找</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu fu = <span class="keyword">new</span> Fu();</span><br><span class="line">        System.out.println(fu.num); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">        Zi zi = <span class="keyword">new</span> Zi();</span><br><span class="line">        System.out.println(zi.num); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>简介通过成员方法访问成员变量<ul><li>该方法属于谁，就优先用谁，没有则想上找</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu fu = <span class="keyword">new</span> Fu();</span><br><span class="line">        fu.methodFu(); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">        Zi zi = <span class="keyword">new</span> Zi();</span><br><span class="line">        zi.methodZi(); <span class="comment">// 10</span></span><br><span class="line">        zi.methodFu(); <span class="comment">// 100</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodFu</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodZi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="区分子类方法中重名的三种变量"><a href="#区分子类方法中重名的三种变量" class="headerlink" title="区分子类方法中重名的三种变量"></a>区分子类方法中重名的三种变量</h3><ul><li>成员变量</li><li>本类的成员变量</li><li>父类的成员变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Zi zi =<span class="keyword">new</span> Zi();</span><br><span class="line">        zi.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">        System.out.println(num); <span class="comment">// 局部变量</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.num); <span class="comment">// 本类的成员变量</span></span><br><span class="line">        System.out.println(<span class="keyword">super</span>.num); <span class="comment">// 父类的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承后的特点–成员方法"><a href="#继承后的特点–成员方法" class="headerlink" title="继承后的特点–成员方法"></a>继承后的特点–成员方法</h2><p>在父子类的继承关系中，创建子类对象，访问成员方法的规则：</p><ul><li>创建的对象是谁，就优先用谁，如果没有则想上找</li><li>无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类的</li></ul><h3 id="成员方法不重名"><a href="#成员方法不重名" class="headerlink" title="成员方法不重名"></a>成员方法不重名</h3><p>如果子类父类中出现不重名的成员方法，这时的调用是没有影响的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Zi zi =<span class="keyword">new</span> Zi();</span><br><span class="line">        zi.method1();</span><br><span class="line">        zi.method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员方法重名–重写（Override）"><a href="#成员方法重名–重写（Override）" class="headerlink" title="成员方法重名–重写（Override）"></a>成员方法重名–重写（Override）</h3><p>如果子类父类中出现重名的成员方法，这时的访问是一种特殊情况，叫做<strong>方法重写（Override）</strong></p><ul><li><strong>方法重写</strong>：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。<strong>声明不变，重新实现。</strong></li><li><code> @Override</code> 是可选的注解，如果不写，满足要求也是正确的方法覆盖重写</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Zi zi =<span class="keyword">new</span> Zi();</span><br><span class="line">        zi.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>子类方法覆盖父类方法，必须要保证权限<strong>大于等于</strong>父类权限</li><li>子类方法覆盖父类方法，返回值类型必须<strong>小于等于</strong>父类方法的返回值范围</li><li>子类方法覆盖父类方法，函数名和参数列表都要一模一样</li></ul><h2 id="继承后的特点–构造方法"><a href="#继承后的特点–构造方法" class="headerlink" title="继承后的特点–构造方法"></a>继承后的特点–构造方法</h2><p>构造方法的定义格式和作用</p><ul><li>构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。</li><li>构造方法的作用是初始化成员变量的。<ul><li>所以子类的初始化过程中，必须先执行父类的初始化动作。</li><li>子类的构造方法中默认有一个<code>super()</code>，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。</li><li>就算没有写<code>super()</code>，也会自动调用父类的构造方法</li><li>子类构造可以通过<code>super()</code>关键字来电泳父类重载构造</li><li><code>super</code>的父类构造调用，必须是子类构造方法的第一个语句</li><li>不能一个子类构造调用多次<code>super</code>构造</li></ul></li><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Zi zi = <span class="keyword">new</span> Zi();</span><br><span class="line">      <span class="comment">// Fu()</span></span><br><span class="line"><span class="comment">// Zi()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    Fu() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Fu()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    Zi() &#123;</span><br><span class="line">      <span class="comment">// super(); 调用父类构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Zi()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="super关键字的三种用法和this关键字的三种用法"><a href="#super关键字的三种用法和this关键字的三种用法" class="headerlink" title="super关键字的三种用法和this关键字的三种用法"></a>super关键字的三种用法和this关键字的三种用法</h2><ol><li><p>super</p><ol><li>在子类的成员方法中，调用父类的成员变量</li><li>在子类的成员方法在，嗲用父类的成员方法</li><li>在子类的构造方法中，方法父类的构造方法</li></ol></li><li><p>this</p><ol><li>在本类的成员方法中，访问本类的成员变量</li><li>在本类的成员方法中，访问本类的另一个成员方法</li><li>在本类的构造方法中，访问本类的另一个构造方法</li></ol></li><li><p>注意事项</p><ol><li>this()和super()调用都必须是构造方法的第一个语句，唯一一个</li><li>super和this两种构造调用，不能同时使用</li></ol></li></ol><h2 id="super和this图解"><a href="#super和this图解" class="headerlink" title="super和this图解"></a>super和this图解</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/28d125e258a1/03-super%E4%B8%8Ethis%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png" alt="03-super与this的内存图"></p><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>Java只支持单继承，不支持多继承</li><li>Java语言可以多继承</li><li>一个子类的直接父类是唯一的，但是一个父类可以拥有多个子类</li><li>顶层父类是Object类，所有的类默认继承Object，作为父类</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/28d125e258a1/04-Java%E7%BB%A7%E6%89%BF%E7%9A%84%E4%B8%89%E4%B8%AA%E7%89%B9%E7%82%B9.png" alt="04-Java继承的三个特点"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Math类</title>
      <link href="/ac05f6c6cbcf.html"/>
      <url>/ac05f6c6cbcf.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>java.lang.Math</code>类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。</p><h2 id="基本运算的方法"><a href="#基本运算的方法" class="headerlink" title="基本运算的方法"></a>基本运算的方法</h2><ul><li><code>public static double abs(double a)</code>：返回 double 值的绝对值。<ul><li> 如果参数为非负数，则返回该参数。如果参数为负数，则返回该参数的相反数。</li><li> 如果参数为 NaN，那么结果为 NaN。</li></ul></li><li><code>public static double ceil(double a)</code>：向上取整<ul><li>返回最小的（最接近负无穷大）<code>double</code> 值，该值大于等于参数，并等于某个整数。</li></ul></li><li><code>public static double floor(double a)</code>：向下取整<ul><li>返回最大的（最接近正无穷大）double 值，该值小于等于参数，并等于某个整数。</li></ul></li><li><code>public static long round(double a)</code>：四舍五入    <ul><li>返回最接近参数的 long</li></ul></li><li>结果将舍入为整数：加上 1/2，对结果调用 floor 并将所得结果强制转换为 long 类型</li><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> d1 = <span class="number">10.1</span>;</span><br><span class="line">        <span class="keyword">double</span> d2 = -<span class="number">10.1</span>;</span><br><span class="line">        <span class="keyword">double</span> d3 = <span class="number">10.5</span>;</span><br><span class="line">        <span class="keyword">double</span> d4 = -<span class="number">10.5</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======Math.abs=======&quot;</span>);</span><br><span class="line">        System.out.println(Math.abs(d1)); <span class="comment">//10.1</span></span><br><span class="line">        System.out.println(Math.abs(d2)); <span class="comment">//10.1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=======Math.ceil======&quot;</span>);</span><br><span class="line">        System.out.println(Math.ceil(d1)); <span class="comment">//11.0</span></span><br><span class="line">        System.out.println(Math.ceil(d2)); <span class="comment">//-10.0</span></span><br><span class="line">        System.out.println(Math.ceil(d3)); <span class="comment">//11.0</span></span><br><span class="line">        System.out.println(Math.ceil(d4)); <span class="comment">//-10.0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=======Math.floor=====&quot;</span>);</span><br><span class="line">        System.out.println(Math.floor(d1)); <span class="comment">//10.0</span></span><br><span class="line">        System.out.println(Math.floor(d2)); <span class="comment">//-11.0</span></span><br><span class="line">        System.out.println(Math.floor(d3)); <span class="comment">//10.0</span></span><br><span class="line">        System.out.println(Math.floor(d4)); <span class="comment">//-11.0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=======Math.round=====&quot;</span>);</span><br><span class="line">        System.out.println(Math.round(d1));  <span class="comment">//10</span></span><br><span class="line">        System.out.println(Math.round(d2));  <span class="comment">//-10</span></span><br><span class="line">        System.out.println(Math.round(d3));  <span class="comment">//11</span></span><br><span class="line">        System.out.println(Math.round(d4));  <span class="comment">//-10</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arrays类</title>
      <link href="/f70d50f7bf77.html"/>
      <url>/f70d50f7bf77.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>java.util.Arrays</code>此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来非常简单。</p><h2 id="操作数组的方法"><a href="#操作数组的方法" class="headerlink" title="操作数组的方法"></a>操作数组的方法</h2><ul><li><p><code>public static String toString(int[] a)</code>：返回指定数组内容的字符串表示形式</p></li><li><p><code>public static void sort(int[] a)</code>：对指定的数组按数字升序进行排序</p><ul><li>数值，sort默认按照升序从小到大</li></ul></li><li><p>字符串，sort默认按照字母升序</p><ul><li>自定义类型，自定义类需要有Comparable或者Comparator接口的支持</li></ul></li><li><p>实现</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = &#123;<span class="number">99</span>,<span class="number">98</span>,<span class="number">97</span>&#125;;</span><br><span class="line">    <span class="keyword">short</span>[] shorts = &#123;<span class="number">99</span>,<span class="number">98</span>,<span class="number">97</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] ints =&#123;<span class="number">99</span>,<span class="number">98</span>,<span class="number">97</span>&#125;;</span><br><span class="line">    <span class="keyword">long</span>[] longs = &#123;<span class="number">99</span>,<span class="number">98</span>,<span class="number">97</span>&#125;;</span><br><span class="line">    <span class="keyword">float</span>[] floats = &#123;<span class="number">99.0F</span>,<span class="number">98.0F</span>,<span class="number">97.0F</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span>[] doubles = &#123;<span class="number">99.0</span>,<span class="number">98.0</span>,<span class="number">97.0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span>[] chars = &#123;<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">boolean</span>[] booleans = &#123;<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">true</span>&#125;;</span><br><span class="line">    String[] strings =  &#123;<span class="string">&quot;c&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// Arrays.toString</span></span><br><span class="line">    System.out.println(Arrays.toString(bytes));     <span class="comment">//[99, 98, 97]</span></span><br><span class="line">    System.out.println(Arrays.toString(shorts));    <span class="comment">//[99, 98, 97]</span></span><br><span class="line">    System.out.println(Arrays.toString(ints));      <span class="comment">//[99, 98, 97]</span></span><br><span class="line">    System.out.println(Arrays.toString(longs));     <span class="comment">//[99, 98, 97]</span></span><br><span class="line">    System.out.println(Arrays.toString(chars));     <span class="comment">//[c, b, a]</span></span><br><span class="line">    System.out.println(Arrays.toString(floats));    <span class="comment">//[99.0, 98.0, 97.0]</span></span><br><span class="line">    System.out.println(Arrays.toString(doubles));   <span class="comment">//[99.0, 98.0, 97.0]</span></span><br><span class="line">    System.out.println(Arrays.toString(booleans));  <span class="comment">//[true, false, true]</span></span><br><span class="line">    System.out.println(Arrays.toString(strings));   <span class="comment">//[c, b, a]</span></span><br><span class="line">    <span class="comment">// Arrays.sort</span></span><br><span class="line">    Arrays.sort(bytes);</span><br><span class="line">    Arrays.sort(shorts);</span><br><span class="line">    Arrays.sort(ints);</span><br><span class="line">    Arrays.sort(longs);</span><br><span class="line">    Arrays.sort(chars);</span><br><span class="line">    Arrays.sort(floats);</span><br><span class="line">    Arrays.sort(doubles);</span><br><span class="line">    Arrays.sort(strings);</span><br><span class="line">    System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">    System.out.println(Arrays.toString(bytes));   <span class="comment">//[97, 98, 99]</span></span><br><span class="line">    System.out.println(Arrays.toString(shorts));  <span class="comment">//[97, 98, 99]</span></span><br><span class="line">    System.out.println(Arrays.toString(ints));    <span class="comment">//[97, 98, 99]</span></span><br><span class="line">    System.out.println(Arrays.toString(longs));   <span class="comment">//[97, 98, 99]</span></span><br><span class="line">    System.out.println(Arrays.toString(chars));   <span class="comment">//[a, b, c]</span></span><br><span class="line">    System.out.println(Arrays.toString(floats));  <span class="comment">//[97.0, 98.0, 99.0]</span></span><br><span class="line">    System.out.println(Arrays.toString(doubles)); <span class="comment">//[97.0, 98.0, 99.0]</span></span><br><span class="line">    System.out.println(Arrays.toString(strings)); <span class="comment">//[a, b, c]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Static关键字</title>
      <link href="/c60ecd4f0833.html"/>
      <url>/c60ecd4f0833.html</url>
      
        <content type="html"><![CDATA[<h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>关于<code>static</code>关键字的使用，它可以用来修饰的成员变量和成员方法，<strong>被修饰的成员是属于类的，而不是单单是属于某个对象的</strong>。也就是说，既然属于类，就可以不靠创建对象来调用了.</p><h2 id="定义和使用格式"><a href="#定义和使用格式" class="headerlink" title="定义和使用格式"></a>定义和使用格式</h2><h3 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h3><p>当<code>static</code>修饰成员变量时，该变量称为<strong>类变量</strong>。该类的每个对象都<strong>共享</strong>同一个类变量的值。任何对象都可以更改该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。</p><ul><li><strong>类变量</strong>：使用static关键字修饰的成员变量</li><li>格式：<ul><li><code>static 数据类型 变量名;</code></li></ul></li><li>实现：<ul><li><code>static int number</code></li></ul></li></ul><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>当<code>static</code>修饰成员方法时，该方法称为类方法。静态方法在声明中有<code>static</code>，建议使用类名来调用，而不需要创建类的对象。调用方式非常简单。</p><ul><li><p><strong>类方法</strong>：使用static关键字修饰的成员方法，习惯称为<strong>静态方法</strong>。</p></li><li><p>格式：</p></li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">static</span> 返回值类型 方法名(参数列表)&#123;</span><br><span class="line"><span class="comment">//执行语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>静态方法调用的注意事项</strong>：<ul><li>静态方法可以直接访问类变量和静态方法。</li><li><strong>静态方法不能直接访问普通成员变量或成员方法</strong>。反之，成员方法可以直接访问类变量或静态方法。</li><li>静态方法中，不能使用<strong>this</strong>关键字。</li></ul></li></ul><blockquote><p>静态方法只能访问静态成员</p></blockquote><h3 id="调用格式"><a href="#调用格式" class="headerlink" title="调用格式"></a>调用格式</h3><p>被<code>static</code>修饰的成员可以并且建议通过类名直接访问。虽然也可以通过对象名访问静态成员，原因即多个对象均属于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息。</p><ul><li>格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问类变量</span></span><br><span class="line">类名.类变量名;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用静态方法</span></span><br><span class="line">类名.静态方法名(参数);</span><br></pre></td></tr></table></figure><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test.show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="静态原理图解"><a href="#静态原理图解" class="headerlink" title="静态原理图解"></a>静态原理图解</h2><p><code>static</code>修饰的内容：</p><ul><li>是随着类的加载而加载的，且只加载一次</li><li>存储于一块固定的内存区域（静态区），所以，可以直接被类名调用</li><li>它优先于对象存在，所以，可以被所有对象共享</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/c60ecd4f0833/03-%E9%9D%99%E6%80%81%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png" alt="03-静态的内存图"></p><h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><ul><li><p><strong>静态代码块</strong>：定义在成员位置，使用static修饰的代码块{}。</p><ul><li>位置：类中方法外。</li><li>执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。</li></ul></li><li><p>格式</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">    <span class="comment">//执行语句</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(i); <span class="comment">// 20</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String类</title>
      <link href="/ed6a15da5969.html"/>
      <url>/ed6a15da5969.html</url>
      
        <content type="html"><![CDATA[<h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>java.lang.String</code>类代表字符串。Java程序中所有的字符串文字（例如<code>&quot;abc&quot;</code>）都可以被看作是实现此类的实例。</p><p>类<code>String</code>中包括用于检查各个字符串的方法，比如用于<strong>比较</strong>字符串，<strong>搜索</strong>字符串，<strong>提取</strong>子字符串以及创建具有翻译为<strong>大写或小写</strong>的所有字符的字符串的副本。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>字符串不变：<strong>字符串的值在创建后不能被更改</strong></li><li>因为String对象不是可变的，所以他们可以被共享</li><li>字符串效果上相当于char[]字符数组，但是底层原理是byte[]字节数组</li><li><code>&quot;abc&quot;</code>等效于<code>char[] data = &#123; &#39;a&#39; , &#39;b&#39; , &#39;c&#39; &#125;</code></li></ol><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/ed6a15da5969/image-20200405165653102.png" alt="image-20200405165653102"></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ul><li><p>查看类</p><ul><li><code>java.lang.String</code>：此类不需要导入。</li></ul></li><li><p>查看构造方法</p><ul><li><code>public string()</code>：初始化新创建的String对象，以使其表示空字符序列。</li><li><code>public string(char[] value)</code>：通过当前参数中的字符数组来构造新的String.</li><li><code>public String(byte[] bytes)</code>：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的String.</li></ul></li><li><p>实现</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="keyword">new</span> String();</span><br><span class="line">    System.out.println(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] chars = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">    String str2 = <span class="keyword">new</span> String(chars);</span><br><span class="line">    System.out.println(str2); <span class="comment">// abc</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&#125;;</span><br><span class="line">    String str3 = <span class="keyword">new</span> String(bytes);</span><br><span class="line">    System.out.println(str3); <span class="comment">// abc</span></span><br><span class="line">  <span class="comment">// 直接创建</span></span><br><span class="line">  String str4 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">  System.out.println(str4); <span class="comment">// abc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>程序中直接写上的双引号字符串，就在字符串常量池中</p><ul><li>对于基本类型来说：==是进行数值比较</li><li>对于引用类型来说：==是进行【地址值的比较】</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/ed6a15da5969/01-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0.png" alt="01-字符串的常量池"></p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><ul><li><code>public boolean equals(Object anObject)</code>：将此字符串与指定的对象比较。当且仅当该参数不为 null，并且是与此对象表示相同字符序列的 String 对象时，结果才为 true。 <ul><li>任何对象都能用<code>Object</code>进行接受</li><li><code>equals</code>方法具有对称性，也就是<code>a.equals(b)</code>和<code>b.equals(a)</code>效果一样</li><li>如果比较双方一个常量一个变量，推荐把常量字符串写在前面</li></ul></li><li><code>public boolean equalsIgnoreCase(String anotherString)</code>：将此 String 与另一个 String 比较，不考虑大小写。如果两个字符串的长度相同，并且其中的相应字符都相等（忽略大小写），则认为这两个字符串是相等的。 </li><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String s3 = <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line">    <span class="comment">// equals</span></span><br><span class="line">    System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br><span class="line">    System.out.println(s1.equals(s3)); <span class="comment">// false</span></span><br><span class="line">    <span class="comment">// equalsIgnoreCase</span></span><br><span class="line">    System.out.println(s1.equalsIgnoreCase(s2)); <span class="comment">// true</span></span><br><span class="line">    System.out.println(s1.equalsIgnoreCase(s3)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Object是”对象”的意思，也是一种引用类型。作为参数类型，表示任意对象都可以传递到方法中。</p></blockquote><h3 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h3><ul><li><p><code>public boolean isEmpty()</code>：返回此字符串的长度。长度等于字符串中 Unicode 代码单元的数量。 </p></li><li><p><code>public String concat(String str)</code>：将指定字符串连接到此字符串的结尾。 </p><ul><li>如果参数字符串的长度为 0，则返回此 String 对象。否则，创建一个新的 String 对象，用来表示由此 String 对象表示的字符序列和参数字符串表示的字符序列连接而成的字符序列。</li></ul></li><li><p><code>public char charAt(int index)</code>：返回指定索引处的 char 值。索引范围为从 0 到 length() - 1。序列的第一个 char 值位于索引 0 处，第二个位于索引 1 处，依此类推，这类似于数组索引。 </p></li><li><p><code>public int indexOf(int ch)</code>：返回指定字符在此字符串中第一次出现处的索引。</p></li><li><p><code>public String substring(int beginIndex)</code>：返回一个新的字符串，它是此字符串的一个子字符串。该子字符串从指定索引处的字符开始，直到此字符串末尾。</p></li><li><p><code>public String substring(int beginIndex,int endIndex)</code>：返回一个新字符串，它是此字符串的一个子字符串。该子字符串从指定的 <code>beginIndex </code>处开始，直到索引 <code>endIndex - 1</code> 处的字符。因此，该子字符串的长度为 <code>endIndex-beginIndex</code>。 </p></li><li><p>实现</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// length</span></span><br><span class="line">    System.out.println(str.length()); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// concat</span></span><br><span class="line">    System.out.println(str.concat(<span class="string">&quot;---&gt;d&quot;</span>));  <span class="comment">// abc---&gt;d</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// charAt</span></span><br><span class="line">    System.out.println(str.charAt(<span class="number">0</span>)); <span class="comment">// a</span></span><br><span class="line">    System.out.println(str.charAt(str.length() - <span class="number">1</span>));<span class="comment">// c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// indexOf</span></span><br><span class="line">    System.out.println(str.indexOf(<span class="number">1</span>)); <span class="comment">// -1</span></span><br><span class="line">    System.out.println(str.indexOf(<span class="string">&quot;a&quot;</span>)); <span class="comment">// 0</span></span><br><span class="line">    System.out.println(str.indexOf(<span class="string">&quot;bcd&quot;</span>)); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// substring</span></span><br><span class="line">    System.out.println(str.substring(<span class="number">0</span>)); <span class="comment">// abc</span></span><br><span class="line">    System.out.println(str.substring(<span class="number">1</span>)); <span class="comment">// bc</span></span><br><span class="line">    System.out.println(str.substring(<span class="number">0</span>,str.length())); <span class="comment">// abc</span></span><br><span class="line">    System.out.println(str.substring(<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">// b</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转换功能的方法"><a href="#转换功能的方法" class="headerlink" title="转换功能的方法"></a>转换功能的方法</h3><ul><li><p><code>public char[] toCharArray()</code>：将此字符串转换为一个新的字符数组。 </p></li><li><p><code>public byte[] getBytes()</code>：使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 </p></li><li><p><code>public String replace(CharSequence target, CharSequence replacement)</code>：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。</p><ul><li>该替换从字符串的开头朝末尾执行，例如，用 “b” 替换字符串 “aaa” 中的 “aa” 将生成 “ba” 而不是 “ab”。 </li></ul></li><li><p>CharSequence 是一个接口，意思就是说可以接受字符串类型</p></li><li><p>实现</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="comment">// toCharArray</span></span><br><span class="line">    <span class="keyword">char</span>[] chars =str.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        System.out.print(chars[i]+<span class="string">&quot;\t&quot;</span>); <span class="comment">// abc</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getBytes</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = str.getBytes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">        System.out.print(bytes[i]+<span class="string">&quot;\t&quot;</span>);<span class="comment">// 979899</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// replace</span></span><br><span class="line">    String replace = str.replace(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">    System.out.println(str+<span class="string">&quot;---&gt;&quot;</span>+replace); <span class="comment">// abc---&gt;Abc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CharSequence是一个接口，也是一种引用类型。作为参数类型，可以把String对象传递到方法中</p></blockquote><h3 id="分割功能的方法"><a href="#分割功能的方法" class="headerlink" title="分割功能的方法"></a>分割功能的方法</h3><ul><li><code>public String[] split(String regex,int limit)</code>：根据匹配给定的正则表达式来拆分此字符串。 <ul><li>split的参数是一个正则表达式</li><li>如果要按照英文句点<code>.</code>惊醒切分，必须写两个反斜杠<code>&quot;\\.&quot;</code></li></ul></li><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;a,b,c&quot;</span>;</span><br><span class="line">    String[] split = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; split.length; i++) &#123;</span><br><span class="line">        System.out.print(split[i] + <span class="string">&quot;\t&quot;</span>); <span class="comment">// abc</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList类</title>
      <link href="/b176b2fd8637.html"/>
      <url>/b176b2fd8637.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是ArrayList类"><a href="#什么是ArrayList类" class="headerlink" title="什么是ArrayList类"></a>什么是ArrayList类</h2><p><code>java.utiL.ArrayList</code>是大小可变的数组的实现，存储在内的数据称为元素。</p><p>此类提供一些方法来操作内部存储的元素。</p><p><code>ArrayList</code>中可不断添加元素，其大小也自动增长。</p><h2 id="ArrayList使用步骤"><a href="#ArrayList使用步骤" class="headerlink" title="ArrayList使用步骤"></a>ArrayList使用步骤</h2><ul><li>查看类<ul><li><code>java.util.ArrayList &lt;E&gt;</code>：该类需要import导入后使用<ul><li><code>&lt;E&gt;</code>，表示一种指定的数据类型，叫做泛型，<code>E</code>：取自Element（元素）的首字母，在出现<code>E</code>的地方，我们使用一种引用数据类型将其替换立刻，边是我们将存储那种引用类型的元素。</li><li>例如：<code>ArrayList&lt;String&gt;</code></li></ul></li></ul></li><li>查看构造方法<ul><li><code>public ArrayList()</code>：构造一个内容为空的集合</li></ul></li><li>格式<ul><li><code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></li><li>在JDK7之后，右侧泛型的尖括号之内可以留空</li><li><code>ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</code></li></ul></li><li>查看成员方法<ul><li><code>public boolean add(E e)</code>：将指定的元素添加到此列表的尾部<ul><li>参数<code>E e</code>，在构造Arraylist对象时，<code>&lt;E&gt;</code>指定了什么数据类型，那么<code>add (E e)</code>方法中，只能添加什么数据类型的对象。</li></ul></li></ul></li><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">     list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">     list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">     System.out.println(list);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="常用方法和遍历"><a href="#常用方法和遍历" class="headerlink" title="常用方法和遍历"></a>常用方法和遍历</h2><p>对于元素的操作，基本体现在-一增、删、查。常用的方法有：</p><ul><li><code>public boolean add(E e)</code>：将指定的元素添加到此集合的尾部</li><li><code>public E remove(int index)</code>：移除此集合中指定位置上的元素。返回被删除的元素</li><li><code>public E get(int index)</code>：返回此集合中指定位置上的元素。返回获取的元素</li><li><code>public int size()</code>：返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界</li><li>这些都是最基本的方法，操作非常简单，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">       System.out.println(list); <span class="comment">// [a, b, c]</span></span><br><span class="line">       System.out.println(list.remove(<span class="number">1</span>)); <span class="comment">// b</span></span><br><span class="line">       System.out.println(list); <span class="comment">// [a, c]</span></span><br><span class="line">       System.out.println(list.get(<span class="number">1</span>)); <span class="comment">// c</span></span><br><span class="line">       System.out.println(list.size()); <span class="comment">// 2</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="如何存储基本数据类型"><a href="#如何存储基本数据类型" class="headerlink" title="如何存储基本数据类型"></a>如何存储基本数据类型</h2><p><code>ArrayList</code>对象不能存储基本类型，只能存储引用类型的数据。类似<code>&lt;int&gt;</code>不能写，但是存储基本数据类型对应的<code>包装类型</code>是可以的。所以，想要存储基本类型数据，<code>&lt;&gt;</code>中的数据类型，必须转换后才能编写，转换写法如下：</p><table><thead><tr><th>基本类型</th><th>基本类型包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       list.add(<span class="number">1</span>);</span><br><span class="line">       list.add(<span class="number">2</span>);</span><br><span class="line">       list.add(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Random类</title>
      <link href="/59d451fe7cbc.html"/>
      <url>/59d451fe7cbc.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Random类"><a href="#什么是Random类" class="headerlink" title="什么是Random类"></a>什么是Random类</h2><p>此类的实例用于生成伪随机数</p><p>例如：获取一个随机数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Random random = <span class="keyword">new</span> Random();</span><br><span class="line">  <span class="keyword">int</span> i = random.nextInt();</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Random使用步骤"><a href="#Random使用步骤" class="headerlink" title="Random使用步骤"></a>Random使用步骤</h2><ul><li>查看类<ul><li><code>java.util.Random</code>：该类需要import导入后使用</li></ul></li><li>查看构造方法<ul><li><code>public Random()</code>：创建一个新的随机数生成器</li></ul></li><li>查看成员方法<ul><li><code>public int nextInt(int n)</code>：返回一个伪随机数，范围在0（包括）和n（不包括）之间的<code>int</code>值</li></ul></li><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = random.nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(i+<span class="string">&quot;--------&gt;&quot;</span>+y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>创建一个Random对象，每次调用nextInt()方法，都会生成一个随机数</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scanner类</title>
      <link href="/b53c187d0041.html"/>
      <url>/b53c187d0041.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Scanner类"><a href="#什么是Scanner类" class="headerlink" title="什么是Scanner类"></a>什么是Scanner类</h2><p>一个可以解析基本类型和字符串的简单文本扫描器。</p><p>例如：读取用户键盘输入的一个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> i = scanner.nextInt();</span><br></pre></td></tr></table></figure><blockquote><p>System.in系统输入指的是通过键盘录入数据</p></blockquote><h2 id="引用类型一般使用步骤"><a href="#引用类型一般使用步骤" class="headerlink" title="引用类型一般使用步骤"></a>引用类型一般使用步骤</h2><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><p>使用<code>import</code>关键字导包，在类的所有代码之前导包，引入要使用的类型，java.lang包下的所有类无需导入</p><ul><li>格式：</li></ul><p><code>import 包名.类名</code></p><ul><li>实现：</li></ul><p><code>import java.util.Scanner</code></p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>使用该类的构造方法，创建一个该类的对象</p><ul><li>格式：</li></ul><p><code>数据类型 变量名 = new 数据类型(参数列表)</code></p><ul><li>实现：</li></ul><p><code>Scanner scanner = new Scanner(System.in);</code></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>调用该类的成员方法，完成指定功能</p><ul><li>格式：</li></ul><p><code>变量名.方法名();</code></p><ul><li>实现：</li></ul><p><code>int i = scanner.nextInt();</code></p><h2 id="Scanner使用步骤"><a href="#Scanner使用步骤" class="headerlink" title="Scanner使用步骤"></a>Scanner使用步骤</h2><ul><li>查看类<ul><li><code>java.util.Scanner</code>：该类需要import导入后使用</li></ul></li><li>查看构造方法<ul><li><code>public Scanner(InputStream source)</code>：构造一个新的<code>Scanner</code>，它生成的值从指定的输入流扫描</li></ul></li><li>查看成员方法<ul><li><code>public int nextInt()</code>：将输入信息的下一个标记扫描为一个<code>int</code>值</li></ul></li><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">      <span class="keyword">int</span> i = scanner.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。虽然是创建对象的简化写法，但是应用场景非常有限。</p><ul><li>匿名对象：没有变量名的对象</li><li>格式：<ul><li><code>new 类名(参数列表);</code></li></ul></li><li>实现：<ul><li><code>new Scanner(System.in);</code></li></ul></li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><p>创建匿名对象直接调用方法，没有变量名</p></li><li><p><code>new Scanner(System.in).nextInt();</code></p></li><li><p>但是一旦调用两次方法，就是创建了两个对象，造成浪费</p><ul><li><p>```java<br>new Scanner(System.in).nextInt();<br>new Scanner(System.in).nextInt();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 匿名对象可以作为方法的参数和返回值</span><br><span class="line"></span><br><span class="line">  - 作为参数</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  public class Test &#123;</span><br><span class="line">      public static void main(String[] args)&#123;</span><br><span class="line">        input(new Scanner(System.in));</span><br><span class="line">  </span><br><span class="line">      &#125;</span><br><span class="line">      public static void input(Scanner scanner)&#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>作为返回值</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = input();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scanner <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是API</title>
      <link href="/3f94559a860d.html"/>
      <url>/3f94559a860d.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>API（Application Programming Interface），应用程序编程接口。Java API是一本程序员的字典，是JDK中提供给我们使用的类的说明文档。</p><p>这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。</p><p>所以我们可以通过查询APl的方式，来学习Java提供的类，并得知如何使用它们。</p><h2 id="API使用步骤"><a href="#API使用步骤" class="headerlink" title="API使用步骤"></a>API使用步骤</h2><p>JDK API 1.6 中文版为SUN公司提供，之后的中文为机翻</p><ul><li>链接：<a href="https://pan.baidu.com/s/1kw_UNgwL7hLN0N99KroK5w">https://pan.baidu.com/s/1kw_UNgwL7hLN0N99KroK5w</a> <ul><li>提取码：ntlx</li></ul></li></ul><ol><li>打开帮助文档。</li><li>点击显示，找到索引，看到输入框。</li><li>你要找谁？在输入框里输入，然后回车。</li><li>看包。java.lang下的类不需要导包，其他需要。</li><li>看类的解释和说明。</li><li>学习构造方法。</li><li>使用成员方法</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装</title>
      <link href="/6321ac3497ca.html"/>
      <url>/6321ac3497ca.html</url>
      
        <content type="html"><![CDATA[<h1 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h1><h2 id="什么是Scanner类"><a href="#什么是Scanner类" class="headerlink" title="什么是Scanner类"></a>什么是Scanner类</h2><p>一个可以解析基本类型和字符串的简单文本扫描器。</p><p>例如：读取用户键盘输入的一个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> i = scanner.nextInt();</span><br></pre></td></tr></table></figure><blockquote><p>System.in系统输入指的是通过键盘录入数据</p></blockquote><h2 id="引用类型一般使用步骤"><a href="#引用类型一般使用步骤" class="headerlink" title="引用类型一般使用步骤"></a>引用类型一般使用步骤</h2><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><p>使用<code>import</code>关键字导包，在类的所有代码之前导包，引入要使用的类型，java.lang包下的所有类无需导入</p><ul><li>格式：</li></ul><p><code>import 包名.类名</code></p><ul><li>实现：</li></ul><p><code>import java.util.Scanner</code></p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>使用该类的构造方法，创建一个该类的对象</p><ul><li>格式：</li></ul><p><code>数据类型 变量名 = new 数据类型(参数列表)</code></p><ul><li>实现：</li></ul><p><code>Scanner scanner = new Scanner(System.in);</code></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>调用该类的成员方法，完成指定功能</p><ul><li>格式：</li></ul><p><code>变量名.方法名();</code></p><ul><li>实现：</li></ul><p><code>int i = scanner.nextInt();</code></p><h2 id="Scanner使用步骤"><a href="#Scanner使用步骤" class="headerlink" title="Scanner使用步骤"></a>Scanner使用步骤</h2><ul><li>查看类<ul><li><code>java.util.Scanner</code>：该类需要import导入后使用</li></ul></li><li>查看构造方法<ul><li><code>public Scanner(InputStream source)</code>：构造一个新的<code>Scanner</code>，它生成的值从指定的输入流扫描</li></ul></li><li>查看成员方法<ul><li><code>public int nextInt()</code>：将输入信息的下一个标记扫描为一个<code>int</code>值</li></ul></li><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">      <span class="keyword">int</span> i = scanner.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。虽然是创建对象的简化写法，但是应用场景非常有限。</p><ul><li>匿名对象：没有变量名的对象</li><li>格式：<ul><li><code>new 类名(参数列表);</code></li></ul></li><li>实现：<ul><li><code>new Scanner(System.in);</code></li></ul></li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><p>创建匿名对象直接调用方法，没有变量名</p></li><li><p><code>new Scanner(System.in).nextInt();</code></p></li><li><p>但是一旦调用两次方法，就是创建了两个对象，造成浪费</p><ul><li><p>```java<br>new Scanner(System.in).nextInt();<br>new Scanner(System.in).nextInt();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 匿名对象可以作为方法的参数和返回值</span><br><span class="line"></span><br><span class="line">  - 作为参数</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  public class Test &#123;</span><br><span class="line">      public static void main(String[] args)&#123;</span><br><span class="line">        input(new Scanner(System.in));</span><br><span class="line">  </span><br><span class="line">      &#125;</span><br><span class="line">      public static void input(Scanner scanner)&#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>作为返回值</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = input();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scanner <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>体现：</p><ol><li>方法就是一种封装</li><li>关键字<code>private</code>也是一种封装</li></ol><h2 id="封装的概述"><a href="#封装的概述" class="headerlink" title="封装的概述"></a>封装的概述</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。</p><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>将<strong>属性隐藏</strong>起来，若需要访问某个属性，<strong>提供公共方法</strong>对其访问。</p><h2 id="封装的步骤"><a href="#封装的步骤" class="headerlink" title="封装的步骤"></a>封装的步骤</h2><ul><li>使用<code>private</code>关键字来修饰成员变量。</li><li>对需要访问的成员变量，提供对应的一对<code>getxxx方法、setxxx方法</code>。</li></ul><h2 id="private关键字"><a href="#private关键字" class="headerlink" title="private关键字"></a>private关键字</h2><h3 id="private的含义"><a href="#private的含义" class="headerlink" title="private的含义"></a>private的含义</h3><ul><li><code>private</code>是一个权限修饰符，代表最小权限。</li><li>可以修饰成员变量和成员方法。</li><li>被<code>private</code>修饰后的成员变量和成员方法，只在本类中才能访问。</li></ul><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p><code>private 数据类型 变量名;</code></p><ul><li>实现</li></ul><p>使用<code>private</code>修饰成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供get/set方法，访问成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>因为<code>set方法</code>的成员变量赋值会失败（<strong>当方法的局部变量和类的成员变量重名的时候，根据就近原则，优先使用局部变量</strong>），相当于set方法没有用，但是又要满足见名知意的规定</p><p>Java就提供了访问当前对象的引用的关键字<code>this</code></p><h3 id="this的含义"><a href="#this的含义" class="headerlink" title="this的含义"></a>this的含义</h3><p>this代表所在类的当前对象的引用（地址值），即对象自己的引用。</p><blockquote><p>记住：方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。</p></blockquote><h3 id="this的使用"><a href="#this的使用" class="headerlink" title="this的使用"></a>this的使用</h3><ul><li>格式</li></ul><p><code>this.成员变量</code></p><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。</p><p>无论你与否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个无参数构造方法，一旦自己定义了构造方法，lava自动提供的默认无参数构造方法就会失效</p><ul><li>格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 构造方法名(参数列表)&#123;</span><br><span class="line"> <span class="comment">//方法体 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法的写法上，方法名与它所在的类名相同。它没有返回值，所以不需要返回值类型，甚至不需要void，使用构造方法后，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="comment">//无参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//有参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>构造方法的名称必须和所在的类名名称完全一样，就连大小写也要一样</li><li>构造方法不要写返回值类型，连void都不要写</li><li>构造方法不能return一个具体的返回值</li><li>如果你不提供构造方法，系统会给出无参数构造方法</li><li>如果你提供了构造方法，系统将不再提供无参数构造方法</li><li>构造方法是可以重载的，既可以定义参数，也可以不定义参数</li></ul><h2 id="JavaBean-标准代码"><a href="#JavaBean-标准代码" class="headerlink" title="JavaBean(标准代码)"></a>JavaBean(标准代码)</h2><p><code>JavaBean</code>是Java语言编写类的一种标准规范。符合J<code>avaBean</code>的类，要求类必须是具体的和公共的，并且具有<code>无参数的构造方法</code>，提供用来操作成员变量的<code>set</code>和<code>get</code>方法。</p><ul><li>格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line">  <span class="comment">//成员变量</span></span><br><span class="line">  <span class="comment">//构造方法</span></span><br><span class="line">  <span class="comment">//无参构造方法【必须】</span></span><br><span class="line">  <span class="comment">//有参构造方法【建议】</span></span><br><span class="line">  <span class="comment">//成员方法</span></span><br><span class="line">  <span class="comment">//get</span></span><br><span class="line">  <span class="comment">//set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有参构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reading</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;正在读书&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get set</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/d911e46da2b8.html"/>
      <url>/d911e46da2b8.html</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象思想概述"><a href="#面向对象思想概述" class="headerlink" title="面向对象思想概述"></a>面向对象思想概述</h2><p>Java语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，使用Java语言去设计、开发计算机程序。这里的<strong>对象</strong>泛指现实中一切事物，每种事物都具备自己的<strong>属性</strong>和<strong>行为</strong>。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算机事件的设计思想。它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。</p><p>面向对象和面向过程区别：</p><ul><li>面向过程：强调步骤</li><li>面向对象，强调对象</li></ul><p>特点：</p><ul><li>面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成了指挥者面向对象的语言中，包含了<strong>三大基本特征</strong>，即<strong>封装、继承和多态</strong>。</li></ul><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类"></a>什么是类</h3><ul><li><strong>类</strong>：是一组相关<strong>属性</strong>和<strong>行为</strong>的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。</li></ul><p>在先使用，描述一类事物：</p><ul><li><strong>属性</strong>：就是该事物的状态信息</li><li><strong>行为</strong>：就是该事物能够做什么</li></ul><h3 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h3><ul><li><strong>对象</strong>：是一类事物的具体体现。对象是类的一个实例（对象并不是找个女朋友），必然具备该类事物的属性和行为。</li></ul><h3 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h3><ul><li>类是对一类事物的描述，是<strong>抽象的</strong></li><li>对象是一类事物的实例，是<strong>具体的</strong></li><li><strong>类是对象的模板，对象是类的实体</strong></li></ul><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><h3 id="事物与类的对比"><a href="#事物与类的对比" class="headerlink" title="事物与类的对比"></a>事物与类的对比</h3><p>现实世界的一类事物：</p><ul><li><p><strong>属性</strong>：事物的状态信息</p></li><li><p><strong>行为</strong>：事物能够做什么</p></li></ul><p>Java中用class描述事物也是如此：</p><ul><li><p><strong>成员变量</strong>：对应事物的<strong>属性</strong></p></li><li><p><strong>成员方法</strong>：对应事物的<strong>行为</strong></p></li></ul><h3 id="类的定义格式"><a href="#类的定义格式" class="headerlink" title="类的定义格式"></a>类的定义格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line">  <span class="comment">//成员变量</span></span><br><span class="line">  <span class="comment">//成员方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>定义类</strong>：就是定义类的成员，包括<strong>成员变量</strong>和<strong>成员方法</strong>。</p></li><li><p><strong>成员变量</strong>：和以前定义变量几乎是一样的。只不过位置发生了改变。<strong>在类中，方法外</strong>。</p></li><li><p><strong>成员方法</strong>：和以前定义方法几乎是一样的。只不过<strong>把static去掉</strong>，static的作用在面向对象后面课程中再详细讲解。</p></li><li><p>实现</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">  <span class="comment">//成员变量</span></span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//成员方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;好好学习&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h2><h3 id="对象的使用格式"><a href="#对象的使用格式" class="headerlink" title="对象的使用格式"></a>对象的使用格式</h3><ul><li>创建对象：</li></ul><p><code>类名 对象名 = new 类名();</code></p><ul><li>使用对象访问类中的成员:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象名.成员变量;</span><br><span class="line">对象名.成员方法();</span><br></pre></td></tr></table></figure><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="comment">//创建对象</span></span><br><span class="line">  Student s = <span class="keyword">new</span> Student();</span><br><span class="line">  <span class="comment">//获取成员变量</span></span><br><span class="line">  System.out.print(s.name);</span><br><span class="line">  <span class="comment">//给成员变量赋值</span></span><br><span class="line">  s.name = <span class="string">&quot;大黄&quot;</span>;</span><br><span class="line">  <span class="comment">//调用成员方法</span></span><br><span class="line">  s.study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员变量的默认值"><a href="#成员变量的默认值" class="headerlink" title="成员变量的默认值"></a>成员变量的默认值</h3><table><thead><tr><th></th><th>数据类型</th><th>默认值</th></tr></thead><tbody><tr><td>基本类型</td><td>整数（byte、short、int、long）</td><td>0</td></tr><tr><td></td><td>浮点数（float、double）</td><td>0.0</td></tr><tr><td></td><td>字符（char）</td><td>‘\u0000’</td></tr><tr><td></td><td>布尔（boolean）</td><td>false</td></tr><tr><td>引用类型</td><td>数组、类、接口</td><td>null</td></tr></tbody></table><h2 id="对象的内存图"><a href="#对象的内存图" class="headerlink" title="对象的内存图"></a>对象的内存图</h2><h3 id="只有一个对象的内存图"><a href="#只有一个对象的内存图" class="headerlink" title="只有一个对象的内存图"></a>只有一个对象的内存图</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/d911e46da2b8/01-%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png" alt="01-只有一个对象的内存图"></p><h3 id="两个对象使用同一个方法的内存图"><a href="#两个对象使用同一个方法的内存图" class="headerlink" title="两个对象使用同一个方法的内存图"></a>两个对象使用同一个方法的内存图</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/d911e46da2b8/02-%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png" alt="02-两个对象使用同一个方法的内存图"></p><h3 id="两个引用指向同一个对象的内存图"><a href="#两个引用指向同一个对象的内存图" class="headerlink" title="两个引用指向同一个对象的内存图"></a>两个引用指向同一个对象的内存图</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/d911e46da2b8/03-%E4%B8%A4%E4%B8%AA%E5%BC%95%E7%94%A8%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png" alt="03-两个引用指向同一个对象的内存图"></p><h3 id="使用对象类型作为方法的参数"><a href="#使用对象类型作为方法的参数" class="headerlink" title="使用对象类型作为方法的参数"></a>使用对象类型作为方法的参数</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/d911e46da2b8/04-%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0.png" alt="04-使用对象类型作为方法的参数"></p><h3 id="使用对象类型作为方法的返回值"><a href="#使用对象类型作为方法的返回值" class="headerlink" title="使用对象类型作为方法的返回值"></a>使用对象类型作为方法的返回值</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/d911e46da2b8/05-%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC.png" alt="05-使用对象类型作为方法的返回值"></p><h2 id="成员变量和局部变量区别"><a href="#成员变量和局部变量区别" class="headerlink" title="成员变量和局部变量区别"></a>成员变量和局部变量区别</h2><p>变量根据定义<strong>位置的不同</strong>，我们给变量起了不同的名字。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/d911e46da2b8/image-20200404165047761.png" alt="image-20200404165047761"></p><ul><li>在类中的位置不同<ul><li>成员变量：类中，方法外</li><li>局部变量：方法中或者方法声明上（形式参数）</li></ul></li><li>作用范围不一样<ul><li>成员变量：类中</li><li>局部变量：方法中</li></ul></li><li>初始化值的不同<ul><li>成员变量：有默认值</li><li>局部变量：没有默认值。必须先定义，赋值，最后使用</li></ul></li><li>在内存中的位置不同<ul><li>成员变量：堆内存</li><li>局部变量：栈内存</li></ul></li><li>生命周期不同<ul><li>成员变量：随着对象的创建而存在，随着对象的消失而消失</li><li>局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/843e58d8929c.html"/>
      <url>/843e58d8929c.html</url>
      
        <content type="html"><![CDATA[<h2 id="数组的定义和访问"><a href="#数组的定义和访问" class="headerlink" title="数组的定义和访问"></a>数组的定义和访问</h2><h3 id="容器概念"><a href="#容器概念" class="headerlink" title="容器概念"></a>容器概念</h3><ul><li>容器：是将多个数据存储到一起，每个数据称为容器的元素</li><li>比如：水杯就时容器，而里面的的存放的水、饮料、酒就可以称为容器的元素</li></ul><h3 id="数组的概念"><a href="#数组的概念" class="headerlink" title="数组的概念"></a>数组的概念</h3><ul><li>数组：数组就是存储数据长度固定的容器<ul><li>特点：<ul><li><strong>数组是一种引用数据类型</strong></li><li><strong>数组当中的多个数据，类型必须统一</strong></li><li><strong>数组的长度在运行期间不可以改变</strong></li></ul></li></ul></li></ul><h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3><h4 id="动态初始化（指定长度）"><a href="#动态初始化（指定长度）" class="headerlink" title="动态初始化（指定长度）"></a>动态初始化（指定长度）</h4><ul><li>格式：</li></ul><p><code>数据类型[] 数据名称 = new 数据类型[长度]</code></p><ul><li><p>解释：</p><ul><li><code>数据类型</code>：创建的数组容器可以存储什么数据类型</li><li><code>[]</code>：表示数组。</li><li><code>数据名称</code>：为定义的数组起个变量名，满足标识符规范，可以使用名字操作数组。</li><li><code>new：关键字</code>，创建数组使用的关键字。</li><li><code>数据类型</code>：创建的数组容器可以存储什么数据类型。</li><li><code>[长度]</code>：数组的长度，表示数组容器中可以存储多少个元素，是int数字。</li><li><strong>注意：数组有定长特性，长度一旦指定，不可更改。</strong><ul><li>和水杯一个道理，买了一个2升的水杯，总量也就只有2升，不能多也少不了</li></ul></li></ul></li><li><p>实现</p></li></ul><p><code>int[] arr = new int[300];</code></p><h4 id="静态初始化（指定内容）"><a href="#静态初始化（指定内容）" class="headerlink" title="静态初始化（指定内容）"></a>静态初始化（指定内容）</h4><ul><li>格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数据名称 = <span class="keyword">new</span> 数据类型[]&#123;元素<span class="number">1</span>,元素<span class="number">2.</span>..&#125;;</span><br><span class="line">或者</span><br><span class="line">数据类型[] 数据名称 = &#123;元素<span class="number">1</span>,元素<span class="number">2.</span>..&#125;;</span><br></pre></td></tr></table></figure><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>静态初始化没有直接告诉长度，但是根据大括号里面的元素具体内容，也可以自动推算出来长度</li><li>静态初始化标准格式可以拆分成为两个步骤</li><li>动态初始化可以拆分成为两个步骤</li><li>静态初始化一旦使用省略格式，就不能拆分呈两个步骤</li><li>建议：<ul><li>如果不确定数组当中的具体内容，用动态初始化</li><li>已经确定了具体的内容，同静态初始化</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 静态初始化标准格式可以拆分成为两个步骤</span></span><br><span class="line">        <span class="keyword">int</span>[] arrayA;</span><br><span class="line">        arrayA = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="comment">// 动态初始化可以拆分成为两个步骤</span></span><br><span class="line">        <span class="keyword">int</span>[] arrayB;</span><br><span class="line">        arrayB = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态初始化一旦使用省略格式，就不能拆分呈两个步骤</span></span><br><span class="line">        <span class="comment">//int [] arrayC;</span></span><br><span class="line">        <span class="comment">//arrayC = &#123;1,2,3&#125;;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据的访问"><a href="#数据的访问" class="headerlink" title="数据的访问"></a>数据的访问</h3><ul><li><strong>索引</strong>：每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为数组索引（index），可以通过数组的索引访问到数组中的元素。</li><li><strong>格式</strong>：</li></ul><p><code>数组名[索引]</code></p><ul><li><strong>数组的长度属性</strong>：<strong>每个数组都具有长度，而且是固定的</strong>，Java中赋予了数组的一个属性，可以获取到数组的长度，语句为：<code>数组名.length</code>，属性length的执行结果是数组的长度，int类型结果。由次可以推断出，费组的最大索引值为<code>数组名.length-1</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(array.length); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>索引访问数组中的元素</strong>：<ul><li>数组名[索引] = 数组，为数组中的元素赋值</li><li>变量 = 数组名[索引]，获取出数组中的元素</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(array.length); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 索引从0开始</span></span><br><span class="line">        System.out.println(array[<span class="number">0</span>]); <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// length - 1 结束</span></span><br><span class="line">        System.out.println(array[array.length - <span class="number">1</span>]); <span class="comment">// 3</span></span><br><span class="line">        <span class="comment">// 改变索引的值</span></span><br><span class="line">        array[<span class="number">0</span>] = <span class="number">6</span>;</span><br><span class="line">        System.out.println(array[<span class="number">0</span>]); <span class="comment">// 6</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>动态数组的访问</p><ul><li>如果使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值<ul><li>如果是整数类型，默认为0</li><li>如果是浮点类型，默认为0.0</li><li>如果是字符类型，默认为’\u0000’</li><li>如果是布尔类型，默认为false</li><li>如果是引用类型，默认为null</li></ul></li></ul></li><li><p>注意事项</p><ul><li>静态初始化其实也有默认值的过程，只不过系统马上替换成了大括号中的对应值</li></ul></li></ul><h2 id="数组原理内存图"><a href="#数组原理内存图" class="headerlink" title="数组原理内存图"></a>数组原理内存图</h2><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存是计算机中的重要原件，临时存储区域，作用是运行程序。我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。</p><p>Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。</p><h3 id="Java虚拟机的内存划分"><a href="#Java虚拟机的内存划分" class="headerlink" title="Java虚拟机的内存划分"></a>Java虚拟机的内存划分</h3><p>为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。</p><ul><li><p>JVM的内存划分：</p><table><thead><tr><th>区域名称</th><th>作用</th></tr></thead><tbody><tr><td>寄存器</td><td>给CPU使用，和开发无关</td></tr><tr><td>本地方法栈</td><td>JVM在使用操作系统功能的时候使用，和开发无关</td></tr><tr><td>方法区</td><td>存储可以运行的Class文件</td></tr><tr><td>堆内存</td><td>存储对象或者数组，new来创建的，都存储在堆内存</td></tr><tr><td>方法栈</td><td>方法运行时使用的内存，比如main方法运行，进入方法栈中执行</td></tr></tbody></table><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/843e58d8929c/01-Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.png" alt="01-Java中的内存划分"></p></li></ul><h3 id="数组在内存中的存储"><a href="#数组在内存中的存储" class="headerlink" title="数组在内存中的存储"></a>数组在内存中的存储</h3><h4 id="一个数组内存图"><a href="#一个数组内存图" class="headerlink" title="一个数组内存图"></a>一个数组内存图</h4><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/843e58d8929c/02-%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png" alt="02-只有一个数组的内存图"></p><h4 id="两个数组内存图"><a href="#两个数组内存图" class="headerlink" title="两个数组内存图"></a>两个数组内存图</h4><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/843e58d8929c/03-%E6%9C%89%E4%B8%A4%E4%B8%AA%E7%8B%AC%E7%AB%8B%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png" alt="03-有两个独立数组的内存图"></p><h4 id="两个引用指向同一个数组的内存图"><a href="#两个引用指向同一个数组的内存图" class="headerlink" title="两个引用指向同一个数组的内存图"></a>两个引用指向同一个数组的内存图</h4><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/843e58d8929c/04-%E4%B8%A4%E4%B8%AA%E5%BC%95%E7%94%A8%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png" alt="04-两个引用指向同一个数组的内存图"></p><h3 id="数组长度保持不变的内存图"><a href="#数组长度保持不变的内存图" class="headerlink" title="数组长度保持不变的内存图"></a>数组长度保持不变的内存图</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/843e58d8929c/05-%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6%E8%BF%90%E8%A1%8C%E6%9C%9F%E9%97%B4%E4%B8%8D%E5%8F%AF%E6%94%B9%E5%8F%98.png" alt="05-数组的长度运行期间不可改变"></p><h2 id="数组的常见操作"><a href="#数组的常见操作" class="headerlink" title="数组的常见操作"></a>数组的常见操作</h2><h3 id="数组越界异常"><a href="#数组越界异常" class="headerlink" title="数组越界异常"></a>数组越界异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>创建数组</p></li><li><p>赋值3个元素，数组的索引就是0，1，2</p></li><li><p>没有3索引，因此我们不能访问数组中不存在的索引</p></li><li><p>程序运行后，将会抛出<code>ArrayIndexOutofBoundsException</code>数组越界异常</p></li><li><p>在开发中，数组的越界异常是<strong>不能出现</strong>的，一旦出现了，就必须要修改我们编写的代码</p></li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/843e58d8929c/image-20200404115449968.png" alt="image-20200404115449968"></p><h3 id="数组空指针异常"><a href="#数组空指针异常" class="headerlink" title="数组空指针异常"></a>数组空指针异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    arr = <span class="keyword">null</span>;</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>arr = null;</code>这行代码，意味着变量arr将不会在保存数组的内存地址，也就不允许再操作数组了</p><ul><li><strong>所有的引用类型变量，都可以赋值为一个null值，代表其中什么都没有</strong></li></ul></li><li><p>因此运行的时候会抛出<code>Nul1PointerException</code>空指针异常</p></li><li><p>在开发中，数组的空指针异常是不能出现的，一旦出现了，就必须要修改我们编写的代码</p></li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/843e58d8929c/image-20200404115849231.png" alt="image-20200404115849231"></p><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p><strong>数组遍历</strong>：就是将数组中的每个元素分别获取出来，就是遍历。遍历也是数组操作中的基石。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           System.out.println(arr[i]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="数组获取最大值元素"><a href="#数组获取最大值元素" class="headerlink" title="数组获取最大值元素"></a>数组获取最大值元素</h3><ul><li><p>最大值获取：从数组的所有元素中找出最大值。</p></li><li><p>实现思路：</p><ul><li>定义变量，保存数组0索引上的元素</li><li>遍历数组，获取出数组中的每个元素</li><li>将遍历到的元素和保存数组0索引上值的变量进行比较</li><li>如果数组元素的值大于了变量的值，变量记录住新的值</li><li>数组循环遍历结束，变量保存的就是数组中的最大值</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">321</span>, <span class="number">431</span>, <span class="number">431</span>, <span class="number">431</span>, <span class="number">546</span>, <span class="number">57</span>, <span class="number">48758</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; arr[i]) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h3><ul><li>数组的反转：数组中的元素颠倒顺序，实现思想：数组最远端的元素互换位置。<ul><li>实现反转，就需要将数组最远端元素位置交换</li><li>定义两个变量，保存数组的最小索引和最大索引</li><li>两个索引上的元素交换位置</li><li>最小索引<code>++</code>，最大索引<code>--</code>，再次交换位置</li><li>最小索引超过了最大索引，数组反转操作结束</li></ul></li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/843e58d8929c/07-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%8F%8D%E8%BD%AC%E7%9A%84%E6%80%9D%E8%B7%AF.png" alt="07-数组元素反转的思路"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">321</span>, <span class="number">431</span>, <span class="number">431</span>, <span class="number">431</span>, <span class="number">546</span>, <span class="number">57</span>, <span class="number">48758</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> min = <span class="number">0</span>, max = arr.length - <span class="number">1</span>; min &lt; max; min++, max--) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[min];</span><br><span class="line">        arr[min] = arr[max];</span><br><span class="line">        arr[max] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        System.out.print(arr[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组为方法参数和返回值"><a href="#数组为方法参数和返回值" class="headerlink" title="数组为方法参数和返回值"></a>数组为方法参数和返回值</h2><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><ul><li><p>数组作为方法的参数</p></li><li><p>当调用方法的时候，向方法的小括号进行传参，传递进去的其实时数组的地址值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">321</span>, <span class="number">431</span>, <span class="number">431</span>, <span class="number">431</span>, <span class="number">546</span>, <span class="number">57</span>, <span class="number">48758</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    printArray(arr); <span class="comment">// 传递进去的是arr当中保存的地址值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        System.out.print(array[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul><li>数组作为方法的返回值，返回的是数组的内存地址</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = NewArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] NewArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">321</span>, <span class="number">431</span>, <span class="number">431</span>, <span class="number">431</span>, <span class="number">546</span>, <span class="number">57</span>, <span class="number">48758</span>, <span class="number">9</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法的参数类型区别"><a href="#方法的参数类型区别" class="headerlink" title="方法的参数类型区别"></a>方法的参数类型区别</h3><ul><li>引用类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]); <span class="comment">// 1</span></span><br><span class="line">    change(arr);</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]); <span class="comment">// 200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>基本类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        System.out.println(a); <span class="comment">// 1</span></span><br><span class="line">        change(a);</span><br><span class="line">        System.out.println(a); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        a = a + <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>总结<ul><li>方法的参数为基本类型时，传递的是数据值，方法的参数为引用类型时，传递的是地址值</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法</title>
      <link href="/b3421d932a26.html"/>
      <url>/b3421d932a26.html</url>
      
        <content type="html"><![CDATA[<h2 id="方法的定义和调用-回顾"><a href="#方法的定义和调用-回顾" class="headerlink" title="方法的定义和调用(回顾)"></a>方法的定义和调用(回顾)</h2><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名称()&#123;</span><br><span class="line">  方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法名称();</span><br></pre></td></tr></table></figure><p>注意事项</p><ol><li>方法定义的先后顺序无所谓</li><li>方法定义必须时挨着的，不能一个方法的内部定义另外一个方法(特殊情况除外)</li><li>方法定义之后，自己不会执行的，如果希望执行，一定要进行方法的调用</li></ol><p>控制台输出矩形</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义格式的格式详解"><a href="#定义格式的格式详解" class="headerlink" title="定义格式的格式详解"></a>定义格式的格式详解</h2><p>方法其实就是若干语句的功能集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法格式：</span><br><span class="line">修饰符 返回值类型 方法名(参数类型 参数名称,...)&#123;</span><br><span class="line">  <span class="comment">//代码</span></span><br><span class="line">  <span class="keyword">return</span> 结果;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修饰符：现阶段只有public static固定写法</li><li>返回值类型：表示方法运行的结果的数据类型，方法执行后将结果返回到调用者</li><li>方法名：方法的名称，规则和变量一样，小驼峰</li><li>参数类型：进入方法的数据时什么类型</li><li>参数名称：进入方法的数据对应的变量名称（参数有多个用逗号分割）</li><li>return：两个作用，第一个停止方法，第二个将后面的返回值还给调用处<ul><li>return 返回的返回值，必须和方法名称中的返回值类型保持对应</li></ul></li></ul><h2 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h2><ul><li>定义方法明确<ul><li>返回值类型：明确这个方法必定返回的类型</li><li>方法名称：明确这个方法是做什么的</li><li>参数列表：明确需要传入的值有哪些</li></ul></li></ul><p>实现两个整数求和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewMethodDefine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法三种调用"><a href="#方法三种调用" class="headerlink" title="方法三种调用"></a>方法三种调用</h2><ol><li>单独调用：方法名称(参数);</li><li>打印调用</li><li>赋值调用<ul><li>返回值类型固定写为<strong>void</strong>，这种方法只能单独调用，不能进行打印调用和赋值调用</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewMethodDefine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//单独调用</span></span><br><span class="line">        sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//打印调用</span></span><br><span class="line">        System.out.println(sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        <span class="comment">//赋值调用</span></span><br><span class="line">        <span class="keyword">int</span> num = sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用方法的流程图"><a href="#调用方法的流程图" class="headerlink" title="调用方法的流程图"></a>调用方法的流程图</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/b3421d932a26/image-20200403103522213.png" alt="image-20200403103522213"></p><h2 id="方法区别"><a href="#方法区别" class="headerlink" title="方法区别"></a>方法区别</h2><h3 id="有参数或无参数"><a href="#有参数或无参数" class="headerlink" title="有参数或无参数"></a>有参数或无参数</h3><p>有参数：小括号当中有内容，当一个方法需要一些数据条件，才能完成任务的时候，就是有参数</p><p>无参数：小括号当中留空，一个方法不需要任何数据条件，自己就能独立完成任务，就是无参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewMethodDefine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有返回值或无返回值"><a href="#有返回值或无返回值" class="headerlink" title="有返回值或无返回值"></a>有返回值或无返回值</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/b3421d932a26/04-%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%9C%89%E6%97%A0.png" alt="04-方法返回值的有无"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>方法应该定义在类当中，但是不能在方法当中在定义方法，不能嵌套</li><li>方法定义的前后顺序无所谓</li><li>方法定义之后不会执行，如果希望执行，一定要调用<ul><li>单独调用</li><li>打印调用</li><li>赋值调用</li></ul></li><li>如果方法又返回值，那么必须写上<code>return 返回值;</code></li><li>return后面的返回值数据，必须和方法的返回值类型，对应</li><li>对于一个void没有返回值的方法，不能写return后面的返回值，只能写return自己</li><li>对于void方法当中最后一行的return可以省略不写</li><li>一个方法当中可以有多个return语句，但是必须保证同时只有一个会被执行到，两个return不能连写</li></ol><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><ul><li>方法重载：指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返回值类型无关。</li><li>参数列表：<ul><li>个数不同</li><li>数据类型不同</li><li>顺序不同</li></ul></li><li>重载方法调用：JVM通过方法的参数列表，调用不同的方法。</li><li>优势：只需要记住唯一一个方法名称，就可以实现类似的多个功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewMethodOverload</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        System.out.println(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(sum(<span class="number">1.0</span>, <span class="number">2.0</span>));</span><br><span class="line">        System.out.println(sum(<span class="number">1.0</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (a + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//错误!与参数名称无关</span></span><br><span class="line">    <span class="comment">//    public static int sum(double x, int y) &#123;</span></span><br><span class="line">    <span class="comment">//        return (int) (x + y);</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//错误!与返回值类型无关</span></span><br><span class="line">    <span class="comment">//    public static double sum(double a, int b) &#123;</span></span><br><span class="line">    <span class="comment">//        return a + b;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发工具Intellij-IDEA</title>
      <link href="/0d714c49bb0b.html"/>
      <url>/0d714c49bb0b.html</url>
      
        <content type="html"><![CDATA[<h2 id="开发工具概述"><a href="#开发工具概述" class="headerlink" title="开发工具概述"></a>开发工具概述</h2><p>IDEA是一个专门针对Java的集成开发工具（IDE），由Java语言编写。所以，需要有JRE运行环境并配置好环境变量它可以极大地提升我们的开发效率。可以自动编译，检查错误。在公司中，使用的就是IDEA进行开发。</p><p>下载地址：<a href="https://www.jetbrains.com/idea/">https://www.jetbrains.com/idea/</a></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402170317121.png" alt="image-20200402170317121"></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402170351577.png" alt="image-20200402170351577"></p><h2 id="IDEA软件安装"><a href="#IDEA软件安装" class="headerlink" title="IDEA软件安装"></a>IDEA软件安装</h2><p>此软件集成了32位和64位，双击<code>ideaIU-2017.3.2.exe</code>进入安装。</p><h3 id="欢迎界面"><a href="#欢迎界面" class="headerlink" title="欢迎界面"></a>欢迎界面</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402170525471.png" alt="image-20200402170525471"></p><h3 id="安装路径"><a href="#安装路径" class="headerlink" title="安装路径"></a>安装路径</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402170544275.png" alt="image-20200402170544275"></p><h3 id="配置安装选项"><a href="#配置安装选项" class="headerlink" title="配置安装选项"></a>配置安装选项</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402170608817.png" alt="image-20200402170608817"></p><h3 id="开始菜单"><a href="#开始菜单" class="headerlink" title="开始菜单"></a>开始菜单</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402170635952.png" alt="image-20200402170635952"></p><h3 id="安装完毕"><a href="#安装完毕" class="headerlink" title="安装完毕"></a>安装完毕</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402170652435.png" alt="image-20200402170652435"></p><h2 id="IDEA首次驱动"><a href="#IDEA首次驱动" class="headerlink" title="IDEA首次驱动"></a>IDEA首次驱动</h2><h3 id="选择不导入任何设置，点击OK"><a href="#选择不导入任何设置，点击OK" class="headerlink" title="选择不导入任何设置，点击OK"></a>选择不导入任何设置，点击OK</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402170744130.png" alt="image-20200402170744130"></p><h3 id="选择Create-New-Project"><a href="#选择Create-New-Project" class="headerlink" title="选择Create New Project"></a>选择Create New Project</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402170816522.png" alt="image-20200402170816522"></p><h3 id="点击new按钮，配置安装的JDK版本"><a href="#点击new按钮，配置安装的JDK版本" class="headerlink" title="点击new按钮，配置安装的JDK版本"></a>点击new按钮，配置安装的JDK版本</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402170854718.png" alt="image-20200402170854718"></p><h3 id="选择自己电脑上的JDK目录，点击确定"><a href="#选择自己电脑上的JDK目录，点击确定" class="headerlink" title="选择自己电脑上的JDK目录，点击确定"></a>选择自己电脑上的JDK目录，点击确定</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402170941742.png" alt="image-20200402170941742"></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402171012124.png" alt="image-20200402171012124"></p><h3 id="不使用模板"><a href="#不使用模板" class="headerlink" title="不使用模板"></a>不使用模板</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402171036407.png" alt="image-20200402171036407"></p><h3 id="为工程起名称，这里未测试就用的demo，选择存储的位置，如果选择的没有这个目录，会自动创建"><a href="#为工程起名称，这里未测试就用的demo，选择存储的位置，如果选择的没有这个目录，会自动创建" class="headerlink" title="为工程起名称，这里未测试就用的demo，选择存储的位置，如果选择的没有这个目录，会自动创建"></a>为工程起名称，这里未测试就用的demo，选择存储的位置，如果选择的没有这个目录，会自动创建</h3><blockquote><p>首次新建项目时，默认的Project Location路径有问题，如<code>c:\\xxx</code>，正确写法为<code>c:\xxx</code>。更改后不会出现此类问题。</p></blockquote><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402171237437.png" alt="image-20200402171237437"></p><h3 id="打开一个每日一帖对话框，勾掉每次启动显示，点击close"><a href="#打开一个每日一帖对话框，勾掉每次启动显示，点击close" class="headerlink" title="打开一个每日一帖对话框，勾掉每次启动显示，点击close"></a>打开一个每日一帖对话框，勾掉每次启动显示，点击close</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402171303668.png" alt="image-20200402171303668"></p><h3 id="IDEA的工作界面，我们的项目已经创建好了，如果再新建项目，点击File-gt-new-gt-Project"><a href="#IDEA的工作界面，我们的项目已经创建好了，如果再新建项目，点击File-gt-new-gt-Project" class="headerlink" title="IDEA的工作界面，我们的项目已经创建好了，如果再新建项目，点击File-&gt;new-&gt;Project"></a>IDEA的工作界面，我们的项目已经创建好了，如果再新建项目，点击File-&gt;new-&gt;Project</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402171333076.png" alt="image-20200402171333076"></p><h2 id="IDEA的项目结构"><a href="#IDEA的项目结构" class="headerlink" title="IDEA的项目结构"></a>IDEA的项目结构</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/02-IDEA%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" alt="02-IDEA的项目结构"></p><h3 id="创建包和类"><a href="#创建包和类" class="headerlink" title="创建包和类"></a>创建包和类</h3><p>展开创建的工程，在源代码目录<code>src</code>上，鼠标右键，选择<code>new-&gt;package</code>，输入包名<code>com.itheima.demo</code>（随便你自己）点击确定。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402171834576.png" alt="image-20200402171834576"></p><p>右键点击<code>com.itheima.demo</code>，选择<code>Show in Explorer</code>，会发现创建包的目录结构。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402171910062.png" alt="image-20200402171910062"></p><p>在创建好的包上，鼠标右键，选择<code>new-&gt;class </code>创建类，键入类名。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402172005458.png" alt="image-20200402172005458"></p><p>在代码编辑区，键入主方法，并输出<code>HelloWorld</code></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402172028412.png" alt="image-20200402172028412"></p><p>运行程序，在代码编辑区鼠标右键，选择<code>Run HelloWorld</code>即可，或在菜单中选择<code>Run-&gt;Run HelloWor1d</code></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402172155375.png" alt="image-20200402172155375"></p><h2 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h2><p>IDEA工具的默认字体非常小，代码编辑器和控制台的输出字体都需要进行调整。</p><ul><li>点击菜单栏上的<code>File-&gt;Settings-&gt;Editor-&gt;Font</code>修改字体。</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402172320302.png" alt="image-20200402172320302"></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402172334670.png" alt="image-20200402172334670"></p><h2 id="IDEA的项目目录"><a href="#IDEA的项目目录" class="headerlink" title="IDEA的项目目录"></a>IDEA的项目目录</h2><ul><li>我们创建的项目，在<code>d:videawork</code>目录的<code>demo</code>下<ul><li><code>.idea</code>目录和<code>demo.iml</code>和我们开发无关，是IDEA工具自己使用的</li><li><code>out</code>目录是存储编译后的<code>.class</code>文件</li><li><code>src</code>目录是存储我们编写的<code>.java</code>源文件</li></ul></li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402172453930.png" alt="image-20200402172453930"></p><h2 id="IDEA常用快捷键"><a href="#IDEA常用快捷键" class="headerlink" title="IDEA常用快捷键"></a>IDEA常用快捷键</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td><code>Alt+Enter</code></td><td>导入包，自动修正代码</td></tr><tr><td><code>Ctrl+Y</code></td><td>删除光标所在行</td></tr><tr><td><code>Ctrl+D</code></td><td>复制光标所在行的内容，插入光标位置下面</td></tr><tr><td><code>Ctrl+Alt+L</code></td><td>格式化代码</td></tr><tr><td><code>Ctrl+/</code></td><td>单行注释</td></tr><tr><td><code>Ctrl+Shift+/</code></td><td>选中代码注释，多行注释，再按取消注释</td></tr><tr><td><code>Alt+Ins</code></td><td>自动生成代码，toString，get，set等方法</td></tr><tr><td><code>Alt+Shift+上下箭头</code></td><td>移动当前代码行</td></tr></tbody></table><h2 id="IDEA修改快捷键"><a href="#IDEA修改快捷键" class="headerlink" title="IDEA修改快捷键"></a>IDEA修改快捷键</h2><p>在IDEA工具中，<code>ctrl+空格</code>的快捷键，可以帮助我们补全代码，但是这个快捷键和Windows中的输入法切换快捷键冲突，需要修改IDEA中的快捷键。</p><p><code>File-&gt;Settings-&gt;keymap-&gt;Main menu-&gt;code-&gt;Completion-&gt;Basic</code></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402173148296.png" alt="image-20200402173148296"></p><p>双击<code>Basic-&gt;remove-&gt;Ctrl+空格</code></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402173230646.png" alt="image-20200402173230646"></p><p>再双击<code>Basic-&gt;Add Keyboard-&gt;输入 Alt+/-&gt;点击OK</code></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402173336235.png" alt="image-20200402173336235"></p><h2 id="IDEA导入和关闭项目"><a href="#IDEA导入和关闭项目" class="headerlink" title="IDEA导入和关闭项目"></a>IDEA导入和关闭项目</h2><p>关闭IDEA中已经存在的项目，<code>File-&gt;Close Project</code></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402173432324.png" alt="image-20200402173432324"></p><p><code>File-&gt;Close Project</code>这时IDEA回到了刚启动界面，点击项目上的<code>x</code>，IDEA中就没有这个项目了</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402173507196.png" alt="image-20200402173507196"></p><p>在IDEA启界面上，点击<code>OPEN</code>，选择项目目录即可</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/0d714c49bb0b/image-20200402173526958.png" alt="image-20200402173526958"></p><blockquote><p>若想通过IDEA同时开多个项目，点击OPEN打开项目时，点击New Window按钮</p></blockquote><p>![image-20200402173626718](14.开发工具Intellij IDEA/image-20200402173626718.png)</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环语句</title>
      <link href="/2871874be300.html"/>
      <url>/2871874be300.html</url>
      
        <content type="html"><![CDATA[<h2 id="循环概述"><a href="#循环概述" class="headerlink" title="循环概述"></a>循环概述</h2><p>循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复执行这个循环体时，需要在合适的时候把循环判断条件修改为<strong>false</strong>，从而结束循环，否则循环将一直执行下去，形成死循环。</p><p>循环结构的基本组成部分，一般可以分成四部分：</p><ul><li>初始化语句：在循环开始最初执行，而且只做唯一一次</li><li>条件判断：如果成立，则循环继续，如不不成立，则循环推出</li><li>循环体：重复要做的事情内容，若干行语句</li><li>步进语句：每次循环之后都要进行的扫尾工作，每次循环结束之后都要执行一次</li></ul><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><ul><li>for循环语句格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式① ; 布尔表达式② ; 步进表达式④)&#123;</span><br><span class="line">  循环体③;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopStatement</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span><span class="comment">/*初始化表达式*/</span>; i &lt; <span class="number">50</span><span class="comment">/*布尔表达式*/</span>; i++<span class="comment">/*步进表达式*/</span>) &#123;</span><br><span class="line">      <span class="comment">//循环体③</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(i); <span class="comment">//50</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for的流程图"><a href="#for的流程图" class="headerlink" title="for的流程图"></a>for的流程图</h4><ul><li>执行顺序：①②③④&gt;②③④&gt;②③④…直到②不满住为止</li><li>①负责完成循环变量初始化</li><li>②负责判断是否满足循环条件，不满足则跳出循环</li><li>③具体执行的语句</li><li>④循环后，循环条件所涉及变量的变化情况</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2871874be300/05-for%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="05-for循环的流程图"></p><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>while循环有一个标准格式，还有一个扩展格式</p><ul><li>标准格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件判断)&#123;</span><br><span class="line">  循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>扩展格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化表达式①</span><br><span class="line"><span class="keyword">while</span>(条件判断②)&#123;</span><br><span class="line">  循环体③;</span><br><span class="line">  步进表达式④;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopStatement</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 初始化表达式</span></span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">50</span><span class="comment">/*条件判断*/</span>)&#123;</span><br><span class="line"><span class="comment">//循环体③</span></span><br><span class="line">i++; <span class="comment">// 步进表达式</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(i); <span class="comment">//50</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="while的流程图"><a href="#while的流程图" class="headerlink" title="while的流程图"></a>while的流程图</h3><ul><li>执行顺序：①②③④&gt;②③④&gt;②③④…直到②不满住为止</li><li>①负责完成循环变量初始化</li><li>②负责判断是否满足循环条件，不满足则跳出循环</li><li>③具体执行的语句</li><li>④循环后，循环变量的变化情况</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2871874be300/06-while%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="06-while循环的流程图"></p><h2 id="do…while"><a href="#do…while" class="headerlink" title="do…while"></a>do…while</h2><p>do…while循环有一个标准格式，还有一个扩展格式</p><ul><li>标准格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  循环体;</span><br><span class="line">&#125; <span class="keyword">while</span> (条件判断);</span><br></pre></td></tr></table></figure><ul><li>扩展格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化表达式①</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  循环体③;</span><br><span class="line">  步进表达式④</span><br><span class="line">&#125; <span class="keyword">while</span> (布尔表达式②);</span><br></pre></td></tr></table></figure><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopStatement</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 初始化表达式</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="comment">//循环体</span></span><br><span class="line">i++; <span class="comment">// 步进表达式</span></span><br><span class="line">&#125;<span class="keyword">while</span>(i &lt; <span class="number">50</span><span class="comment">/*布尔表达式*/</span>);</span><br><span class="line">System.out.println(i); <span class="comment">//50</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="do…while的流程图"><a href="#do…while的流程图" class="headerlink" title="do…while的流程图"></a>do…while的流程图</h3><ul><li>执行顺序：①②③④&gt;②③④&gt;②③④…直到②不满住为止</li><li>①负责完成循环变量初始化</li><li>②负责判断是否满足循环条件，不满足则跳出循环</li><li>③具体执行的语句</li><li>④循环后，循环变量的变化情况</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2871874be300/image-20200402161047519.png" alt="image-20200402161047519"></p><h2 id="循环语句的区别"><a href="#循环语句的区别" class="headerlink" title="循环语句的区别"></a>循环语句的区别</h2><ul><li><strong>for</strong>和<strong>while</strong>的小区别：<ul><li>控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消失，能够提高内存的使用效率</li><li>如果条件判断从来没有满足过，那么for循环和while循环将会执行0次，但是do…while循环会执行至少一次</li><li>在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while</li></ul></li></ul><h2 id="跳出语句"><a href="#跳出语句" class="headerlink" title="跳出语句"></a>跳出语句</h2><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>常用的两种：</p><ol><li>可以用在switch语句当中，一旦执行，整个switch语句立刻结束</li><li>还可以用在循环语句当中，一旦执行，整个循环语句立刻结束，打断循环</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopStatement</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><ul><li>一旦执行，立刻跳过当次循环剩余内容，马上开始下次循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopStatement</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环拓展"><a href="#循环拓展" class="headerlink" title="循环拓展"></a>循环拓展</h2><h3 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h3><ul><li>死循环：也就是循环中的条件永远为true，死循环的是永不结束的循环。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在后期的开发中，会出现使用死循环的场景，例如：我们需要读取用户输入的输入，但是用户输入多少数据我们不清楚，也只能使用死循环，当用户不想输入数据了，就可以结束循环了，如何去结束一个死循环呢，就需要使用到跳出语句了。</p><h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><p>所谓嵌套循环，是指一个循环的循环体是另一个循环。比如for循环里面还有一个for循环，就是嵌套循环。总共的循环次数=外循环次数*内循环次数</p><ul><li>格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式① ; 循环条件② ; 步进表达式⑦)&#123;</span><br><span class="line"> <span class="keyword">for</span>(初始化表达式③ ; 循环条件④ ; 步进表达式⑥)&#123;</span><br><span class="line">    执行语句⑤;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopStatement</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;<span class="number">10</span>; j++) &#123;</span><br><span class="line">System.out.println(i+<span class="string">&quot;------&gt;&quot;</span>+j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="嵌套循环执行流程"><a href="#嵌套循环执行流程" class="headerlink" title="嵌套循环执行流程"></a>嵌套循环执行流程</h4><ul><li>执行流程：①②③④⑤⑥&gt;④⑤⑥&gt;⑦②③④⑤⑥&gt;④⑤⑥</li><li>外循环一次，内循环多次</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>添加Abbrlink后图片无法显示</title>
      <link href="/7c8516486039.html"/>
      <url>/7c8516486039.html</url>
      
        <content type="html"><![CDATA[<p>在以前安装了<a href="https://github.com/7ym0n/hexo-asset-image.git">hexo-asset-image</a>,在创建新的md时会在,同级目录下创建名称相同的文件夹,用来存放图片.</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>但添加abbrlink后图片地址就发生了错误无法正确的找到图片的地址</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>我的基础设置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">new_post_name:</span> <span class="string">:year/:title.md</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:abbrlink/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用修改过的hexo-asset-image</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/isGuard/hexo-asset-image --save</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对Hexo博客静态资源进行压缩</title>
      <link href="/ed9a6f7913bc.html"/>
      <url>/ed9a6f7913bc.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装gulp相关依赖"><a href="#安装gulp相关依赖" class="headerlink" title="安装gulp相关依赖"></a>安装gulp相关依赖</h2><p>首先将 <code>gulp</code> 安装到全局中，否则无法使用，百度到的各种博客文章，就没有人说过这个问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp -g</span><br><span class="line"></span><br><span class="line">npm install gulp --save</span><br><span class="line">npm install gulp-imagemin --save</span><br><span class="line">npm install gulp-minify-css --save</span><br><span class="line">npm install gulp-minify-html --save</span><br><span class="line">npm install gulp-uglify --save</span><br><span class="line">npm install gulp-babel --save</span><br><span class="line">npm install babel-core --save</span><br><span class="line">npm install babel-loader --save </span><br><span class="line">npm install babel-preset-es2015 --save</span><br><span class="line">npm install imagemin-pngquant --save</span><br><span class="line">npm install gulp-cache --save</span><br></pre></td></tr></table></figure><p>注意:<br>babel-loader (7.15)、babel-core(6.xx)和gulp-bael(7.0x)的版本</p><h2 id="创建-gulpfile-js"><a href="#创建-gulpfile-js" class="headerlink" title="创建 gulpfile.js"></a>创建 gulpfile.js</h2><p>在 <code>Hexo</code> 博客的根目录下面，创建一个 <code>gulpfile.js</code> 文件，这个名字不可改，必须是这个名字。<br>在刚创建的文件中写入如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Plugins模块获取</span></span><br><span class="line"><span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">&#x27;gulp-minify-css&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">&#x27;gulp-uglify&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> minifyhtml = <span class="built_in">require</span>(<span class="string">&#x27;gulp-minify-html&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> imagemin = <span class="built_in">require</span>(<span class="string">&#x27;gulp-imagemin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩 public 目录 css文件</span></span><br><span class="line">gulp.task(<span class="string">&#x27;minify-css&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./public/**/*.css&#x27;</span>)</span><br><span class="line">        .pipe(minifycss())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩 public/js 目录 js文件</span></span><br><span class="line">gulp.task(<span class="string">&#x27;minify-js&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./public/**/*.js&#x27;</span>)</span><br><span class="line">    .pipe(<span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Plugins模块获取</span></span><br><span class="line"><span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">&#x27;gulp-minify-css&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">&#x27;gulp-uglify&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> minifyhtml = <span class="built_in">require</span>(<span class="string">&#x27;gulp-minify-html&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> imagemin = <span class="built_in">require</span>(<span class="string">&#x27;gulp-imagemin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">&#x27;gulp-babel&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pngquant = <span class="built_in">require</span>(<span class="string">&#x27;imagemin-pngquant&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> cache = <span class="built_in">require</span>(<span class="string">&#x27;gulp-cache&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩 public 目录 css文件</span></span><br><span class="line">gulp.task(<span class="string">&#x27;minify-css&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./public/**/*.css&#x27;</span>)</span><br><span class="line">        .pipe(minifycss())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩 public 目录 html文件</span></span><br><span class="line">gulp.task(<span class="string">&#x27;minify-html&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./public/**/*.html&#x27;</span>)</span><br><span class="line">        .pipe(minifyhtml())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">&#x27;./public&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩 public/js 目录 js文件</span></span><br><span class="line">gulp.task(<span class="string">&#x27;minify-js&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./public/**/*.js&#x27;</span>)</span><br><span class="line">        .pipe(babel(</span><br><span class="line">        &#123;<span class="attr">presets</span>: [<span class="string">&#x27;es2015&#x27;</span>]&#125;</span><br><span class="line">        ))</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩public/posts 目录 图片文件</span></span><br><span class="line">gulp.task(<span class="string">&#x27;minify-img&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./public/**/**/*.*&#x27;</span>)</span><br><span class="line">        .pipe(cache(imagemin(&#123;                     <span class="comment">//启用缓存，只压缩发生变化的图片</span></span><br><span class="line">            <span class="attr">progressive</span>: <span class="literal">true</span>,                     <span class="comment">//是否无损压缩jpg图片</span></span><br><span class="line">            <span class="attr">interlaced</span>: <span class="literal">false</span>,                     <span class="comment">//是否隔行扫描gif进行渲染</span></span><br><span class="line">            <span class="attr">svgoPlugins</span>: [&#123;<span class="attr">removeViewBox</span>: <span class="literal">false</span>&#125;], <span class="comment">//是否移除svg的viewbox属性</span></span><br><span class="line">            <span class="attr">multipass</span>: <span class="literal">false</span>,                      <span class="comment">//是否多次优化svg直到完全优化</span></span><br><span class="line">            <span class="attr">optimizationLevel</span>: <span class="number">5</span>,                  <span class="comment">//优化等级，取值范围：0-7，默认值：3</span></span><br><span class="line">            <span class="attr">use</span>: [pngquant()]                      <span class="comment">//使用pngquant深度压缩png图片的imagemin插件</span></span><br><span class="line">        &#125;)))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">&#x27;./public&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别执行css、heml、js和图片的压缩任务</span></span><br><span class="line">gulp.task(<span class="string">&#x27;build&#x27;</span>, gulp.series(<span class="string">&#x27;minify-css&#x27;</span>, <span class="string">&#x27;minify-html&#x27;</span>, <span class="string">&#x27;minify-js&#x27;</span>, <span class="string">&#x27;minify-img&#x27;</span>));</span><br><span class="line">babel(</span><br><span class="line">    &#123;<span class="attr">presets</span>: [<span class="string">&#x27;es2015&#x27;</span>]&#125;</span><br><span class="line">    ))</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩 public 目录 html文件</span></span><br><span class="line">gulp.task(<span class="string">&#x27;minify-html&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./public/**/*.html&#x27;</span>)</span><br><span class="line">        .pipe(minifyhtml())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">&#x27;./public&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩public/posts 目录 图片文件</span></span><br><span class="line">gulp.task(<span class="string">&#x27;minify-img&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./public/**/**/*.*&#x27;</span>)</span><br><span class="line">        .pipe(imagemin(</span><br><span class="line">            [</span><br><span class="line">                imagemin.gifsicle(&#123;</span><br><span class="line">                    <span class="string">&#x27;optimizationLevel&#x27;</span>: <span class="number">3</span></span><br><span class="line">                &#125;),</span><br><span class="line">                imagemin.jpegtran(&#123;</span><br><span class="line">                    <span class="string">&#x27;progressive&#x27;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;),</span><br><span class="line">                imagemin.optipng(&#123;</span><br><span class="line">                    <span class="string">&#x27;optimizationLevel&#x27;</span>: <span class="number">7</span></span><br><span class="line">                &#125;),</span><br><span class="line">                imagemin.svgo()</span><br><span class="line">            ], &#123;</span><br><span class="line">                <span class="string">&#x27;verbose&#x27;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">&#x27;./public&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别执行css、heml、js和图片的压缩任务</span></span><br><span class="line">gulp.task(<span class="string">&#x27;build&#x27;</span>, gulp.series(<span class="string">&#x27;minify-css&#x27;</span>, <span class="string">&#x27;minify-html&#x27;</span>, <span class="string">&#x27;minify-js&#x27;</span>, <span class="string">&#x27;minify-img&#x27;</span>));</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>以上代码是运行在 <code>gulp4</code> 环境的，与 <code>gulp3</code> 不通用</li><li>图片压缩速度很慢，若不需要压缩图片，请将第52行的代码中的 <code>&#39;minify-img&#39;</code> 删除，忽略其它文件压缩同理。<h2 id="对代码进行压缩"><a href="#对代码进行压缩" class="headerlink" title="对代码进行压缩"></a>对代码进行压缩</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">gulp build</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>先清空文件，生成静态文件，然后使用 <code>gulp</code> 命令对代码进行压缩，最后将其推送到服务器就行了</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择语句</title>
      <link href="/e460c106f773.html"/>
      <url>/e460c106f773.html</url>
      
        <content type="html"><![CDATA[<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><ul><li><strong>switch语句格式</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">  <span class="keyword">case</span> 常量值<span class="number">1</span>:</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 常量值<span class="number">2</span>:</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    语句体n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectAStatement</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(num)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;星期二&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;星期三&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;星期四&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;星期五&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;星期六&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;星期日&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;数据有误&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="switch的流程图"><a href="#switch的流程图" class="headerlink" title="switch的流程图"></a>switch的流程图</h3><ul><li>首先计算出表达式的值</li><li>其次和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到<strong>break</strong>就会结束</li><li>最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e460c106f773/image-20200402150825436.png" alt="image-20200402150825436"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>多个case后面的数值不可以重复</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectAStatement</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(num)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">// 错误: case 标签重复</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>switch后面小括号当中只能是下列数据类型<ul><li>基本数据类型：byte/short/char/int</li><li>引用数据类型：String（jdk1.7以后支持）、enum枚举</li></ul></li><li>switch语句格式可以很灵活：前后顺序可以颠倒，而且break语句还可以省略<ul><li>但是case的后面的break不写，会出现穿透现象，也就是不会再判断下一个case的值，直接向后运行，直到遇到break或者整体switch结束</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectAStatement</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(num)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;输出1&quot;</span>);</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:  </span><br><span class="line">System.out.println(<span class="string">&quot;输出2&quot;</span>);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;输出default&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出1</span></span><br><span class="line"><span class="comment">// 输出2</span></span><br><span class="line"><span class="comment">// 输出default</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断语句</title>
      <link href="/b44c36a2cabb.html"/>
      <url>/b44c36a2cabb.html</url>
      
        <content type="html"><![CDATA[<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><ul><li><strong>if语句的第一种格式</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)&#123;</span><br><span class="line"> 语句体; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JudgmentStatementIf</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">10</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a等于10&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( a == <span class="number">20</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a等于20&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 只显示了:a等于10</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="if的流程图"><a href="#if的流程图" class="headerlink" title="if的流程图"></a>if的流程图</h3><ul><li>首先判断关系表达式看其结果是true还是false</li><li>如果是rue就执行语句体</li><li>如果是false就不执行语句体</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/b44c36a2cabb/02-%E5%8D%95if%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="02-单if语句的流程图"></p><h2 id="if…else"><a href="#if…else" class="headerlink" title="if…else"></a>if…else</h2><ul><li><strong>if语句第二种格式</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)&#123;</span><br><span class="line">语句体<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JudgmentStatementIf</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">10</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a等于10&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a不等于10&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="if…else的流程图"><a href="#if…else的流程图" class="headerlink" title="if…else的流程图"></a>if…else的流程图</h3><ul><li>首先判断关系表达式看其结果的true还是false</li><li>如果true就执行语句体1</li><li>如果false就执行语句体2</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/b44c36a2cabb/03-%E6%A0%87%E5%87%86if-else%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="03-标准if-else语句的流程图"></p><h2 id="if…else-if…else"><a href="#if…else-if…else" class="headerlink" title="if…else if…else"></a>if…else if…else</h2><ul><li><strong>if语句第三种格式</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (判断条件<span class="number">1</span>)&#123;</span><br><span class="line">执行语句<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(判断条件<span class="number">2</span>)&#123;</span><br><span class="line">执行语句<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(判断条件n)&#123;</span><br><span class="line">执行语句n;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">  执行语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JudgmentStatementIf</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">10</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a等于10&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">20</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a等于20&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a不等于10也不等于20&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="if…else-if…else的流程图"><a href="#if…else-if…else的流程图" class="headerlink" title="if…else if…else的流程图"></a>if…else if…else的流程图</h3><ul><li>首先判断关系表达式1看其结果是true还是false</li><li>如果是true就执行语句体1</li><li>如果是false就继续判断关系表达式2看其结果是true还是false</li><li>如果是true就执行语句体2</li><li>如果是false就继续判断关系表达式看其结果是true还是false</li><li>…</li><li>如果没有任何关系表达式为true，就执行语句体n+1</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/b44c36a2cabb/04-%E6%89%A9%E5%B1%95if-else%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="04-扩展if-else语句的流程图"></p><h2 id="if语句和三元运算符的互换"><a href="#if语句和三元运算符的互换" class="headerlink" title="if语句和三元运算符的互换"></a>if语句和三元运算符的互换</h2><p>在某些简单的应用中,if语句是可以和三元运算符互换使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 比较两个值的大小</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">30</span>;</span><br><span class="line">  <span class="comment">// 保存a和b的较大值</span></span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line">  <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">    c = a;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    c = b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//三元运算符</span></span><br><span class="line">  c = a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序结构</title>
      <link href="/8f0902f5fa56.html"/>
      <url>/8f0902f5fa56.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在一个程序执行的过程中，各象语句的执行顺序对程序的结果是有直接影响的，也就是说，程序的流程对运行结果有直接的影响。所以，我们必须清楚每条语句的执行流程。而且，很多时候我们要通过控制语句的执行顺序来实现我们要完成的功能。</p><h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><p>顺序执行,根据编写的顺序,从上到下运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//顺序执行,根据编写的顺序,从上到下运行</span></span><br><span class="line">    System.out.print(<span class="string">&quot;先&quot;</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;中&quot;</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;后&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序结构的流程图"><a href="#顺序结构的流程图" class="headerlink" title="顺序结构的流程图"></a>顺序结构的流程图</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/8f0902f5fa56/01-%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="01-顺序结构的流程图"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JShell脚本工具</title>
      <link href="/3a4ba11b7a5e.html"/>
      <url>/3a4ba11b7a5e.html</url>
      
        <content type="html"><![CDATA[<h1 id="JShell脚本工具"><a href="#JShell脚本工具" class="headerlink" title="JShell脚本工具"></a>JShell脚本工具</h1><p>JShell脚本工具是JDK9的新特性</p><p>从java9开始，java开始引入了类似于python的交互式 REPL（Read-Eval-Print Loop，读取-求值-输出 循环）工具。官方的表述如下：</p><blockquote><p>The Java Shell tool (JShell) is an interactive tool for learning the Java programming language and prototyping Java code. JShell is a Read-Evaluate-Print Loop (REPL), which evaluates declarations, statements, and expressions as they are entered and immediately shows the results. The tool is run from the command line.</p></blockquote><p>简而言之，使用 JShell，你可以输入代码片段并马上看到运行结果，然后就可以根据需要作出调整。官方的表述如下：</p><blockquote><p>JShell helps you try out code and easily explore options as you develop your program. You can test individual statements, try out different variations of a method, and experiment with unfamiliar APIs within the JShell session. JShell doesn’t replace an IDE. As you develop your program, paste code into JShell to try it out, and then paste working code from JShell into your program editor or IDE.</p></blockquote><p>什么时候会用到<code>JShell</code>工具呢，当我们编写的代码非常少的时候，而又不愿意编写类，main方法，也不愿意去编译和运行，这个时候可以使用Shell工具。</p><p>启动Shell工具，在DOS命令行直接输入JShell命令。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/3a4ba11b7a5e/image-20200401173052296.png" alt="image-20200401173052296"></p><p>接下来可以编写Java代码，无需写类和方法，直接写方法中的代码即可，同时无需编译和运行，直接回车即可</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/3a4ba11b7a5e/image-20200401173119744.png" alt="image-20200401173119744"></p><p>当然我门也可以在JShell里定义函数方法</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/3a4ba11b7a5e/2726392-c425eceb3af74ae9.webp" alt="img"></p><p>这样我们就创建了一个方法。接下来使用我们的方法。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/3a4ba11b7a5e/2726392-d0942ddba42c8889.webp" alt="img"></p><p>那么从上面的这些例子我们可以看出，Jshell是可以执行我们的任何代码片段。但有个问题，就是加入我声明多个函数之后，我忘了那个是哪个，怎么办呢？所以我们需要学习Jshell提供给我们的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; /<span class="built_in">help</span></span><br><span class="line">|  键入 Java 语言表达式, 语句或声明。</span><br><span class="line">|  或者键入以下命令之一:</span><br><span class="line">|  /list [&lt;名称或 id&gt;|-all|-start]</span><br><span class="line">|       列出您键入的源</span><br><span class="line">|  /edit &lt;名称或 id&gt;</span><br><span class="line">|       编辑源条目</span><br><span class="line">|  /drop &lt;名称或 id&gt;</span><br><span class="line">|       删除源条目</span><br><span class="line">|  /save [-all|-<span class="built_in">history</span>|-start] &lt;文件&gt;</span><br><span class="line">|       将片段源保存到文件</span><br><span class="line">|  /open &lt;file&gt;</span><br><span class="line">|       打开文件作为源输入</span><br><span class="line">|  /vars [&lt;名称或 id&gt;|-all|-start]</span><br><span class="line">|       列出已声明变量及其值</span><br><span class="line">|  /methods [&lt;名称或 id&gt;|-all|-start]</span><br><span class="line">|       列出已声明方法及其签名</span><br><span class="line">|  /types [&lt;名称或 id&gt;|-all|-start]</span><br><span class="line">|       列出类型声明</span><br><span class="line">|  /imports</span><br><span class="line">|       列出导入的项</span><br><span class="line">|  /<span class="built_in">exit</span> [&lt;integer-expression-snippet&gt;]</span><br><span class="line">|       退出 jshell 工具</span><br><span class="line">|  /env [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;] [-add-modules &lt;模块&gt;] ...</span><br><span class="line">|       查看或更改评估上下文</span><br><span class="line">|  /reset [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;] [-add-modules &lt;模块&gt;]...</span><br><span class="line">|       重置 jshell 工具</span><br><span class="line">|  /reload [-restore] [-quiet] [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;]...</span><br><span class="line">|       重置和重放相关历史记录 -- 当前历史记录或上一个历史记录 (-restore)</span><br><span class="line">|  /<span class="built_in">history</span></span><br><span class="line">|       您键入的内容的历史记录</span><br><span class="line">|  /<span class="built_in">help</span> [&lt;<span class="built_in">command</span>&gt;|&lt;subject&gt;]</span><br><span class="line">|       获取有关使用 jshell 工具的信息</span><br><span class="line">|  /<span class="built_in">set</span> editor|start|feedback|mode|prompt|truncation|format ...</span><br><span class="line">|       设置配置信息</span><br><span class="line">|  /? [&lt;<span class="built_in">command</span>&gt;|&lt;subject&gt;]</span><br><span class="line">|       获取有关使用 jshell 工具的信息</span><br><span class="line">|  /!</span><br><span class="line">|       重新运行上一个片段 -- 请参阅 /<span class="built_in">help</span> rerun</span><br><span class="line">|  /&lt;id&gt;</span><br><span class="line">|       按 ID 或 ID 范围重新运行片段 -- 参见 /<span class="built_in">help</span> rerun</span><br><span class="line">|  /-&lt;n&gt;</span><br><span class="line">|       重新运行以前的第 n 个片段 -- 请参阅 /<span class="built_in">help</span> rerun</span><br><span class="line">|</span><br><span class="line">|  有关详细信息, 请键入 <span class="string">&#x27;/help&#x27;</span>, 后跟</span><br><span class="line">|  命令或主题的名称。</span><br><span class="line">|  例如 <span class="string">&#x27;/help /list&#x27;</span> 或 <span class="string">&#x27;/help intro&#x27;</span>。主题:</span><br><span class="line">|</span><br><span class="line">|  intro</span><br><span class="line">|       jshell 工具的简介</span><br><span class="line">|  id</span><br><span class="line">|       片段 ID 以及如何使用它们的说明</span><br><span class="line">|  shortcuts</span><br><span class="line">|       片段和命令输入提示, 信息访问以及</span><br><span class="line">|       自动代码生成的按键说明</span><br><span class="line">|  context</span><br><span class="line">|       /env /reload 和 /reset 的评估上下文选项的说明</span><br><span class="line">|  rerun</span><br><span class="line">|       重新评估以前输入片段的方法的说明</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法入门</title>
      <link href="/c6e327594862.html"/>
      <url>/c6e327594862.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们在学习运算符的时候，都为每个运算符单独的创建一个新的类和main方法，我们会发现这样编写代码非常的繁琐，而且重复的代码过多，能否避免这些重复的代码呢，就需要使用方法来实现。</p><ul><li><strong>方法</strong>：就是将一个<strong>功能</strong>抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。</li></ul><p>当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。</p><h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><ul><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名 (参数列表) &#123;</span><br><span class="line">  代码...</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>格式结束：</p><ul><li>修饰符：目前固定格式<code>public static</code></li><li>返回值类型：目前固定写发<code>void</code></li><li>方法名：给定义的方法起一个名称，满足标识符规范，<strong>强烈推荐小驼峰</strong></li><li>参数列表：目前无参数</li><li><strong>return</strong>：方法结束。返回值类型为<strong>void</strong>时，方法体中的<strong>return</strong>可以不写</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewMethod</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> viod <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> staitc <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法在定义完毕后，方法不会自己运行，必须被调用才能执行，我们可以在主方法main中来调用我们自己定义好的方法。在主方法中，直接写要调用的方法名字就可以调用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewMethod</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> viod <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//调用test方法</span></span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> staitc <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><ul><li>方法定义注意事项：<ul><li>方法必须定义在一类中方法外</li><li>方法不能定义在另一个方法的里面</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/85bb8468cbb1.html"/>
      <url>/85bb8468cbb1.html</url>
      
        <content type="html"><![CDATA[<h3 id="常用Maven命令"><a href="#常用Maven命令" class="headerlink" title="常用Maven命令"></a>常用Maven命令</h3><p>执行与构建过程相关的命令，必须进入pom.xml所在的目录。</p><p>与构建过程相关的：编译、测试、打包…</p><ol><li>mvn clean：清理</li><li>mvn compile：编译主程序</li><li>mvn test-compile：编译测试程序</li><li>mvn test：执行测试</li><li>mvn package：打包</li><li>mvn install：安装进入仓库</li><li>mvn site：生成站点</li></ol><h3 id="联网问题"><a href="#联网问题" class="headerlink" title="联网问题"></a>联网问题</h3><ol><li><p>Maven的核心程序中仅仅定义了抽象的生命周期，但是具体的工作必须由特定的插件来完成。而插件本身并不包含再Maven的核心程序中。</p></li><li><p>当我们执行的Maven命令需要用到某些插件时，Maven核心程序首先到本地仓库中查找。</p></li><li><p>本地仓库的默认位置：[系统中当前用户的目录]\.m2\repository</p></li><li><p>Maven核心程序如果再本地仓库找不到需要的插件，那么它会自动链接外网，到中央仓库下载。</p></li><li><p>如果此时无法联网，则构建失败。</p></li><li><p>修改默认本地仓库的位置可以让Maven核心程序到我们事先准备好的目录下查找插件</p><ol><li>找到Maven文件下的\conf\settings.xml</li><li>找到标签<code>localRepository</code></li><li>将标签<code>localRepository</code>从注释中取出</li><li>定义当自定义的目录如：<code>&lt;localRepository&gt;E:\maven\maven-repository&lt;/localRepository&gt;</code></li></ol></li><li><p>设置阿里Maven仓库</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">      http://maven.aliyun.com/nexus/content/groups/public/</span><br><span class="line">  <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h3><ol><li><p>含义：Project Object Model 项目对象模型</p><p>​            DOM Document Object Model 文档对象模型</p></li><li><p>pom.xml对于Maven工程是核心配置文件，与构建过程相关的一切设置都在这个文件中进行配置。重要程度相当于web.xml对于动态Web工程</p></li></ol><h3 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h3><p>Maven的坐标</p><ol><li>groupid：公司或组织域名倒序+项目名称</li><li>artifactid：模块名</li><li>version：版本</li></ol><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><ol><li><p>仓库的分类</p><ol><li>本地仓库：当前电脑上部署的仓库目录，当前电脑上所有Maven工程服务</li><li>远程仓库<ol><li>私服：搭建再局域网环境中，为局域网范围内的所有Maven工程服务（Nexus）</li><li>中央仓库：架设再Internet上，为全世界所有Maven工程</li><li>中央仓库的镜像：为了分担中央仓库的流量，提升用户访问速度</li></ol></li></ol></li><li><p>仓库中保存的内容：Maven工程</p><ol><li>Maven自身所需要的插件</li><li>第三方框架或工具的jar包</li><li>我们自己开发的Maven工程</li></ol></li></ol><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><ol><li><p>Maven解析依赖信息时会到本地仓库中查找被依赖的jar包</p></li><li><p>对于我们自己开发的Maven工程，使用install命令安装后就可以进入仓库</p></li><li><p>依赖的范围</p><ol><li>compile<ol><li>对主程序是否有效：有效</li><li>对测试程序是否有效：有效</li><li>是否参与打包：参与</li></ol></li><li>test<ol><li>对主程序是否有效：无效</li><li>对测试程序是否有效：有效</li><li>是否参与打包：不参与</li><li>典型例子：junit.jar</li></ol></li><li>provided<ol><li>对主程序是否有效：有效</li><li>对测试程序是否有效：有效</li><li>是否参与打包：不参与</li><li>是否参与部署：不参与</li><li>典型例子：servlet-api.jar</li></ol></li></ol></li><li><p>依赖的传递性</p><ol><li>在父工程依赖一次既可重复使用</li><li>注意：非complie范围的不能传递。所以在各个工程模块中，重复声明</li></ol></li><li><p>依赖的排除</p><ol><li><p>在不需要j一些ar包或jar包重复时，则要排除一部分jar包</p></li><li><p>排除设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">gourpId</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">gourpId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxxxxx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>依赖原则</p><ol><li>作用：解决模块工程之间的jar包冲突问题</li><li>Maven默认解决方案：路径最短者优先</li><li>Maven默认解决方案：先声明者有限(dependency先后)</li></ol></li><li><p>统一管理依赖的版本</p><ol><li>使用properties标签使用自定义标签统一声明版本号</li><li>在需要的地方使用${自定义标签}引用声明的版本号</li><li>其实properties标签配合自定义标签声明数据的配置并不只能用于声明依赖的版本号，凡是需要统一声明后再引用的声明都能使用。如：字符集、声明…</li></ol></li></ol></li></ol><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol><li><p>各个构建环境执行的顺序：不能打乱顺序，必须按照指定的正确顺序来执行。</p></li><li><p>Maven的核心程序中定义了抽象的生命周期，生命周期中各个阶段的具体任务时由插件来完成的。</p></li><li><p>Maven有三条相互独立的生命周期：</p><ol><li>Clean Lifecycle在进行真正的构建之前进行一些清理工作。</li><li>Default Lifecycle在构建核心部分，编译，测试，打包，安装，部署等等。</li><li>Site Lifecycle生成项目报告，站点，发布站点。</li></ol></li><li><p>Maven核心程序为了更好的实现自动化构建，按照这一特点执行生命周期中的各个阶段：不论现在执行生命周期的哪一个阶段，都是从这个生命周期最初的位置开始执行。</p></li></ol><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ol><li><p>统一管理各个模块工程中的test范围的依赖的版本</p></li><li><p>将test的依赖统一提取到父工程中，在子工程中声明的依赖时不指定版本，以工程中统一设定的为准，同时也便于修改</p></li><li><p>操作步骤</p><ol><li><p>创建一个Maven工程为父工程。注意：打包方式为pom</p><p><code>&lt;packaging&gt;pom&lt;/packaging&gt;</code></p></li><li><p>在子工程中声明对父工程的引用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子工程中声明父工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ren.guard.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 以当前文件为基准的父工程pom.xml文件的相对路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../Parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>将子工程的坐标中与父工程坐标中重复的内容删除</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ren.guard.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="comment">&lt;!-- 删除 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="comment">&lt;!-- 删除 --&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在父工程中统一管理test依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在子工程中删除test依赖的版本号部分</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在配置继承后，执行安装命令时要先安装父工程</p></li></ol></li></ol><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><ol><li><p>作用：一键安装各个模块工程</p></li><li><p>配置方式：在一个“总的聚合工程”中配置各个参与聚合的模块</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定各个子工程的相对路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>jpa_settings<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>log4j_settings<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>logger_settings<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用方式：在聚合工程的pom.xml上点击maven install</p></li></ol><h3 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置当工程构建过程中的特殊设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目最后的名称 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">finalName</span>&gt;</span>mavenWeb<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置构建过程中需要使用的插件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- cargo是一家专门从事“启动Servlet容器”的组织 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.cargo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cargo-maven2-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 针对插件进行的配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 配置当前系统中容器的位置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">container</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">containerId</span>&gt;</span>tomcat8x<span class="tag">&lt;/<span class="name">containerId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">home</span>&gt;</span>D:\xxxx\xxxxx<span class="tag">&lt;/<span class="name">home</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>existing<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">home</span>&gt;</span>D:\xxxx\xxxxx<span class="tag">&lt;/<span class="name">home</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 如果Tomcat端口为默认值8080则不必设置该属性 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">cargo.servlet.port</span>&gt;</span>8989<span class="tag">&lt;/<span class="name">cargo.servlet.port</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">&lt;!-- 配置插件在什么情况下执行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>cargo-run<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 生命周期的阶段 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>install<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 插件的目标 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>mvn deploy</code></p><h3 id="依赖信息网址"><a href="#依赖信息网址" class="headerlink" title="依赖信息网址"></a>依赖信息网址</h3><p><a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符</title>
      <link href="/a66da301ed65.html"/>
      <url>/a66da301ed65.html</url>
      
        <content type="html"><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>运算符：进行特定操作的符号。如：+</p><p>表达式：用运算符连起来的式子。如：a + b</p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><table><thead><tr><th>算术运算符：</th><th></th></tr></thead><tbody><tr><td><code>+</code></td><td>加法运算，字符串连接运算</td></tr><tr><td><code>-</code></td><td>减法运算</td></tr><tr><td><code>*</code></td><td>乘法运算</td></tr><tr><td><code>/</code></td><td>除法运算</td></tr><tr><td><code>%</code></td><td>取模运算，两个数字相除取余数</td></tr><tr><td><code>++</code></td><td>自增运算</td></tr><tr><td><code>--</code></td><td>自减运算</td></tr></tbody></table><ul><li>两个常量之间可以进行数学运算</li><li>两个变量之家也可以进行数学运算</li><li>变量和常量之间可以混合运算</li><li>变量和常量之间可以混合使用</li><li>除法用的是整除，整数除以整数，结果也是整数，只看商，不看余数</li><li>取模运算:取的余数（只是对于整数的除法来说，取模运算符才有余数的意义）</li><li>一旦运算当中又不同类型的数据，那么结果将会是数据类型范围大的</li><li>对于<strong>char</strong>类型来说，在计算之前，<strong>char</strong>会被提升为<strong>int</strong>，然后再计算</li><li><strong>char</strong>类型字符和<strong>int</strong>类型数字之间的对照关系表：ASCII、Unicode</li><li>对于字符串String(首字母大写,并不是关键字)来说，<strong>加号代表字符串连接操作</strong><ul><li>字符串类型的变量基本使用</li><li>数据类型 变量名称 = 数据值;</li></ul></li><li>优先级：小括号优先一切</li><li>自增、自减运算符：++、–<ul><li>基本含义：让一个变量加一个1或者让一个变量减一个1</li><li>使用方法：<ul><li>单独使用：不和其他任何操作混合，自己独立成一个步骤</li><li>混合使用：和其他操作混合，例如与赋值混合或者打印操作混合，等</li></ul></li><li>使用区别：<ul><li>再单独使用的时候，**前++<strong>和后</strong>++**没有任何区别</li><li>再混合使用的时候<ul><li>如果是<strong>【前++】</strong>，那么变量<strong>【立刻加1】</strong>，然后拿着结果进行使用。<strong>【先加后用】</strong></li><li>如果是【后++】，那么首先使用变量本来的数值，<strong>【然后再让变量+1】</strong>。<strong>【先用后加】</strong></li></ul></li></ul></li></ul></li><li>注意事项：<ul><li>只有变量才能使用自增、自减运算符。常量不可发生改变，所以不能用。</li><li><strong>byte，short，char</strong>在运算的过程中会强制转换成<strong>int</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArithmeticOperators</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 两个常量之间可以进行数学运算</span></span><br><span class="line">System.out.println(<span class="number">10</span> + <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个变量之家也可以进行数学运算</span></span><br><span class="line">System.out.println(a - b); <span class="comment">// -10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量和常量之间可以混合运算</span></span><br><span class="line">System.out.println(a * b); <span class="comment">// 200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量和常量之间可以混合使用</span></span><br><span class="line"><span class="comment">// 除法用的是整除，整数除以整数，结果也是整数，只看商，不看余数</span></span><br><span class="line">System.out.println(a / <span class="number">20</span>); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取模运算:取的余数（只是对于整数的除法来说，取模运算符才有余数的意义）</span></span><br><span class="line">System.out.println(a % b); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一旦运算当中又不同类型的数据，那么结果将会是数据类型范围大的</span></span><br><span class="line"><span class="keyword">double</span> c = <span class="number">30.5</span>;</span><br><span class="line">System.out.println(b + c); <span class="comment">// 50.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于char类型来说，在计算之前，char会被提升为int，然后再计算</span></span><br><span class="line"><span class="comment">// char类型字符和int类型数字之间的对照关系表：ASCII、Unicode</span></span><br><span class="line"><span class="keyword">char</span> d = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">System.out.println(d + c); <span class="comment">//95.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于字符串String(首字母大写,并不是关键字)来说，加号代表字符串连接操作</span></span><br><span class="line"><span class="comment">// 字符串类型的变量基本使用</span></span><br><span class="line"><span class="comment">// 数据类型 变量名称 = 数据值;</span></span><br><span class="line">String e = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">System.out.println(e + <span class="number">10</span>); <span class="comment">//Hello10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//优先级：小括号优先一切</span></span><br><span class="line">System.out.println(e + <span class="number">10</span> + <span class="number">20</span>); <span class="comment">//Hello1020</span></span><br><span class="line">System.out.println(e + (<span class="number">10</span> + <span class="number">20</span>)); <span class="comment">//Hello30</span></span><br><span class="line">System.out.println(<span class="number">10</span> + <span class="number">20</span> + e); <span class="comment">//30Hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自增运算符：++</span></span><br><span class="line"><span class="comment">//自减运算符：--</span></span><br><span class="line"><span class="comment">//基本含义：让一个变量加一个1或者让一个变量减一个1</span></span><br><span class="line"><span class="comment">//使用方法：</span></span><br><span class="line"><span class="comment">//1. 单独使用：不和其他任何操作混合，自己独立成一个步骤</span></span><br><span class="line"><span class="comment">//2. 混合使用：和其他操作混合，例如与赋值混合或者打印操作混合，等</span></span><br><span class="line"><span class="comment">//使用区别：</span></span><br><span class="line"><span class="comment">//1. 再单独使用的时候，前++和后++没有任何区别</span></span><br><span class="line"><span class="comment">//2. 再混合使用的时候</span></span><br><span class="line"><span class="comment">//- 如果是【前++】，那么变量【立刻加1】，然后拿着结果进行使用。【先加后用】</span></span><br><span class="line"><span class="comment">//- 如果是【后++】，那么首先使用变量本来的数值，【然后再让变量+1】。【先用后加】</span></span><br><span class="line"><span class="comment">//注意事项：</span></span><br><span class="line"><span class="comment">//只有变量才能使用自增、自减运算符。常量不可发生改变，所以不能用。</span></span><br><span class="line"><span class="keyword">int</span> f = <span class="number">10</span>;</span><br><span class="line">f++;</span><br><span class="line">System.out.println(f); <span class="comment">// 11</span></span><br><span class="line">++f;</span><br><span class="line">System.out.println(f); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g = <span class="number">10</span>;</span><br><span class="line">System.out.println(g++); <span class="comment">// 10</span></span><br><span class="line">System.out.println(++g); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i = h--;</span><br><span class="line">System.out.println(i); <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">int</span> j = --h;</span><br><span class="line">System.out.println(j); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//30++; // 异常</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// byte，short，char在运算的过程中会强制转换成int</span></span><br><span class="line">    <span class="keyword">byte</span> k = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">byte</span> l = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//byte m = k + l; // 异常</span></span><br><span class="line">    <span class="keyword">int</span> n = k + i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table><thead><tr><th>赋值运算符：</th><th></th></tr></thead><tbody><tr><td><code>=</code></td><td>等于号</td></tr><tr><td><code>+=</code></td><td>加等于</td></tr><tr><td><code>-=</code></td><td>减等于</td></tr><tr><td><code>*=</code></td><td>乘等于</td></tr><tr><td><code>/=</code></td><td>除等于</td></tr><tr><td><code>%=</code></td><td>取模等</td></tr></tbody></table><ul><li><p>赋值运算符：就是将符号右边的值，赋给左边的变量。</p><ul><li>基本赋值运算符：就是一个等号”=”，代表将右侧的数据交给左侧的变量。<ul><li><code>int a = 30;</code></li></ul></li><li>复合赋值运算符：<ul><li><code>+=    a += 1    相当于    a = a + 1</code></li><li><code>-=    a -= 1    相当于    a = a - 1</code></li><li><code>*=    a *= 1    相当于    a = a * 1</code></li><li><code>/=    a /= 1    相当于    a = a / 1</code></li><li><code>%=    a %= 1    相当于    a = a % 1</code></li></ul></li></ul></li><li><p>注意事项：</p><ul><li>只有变量才能使用赋值运算符，常量不能进行赋值</li><li>复合赋值运算符其中隐含了一个强制类型转换</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssignmentOperator</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">a += <span class="number">3</span>;</span><br><span class="line">System.out.println(a); <span class="comment">// 13</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a -= <span class="number">3</span>;</span><br><span class="line">System.out.println(a); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a *= <span class="number">3</span>;</span><br><span class="line">System.out.println(a); <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a /= <span class="number">3</span>;</span><br><span class="line">System.out.println(a); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a %= <span class="number">3</span>;</span><br><span class="line">System.out.println(a); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">//强制类型转换</span></span><br><span class="line"><span class="keyword">byte</span> num = <span class="number">10</span>;</span><br><span class="line">num += <span class="number">5</span>;</span><br><span class="line"><span class="keyword">byte</span> num2 = num;</span><br><span class="line">System.out.println(num2); <span class="comment">// 15</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><table><thead><tr><th>比较运算符：</th><th></th></tr></thead><tbody><tr><td><code>==</code></td><td>比较符号两边数据是否相等，相等结果是true</td></tr><tr><td><code>&lt;</code></td><td>比较符号左边的数据是否小于右边的数据，如果小于结果为true</td></tr><tr><td><code>&gt;</code></td><td>比较符号左边的数据是否大于右边的数据，如果大于结果是true</td></tr><tr><td><code>&lt;=</code></td><td>比较符号左边的数据是否小于或者等于右边的数据，如果小于结果为true</td></tr><tr><td><code>&gt;=</code></td><td>比较符号左边的数据是否大于或者等于右边的数据，如果大于结果是true</td></tr><tr><td><code>!=</code></td><td>不等于服好，如果符号两边的数据不相等，结果为true</td></tr></tbody></table><ul><li>比较运算符，是两个数据之间进行比较的运算，运算结果都是布尔值<strong>true</strong>或者<strong>false</strong></li><li>两个常量之间可以进行比较运算</li><li>两个变量之家也可以进行比较运算</li><li>变量和常量之间可以比较运算</li><li>注意事项：<ul><li>不能连续使用，如果要连续使用，<strong>用逻辑运算符关联</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparisonOperators</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">System.out.println(<span class="number">2</span>==<span class="number">3</span>); <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="number">2</span>&lt;b); <span class="comment">// true</span></span><br><span class="line">System.out.println(a&gt;<span class="number">3</span>); <span class="comment">// false</span></span><br><span class="line">System.out.println(a&lt;=b); <span class="comment">// true</span></span><br><span class="line">System.out.println(a&gt;=<span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line">System.out.println(a!=b); <span class="comment">// true</span></span><br><span class="line"><span class="comment">//System.out.println(a&lt;b&lt;5);异常</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th>逻辑运算符：</th><th></th></tr></thead><tbody><tr><td><code>&amp;&amp;</code>与（短路）</td><td>两边都是true，结果为true<br> 一边为false，结果为false<br> 短路特点：符号左边是false，右边不再运算</td></tr><tr><td>`</td><td></td></tr><tr><td><code>!</code>非</td><td>!true结果是false<br> !false结果是true</td></tr></tbody></table><ul><li>逻辑运算符，是用来连接两个布尔类型结果的运算符，运算结果都是布尔值<strong>true</strong>或者<strong>false</strong></li><li>与<code>&amp;&amp;</code>，或<code>||</code>，具有短路效果：如果根据左边已经可以判断得到最终结果，那么右边的代码将不再执行，从而节省一定的性能。</li><li>注意事项：<ul><li>逻辑运算符只能用于boolean值</li><li>与、或需要左右各自有一个boolean值，但是取反只要有唯一的boolean值即可</li><li>与、或两种运算符，如果有多个条件，可以连续写</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogicalOperators</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">true</span> &amp;&amp; <span class="keyword">false</span>); <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="number">3</span>&lt;<span class="number">4</span> &amp;&amp; <span class="number">10</span>&gt;<span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">true</span> || <span class="keyword">false</span>); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="keyword">true</span> || <span class="keyword">true</span>); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="keyword">false</span> || <span class="keyword">false</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">System.out.println(!<span class="keyword">true</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">System.out.println(<span class="number">3</span>&gt;<span class="number">4</span> &amp;&amp; ++a&lt;<span class="number">100</span>); <span class="comment">// false</span></span><br><span class="line">System.out.println(a); <span class="comment">// 10</span></span><br><span class="line">System.out.println(<span class="number">4</span>&gt;<span class="number">3</span> || ++a&lt;<span class="number">100</span>); <span class="comment">// true</span></span><br><span class="line">System.out.println(a); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>一元运算符：只需要一个数据就可以进行操作的运算符。如：！、++、–</p><p>二元运算符：需要两个数据才可以进行进行操作的运算符。如：+、=</p><p>三元运算符：需要三个数据才可以进行进行操作的运算符。</p><p>格式：</p><ul><li><code>数据类型 变量名称 = 条件判断 ? 表达式A : 表达式B</code></li></ul><p>流程：</p><ul><li>先判断条件是否成立：</li><li>如果成立为true，那么将表达式A的值赋值给左侧的变量</li><li>如果不成立为false，那么将表达式B的值赋值给左侧的变量</li></ul><p>注意事项：</p><ul><li>必须同时保证表达式A和表达式B都符合左侧数据类型的要求</li><li>三元运算符的结果必须被使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreePartOperator</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> max = a &gt; b ? a : b;</span><br><span class="line">System.out.println(max);</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误写法</span></span><br><span class="line"><span class="comment">//int result = 3 &gt; 4 ? 2.5 : 10;</span></span><br><span class="line"><span class="comment">//a &gt; b ? a : b;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据类型转换</title>
      <link href="/ac93dc79a32b.html"/>
      <url>/ac93dc79a32b.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><p>Java程序中要求参与的计算的数据，必须要保证数据类型的一致性，如果数据类型不一致将发生类型的转换</p><h2 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h2><ol><li>自动转换：将<strong>取值范围小的类型</strong>自动提升为<strong>取值范围大的类型</strong></li><li>特点：代码不需要进行特殊处理，自动完成</li><li>规则：数据范围从小到大</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataConversion</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 自动类型转换</span></span><br><span class="line"><span class="comment">// 左边是long类型，右边是默认的int类型，左右类型不同</span></span><br><span class="line"><span class="comment">// 一个等号代表赋值，将右侧的int常量，交给左侧的long变量进行储存</span></span><br><span class="line"><span class="comment">// int --&gt; long，符合数据范围从小到大的要求</span></span><br><span class="line"><span class="comment">// 自动类型转换</span></span><br><span class="line"><span class="keyword">long</span> num1 = <span class="number">100</span>;</span><br><span class="line">System.out.println(num1); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 左边是double类型，右边是float类型，左右不一样</span></span><br><span class="line"><span class="comment">// float-&gt; double，符合从小到大的规则</span></span><br><span class="line"><span class="comment">// 自动类型转换</span></span><br><span class="line"><span class="keyword">double</span> num2 = <span class="number">2.5F</span>;</span><br><span class="line">System.out.println(num2); <span class="comment">// 2.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 左边是float类型，右边是long类型，左右不一样</span></span><br><span class="line"><span class="comment">// long--&gt; float，范围是float更大一些，符合从小到大的规则</span></span><br><span class="line"><span class="comment">// 自动类型转换</span></span><br><span class="line"><span class="keyword">float</span> num3 = <span class="number">30L</span>;</span><br><span class="line">System.out.println(num3); <span class="comment">// 30.0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h3><p>范围小的类型向范围大的类型提升，<strong>byte，short，char</strong>运算时直接提升为<strong>int</strong></p><p><code>byte, short, char--&gt;int--&gt;long--&gt;float--&gt;double</code></p><h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><ol><li>强制转换：将<strong>取值范围大的类型</strong>强制转换成<strong>取值范围小的类型</strong></li><li>特点：代码需要进行特殊的格式处理，不能自动完成</li><li>格式：<code>范围小的类型 范围小的变量名 = (范围小的类型) 原本范围大的数据;</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataConversion</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">// 强制类型转换</span></span><br><span class="line"><span class="comment">// 左边式int类型，右边式long类型，不一样</span></span><br><span class="line"><span class="comment">// long --&gt; int，不是从小到大</span></span><br><span class="line"><span class="comment">// 不能发生自动类型转换</span></span><br><span class="line"><span class="comment">// 强制类型转换</span></span><br><span class="line"><span class="keyword">int</span> num4 = (<span class="keyword">int</span>) <span class="number">100L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// long --&gt; int 超过int的最大值数据就会直接溢出，不会得到自己想要的值</span></span><br><span class="line"><span class="keyword">int</span> num5 = (<span class="keyword">int</span>) <span class="number">6000000000L</span>;</span><br><span class="line">System.out.println(num5); <span class="comment">// 1705032704</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// double --&gt; int 所有小数都会被舍去</span></span><br><span class="line"><span class="keyword">int</span> num6 = (<span class="keyword">int</span>) <span class="number">3.99</span>;</span><br><span class="line">System.out.println(num6); <span class="comment">// 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// int --&gt; byte 右侧的数值大小不能超过左侧的类型范围</span></span><br><span class="line"><span class="keyword">byte</span> num7 = (<span class="keyword">int</span>) <span class="number">40</span>;</span><br><span class="line">System.out.println(num7); <span class="comment">// 40</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num8 = <span class="number">40</span>;</span><br><span class="line"><span class="comment">//byte num9 = num8; // 错误: 不兼容的类型: 从int转换到byte可能会有损失</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// char --&gt; int 原因ASII</span></span><br><span class="line"><span class="keyword">int</span> num10 = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">System.out.println(num10); <span class="comment">// 65</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul><li>浮点转成整数，直接取消小数点，可能造成数据损失精度。</li><li><strong>取值范围大的类型</strong>强制转成<strong>取值范围小的类型</strong>，可能造成数据丢失。</li><li><strong>取值范围大的类型</strong>强制转成<strong>取值范围小的类型</strong>的时候范围大的类型数值超过范围小的类型，数据会直接溢出</li><li>对于<code>byte/short/char</code>三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器将会自动隐含的不上<code>(byte)(short)(char)</code><ul><li>如果右侧超过了左侧范围，那么直接编译器报错</li><li>如果右侧的表达式房中全都是常量，那么编译器javac将会直接将若干个常量表达式计算得到结果<ul><li>需要注意，右侧的常量结果数值，没有超过左侧范围</li><li>这也被成为编译器的常量优化</li><li>但一旦有表达式参与，那么编译器就不会进行这种优化了</li></ul></li></ul></li><li><code>char</code>类型可以直接转换成int类型</li><li><code>boolean</code>类型不能发生数据类型转换</li></ul><h2 id="ASCII编码表"><a href="#ASCII编码表" class="headerlink" title="ASCII编码表"></a>ASCII编码表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ASCIICodingTable</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">// 字符类型</span></span><br><span class="line"><span class="keyword">char</span> c1 = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="comment">// 字符类型 + int类型</span></span><br><span class="line">System.out.println((<span class="keyword">int</span>)c1); <span class="comment">// 66</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> c2 = <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">System.out.println((<span class="keyword">int</span>)c2); <span class="comment">// 20013</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在计算机的底层会用一个数字（二进制）来表示字符A，A代表的数字就是65</p><p>而数字和字符的对照关系表（编码表）：</p><ul><li>ASCII码表：American Standard Code for Information Interchange，美国信息卒换标准代码.</li><li>Unicode码表：万国码。也是数字和符号的对照关系，开头0-127部分和ASCII完全一样，但是从128开始包含有更多字符。</li></ul><p>需要记忆的就只有三个</p><ul><li>48 -&gt; ‘0’</li><li>65 -&gt; ‘A’</li><li>97 -&gt; ‘a’</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量和数据类型</title>
      <link href="/dc7e2b97a6a2.html"/>
      <url>/dc7e2b97a6a2.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h3><p>Java的数据类型分为两大类：</p><ul><li><strong>基本数据类型</strong>：包括整数、浮点数、字符、布尔。</li><li><strong>引用数据类型</strong>：包括类、数组、接口、字符串…</li></ul><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>四类八种基本数据类型：</p><table><thead><tr><th>数据类型</th><th>关键字</th><th>内存占用</th><th>取值范围</th></tr></thead><tbody><tr><td>字节型</td><td>byte</td><td>1个字节</td><td>-2^7~2^7-1</td></tr><tr><td>短整型</td><td>short</td><td>2个字节</td><td>-2^15~2^15-1</td></tr><tr><td>整型</td><td>int（默认）</td><td>4个字节</td><td>-2^31~2^31-1</td></tr><tr><td>长整型</td><td>long</td><td>8个字节</td><td>-2^63~2^63-1</td></tr><tr><td>单精度浮点数</td><td>float</td><td>4个字节</td><td>-2^31~2^31-1</td></tr><tr><td>双精度浮点数</td><td>double（默认）</td><td>8个字节</td><td>4.9E-324~1.7977E+308</td></tr><tr><td>字符型</td><td>char</td><td>2个字节</td><td>0-65535</td></tr><tr><td>布尔型</td><td>boolean</td><td>1个字节</td><td>true，false</td></tr></tbody></table><p>==Java中的默认类型：整数类型是int、浮点类型是double==</p><p>注意事项：</p><ul><li>字符串不是基本类型，而引用类型</li><li>浮点型可能只是一个近似值，并非精确的值</li><li>数据范围与字节数不一定相关，例如float数据范围比long更加广泛，但是float是4字节，long是8字节</li><li>浮点数当中默认类型是double。如果一定要使用float类型，需要加上一个后缀F</li><li>整数默认为int类型，如果一定要使用long类型，需要加上一个后缀L</li><li>推荐使用大写字母后缀</li></ul><h2 id="变量概述"><a href="#变量概述" class="headerlink" title="变量概述"></a>变量概述</h2><ul><li>变量：常量是固定不变的数据，那么在程序中可以变化的量称为变量。</li><li>数学中，可以使用字母代替数字运算，例如x=1+5或者6=x+5</li><li>程序中，可以使用字母保存数字的方式进行运算，提高计算能力，可以解决更多的问题。比如x保存5，x也可以保存6，这样x保存的数据是可以改变的，也就是我们所讲解的变量。</li></ul><p>==Java中要求一个变量每次只能保存一个数据，必须要明确保存的数据类型。==</p><h2 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h2><p>变量定义的格式包括三个要素：<strong>数据类型</strong>、<strong>变量名</strong>、<strong>数据值</strong>。</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p><code>数据类型 变量名; 变量名=数据值;</code></p><p><code>数据类型 变量名=数据值;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variable</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">// 创建一个变量</span></span><br><span class="line"><span class="keyword">int</span> num1;</span><br><span class="line">num1 = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当打印输出变量名称的时候,显示出来的是变量的内容</span></span><br><span class="line">System.out.println(num1); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变变量当中本来的数字,变成新的数字</span></span><br><span class="line">num1 = <span class="number">10</span>;</span><br><span class="line">System.out.println(num1); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> num3 = <span class="number">30</span>; <span class="comment">// 注意:右侧数值的范围不能超过左侧数据类型的取值范围</span></span><br><span class="line">System.out.println(num3); <span class="comment">//30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//byte num4 = 400; //右侧超出了byte数据范围,报错!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> num5 = <span class="number">50</span>;</span><br><span class="line">System.out.println(num5); <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> num6 = <span class="number">3000000000L</span>;</span><br><span class="line">System.out.println(num6); <span class="comment">// 3000000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> num7 = <span class="number">2.5F</span>;</span><br><span class="line">System.out.println(num7); <span class="comment">// 2.5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> num8 = <span class="number">2.5</span>;</span><br><span class="line">System.out.println(num8); <span class="comment">// 2.5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">System.out.println(ch); <span class="comment">// A</span></span><br><span class="line">ch = <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">System.out.println(ch); <span class="comment">// 中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> flag1 = <span class="keyword">true</span>;</span><br><span class="line">System.out.println(flag1); <span class="comment">// true</span></span><br><span class="line">flag1 = <span class="keyword">false</span>;</span><br><span class="line">System.out.println(flag1); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个变量的数据内容,赋值交给另一个变量</span></span><br><span class="line"><span class="comment">//右侧的变量名称flag1已经存在,里面装的是false布尔值</span></span><br><span class="line"><span class="comment">//将右侧变量里面的false,向左交给flag2变量进行存储</span></span><br><span class="line"><span class="keyword">boolean</span> flag2 = flag1;</span><br><span class="line">System.out.println(flag2); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>在同一个大括号范围内，创建多个变量，那么变量之间的名称不可以重复</p></li><li><p>对于float和long类型来说，字母后缀F和L不要丢掉</p></li><li><p>如右侧数值的范围不能超过左侧数据类型的取值范围</p></li><li><p>没有进行赋值的变量，不能直接使用</p></li><li><p>变量的使用不能超过作用域的范围【作用域：从定义变量的一行开始，一直到直接所属的大括号结束为止】</p></li><li><p>可以通过一个语句来创建多个变量，但一般不推荐使用</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常量</title>
      <link href="/245047f7f750.html"/>
      <url>/245047f7f750.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>常量：是指在Java程序中固定不变的数据</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><table><thead><tr><th>类型</th><th>含义</th><th>数据举例</th></tr></thead><tbody><tr><td>整数常量</td><td>所有的整数</td><td>0，1，128，-128</td></tr><tr><td>浮点数常量</td><td>所有的小数</td><td>0.0，-0.1，2.55</td></tr><tr><td>字符常量</td><td>单引号引起来，只能写一个字符，必须有内容</td><td>‘a’，’ ‘，’好’</td></tr><tr><td>字符串常量</td><td>双引号引起来，可以写多个字符，也可以不写</td><td>“A”，”Hello”，””</td></tr><tr><td>布尔常量</td><td>只有两个值</td><td>true，false</td></tr><tr><td>空常量</td><td>只有一个值</td><td>null</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constant</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//整数常量</span></span><br><span class="line">System.out.println(<span class="number">123</span>);</span><br><span class="line">System.out.println(-<span class="number">123</span>);</span><br><span class="line"><span class="comment">//浮点数常量</span></span><br><span class="line">System.out.println(<span class="number">0.123</span>);</span><br><span class="line">System.out.println(-<span class="number">0.123</span>);</span><br><span class="line"><span class="comment">//字符常量</span></span><br><span class="line">System.out.println(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">System.out.println(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line"><span class="comment">//System.out.println(&#x27;&#x27;); //两个单引号中间必须有且仅有一个字符</span></span><br><span class="line"><span class="comment">//System.out.println(&#x27;AB&#x27;); //两个单引号中间必须有且仅有一个字符</span></span><br><span class="line"><span class="comment">//布尔常量</span></span><br><span class="line">System.out.println(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//字符串常量</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello Java&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>); <span class="comment">//字符串两个双引号中间的内容为空</span></span><br><span class="line"><span class="comment">//空常量</span></span><br><span class="line"><span class="comment">//System.out.println(null);//空常量不能直接用来打印输出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HelloWorld入门程序</title>
      <link href="/df684ffb9540.html"/>
      <url>/df684ffb9540.html</url>
      
        <content type="html"><![CDATA[<h2 id="程序开发步骤说明"><a href="#程序开发步骤说明" class="headerlink" title="程序开发步骤说明"></a>程序开发步骤说明</h2><p>开发环境已经搭建完毕，可以开发我们第一个Java程序了。</p><p>Java程序开发三步骤：<strong>编写</strong>、<strong>编译</strong>、<strong>运行</strong></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/df684ffb9540/image-20200330143419255.png" alt="image-20200330143419255"></p><p>编译：后缀为<code>.java</code></p><p>编译：后缀为<code>.class</code></p><h2 id="编写Java源程序"><a href="#编写Java源程序" class="headerlink" title="编写Java源程序"></a>编写Java源程序</h2><ol><li><p>在<strong>E:\JavaSE\day1</strong>目录下新建文本文件，完整的文件名修改为<strong>HelloWorld.java</strong>，其中文件名为<strong>HelloWorld</strong>，后缀名必须为 <strong>.java</strong></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/df684ffb9540/image-20200330144757408.png" alt="image-20200330144757408"></p></li><li><p>用记事本打开</p></li><li><p>在文件中键入文本并保存，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;Hello Wrold!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>==文件名必须是<strong>HelloWorld</strong>，保证文件名和类的名字是一致的，注意大小写==</li><li>==每个字母和符号必须与示例代码一模一样==</li></ul></li></ol><h2 id="编译java源文件"><a href="#编译java源文件" class="headerlink" title="编译java源文件"></a>编译java源文件</h2><p>在DOS命令行中，进入<strong>Java源文件的目录</strong>，使用<strong>javac</strong>命令进行编译。</p><p>命令：<code>javac HelloWorld.java</code></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/df684ffb9540/image-20200330145037750.png" alt="image-20200330145037750"></p><p>编译成功后，命令行没有任何提示。打开<strong>E:\JavaSE\day1</strong>目录，发现产生了一个新的文件HelloWorld.class，该文件就是编译后的文件，是Java的可运行文件，称为字节码文件，有了字节码文件，就可以运行程序了。</p><h2 id="运行Java程序"><a href="#运行Java程序" class="headerlink" title="运行Java程序"></a>运行Java程序</h2><p>在DOS命令行中，进入<strong>Java源文件的目录</strong>，使用<strong>java</strong>命令进行运行。</p><p>命令：<code>java HelloWorld</code></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/df684ffb9540/image-20200330145407426.png" alt="image-20200330145407426"></p><p>==一定不要写<code>.class</code>==</p><h2 id="入门程序说明"><a href="#入门程序说明" class="headerlink" title="入门程序说明"></a>入门程序说明</h2><p>编译和运行是两回事</p><ul><li><p><strong>编译</strong>：是指将我们编写的<strong>Java</strong>源文件翻译成JVM<strong>认识</strong>的<strong>class</strong>文件，在这个过程中，j<strong>avac编译器</strong>会检查我们所写的程序是否有错误，有错误就会提示出来，如果没有错误就会编译成功。</p></li><li><p><strong>运行</strong>：是指将class文件交给JVM去运行，此时JVM就会去执行我们编写的程序了。</p></li></ul><h3 id="关于main方法"><a href="#关于main方法" class="headerlink" title="关于main方法"></a>关于main方法</h3><p><strong>main方法</strong>：称为主方法。写法是<strong>固定格式</strong>不可以更改。main方法是程序的入口点或起始点，无论我们编写多少程序，JVM在运行的时候，都会从main方法这里开始执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加注释comment"><a href="#添加注释comment" class="headerlink" title="添加注释comment"></a>添加注释comment</h2><ul><li>注释：就是对代码的解释和说明。其目的是让人们能够更加轻松地了解代码。为代码添加注释，是十分必须要的，它不影响程序的编译和运行。</li><li>Java中有单行注释和多行注释<ul><li>单行注释以<code>//开头 </code>换行结束</li><li>多行注释以<code>/*开头 以*/</code>结束</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;Hello Wrold!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键字keywords"><a href="#关键字keywords" class="headerlink" title="关键字keywords"></a>关键字keywords</h2><p>关键字：是指在程序中，Java已经定义好的单词，具有特殊含义。</p><ul><li><p>全部都是小写字母。</p></li><li><p>HelloWorld案例中，出现的关键字有<strong>public、class、static、void</strong>等</p><table><thead><tr><th>byte</th><th>基本数据类型之一，字节类型</th></tr></thead><tbody><tr><td>short</td><td>基本数据类型之一，短整数类型</td></tr><tr><td>int</td><td>基本数据类型之一，整数类型</td></tr><tr><td>long</td><td>基本数据类型之一，长整数类型</td></tr><tr><td>float</td><td>基本数据类型之一，单精度浮点数类型</td></tr><tr><td>boolean</td><td>基本数据类型之一，声明布尔类型的关键字</td></tr><tr><td>char</td><td>基本数据类型之一，字符类型</td></tr><tr><td>double</td><td>基本数据类型之一，双精度浮点数类型</td></tr><tr><td>try</td><td>尝试一个可能抛出异常的程序块</td></tr><tr><td>catch</td><td>用在异常处理中，用来捕捉异常</td></tr><tr><td>finally</td><td>用于处理异常情况，用来声明一个基本肯定会被执行到的语句块</td></tr><tr><td>throw</td><td>抛出一个异常</td></tr><tr><td>throws</td><td>声明在当前定义的成员方法中所有需要抛出的异常</td></tr><tr><td>for</td><td>一种循环结构的引导词</td></tr><tr><td>do</td><td>用在do-while循环结构中</td></tr><tr><td>while</td><td>用在循环结构中</td></tr><tr><td>break</td><td>提前跳出一个块</td></tr><tr><td>continue</td><td>回到一个块的开始处</td></tr><tr><td>switch</td><td>分支语句结构的引导词</td></tr><tr><td>case</td><td>用在switch语句之中，表示其中的一个分支</td></tr><tr><td>if</td><td>条件语句的引导词</td></tr><tr><td>else</td><td>用在条件语句中，表明当条件不成立时的分支</td></tr><tr><td>instanceof</td><td>用来测试一个对象是否是指定类型的实例对象</td></tr><tr><td>private</td><td>一种访问控制方式：私用模式</td></tr><tr><td>protected</td><td>一种访问控制方式：保护模式</td></tr><tr><td>public</td><td>一种访问控制方式：共用模式</td></tr><tr><td>super</td><td>表明当前对象的父类型的引用或者父类型的构造方法</td></tr><tr><td>this</td><td>指向当前实例对象的引用</td></tr><tr><td>package</td><td>包</td></tr><tr><td>import</td><td>表明要访问指定的类或包</td></tr><tr><td>class</td><td>声明一个类</td></tr><tr><td>enum</td><td>枚举</td></tr><tr><td>interface</td><td>接口</td></tr><tr><td>abstract</td><td>表明类或者成员方法具有抽象属性</td></tr><tr><td>extends</td><td>表明一个类型是另一个类型的子类型。对于类，可以是另一个类或者抽象类；对于接口，可以是另一个接口</td></tr><tr><td>implements</td><td>表明一个类实现了给定的接口</td></tr><tr><td>static</td><td>表明具有静态属性</td></tr><tr><td>final</td><td>用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量</td></tr><tr><td>void</td><td>声明当前成员方法没有返回值</td></tr><tr><td>return</td><td>从成员方法中返回数据</td></tr><tr><td>default</td><td>默认，例如，用在switch语句中，表明一个默认的分支。Java8 中也作用于声明接口函数的默认实现</td></tr><tr><td>new</td><td>用来创建新实例对象</td></tr><tr><td>synchronized</td><td>表明一段代码需要同步执行</td></tr><tr><td>native</td><td>用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的</td></tr><tr><td>strictfp</td><td>用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范</td></tr><tr><td>assert</td><td>断言，用来进行程序调试</td></tr><tr><td>transient</td><td>声明不用序列化的成员域</td></tr><tr><td>volatile</td><td>表明两个或者多个变量必须同步地发生变化</td></tr><tr><td>goto</td><td>保留关键字，没有具体含义</td></tr><tr><td>const</td><td>保留关键字，没有具体含义</td></tr></tbody></table></li></ul><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符：是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。</p><ul><li>HelloWorld案例中，出现的标识符有类名字<code>HelloWorld</code></li><li>命名规则：硬性要求<ul><li>标识符可以包含英文字母<code>26个（区分大小写）</code>、<code>0-9数字</code>、<code>$（美元符号）</code>和<code>_（下划线）</code></li><li>标识符不能以数字开头。</li><li>标识符不能是关键字。</li></ul></li><li>命名规范：软性建议<ul><li>类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）</li><li>方法名规范：首字母小写，后面每个单词首字母大写（小驼峰式）</li><li>变量名规范：全部小写。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java开发环境搭建</title>
      <link href="/af9f2ecdb071.html"/>
      <url>/af9f2ecdb071.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java虚拟机–JVM"><a href="#Java虚拟机–JVM" class="headerlink" title="Java虚拟机–JVM"></a>Java虚拟机–JVM</h2><ul><li><strong>JVM</strong> （Java Virtual Machine）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的运行环境，是Java最具吸引力的特性之一。我们编写的Java代码，都运行在JVM之上。</li><li><strong>跨平台</strong>：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系统上，这个特性称为<strong>Java语言的跨平台特性</strong>。该特性是由JVM实的，我们编写程序运行在JVM上，而JVM运行在操作系统上。</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/af9f2ecdb071/image-20200330135909560.png" alt="image-20200330135909560"></p><p>如图所示，Java的虚拟机本身不具备跨平台功能的，每个操作系统下都有不同版本的虚拟机。</p><h2 id="JRE和JDK"><a href="#JRE和JDK" class="headerlink" title="JRE和JDK"></a>JRE和JDK</h2><ul><li>JRE （Java Runtime Environment）：是Java程序的运行时环境，包含<strong>JVM</strong>和运行时所需要的<strong>核心类库</strong>。</li><li>JDK（Java Development Kit）：是Java程序开发工具包，包含JRE和开发人员使用的工具。</li></ul><p>我们想要运行一个已有的Java程序，那么只需安装<strong>JRE</strong>即可。</p><p>我们想要开发一个全新的Java程序，那么必须安装<strong>JDK</strong></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/af9f2ecdb071/image-20200330140526466.png" alt="image-20200330140526466"></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/af9f2ecdb071/006tNbRwly1gbmnj3i2fyj315m0rc0z8.jpg" alt="img"></p><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>JDK下载地址： <a href="https://www.oracle.com/cn/java/technologies/javase-downloads.html">https://www.oracle.com/cn/java/technologies/javase-downloads.html</a></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/af9f2ecdb071/image-20200330140937480.png" alt="image-20200330140937480"></p><p>根据自己的需要安装对应的版本注意：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/af9f2ecdb071/image-20200330141046227.png" alt="image-20200330141046227"></p><p>安装自己操作系统适配的安装包</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>注意事项：</p><ul><li>目录最好不要为中文，也不要有空格</li></ul><p>下载下来后双击进入安装页面：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/af9f2ecdb071/20170618230136472.png" alt="这里写图片描述"></p><p>最好自己指定一个安装路径（注意这是JDK的路径）</p><p><strong>注：可以不勾选公共JRE这样也不用再安装JRE了</strong></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/af9f2ecdb071/20170618230149347.png" alt="这里写图片描述"></p><p>接下来是JRE（最好把JDK和JER安装到一个目录下）</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/af9f2ecdb071/20170618230200082.png" alt="这里写图片描述"></p><p>之后就是下一步下一步</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><ul><li><p>打开环境变量配置。计算机→属性→高级系统设置→高级→环境变量，在系统变量中配置。</p></li><li><p>配置<strong>JAVA_HOME</strong></p><p>新建，变量名<code>JAVA_HOME</code>，变量值，jdk路径，我的路径是<code>E:\Java\jdk1.8.0_181</code>，保存</p></li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/af9f2ecdb071/image-20200330142153915.png" alt="image-20200330142153915"></p><ul><li><p>配置<strong>Path</strong></p><p>打开Path变量，在变量值最前加入<code>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</code></p><p>Win10可能是图形界面<code>;分号为分隔符道理一样</code></p></li></ul><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ul><li>运行cmd</li><li>测试代码<ul><li><code>java</code></li><li><code>javac</code></li><li><code>java -version</code></li></ul></li><li>都正常显示就成功了</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发前言</title>
      <link href="/45cec86ad3c4.html"/>
      <url>/45cec86ad3c4.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java语言概述"><a href="#Java语言概述" class="headerlink" title="Java语言概述"></a>Java语言概述</h2><h3 id="什么是Java语言"><a href="#什么是Java语言" class="headerlink" title="什么是Java语言"></a>什么是Java语言</h3><p>Java语言是美国<strong>Sun</strong>公司（Stanford University Network），在<strong>1995</strong>年推出的高级编程语言。所谓编程语言，是计算机的语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。</p><h3 id="Java语言发展历史"><a href="#Java语言发展历史" class="headerlink" title="Java语言发展历史"></a>Java语言发展历史</h3><ul><li>1995年Sun公司发布Java1.0版本</li><li>1997年发布Java 1.1版本</li><li>1998年发布Java 1.2版本</li><li>2000年发布Java 1.3版本</li><li>2002年发布Java 1.4版本</li><li>2004年发布Java 5版本</li><li>2006年发布Java 6版本</li><li>2009年Oracle甲骨文公司收购Sun公司，并于2011发布Java 7版本</li><li><strong>2014年发布Java 8版本</strong></li><li>2017年9月发布Java 9版本</li><li>2018年3月发布Java 10版本</li><li>…</li></ul><h3 id="Java语言能做什么"><a href="#Java语言能做什么" class="headerlink" title="Java语言能做什么"></a>Java语言能做什么</h3><p>Java语言主要应用在互联网程序的开发领域。常见的互联网应用比如<strong>天猫、京东、物流系统、网银系统</strong>等，以及服务器后台处理大数据的存储、查询、数据挖掘等也有很多应用。</p><h2 id="计算机基础知识"><a href="#计算机基础知识" class="headerlink" title="计算机基础知识"></a>计算机基础知识</h2><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>计算机中的数据不同于人们生活中的数据，人们生活采用十进制数，而计算机中全部采用二进制数表示，它只包含0、1两个数，逢二进一，1+1=10，每一个0或者每一个1，叫做一个<strong>bit</strong>（比特，位）。</p><p>下面了解一下十进制和二进制数据之间的转换计算。</p><ul><li><strong>十进制数据转成二进制数据</strong>：使用除以2获取余数的方式</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/45cec86ad3c4/image-20200330111401992.png" alt="image-20200330111401992"></p><ul><li><strong>二进制数据转成十进制数据</strong>：使 8421编码的方式</li></ul><p> <img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/45cec86ad3c4/image-20200330112240805.png" alt="image-20200330112240805"></p><h3 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h3><p>字节是我们常见的计算机中最小存储单元。计算机存储任何的数据，都是以字节的形式存储，右键点击文件属性我们可以查看文件的字节大小。</p><p>bit（位）：一个数字0或者一个数字1，代表一位</p><p>字节（Byte）： 每逢8位是一个字节，这是数据存储的最小单位</p><p>8个bit（二进制位）0000-0000为1个字节，写成<strong>1 byte</strong>或者<strong>1 B</strong></p><ul><li>1 Byte = 8 bit</li><li>1 KB = 1024 Byte</li><li>1 MB = 1024 KB</li><li>1 GB = 1024 MB</li><li>1 TB = 1024 GB</li></ul><h3 id="常用DOS命令"><a href="#常用DOS命令" class="headerlink" title="常用DOS命令"></a>常用DOS命令</h3><p>Java语言的初学者，学习一些DOS命令，会非常有帮助，DOS是一个早期的操作系统，现在已经Windows系统取代，对于我们开发人员，目前需要在DOS中完成一些事情，因此就需要掌握一些必要的命令。</p><p>微软在早年间推出了非图形界面的操作系统：<strong>MS-DOS</strong>(Microsoft Disk Operating System : 磁盘操作系统)，然后推出图形操作系统后，就把<strong>MS-DOS</strong>继承到了<strong>Windows</strong>系统中，当然<strong>Windows 7</strong>的诞生，微软也彻底抛弃它了，<strong>Windows</strong>中的**命令提示符(下面用CMD代替)**也慢慢替代了大部分的命令行操作</p><p>启动CMD：Win+R》输入cmd</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/45cec86ad3c4/image-20200330114552195.png" alt="image-20200330114552195"></p><table><thead><tr><th>切换盘符</th><th><code>盘符名称:</code></th></tr></thead><tbody><tr><td>进入文件夹</td><td><code>cd 文件夹名称</code></td></tr><tr><td>进入多级文件夹</td><td><code>cd 文件夹\文件夹</code></td></tr><tr><td>返回上一级</td><td><code>cd ..</code></td></tr><tr><td>返回根路径</td><td><code>cd \</code></td></tr><tr><td>查看当前内容</td><td><code>dir</code></td></tr><tr><td>创建目录</td><td><code>md 目录名（文件夹）</code></td></tr><tr><td>删除目录</td><td><code>rd 目录名（文件夹）</code></td></tr><tr><td>查看本机ip</td><td><code>ipconfig</code></td></tr><tr><td>复制文件</td><td><code>copy 路径\文件名 路径\文件名 （把一个文件拷贝到另一个地方）</code></td></tr><tr><td>移动文件</td><td><code>move 路径\文件名 路径\文件名 （把一个文件移动（就是剪切+复制）到另一个地方）</code></td></tr><tr><td>删除文件</td><td><code>del 文件名(这个是专门删除文件的，不能删除文件夹)</code></td></tr><tr><td>测试网络是否畅通</td><td><code>ping ip(主机名)</code></td></tr><tr><td>查看所有的dos命令</td><td><code>help</code></td></tr><tr><td>清屏</td><td><code>cls</code></td></tr><tr><td>推出</td><td><code>exit</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寥寥此生虚度</title>
      <link href="/33f8eb0da2f0.html"/>
      <url>/33f8eb0da2f0.html</url>
      
        <content type="html"><![CDATA[<p>寥寥此生虚度<br>作曲 : 暗杠<br>作词 : 竹君<br>编曲：陈夔、暗杠</p><p>摘一道闪电</p><p>甩进黑黝</p><p>造一个深渊</p><p>劈开山谷</p><p>扯一团浓烟</p><p>盖住白骨</p><p>携一方书简</p><p>刻上荒谬</p><p>要多么突兀</p><p>才能蔷薇细嗅</p><p>像外表风平浪静的烈酒</p><p>要多么坚守</p><p>才深爱歧途</p><p>做一个固执己见的山丘</p><p>要多么古旧</p><p>才能踏进坟墓</p><p>像粒心如死灰的珍珠</p><p>要多少尘土</p><p>才能掩埋领悟</p><p>做一棵贪得无厌的树</p><p>折一段笑颜</p><p>长成枯木</p><p>挖一个溪涧</p><p>蒙上薄雾</p><p>展一面山岩</p><p>描摹繁复</p><p>撒一串榆钱</p><p>撕碎早露</p><p>要多么突兀</p><p>才能蔷薇细嗅</p><p>像外表风平浪静的烈酒</p><p>要多么坚守</p><p>才深爱歧途</p><p>做一个固执己见的山丘</p><p>要多么古旧</p><p>才能踏进坟墓</p><p>像粒心如死灰的珍珠</p><p>要多少尘土</p><p>才能掩埋领悟</p><p>做一棵贪得无厌的树</p><p>要怎样弥补</p><p>才能归真返璞</p><p>像内心无动于衷的铁杵</p><p>要多么仓促</p><p>才怪诞谢幕</p><p>做一个是非颠倒的囚徒</p><p>要多么无辜</p><p>才能磨平嫉妒</p><p>像只天生丽质的鸿鹄</p><p>要多少沉浮</p><p>才能生死不顾</p><p>寥寥此生虚度</p><iframe src="//player.bilibili.com/player.html?aid=48944897&cid=85715082&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这个年纪</title>
      <link href="/a295f8b882ca.html"/>
      <url>/a295f8b882ca.html</url>
      
        <content type="html"><![CDATA[<p>这个年纪<br>作曲 : 齐一<br>作词 : 齐一</p><p>当我发现我已到了该成家的年纪</p><p>但我的女人呢，但我的女人呢</p><p>当我习惯把实话都变成了童话</p><p>那我的单纯呢，那我的单纯呢</p><p>这个年纪我已不再将就有些事情无法强求</p><p>该来的总会来该走的也无法挽留</p><p>青春慢慢从身边溜走我开始变的怀旧</p><p>喝光了这杯酒就再也无法回头</p><p>这个年纪的我们爱情跟不上分开的节奏</p><p>这个年纪的我们更珍惜难得的自由</p><p>这个年纪的我们比起从前更容易感动</p><p>这个年纪的我们徘徊在理想与现实之中</p><p>这个年纪我已不再将就有些事情无法强求</p><p>该来的总会来该走的也无法挽留</p><p>青春慢慢从身边溜走我开始变的怀旧</p><p>喝光了这杯酒就再也无法回头</p><p>这个年纪的我们爱情跟不上分开的节奏</p><p>这个年纪的我们更珍惜难得的自由</p><p>这个年纪的我们比起从前更容易感动</p><p>这个年纪的我们徘徊在理想与现实之中</p><p>不知不觉孤独不再可耻了</p><p>不知不觉爸爸的情绪变得脆弱了</p><p>不知不觉一把柴米油盐也成为压力了</p><p>不知不觉我们也开始懂事了</p><p>呐呐呐呐呐 呐呐呐呐呐</p><p>呐呐呐呐呐 呐呐呐呐呐</p><p>呐呐呐呐呐 呐呐呐呐呐</p><p>呐呐呐呐呐 呐呐呐呐呐</p><p><video class="media" src="blob:https://music.163.com/c7e24f71-cfff-4b58-841c-34464754611a"></video></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你的答案</title>
      <link href="/fee0daf7ca52.html"/>
      <url>/fee0daf7ca52.html</url>
      
        <content type="html"><![CDATA[<p>你的答案<br>作曲 : 刘涛<br>作词 : 林晨阳 /刘涛<br>编曲 Arranger：谭侃侃</p><p>也许世界就这样</p><p>我也还在路上</p><p>没有人能诉说</p><p>也许我只能沉默</p><p>眼泪湿润眼眶</p><p>可又不甘懦弱</p><p>低着头 期待白昼</p><p>接受所有的嘲讽</p><p>向着风 拥抱彩虹</p><p>勇敢的向前走</p><p>黎明的那道光</p><p>会越过黑暗</p><p>打破一切恐惧我能</p><p>找到答案</p><p>哪怕要逆着光</p><p>就驱散黑暗</p><p>丢弃所有的负担</p><p>不再孤单</p><p>不再孤单</p><p>也许世界就这样</p><p>我也还在路上</p><p>没有人能诉说</p><p>也许我只能沉默</p><p>眼泪湿润眼眶</p><p>可又不甘懦弱</p><p>低着头 期待白昼</p><p>接受所有的嘲讽</p><p>向着风 拥抱彩虹</p><p>勇敢的向前走</p><p>黎明的那道光</p><p>会越过黑暗</p><p>打破一切恐惧我能</p><p>找到答案</p><p>哪怕要逆着光</p><p>就驱散黑暗</p><p>丢弃所有的负担</p><p>不再孤单</p><p>不再孤单</p><p>黎明的那道光</p><p>会越过黑暗</p><p>打破一切恐惧我能</p><p>找到答案</p><p>哪怕要逆着光</p><p>就驱散黑暗</p><p>有一万种的力量</p><p>淹没孤单</p><p>不再孤单</p><p><video class="media" src="blob:https://music.163.com/f4df5b7f-7d2d-4430-9171-d7a2e264dbc2"></video></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修身(一)</title>
      <link href="/e47508c7c8ce.html"/>
      <url>/e47508c7c8ce.html</url>
      
        <content type="html"><![CDATA[<p>一个人在成长的过程里，总会遇到很多，比如心里的矛盾，现实里的阻碍。<br>美好的想法那是自己惬意的美妙的梦想。<br>一个人如何得到自己想要的，如何实现自己的理想，又如何能够改变自己现在的状态？<br>我相信这是太多的人都面临的一个问题。</p><p>只是才疏学浅，希望读者能够提出最为宝贵的意见。</p><p>所以我只谈一点，那就是修身。</p><p>修身齐家治国平天下，这句话都不是陌生的，但是如何做到？<br>且不说治国平天下，那如何齐起家？<br>所以得先修其身啊。</p><p>怎么修身？</p><p>一个很笼统的话题，那有没有标准？<br>有没有规律，有没有可以快速见到效果的？<br>这就是我们在不断总结出来的一些，现在分享给大家。</p><h2 id="1-修口"><a href="#1-修口" class="headerlink" title="1.修口"></a>1.修口</h2><ol><li>你能让别人舒服，能够让这个此时此刻的环境和谐，能够达到基本目标，能够简单易行，这一点能够得到已经很不错了。</li><li>你能通过自己能为，表达清楚和规划执行，能够明确方向的长远，那种高度，深度，并且可以按照别人接受的顺序讲出来，这还只是你做到了一半，最重要就是执行过程里那种利弊得失，时间空间布局，容易出错的，容易变化的也能补充到位，这就很不容易了。这便是个人的基本趋于综合能力了。</li><li>要成为大才，那你还需要按照自然规律，道德，符合规律还不够，还需要创造，得到进步，推动力，你的创造力，奇特的开发在没有条件的时候创造出来的那才是别人震撼和让你口才有魂的基本。这是我粗浅的理解。那么话说回来最基本的修口具体是什么呢？</li></ol><p>我认为要做到四不。</p><h3 id="第一不"><a href="#第一不" class="headerlink" title="第一不"></a>第一不</h3><p>第一不，就是不插嘴。<br>其实很多人有个很不好的习惯，就是喜欢插嘴。<br>试问下，你如果在说话的时候，别人也插嘴你是怎样的感受？<br>既然你不喜欢你很讨厌，那别人说话的时候你插嘴呢？<br>为何不要插嘴！</p><p>我认真的思考了一下有这样的原因。</p><ol><li>你真的把对方的意思理解了吗？还是用你那个人的感觉判断去理解了？</li><li>别人信息情报具体了吗？说清楚了没有？还是根本就没有开始？</li><li>你都不知道别人目的，不仅仅是事的目的，最重要的是还有人，你要知道他如此说是不是因为可以想到兵法里的话，如何激怒对方？还是在隐藏什么？</li></ol><p>所以你​需要安静冷静。<br>这不仅仅是智慧，还会是你能够获得面子与尊重。<br>因为你这个细节决定了说话的气氛。<br>所以千万别乱插嘴！<br>但是还有一点，不是一概而论的，就是当你该插嘴的时候必须要插嘴了，所以这个平衡需要自己能够把握一个度。</p><h3 id="第二不"><a href="#第二不" class="headerlink" title="第二不"></a>第二不</h3><p>第二不，不争论。<br>你争赢了输了关系，你争输了会输得很惨。<br>大家都知道，争锋对麦芒的！<br>可现实里，又有多少人如此愚蠢？<br>我们大家确实都在争都在论，但是我认为我们得有合适的方法需要正确解决眼前的所有。<br>其实这里就如战场一样。<br>其实你的社会也如是战场，那么你知道了战场，就是生死存亡就是你争我夺的地方。<br>所以难免的就是争论也就会出现输赢出现心里的状态中的悲喜与酸痛。<br>而每个人都一样希望自己是一个智者是一个强者是一个得到支持的人，尤其是在自己说话的时候，所以这里我认为，如何做到与得到你的目标，你应该做到的三点:</p><ol><li>快速恢复对得失中利益的判断，调整自己情绪，去认同对方。</li><li>还需要很认真的去思考别人的意思和言外之意。</li><li>明确做的方向，做的方法。</li></ol><p>其实大家最终要得到的只是一个，那就是大伙达成共识。<br>在这里关于争论与不争论就写到这里，其实还有更加具体的希望可以在以后的过程里分享。</p><h3 id="第三不"><a href="#第三不" class="headerlink" title="第三不"></a>第三不</h3><p>第三不，不否定与不反驳。<br>很多时候，我们总是喜欢反驳习惯了否定。<br>你不认同别人别人一辈子都不会认同你，你反驳了别人那是对别人的不尊重最重要的是还会带来了很大的程度伤害。<br>试问下，你懂别人吗？<br>你又了解清楚别人说的事吗？<br>你又明白别人那个时候发生什么？<br>你又明白别人的难处吗？<br>你又知道那个时候别人最应该做的和不得不做的是什么吗？<br>所以人与人之间的相处，就是因为自己往往按照自己的思考去思考，还有很多的时候都是好为人师指手画脚的，试问下你真的是神吗？<br>不，你不是，既然不是的，也无非就是一个凡人，那有必要如此吗？<br>在这里我们得深深思考！<br>为何那些大成家他们能够让身边的人从内心里舒服，明白吗？<br>所以笔者个人认为，一切好商量，就会成为绝大多数的未来的法宝！​<br>所以当我们理解了，明确了我们自己的日子也定然好过起来，尤其是夫妻之间，尤其是最好的关系之间，人往往犯的错就是很难控制住这一切。<br>所以还有更多的法宝，希望读者可以随时与我们交流。</p><h3 id="第四不"><a href="#第四不" class="headerlink" title="第四不"></a>第四不</h3><p>第四不，不嘴巴变形。<br>其实这是最讨厌也是最没用最没有礼貌的。<br>只要你用心观察身边的人，说话嘴巴变形的人，他的性格与命运，就当做实践的作业吧。<br>为何人喜欢菩萨？<br>喜欢拜佛？<br>不喜欢雷公脸？<br>知道吗？<br>这里牵系了我下面要说的眼。<br>还有更多的知识内容，也需要后面发表…<br>所以修口，很重要，有了四不，就不断的检查自己不断的告诉自己修炼好。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异地恋如何维持长久？</title>
      <link href="/2cc594bf8909.html"/>
      <url>/2cc594bf8909.html</url>
      
        <content type="html"><![CDATA[<p>异地恋，真的不是一张机票就能解决的事，说的很真实，不是我们不在坚持，而是我们遇到了这些…</p><h2 id="表达障碍"><a href="#表达障碍" class="headerlink" title="表达障碍"></a>表达障碍</h2><p>短信听不到语气，电话看不到表情。<br>其实我没生气，你当真了；我在笑呢，你看不到吧；我哭了呢？抱着手机哭倦了睡过又醒了，你在忙吗？</p><h2 id="共同语言"><a href="#共同语言" class="headerlink" title="共同语言"></a>共同语言</h2><p>如果两个人在一起，两个人的交往圈会溶为共同的圈子，话题永远都在更新。<br>而不在一起的两个人，对彼此身边的环境都会因为陌生而失去兴趣，慢慢的，能说的话只有空洞的“我想你”<br>我在努力找话题呢，不要回信息说”喔，嗯，好”了好吗？</p><h2 id="不安全感"><a href="#不安全感" class="headerlink" title="不安全感"></a>不安全感</h2><p>看了10次手机了，你还是没有回信。你在哪，和谁，在干什么？<br>刚刚拒绝了别人的好意，却禁不住想，你身边的莺莺燕燕，一如我身边的花花草草吗？</p><h2 id="远水不救近火"><a href="#远水不救近火" class="headerlink" title="远水不救近火"></a>远水不救近火</h2><p>我这里下雨了，来伞的是同学的弟弟；我吃饭忘带钱了，来解围的是朋友的朋友。原来你不吭声是因为你生病了，可我再担忧，也不能在你身边端一杯水呢。</p><h2 id="距离产生幻觉"><a href="#距离产生幻觉" class="headerlink" title="距离产生幻觉"></a>距离产生幻觉</h2><p>其实我有些小虚荣，照片有时候修掉了眼袋才给你看；其实你有些小自负，认定的事情就以为自己一定对。<br>为了大老远的爱你，我拒绝接受身边一切说你不好的言论，什么都往好的方向想。你也是吧。<br>其实我们都不是对方想象的那样好。</p><h2 id="距离产生误会"><a href="#距离产生误会" class="headerlink" title="距离产生误会"></a>距离产生误会</h2><p>我兴冲冲地发短信给你讲刚刚的趣事，你隔了半天说“喔”，我不知道你在上课的嘛，所以我生闷气了。<br>你给我发了八条短信两个电话我也没回，愤怒得嗷嗷直叫，我在做头发呢，包包寄存了嘛，哪知道手机响着响着没电了。<br>其实我们都知道对方不是故意的，但情绪来了，总需要宣泄的。</p><h2 id="善意的谎言"><a href="#善意的谎言" class="headerlink" title="善意的谎言"></a>善意的谎言</h2><p>我碰巧和相熟的男生去看电影了，想了想，对你说和女生去的。<br>你独自去了我们约好要一起去的地方，犹豫再三，对我说你哪也没去。<br>不愿让对方多想，却因为偶尔的疏忽，放对方想的更多。</p><h2 id="寂寞"><a href="#寂寞" class="headerlink" title="寂寞"></a>寂寞</h2><p>一个人不寂寞，想念一个人才寂寞。<br>你说，来，抱抱。于是我把自己裹在被窝里，闭上眼，恩，抱抱。<br>从学校回家的路上，你还抬头看月亮吗？</p><h2 id="信念坍塌"><a href="#信念坍塌" class="headerlink" title="信念坍塌"></a>信念坍塌</h2><p>我看到身边一对一对的，男生帮女生打开水送饭，在宿舍楼下唧唧我我，周末还能一起爬山，没忍住就对在地图对角线上的你发牢骚，其实是想听你的鼓励。<br>刚刚好你接到朋友异地恋分手倾诉的电话，那么容易就把自己带入了戏，无心的抱怨雪上加霜。<br>有时候折腾一下，只为证明自己的重要性。<br>哪知脆弱基础上的高楼只须多压一根头发的重量，也许就崩溃了…</p><blockquote class="blockquote-center">没有人可以带走你的痛，所以也别让任何人带走你的幸福</blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那年你27、8岁</title>
      <link href="/b6a4fd82fcfc.html"/>
      <url>/b6a4fd82fcfc.html</url>
      
        <content type="html"><![CDATA[<p>18岁以后，他已经不是为了自己而活着</p><p>18岁，你上了大学。</p><p>20岁，你大二结束，开始悔恨<br>自己前两年幼稚的行为<br>于是开始努力</p><p>22岁你大学毕业了，却发现<br>找不到一份令自己满意的工作</p><p>26岁，你看着身边的人都结了婚<br>婚礼的份子钱逐年递增<br>春节回家，父母从带你串亲戚<br>变成了带你去见相亲对象<br>见了十几个姑娘<br>你每次都觉得和那个她比<br>差了一点</p><p>28岁那年，你遇到了一个和你遭遇差不多的姑娘<br>你们有一搭没一搭聊着<br>她说：你还不错<br>你喝了一口可乐说：你也是<br>你还不确定喜不喜欢她<br>双方家长就已经摆好了订婚宴<br>结婚的前一周，你和朋友出去喝酒<br>你说，不想结婚<br>朋友说，你啊，就是想太多。谁不是这么过来的？</p><p>29岁，你们终于结了婚<br>婚礼办的不大不小，朋友来的不多不少<br>攒了几年想要去实现理想的钱<br>搭在了这一场百人的私人庙会上<br>婚礼进行到中间<br>司仪带着标准的商业化微笑<br>对着台下的亲朋喊道<br>要不要让他们亲一个！<br>台下那些人跟着一起起哄<br>不知道为什么<br>你简简单单的亲了一口<br>俩人恢复到了一开始的站位<br>你小声说了一句：我爱你<br>那个昨天还看不惯你倒腾模型的新娘<br>愣了一下说：我也爱你<br>你不确定她是不是对你说的<br>就像你不确定是不是对她说的一样<br>婚礼结束后，并没有你想象的浪漫<br>你听着外屋的新娘一笔一笔的算着份子钱<br>想着不过才两年，怎么就变成这样了<br>想着想着，洞房夜就睡着了</p><p>30岁，她怀孕了<br>辞掉了工作，在家养胎<br>你在公司逐渐有了点地位<br>手里管着十来个人<br>独立负责一个项目<br>结婚前陪嫁的那辆20万左右的车<br>也变成了你一个人的独享<br>但你依然不敢放松<br>每次加班<br>电话那头都是抱怨与委屈<br>但你不能争辩什么<br>谁让她怀了你的孩子<br>在这一刻<br>不论是她的父母还是你的父母<br>都无条件的站在这一边</p><p>31岁，孩子落地了<br>前前后后连孕检带住院费花了10万块钱<br>不过无所谓<br>你看着你的孩子，怎么看怎么喜欢<br>高兴的仿佛这是你的新生</p><p>32岁，这是人生最不愿意重复的一年<br>平均睡眠3小时<br>孩子每一个小时都要闹腾一次<br>第二天拖着睡不醒的眼睛去上班<br>老板说你上班不干活<br>回家媳妇说你不干活<br>你想了半天不明白，那谁干活呢？<br>那辆开了3年的车<br>成为了你真正的家<br>你不在抱怨路上拥堵的交通<br>你甚至开始希望<br>再多堵一会<br>回到家，你关了发动机<br>在车上点了一根烟<br>这是你每天最幸福的十分钟<br>车前是功名利禄，车尾是柴米油盐</p><p>35岁你因为身体越来越差<br>加班越来越少<br>晋升的速度也越来越缓慢<br>那天下班，媳妇告诉你<br>孩子要上幼儿园了<br>双语的一个月3000<br>你皱了皱眉头，那边就已经不耐烦了<br>“四单元的老王家孩子，一个月6000”<br>“你已经这样了，你想让孩子也输？”<br>你没说话，回屋给媳妇转了6000块钱<br>这笔钱，你原本打算给自己过个生日，买个新电脑</p><p>38岁，孩子上了一年级<br>老师说一年级最关键，打好基础很重要<br>你笑着说，是是是，老师您多照顾<br>新生接待的老师看着你不明事理的脸<br>给你指了一条明路<br>“课外辅导班，一个月2200”</p><p>40岁的时候，孩子上了三年级<br>老师说，三年级，最关键，承上启下很重要<br>你笑着说：是是是，正打算再报个补习班</p><p>44岁，孩子上了初中<br>有一天回到家，她对你说<br>爸爸，我想学钢琴<br>你没什么犹豫的<br>你以为这些年，你已经习惯了<br>但那句“爸爸现在买不起”你始终说不出口<br>好在孩子比较懂事<br>她说：爸爸没事，要不我先学陶笛也可以<br>你看着这么懂事的孩子，却开心不起来</p><p>46岁，孩子上了一个不好不差的高中<br>有一天你在开会，接到了老师的电话<br>电话里说你的孩子在学校打架了<br>叫你去一趟<br>你唯唯诺诺的<br>和那个比你还小5岁的领导请了个假<br>到学校又被老师训了一通<br>无非台词就是那一句<br>你们做家长的就知道工作，能不能陪陪孩子<br>你看着这个老师，有点可笑<br>好像当时说：家长在外辛苦点<br>多赚点钱让孩子多补补课的和他不是一个人</p><p>50岁，孩子上了大学<br>很争气，是一个一本<br>他学的专业你有点看不懂<br>你只知道工作不一定好找<br>而且学费还死贵<br>你和他深夜想聊聊<br>准备了半斤白酒，一碟花生米<br>你说着那些曾经你最讨厌的话<br>还是要为以后工作着想<br>挑个热门的专业<br>活着比热爱重要<br>你们从交流变成了争吵<br>你发现，你老了<br>老到可能都打不过这个18岁的孩子<br>你说不过他，只能说一句：我是你爸爸！<br>孩子看着你，知道再怎么争辩都没用<br>这场确立你最后威严的酒局不欢而散<br>你听的不真切<br>在孩子回自己屋的路上好像叨叨了一句<br>“我不想活的像你一样”<br>怎么就哭了呢？50岁的人了<br>一定是酒太辣了，对不对<br>一定是酒太辣了</p><p>55岁，孩子工作了，似乎有一点理解你了<br>但你却反了过来，你说不要妥协</p><p>56岁，孩子也结婚了<br>你问他喜欢那个姑娘么<br>他愣了愣说：喜欢吧</p><p>60岁，辛苦了一辈子，想出去走走<br>身边的那个人过了30年<br>你依旧分不清到底喜不喜欢<br>你们开始规划旅游路线<br>这么多年了<br>你们还是存在分歧，还是在争吵<br>某个瞬间，你觉得<br>这样可能也挺好<br>一切都准备好了<br>儿子说：爸妈，我工作太忙了<br>可以帮我照顾一下孩子么<br>你们退了机票，又回到了30年前</p><p>70岁，孩子的孩子也长大了，不用天天操心了<br>你下定决心说：一定要去玩一趟<br>可是手边的拐杖<br>只能支持你走到楼下的花园<br>75岁，你在医院的病床上<br>身边聚满了人，你迷迷糊糊的看见医生摇了摇头<br>周围那些人神情肃穆<br>你明白了，你要死掉了<br>你没有感到一丝害怕<br>你突然问自己，我到底是什么时候死掉的呢？<br>你想起来30岁的那场婚礼<br>原来，那时候，你就死掉了吧<br>依照惯例<br>死前的3秒，你的大脑要走马灯<br>倒叙你这75个年头的一生<br>画面一张一张的过<br>1秒<br>2秒<br>两秒过去了<br>你面无表情的看着这两秒内的回忆<br>第3秒<br>突然你笑了<br>原来已经回到了15岁的那一年<br>你看见一个男孩<br>他叼着一袋牛奶，背着书包<br>从另一个女孩家的阳台下跑过<br>那个男孩朝窗户里看了看<br>那是15岁的你暗恋的那个女孩子<br>你想不起来她长什么样子了<br>最后一秒你努力的回忆着<br>然后终于笑了出来<br>3秒过去了<br>身边的人突然间开始嚎啕大哭<br>你可能听不清了<br>你最后听到的嘈杂的声音<br>是一群十五六的少年 起着哄说的<br>答应他<br>答应他<br>答应他</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-算法练习</title>
      <link href="/79edd52b58c3.html"/>
      <url>/79edd52b58c3.html</url>
      
        <content type="html"><![CDATA[<h2 id="心里的准备"><a href="#心里的准备" class="headerlink" title="心里的准备"></a>心里的准备</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/79edd52b58c3/1.png"></p><h2 id="算法练习的网站"><a href="#算法练习的网站" class="headerlink" title="算法练习的网站"></a>算法练习的网站</h2><p><a href="https://leetcode.com/problemset/all/">https://leetcode.com/problemset/all/</a><br>或者<br><a href="https://leetcode-cn.com/problemset/all/">https://leetcode-cn.com/problemset/all/</a><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/79edd52b58c3/2.png"></p><ul><li>做题的时候用上切题四件套</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/79edd52b58c3/3.png"></p><h2 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/79edd52b58c3/4.png"></p><h2 id="坚持"><a href="#坚持" class="headerlink" title="坚持"></a>坚持</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/79edd52b58c3/5.png"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-复杂度</title>
      <link href="/e72787e674a1.html"/>
      <url>/e72787e674a1.html</url>
      
        <content type="html"><![CDATA[<h2 id="课程的进度"><a href="#课程的进度" class="headerlink" title="课程的进度"></a>课程的进度</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e72787e674a1/1.png"></p><h2 id="算法的复杂度"><a href="#算法的复杂度" class="headerlink" title="算法的复杂度"></a>算法的复杂度</h2><ul><li>时间复杂度</li><li>空间复杂度</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e72787e674a1/2.png"></p><h2 id="常用复杂度"><a href="#常用复杂度" class="headerlink" title="常用复杂度"></a>常用复杂度</h2><p>多块代码复杂度只看最高复杂度</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e72787e674a1/3.png"></p><h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><h3 id="常数统一为O-1"><a href="#常数统一为O-1" class="headerlink" title="常数统一为O(1)"></a>常数统一为O(1)</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e72787e674a1/4.png"><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e72787e674a1/5.png"><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e72787e674a1/6.png"><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e72787e674a1/7.png"></p><h3 id="算法的使用对比"><a href="#算法的使用对比" class="headerlink" title="算法的使用对比"></a>算法的使用对比</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e72787e674a1/8.png"></p><h3 id="递归的复杂度计算"><a href="#递归的复杂度计算" class="headerlink" title="递归的复杂度计算"></a>递归的复杂度计算</h3><p>斐波拉契数列</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e72787e674a1/9.png"></p><p>每次计算都要重新计算一便前面的数据，复杂度应该为O(2^N)</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e72787e674a1/10.png"></p><h4 id="常见递归及递归复杂度计算网站"><a href="#常见递归及递归复杂度计算网站" class="headerlink" title="常见递归及递归复杂度计算网站"></a>常见递归及递归复杂度计算网站</h4><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e72787e674a1/11.png"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-学习方式</title>
      <link href="/aee8b86da60e.html"/>
      <url>/aee8b86da60e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>明确！目标！</p></blockquote><p>学习最重要的是方式，更重要也是坚持</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/aee8b86da60e/1.png"></p><h2 id="Chunk-it-up-切碎知识点"><a href="#Chunk-it-up-切碎知识点" class="headerlink" title="Chunk it up(切碎知识点)"></a>Chunk it up(切碎知识点)</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/aee8b86da60e/2.png"><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/aee8b86da60e/3.png"><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/aee8b86da60e/6.png"></p><h2 id="Deliberate-practicing-刻意练习"><a href="#Deliberate-practicing-刻意练习" class="headerlink" title="Deliberate practicing(刻意练习)"></a>Deliberate practicing(刻意练习)</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/aee8b86da60e/4.png"></p><h2 id="Feedback-反馈"><a href="#Feedback-反馈" class="headerlink" title="Feedback(反馈)"></a>Feedback(反馈)</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/aee8b86da60e/5.png"></p><h2 id="算法的解析"><a href="#算法的解析" class="headerlink" title="算法的解析"></a>算法的解析</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/aee8b86da60e/7.png"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot打war包</title>
      <link href="/18e2d5e4b6f3.html"/>
      <url>/18e2d5e4b6f3.html</url>
      
        <content type="html"><![CDATA[<ol><li><p>更改pom.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;packaging&gt;war&lt;/packaging&gt;</span><br></pre></td></tr></table></figure></li><li><p>添加spring-boot-starter-tomcat的provided依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupld&gt;org.springframework.boot&lt;/groupld&gt;</span><br><span class="line">&lt;artifactld&gt;spring-boot-starter-tomcat&lt;/artifactld&gt;</span><br><span class="line">&lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>添加maven-war-plugin插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">&lt;finalName&gt;$(project.artifactld)&lt;/finalName&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupld&gt;org.apache.maven.plugins&lt;/groupld&gt;</span><br><span class="line">&lt;artifactld&gt;maven-war-plugin&lt;/artifactld&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></li><li><p>修改启动类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@ SpringBootApplication </span><br><span class="line">public class MainApplication extends SpringBootServletlnitializer &#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">SpringApplication.run(MainApplication.class,args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override </span><br><span class="line">protected SpringApplicationBuilder configure(SpringApplicationBuilder builder)&#123;</span><br><span class="line">return builder.sources(MainApplication.class);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>目录下<br><code>mvn clean package</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter</title>
      <link href="/e1ce4e19566f.html"/>
      <url>/e1ce4e19566f.html</url>
      
        <content type="html"><![CDATA[<h1 id="JMeter入门"><a href="#JMeter入门" class="headerlink" title="JMeter入门"></a>JMeter入门</h1><p>官方网站：<a href="https://jmeter.apache.org/">https://jmeter.apache.org/</a><br>软件下载：<a href="https://jmeter.apache.org/download_jmeter.cgi">https://jmeter.apache.org/download_jmeter.cgi</a><br>用户手册：<a href="https://jmeter.apache.org/usermanual/index.html">https://jmeter.apache.org/usermanual/index.html</a></p><p>下载后解压，找到目录 bin 下的 jmeter.bat 文件，双击启动<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e1ce4e19566f/1.png"><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e1ce4e19566f/2.png"></p><h2 id="设置中文界面"><a href="#设置中文界面" class="headerlink" title="设置中文界面"></a>设置中文界面</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e1ce4e19566f/3.png"></p><h2 id="测试接口"><a href="#测试接口" class="headerlink" title="测试接口"></a>测试接口</h2><ol><li>设置线程组<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e1ce4e19566f/4.png"></li></ol><ul><li>线程数为并发数</li><li>Ramp-Up时间（秒）为启动全部线程的时间</li></ul><ol start="2"><li>添加HTTP请求默认值</li></ol><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e1ce4e19566f/5.png"><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e1ce4e19566f/6.png"></p><ul><li>只需要配置web服务器，就不用每次都配置请求（端口不填默认80）</li></ul><ol start="3"><li>添加取样器</li></ol><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e1ce4e19566f/7.png"><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e1ce4e19566f/8.png"></p><ul><li>这里就不用添加web服务器了</li></ul><ol start="4"><li>添加监听器</li></ol><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e1ce4e19566f/9.png"></p><p>因为查看的结果的不同，添加你觉得适合的监听器</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e1ce4e19566f/10.png"></p><p>我添加的了一个聚合报告，在点击运行的时候回弹出一个对话框，问是否保存测试计划，根据你自己的需求决定</p><h2 id="设置不同的参数"><a href="#设置不同的参数" class="headerlink" title="设置不同的参数"></a>设置不同的参数</h2><ol><li>先添加HTTP请求默认值</li></ol><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e1ce4e19566f/11.png"></p><ol start="2"><li>添加Http请求</li></ol><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e1ce4e19566f/12.png"></p><ol start="3"><li>准备样本文件</li></ol><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e1ce4e19566f/13.png"></p><ol start="4"><li>添加CSV数据文件</li></ol><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e1ce4e19566f/14.png"></p><ul><li>选中你的样本文件</li><li>可以添加多个数据，分隔符可以自己定义，推荐‘,’</li><li>设置对应每行的变量名，也要用分隔符分隔</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e1ce4e19566f/15.png"></p><ol start="5"><li>添加变量</li></ol><p>${定义的变量名}<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e1ce4e19566f/16.png"></p><ol start="6"><li>添加监听器</li></ol><p>我选择了查看结果树</p><p>这样就能看到每次请求的链接</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/e1ce4e19566f/17.png"></p><h2 id="Redis压测"><a href="#Redis压测" class="headerlink" title="Redis压测"></a>Redis压测</h2><ol><li>100个并发连接，100000个请求<br><code>redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000</code></li><li>存取大小为100字节的数据包<br><code>redis-benchmark -h 127.0.0.1 -p 6379 -q -d 100</code></li><li>只测试某些操作的性能<br><code>redis-benchmark -t set,lpush -q -n 100000</code></li><li>只测试某些数值存取的性能<br><code>redis-benchmark -n 100000 -q script load &quot;redis.call(set&#39;,&#39;foo&#39;,&#39;bar)&quot;</code></li></ol><h2 id="JMeter命令行"><a href="#JMeter命令行" class="headerlink" title="JMeter命令行"></a>JMeter命令行</h2><ol><li>在windows上录好jmx</li><li>命令行：<code>sh jmeter.sh -n -t XXX.jmx -l result.jtl</code></li><li>把result.jtl导入到jmeter</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> JMeter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis安装在Liunx</title>
      <link href="/6b7289fc875f.html"/>
      <url>/6b7289fc875f.html</url>
      
        <content type="html"><![CDATA[<p>下载包<br><a href="https://redis.io/">https://redis.io/</a><br>如包名为redis-5.0.4.tar.gz</p><p>上传至服务器：如/tmp<br>移动到目录下<br><code>cd /tmp</code></p><ol><li>解压<br><code>tar -zvxf redis-5.0.4.tar.gz</code></li><li>移动到/usr/local并重名名为redis<br><code>mv redis-5.0.4 /usr/local/redis</code></li><li>切换目录<br><code>cd /usr/local/reids/</code></li><li>编译<br><code>make</code></li><li>添加启动目录<br><code>make install</code></li><li>测试访问<br><code>redis-s &gt; tab &gt;显示 redis-server 即可</code></li><li>打开配置文件<br><code>vi redis.conf</code></li><li>更改<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#服务器访问</span><br><span class="line">bind 127.0.0.1 &gt; 0.0.0.0 </span><br><span class="line">#后台执行</span><br><span class="line">daemonize no &gt; yes</span><br><span class="line">#访问密码</span><br><span class="line">requirepass &gt; 1234567</span><br></pre></td></tr></table></figure>完成后<br><code>:wq</code></li><li>启动服务<br><code>redis-server ./redis.conf</code><br>进程查看<code>ps -ef | grep redis</code></li><li>访问服务<br><code>redis-cli</code></li><li>退出<br><code>exit</code></li><li>关闭<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">shutdown save</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></li><li>配置成服务<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./install_server.sh </span><br><span class="line">1.端口</span><br><span class="line">2.配置文件</span><br><span class="line">3.log文件</span><br><span class="line">4.数据目录</span><br><span class="line">5.可执行文件</span><br></pre></td></tr></table></figure>检测<br><code>chkconfig --list | grep redis</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取Ip</title>
      <link href="/c748da646b0b.html"/>
      <url>/c748da646b0b.html</url>
      
        <content type="html"><![CDATA[<p>util</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.apache.commons.lang3.StringUtils;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.UnknownHostException;</span><br><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class IpUtil &#123;</span><br><span class="line"></span><br><span class="line">    public final static String ERROR_IP = &quot;127.0.0.1&quot;;</span><br><span class="line"></span><br><span class="line">    public final static Pattern pattern = Pattern.</span><br><span class="line">            compile(&quot;(2[5][0-5]|2[0-4]\\d|1\\d&#123;2&#125;|\\d&#123;1,2&#125;)\\.(25[0-5]|2[0-4]\\d|1\\d&#123;2&#125;|\\d&#123;1,2&#125;)\\.(25[0-5]|2[0-4]\\d|1\\d&#123;2&#125;|\\d&#123;1,2&#125;)\\.(25[0-5]|2[0-4]\\d|1\\d&#123;2&#125;|\\d&#123;1,2&#125;)&quot;);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 取外网IP</span><br><span class="line">     *</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String getRemoteIp(HttpServletRequest request) &#123;</span><br><span class="line">        String ip = request.getHeader(&quot;x-real-ip&quot;);</span><br><span class="line">        if (ip == null) &#123;</span><br><span class="line">            ip = request.getRemoteAddr();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //过滤反向代理的ip</span><br><span class="line">        String[] stemps = ip.split(&quot;,&quot;);</span><br><span class="line">        if (stemps != null &amp;&amp; stemps.length &gt;= 1) &#123;</span><br><span class="line">            //得到第一个IP，即客户端真实IP</span><br><span class="line">            ip = stemps[0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ip = ip.trim();</span><br><span class="line">        if (ip.length() &gt; 23) &#123;</span><br><span class="line">            ip = ip.substring(0, 23);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取用户的真实ip</span><br><span class="line">     *</span><br><span class="line">     * @param request</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String getUserIP(HttpServletRequest request) &#123;</span><br><span class="line"></span><br><span class="line">        // 优先取X-Real-IP</span><br><span class="line">        String ip = request.getHeader(&quot;X-Real-IP&quot;);</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;x-forwarded-for&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getRemoteAddr();</span><br><span class="line">            if (&quot;0:0:0:0:0:0:0:1&quot;.equals(ip)) &#123;</span><br><span class="line">                ip = ERROR_IP;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (&quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = ERROR_IP;</span><br><span class="line">            return ip;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int pos = ip.indexOf(&#x27;,&#x27;);</span><br><span class="line">        if (pos &gt;= 0) &#123;</span><br><span class="line">            ip = ip.substring(0, pos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getLastIpSegment(HttpServletRequest request) &#123;</span><br><span class="line">        String ip = getUserIP(request);</span><br><span class="line">        if (ip != null) &#123;</span><br><span class="line">            ip = ip.substring(ip.lastIndexOf(&#x27;.&#x27;) + 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ip = &quot;0&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean isValidIP(HttpServletRequest request) &#123;</span><br><span class="line">        String ip = getUserIP(request);</span><br><span class="line">        return isValidIP(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断我们获取的ip是否是一个符合规则ip</span><br><span class="line">     *</span><br><span class="line">     * @param ip</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean isValidIP(String ip) &#123;</span><br><span class="line">        if (StringUtils.isEmpty(ip)) &#123;</span><br><span class="line">            log.debug(&quot;ip is null. valid result is false&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Matcher matcher = pattern.matcher(ip);</span><br><span class="line">        boolean isValid = matcher.matches();</span><br><span class="line">        log.debug(&quot;valid ip:&quot; + ip + &quot; result is: &quot; + isValid);</span><br><span class="line">        return isValid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getLastServerIpSegment() &#123;</span><br><span class="line">        String ip = getServerIP();</span><br><span class="line">        if (ip != null) &#123;</span><br><span class="line">            ip = ip.substring(ip.lastIndexOf(&#x27;.&#x27;) + 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ip = &quot;0&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getServerIP() &#123;</span><br><span class="line">        InetAddress inet;</span><br><span class="line">        try &#123;</span><br><span class="line">            inet = InetAddress.getLocalHost();</span><br><span class="line">            String hostAddress = inet.getHostAddress();</span><br><span class="line">            return hostAddress;</span><br><span class="line">        &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;127.0.0.1&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mail配置</title>
      <link href="/641601337f0b.html"/>
      <url>/641601337f0b.html</url>
      
        <content type="html"><![CDATA[<p>util</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import cn.zuohy.beans.Mail;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.apache.commons.lang3.StringUtils;</span><br><span class="line">import org.apache.commons.mail.EmailException;</span><br><span class="line">import org.apache.commons.mail.HtmlEmail;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class MailUtil &#123;</span><br><span class="line"></span><br><span class="line">    public static boolean send(Mail mail) &#123;</span><br><span class="line"></span><br><span class="line">        // TODO</span><br><span class="line">        String from = &quot;&quot;;</span><br><span class="line">        int port = 25;</span><br><span class="line">        String host = &quot;&quot;;</span><br><span class="line">        String pass = &quot;&quot;;</span><br><span class="line">        String nickname = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        HtmlEmail email = new HtmlEmail();</span><br><span class="line">        try &#123;</span><br><span class="line">            email.setHostName(host);</span><br><span class="line">            email.setCharset(&quot;UTF-8&quot;);</span><br><span class="line">            for (String str : mail.getReceivers()) &#123;</span><br><span class="line">                email.addTo(str);</span><br><span class="line">            &#125;</span><br><span class="line">            email.setFrom(from, nickname);</span><br><span class="line">            email.setSmtpPort(port);</span><br><span class="line">            email.setAuthentication(from, pass);</span><br><span class="line">            email.setSubject(mail.getSubject());</span><br><span class="line">            email.setMsg(mail.getMessage());</span><br><span class="line">            email.send();</span><br><span class="line">            log.info(&quot;&#123;&#125; 发送邮件到 &#123;&#125;&quot;, from, StringUtils.join(mail.getReceivers(), &quot;,&quot;));</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (EmailException e) &#123;</span><br><span class="line">            log.error(from + &quot;发送邮件到&quot; + StringUtils.join(mail.getReceivers(), &quot;,&quot;) + &quot;失败&quot;, e);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import lombok.*;</span><br><span class="line"></span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Description: 邮件</span><br><span class="line"> * User: dummmmmmmy</span><br><span class="line"> * Date: 2018-12-06</span><br><span class="line"> * Time: 23:16</span><br><span class="line"> */</span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@ToString</span><br><span class="line">@Builder</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class Mail &#123;</span><br><span class="line">    private String subject;</span><br><span class="line"></span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    private Set&lt;String&gt; receivers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MD5加密</title>
      <link href="/2605a2a5060e.html"/>
      <url>/2605a2a5060e.html</url>
      
        <content type="html"><![CDATA[<p>util</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.security.MessageDigest;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class MD5Util &#123;</span><br><span class="line"></span><br><span class="line">    public final static String encrypt(String s) &#123;</span><br><span class="line">        char hexDigits[] = &#123; &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27; &#125;;</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] btInput = s.getBytes();</span><br><span class="line">            // 获得MD5摘要算法的 MessageDigest 对象</span><br><span class="line">            MessageDigest mdInst = MessageDigest.getInstance(&quot;MD5&quot;);</span><br><span class="line">            // 使用指定的字节更新摘要</span><br><span class="line">            mdInst.update(btInput);</span><br><span class="line">            // 获得密文</span><br><span class="line">            byte[] md = mdInst.digest();</span><br><span class="line">            // 把密文转换成十六进制的字符串形式</span><br><span class="line">            int j = md.length;</span><br><span class="line">            char str[] = new char[j * 2];</span><br><span class="line">            int k = 0;</span><br><span class="line">            for (int i = 0; i &lt; j; i++) &#123;</span><br><span class="line">                byte byte0 = md[i];</span><br><span class="line">                str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf];</span><br><span class="line">                str[k++] = hexDigits[byte0 &amp; 0xf];</span><br><span class="line">            &#125;</span><br><span class="line">            return new String(str);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;generate md5 error, &#123;&#125;&quot;, s, e);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax(原生,JQ)</title>
      <link href="/102164869c4c.html"/>
      <url>/102164869c4c.html</url>
      
        <content type="html"><![CDATA[<h1 id="XMLHttpRequest发送请求"><a href="#XMLHttpRequest发送请求" class="headerlink" title="XMLHttpRequest发送请求"></a>XMLHttpRequest发送请求</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//1.获取a节点，并为其添加onclick响应函数</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;a&quot;</span>)[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//3.创建一个XMLHttpRequest对象  </span></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">//4.准备发送请求的数据：url</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">this</span>.href + <span class="string">&quot;?time=&quot;</span> + <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> method = <span class="string">&quot;GET&quot;</span>;</span><br><span class="line"><span class="comment">//5.调用XMLHttpRequest对象的open方法</span></span><br><span class="line">request.open(method, url);</span><br><span class="line"><span class="comment">//6.调用XMLHttpRequest对象的send方法</span></span><br><span class="line">request.send(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//7.为XMLHttpRequest对象添加onreadystatechange响应函数</span></span><br><span class="line">request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//8.判断响应是否完成：XMLHttpRequest对象的readyState属性值为4的时候</span></span><br><span class="line"><span class="keyword">if</span>(request.readyState == <span class="number">4</span>) &#123;</span><br><span class="line"><span class="comment">//9.再判断响应是否可用：XMLHttpRequest对象status属性为200</span></span><br><span class="line"><span class="keyword">if</span>(request.status == <span class="number">200</span> || request.status == <span class="number">304</span>) &#123;</span><br><span class="line"><span class="comment">//10.打印响应结果responseText</span></span><br><span class="line"><span class="built_in">console</span>.log(request.responseText);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.取消a节点的默认行为</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Jquery中的Ajax"><a href="#Jquery中的Ajax" class="headerlink" title="Jquery中的Ajax"></a>Jquery中的Ajax</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">$(<span class="string">&quot;a&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//url</span></span><br><span class="line"><span class="comment">//args :JSON格式</span></span><br><span class="line"><span class="comment">//function :回调函数：当响应结束时，回调函数被触发。响应结果在data中</span></span><br><span class="line"><span class="comment">//使用load方法处理Ajax</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">this</span>.href;</span><br><span class="line"><span class="keyword">var</span> args = &#123;</span><br><span class="line"><span class="string">&quot;time&quot;</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//结果是直接插入HTML节点中</span></span><br><span class="line">$(<span class="string">&quot;#con&quot;</span>).load(url, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用load方法处理Ajax,加上选择器</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">this</span>.href + <span class="string">&quot;h2 a&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> args = &#123;</span><br><span class="line"><span class="string">&quot;time&quot;</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">&#125;;</span><br><span class="line">$(<span class="string">&quot;#con&quot;</span>).load(url, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">//GET请求,返回结果在返回结果里面需要自己指定</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">this</span>.href;</span><br><span class="line"><span class="keyword">var</span> args = &#123;</span><br><span class="line"><span class="string">&quot;time&quot;</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">&#125;;</span><br><span class="line">$.get(url, args,</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">$(<span class="string">&quot;#con&quot;</span>).empty().append(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//POST请求,返回结果在返回结果里面需要自己指定</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">this</span>.href;</span><br><span class="line"><span class="keyword">var</span> args = &#123;</span><br><span class="line"><span class="string">&quot;time&quot;</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">&#125;;</span><br><span class="line">$.post(url, args,</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">$(<span class="string">&quot;#con&quot;</span>).empty().append(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="Json格式"><a href="#Json格式" class="headerlink" title="Json格式"></a>Json格式</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObject = &#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;guigui&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>: <span class="number">12</span>,</span><br><span class="line"><span class="string">&quot;address&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;city&quot;</span>: <span class="string">&quot;sc&quot;</span>,</span><br><span class="line"><span class="string">&quot;school&quot;</span>: <span class="string">&quot;sc&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;teaching&quot;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(jsonObject.name);</span><br><span class="line">alert(jsonObject.address.city);</span><br><span class="line"></span><br><span class="line">jsonObject.teaching();</span><br><span class="line"><span class="comment">//把字符串转为json</span></span><br><span class="line"><span class="keyword">var</span> jsonStr = <span class="string">&quot;&#123;&#x27;name&#x27;:&#x27;guigui&#x27;&#125;&quot;</span>;</span><br><span class="line">jsonStr = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span> + jsonStr + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">alert(jsonStr.name);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Html </tag>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA自定义后的快捷键-仿Eclipse</title>
      <link href="/d2d51dce913f.html"/>
      <url>/d2d51dce913f.html</url>
      
        <content type="html"><![CDATA[<ol><li>执行(run) alt+r</li><li>提示补全 (Class Name Completion) alt+/</li><li>单行注释 ctrl + /</li><li>多行注释 ctrl + shift + /</li><li>向下复制一行 (Duplicate Lines) ctrl+alt+down</li><li>删除一行或选中行 (delete line) ctrl+d</li><li>向下移动行(move statement down) alt+down</li><li>向上移动行(move statement up) alt+up</li><li>向下开始新的一行(start new line) shift+enter</li><li>向上开始新的一行 (Start New Line before current) ctrl+shift+enter</li><li>如何查看源码 (class) ctrl + 选中指定的结构 或 ctrl + shift + t</li><li>万能解错/生成返回值变量 alt + enter</li><li>退回到前一个编辑的页面 (back) alt + left</li><li>进入到下一个编辑的页面(针对于上条) (forward) alt + right</li><li>查看继承关系(type hierarchy) F4</li><li>格式化代码(reformat code) ctrl+shift+F</li><li>提示方法参数类型(Parameter Info) ctrl+alt+/</li><li>复制代码 ctrl + c</li><li>撤销 ctrl + z</li><li>反撤销 ctrl + y</li><li>剪切 ctrl + x</li><li>粘贴 ctrl + v</li><li>保存 ctrl + s</li><li>全选 ctrl + a</li><li>选中数行，整体往后移动 tab</li><li>选中数行，整体往前移动 shift + tab</li><li>查看类的结构：类似于 eclipse 的 outline ctrl+o</li><li>重构：修改变量名与方法名(rename) alt+shift+r</li><li>大写转小写/小写转大写(toggle case) ctrl+shift+y</li><li>生成构造器/get/set/toString alt +shift + s</li><li>查看文档说明(quick documentation) F2</li><li>收起所有的方法(collapse all) alt + shift + c</li><li>打开所有方法(expand all) alt+shift+x</li><li>打开代码所在硬盘文件夹(show in explorer) ctrl+shift+x</li><li>生成 try-catch 等(surround with) alt+shift+z</li><li>局部变量抽取为成员变量(introduce field) alt+shift+f</li><li>查找/替换(当前) ctrl+f</li><li>查找(全局) ctrl+h</li><li>查找文件 double Shift</li><li>查看类的继承结构图(Show UML Diagram) ctrl + shift + u</li><li>查看方法的多层重写结构(method hierarchy) ctrl+alt+h</li><li>添加到收藏(add to favorites) ctrl+alt+f</li><li>抽取方法(Extract Method) alt+shift+m</li><li>打开最近修改的文件(Recently Files) ctrl+E</li><li>关闭当前打开的代码栏(close) ctrl + w</li><li>关闭打开的所有代码栏(close all) ctrl + shift + w</li><li>快速搜索类中的错误(next highlighted error) ctrl + shift + q</li><li>选择要粘贴的内容(Show in Explorer) ctrl+shift+v 49 查找方法在哪里被调用(Call Hierarchy) ctrl+shift+h</li></ol><p><a href="IDEA2-20190406/%E5%BF%AB%E6%8D%B7%E9%94%AE.rar">快捷键包</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntelliJ IDEA </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA常用模板</title>
      <link href="/3494683249bc.html"/>
      <url>/3494683249bc.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">public class Test &#123;</span><br><span class="line">    //常用模板</span><br><span class="line">    //psvm</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //sout</span><br><span class="line">        System.out.println();</span><br><span class="line">//变种 soutp/soutm/soutv/xxx.sout</span><br><span class="line">        System.out.println(&quot;args = [&quot; + args + &quot;]&quot;);</span><br><span class="line">        System.out.println(&quot;Test.main&quot;);</span><br><span class="line">        System.out.println(&quot;args = &quot; + args);</span><br><span class="line">        int num = 0;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">//fori</span><br><span class="line">        int[] arr = new int[]&#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        //变种 iter/itar</span><br><span class="line">        for (int i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            int i1 = arr[i];</span><br><span class="line">            System.out.println(i1);</span><br><span class="line">        &#125;</span><br><span class="line">//list.for</span><br><span class="line">        ArrayList list = new ArrayList();</span><br><span class="line">        list.add(1);</span><br><span class="line">        list.add(2);</span><br><span class="line">        list.add(3);</span><br><span class="line">        for (Object o : list) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        //变种 list.fori/list.forr</span><br><span class="line">        for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">&#125;</span><br><span class="line">        for (int i = list.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">&#125;</span><br><span class="line">//ifn</span><br><span class="line">        ArrayList list2 = new ArrayList();</span><br><span class="line">        list2.add(1);</span><br><span class="line">        list2.add(2);</span><br><span class="line">        list2.add(3);</span><br><span class="line">        if (list2 == null) &#123;</span><br><span class="line">&#125;</span><br><span class="line">        //变种 inn/xxx.nn/xxx.null</span><br><span class="line">        if (list2 != null) &#123;</span><br><span class="line">&#125;</span><br><span class="line">        if (list2 != null) &#123;</span><br><span class="line">&#125;</span><br><span class="line">        if (list2 == null) &#123;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">//prsf</span><br><span class="line">    private static final int num = 0;</span><br><span class="line">    //psf</span><br><span class="line">    public static final int num2 = 0;</span><br><span class="line">    //psgi</span><br><span class="line">    public static final int i = 0;</span><br><span class="line">    //psgs</span><br><span class="line">    public static final String s = &quot;0&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntelliJ IDEA </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solr</title>
      <link href="/cf7513efc8a3.html"/>
      <url>/cf7513efc8a3.html</url>
      
        <content type="html"><![CDATA[<h1 id="索引搜索"><a href="#索引搜索" class="headerlink" title="索引搜索"></a>索引搜索</h1><ul><li>环境配置<ul><li>下载解压</li><li>solr.bat<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">e:</span><br><span class="line">cd E:\MySVN\repository\solr-7.5.0\bin</span><br><span class="line">solr start -p 8989</span><br></pre></td></tr></table></figure></li><li>运行<br><code>http://localhost:8989/solr/#/~cores </code></li><li>创建core（报错）</li><li>solr-7.5.0\server\solr\configsets_default目录下，把conf文件夹复制到solr-7.5.0\server\solr\new_core 目录下，然后再执行Add core</li></ul></li><li>数据库配置<ul><li>Jar包<br>JDBC驱动<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/cf7513efc8a3/1.png"></li><li>放入server\solr-webapp\webapp\WEB-INF\lib</li><li>\example\example-DIH\solr\db\conf覆盖\server\solr\test_core\conf</li><li>修改db-data-config.xml<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dataConfig&gt;</span><br><span class="line">&lt;dataSource driver=&quot;com.mysql.cj.jdbc.Driver&quot; url=&quot;jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;amp;characterEncoding=utf-8&quot; user=&quot;root&quot; password=&quot;123456&quot;/&gt;</span><br><span class="line">&lt;document&gt;</span><br><span class="line">    &lt;entity name=&quot;user&quot; query=&quot;select * from user&quot; pk=&quot;user_id&quot;&gt;</span><br><span class="line">            &lt;field column=&quot;user_id&quot; name=&quot;userId&quot; /&gt;</span><br><span class="line">&lt;field column=&quot;user_name&quot; name=&quot;userName&quot; /&gt;</span><br><span class="line">&lt;field column=&quot;user_pass&quot; name=&quot;userPass&quot; /&gt;</span><br><span class="line">&lt;field column=&quot;user_time&quot; name=&quot;userTime&quot; /&gt;</span><br><span class="line">    &lt;/entity&gt;</span><br><span class="line">&lt;/document&gt;</span><br><span class="line">&lt;/dataConfig&gt;</span><br><span class="line">配置说明：</span><br><span class="line">dataSource--&gt;数据库连接，用户名密码配置</span><br><span class="line">entity--&gt;sql定义</span><br><span class="line">field--&gt;字段定义，column对应数据库字段，name对应solr的索引字段名</span><br></pre></td></tr></table></figure></li><li>修改managed-schema<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;field name=&quot;userId&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot; multiValued=&quot;false&quot; /&gt; </span><br><span class="line">&lt;field name=&quot;userName&quot; type=&quot;text_general&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;</span><br><span class="line">&lt;field name=&quot;userPass&quot; type=&quot;text_general&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;</span><br><span class="line">&lt;field name=&quot;userTime&quot; type=&quot;pdate&quot; indexed=&quot;false&quot; stored=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>注意：我们copy来的配置文件中有一些关键字已经配置了，如id，name，那就不需要重新配置field，只需要配置没有的。</p><p>如果你的表主键id不是叫id，那么你定义的field需要指定required=”true”,并把默认的id的required=”true”属性去掉，并把<uniqueKey>id</uniqueKey>修改成你的主键id值，否则数据导入不进去。</p><p>说明：因为只是做个基础的搜索业务，没有精细该schema文件，精益求精的小伙伴可以把冗余字段都干掉试试。</p><p>到此，配置完成，接下来我们操作导入数据</p><h2 id="清空数据"><a href="#清空数据" class="headerlink" title="清空数据"></a>清空数据</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/cf7513efc8a3/2.png"></p><p><code>&lt;delete&gt;&lt;query&gt;*:*&lt;/query&gt;&lt;/delete&gt;&lt;commit/&gt;</code></p><h1 id="增量更新索引"><a href="#增量更新索引" class="headerlink" title="增量更新索引"></a>增量更新索引</h1><ul><li>准备jar包</li></ul><p><a href="solr-20190406/apache-solr-dataimportscheduler-1.4.jar">下载</a><br>放入\server\solr-webapp\webapp\WEB-INF</p><ul><li>添加监听</li></ul><p>打开web.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line"> &lt;listener-class&gt; org.apache.solr.handler.dataimport.scheduler.ApplicationListener</span><br><span class="line"> &lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure><ul><li>增加dataimport.properties配置</li></ul><p>增加增量导入配置文件<br>重点是目录<br>是在\server\solr目录下创建conf文件再在下面创建dataimport.properties文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#################################################</span><br><span class="line">#                                               #</span><br><span class="line">#       dataimport scheduler properties         #</span><br><span class="line">#                                               #</span><br><span class="line">#################################################</span><br><span class="line"></span><br><span class="line">#  to sync or not to sync</span><br><span class="line">#  1 - active; anything else - inactive</span><br><span class="line">syncEnabled=1</span><br><span class="line"></span><br><span class="line">#  which cores to schedule</span><br><span class="line">#  in a multi-core environment you can decide which cores you want syncronized</span><br><span class="line">#  leave empty or comment it out if using single-core deployment</span><br><span class="line">#  修改成你所使用的core</span><br><span class="line">syncCores=my_core</span><br><span class="line"></span><br><span class="line">#  solr server name or IP address</span><br><span class="line">#  [defaults to localhost if empty]</span><br><span class="line">server=localhost</span><br><span class="line"></span><br><span class="line">#  solr server port</span><br><span class="line">#  [defaults to 80 if empty]</span><br><span class="line">#  安装solr的端口</span><br><span class="line">port=8983</span><br><span class="line"></span><br><span class="line">#  application name/context</span><br><span class="line">#  [defaults to current ServletContextListener&#x27;s context (app) name]</span><br><span class="line">webapp=solr</span><br><span class="line"></span><br><span class="line">#  URL params [mandatory]</span><br><span class="line">#  remainder of URL</span><br><span class="line">#  这里改成下面的形式，solr同步数据时请求的链接</span><br><span class="line">params=/dataimport?command=delta-import&amp;clean=false&amp;commit=true</span><br><span class="line"></span><br><span class="line">#  schedule interval</span><br><span class="line">#  number of minutes between two runs</span><br><span class="line">#  [defaults to 30 if empty]</span><br><span class="line">#这里是设置定时任务的，单位是分钟，也就是多长时间你检测一次数据同步，根据项目需求修改</span><br><span class="line">#  开始测试的时候为了方便看到效果，时间可以设置短一点</span><br><span class="line">interval=1</span><br><span class="line"></span><br><span class="line">#  重做索引的时间间隔，单位分钟，默认7200，即5天; </span><br><span class="line">#  为空,为0,或者注释掉:表示永不重做索引</span><br><span class="line">reBuildIndexInterval=7200</span><br><span class="line"></span><br><span class="line">#  重做索引的参数</span><br><span class="line">reBuildIndexParams=/select?qt=/dataimport&amp;command=full-import&amp;clean=true&amp;commit=true</span><br><span class="line"></span><br><span class="line">#  重做索引时间间隔的计时开始时间，第一次真正执行的时间=reBuildIndexBeginTime+reBuildIndexInterval*60*1000；</span><br><span class="line">#  两种格式：2012-04-11 01:00:00 或者  01:00:00，后一种会自动补全日期部分为服务启动时的日期</span><br><span class="line">reBuildIndexBeginTime=01:00:00</span><br></pre></td></tr></table></figure><ul><li>修改db-data-config.xml</li></ul><p>需要在entity配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deltaImportQuery=&quot;select * from user where id=&#x27;$&#123;dataimporter.delta.user_id&#125;&#x27;&quot;</span><br><span class="line">deltaQuery=&quot;select * from user where `user_time` &gt; &#x27;$&#123;dataimporter.last_index_time&#125;&#x27;&quot;</span><br></pre></td></tr></table></figure><p>如叫studentId，那么，这个取变量就应该写成${dataimporter.delta.studentId}<br>${dataimporter.last_index_time}  固定写法，更新的判断条件，上一次的修改时间需要大于上一次索引的更新时间。<br>需要user_time字段</p><h1 id="分词技术"><a href="#分词技术" class="headerlink" title="分词技术"></a>分词技术</h1><ul><li>IK分词的jar包</li></ul><p><a href="solr-20190406/ikanalyzer-solr6.5.zip">下载</a></p><ul><li>把ik-analyzer-solr5-5.x.jar放入\server\solr-webapp\webapp\WEB-INF\lib</li><li>修改\server\solr\new_core\conf 目录下的managed-schema 文件<br>添加<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt;</span><br><span class="line">&lt;analyzer type=&quot;index&quot; useSmart=&quot;false&quot; class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt;</span><br><span class="line">&lt;analyzer type=&quot;query&quot; useSmart=&quot;false&quot; class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt;</span><br><span class="line">&lt;/fieldType&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 定义ik分词器 --&gt;</span><br><span class="line">&lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt;</span><br><span class="line">&lt;analyzer type=&quot;index&quot;&gt;</span><br><span class="line">     &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;false&quot;/&gt;</span><br><span class="line">     &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;</span><br><span class="line">&lt;/analyzer&gt;</span><br><span class="line">&lt;analyzer type=&quot;query&quot;&gt;</span><br><span class="line">     &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;true&quot;/&gt;</span><br><span class="line">     &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;</span><br><span class="line">&lt;/analyzer&gt;</span><br><span class="line">&lt;/fieldType&gt;</span><br></pre></td></tr></table></figure>name=”text_ik”,分词器名称，在后面的filed定义的时候，可以直接引用。<br>如，type定义为”text_ik”，则代表该字段将进行分词索引<br><code>&lt;field name=&quot;userName&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;</code></li></ul><h1 id="Java调用接口"><a href="#Java调用接口" class="headerlink" title="Java调用接口"></a>Java调用接口</h1><ul><li>pom.xml</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.solr&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;solr-solrj&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;7.5.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>调用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void solrQuery() throws IOException, SolrServerException &#123;</span><br><span class="line"> String solrUrl = &quot;http://127.0.0.1:8983/solr/new_core&quot;; </span><br><span class="line">HttpSolrClient solrClient = new HttpSolrClient.Builder(solrUrl).build(); // 创建搜索对象 </span><br><span class="line">SolrQuery query = new SolrQuery(); // 设置搜索条件 </span><br><span class="line">query.set(&quot;q&quot;,&quot;name:张三是好人&quot;); // 分页参数 </span><br><span class="line">query.setStart(0); // 设置每页显示多少条 </span><br><span class="line">query.setRows(10); //发起搜索请求 </span><br><span class="line">QueryResponse response = solrClient.query(query); // 查询结果 </span><br><span class="line">SolrDocumentList docs = response.getResults(); // 查询结果总数 </span><br><span class="line">long count= docs.getNumFound();</span><br><span class="line">System.out.println(&quot;总条数为&quot;+count+&quot;条&quot;); </span><br><span class="line">for (SolrDocument doc : docs) &#123; </span><br><span class="line">System.out.println(&quot;id:&quot;+ doc.get(&quot;id&quot;) + &quot;,name:&quot;+ doc.get(&quot;name&quot;) + &quot;,uuid:&quot;+ doc.get(&quot;uuid&quot;));</span><br><span class="line">&#125; </span><br><span class="line">solrClient.close(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Solr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thread Local</title>
      <link href="/4264568384dd.html"/>
      <url>/4264568384dd.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>高并发处理 : 在当前进程取出对象，不会冲突<br>放入的东西<br>各个线程保存的东西是分开只与进程有关系<br>每个进程会处理自己的内容</p></blockquote><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLocal的是一个本地线程副本变量工具类。</p><p>主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。</p><span id="more"></span><p>原理大佬说的很清楚了》<a href="https://www.jianshu.com/p/98b68c97df9b">https://www.jianshu.com/p/98b68c97df9b</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">   private static final ThreadLocal&lt;SysUser&gt; userHolder = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   private static final ThreadLocal&lt;HttpServletRequest&gt; requestHolder = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   public static void add(SysUser sysUser)&#123;</span><br><span class="line">       userHolder.set(sysUser);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void add(HttpServletRequest request)&#123;</span><br><span class="line">       requestHolder.set(request);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static SysUser getCurrentUser()&#123;</span><br><span class="line">       return userHolder.get();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static HttpServletRequest getCurrentRequest()&#123;</span><br><span class="line">       return requestHolder.get();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void remove()&#123;</span><br><span class="line">       userHolder.remove();</span><br><span class="line">       requestHolder.remove();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数组</title>
      <link href="/df5068bb57d2.html"/>
      <url>/df5068bb57d2.html</url>
      
        <content type="html"><![CDATA[<h1 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h1><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"> // 这样拷贝数组没有隔离性</span><br><span class="line"> String[] ss1 = &#123; &quot;1&quot;, &quot;2&quot;, &quot;3&quot; &#125;;</span><br><span class="line"> // 把ss1对数组的引用传递给变量ss2,两个变量指向的是用一个数组</span><br><span class="line"> String[] ss2 = ss1;</span><br><span class="line"> ss2[0] = &quot;4&quot;;</span><br><span class="line"> System.out.println(Arrays.toString(ss1));</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// 方法1</span><br><span class="line">// 推荐</span><br><span class="line">String[] ss1 = &#123; &quot;1&quot;, &quot;2&quot;, &quot;3&quot; &#125;;</span><br><span class="line">// 通过new关键字再内存中开辟一块空间，ss2指向的是新的数组对象</span><br><span class="line">String[] ss2 = new String[ss1.length];</span><br><span class="line">for (int i = 0; i &lt; ss2.length; i++) &#123;</span><br><span class="line">ss2[i] = ss1[i];</span><br><span class="line">&#125;</span><br><span class="line">ss2[0] = &quot;张三&quot;;</span><br><span class="line">System.out.println(Arrays.toString(ss1));</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// 方法2</span><br><span class="line">// API提供的方式，底层用C++写的，所以速度很快，比for循环的效率高</span><br><span class="line">String[] ss1 = &#123; &quot;1&quot;, &quot;2&quot;, &quot;3&quot; &#125;;</span><br><span class="line">String[] ss2 = new String[ss1.length];</span><br><span class="line">System.arraycopy(ss1, 0, ss2, 0, ss1.length);</span><br><span class="line">/**</span><br><span class="line"> * (Object src,int srcPos,Object dest,int destPos,int length)</span><br><span class="line"> * src:源数组,srcPos:源数组要复制的起始位置;dest:目的数组;destPos:目的数组放置的起始位置;length:复制的长度</span><br><span class="line"> * 注意：src and dest都必须是同类型或者可以进行转换类型的数组．</span><br><span class="line"> * 有趣的是这个函数可以实现自己到自己复制，比如：</span><br><span class="line"> * int[] fun =&#123;0,1,2,3,4,5,6&#125;; </span><br><span class="line"> * System.arraycopy(fun,0,fun,3,3);</span><br><span class="line"> * 则结果为：&#123;0,1,2,0,1,2,6&#125;;</span><br><span class="line"> */</span><br><span class="line">System.out.println(Arrays.toString(ss2));</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//方法3</span><br><span class="line">String[] ss1 = &#123; &quot;1&quot;, &quot;2&quot;, &quot;3&quot; &#125;;</span><br><span class="line">String[] ss2 = Arrays.copyOf(ss1, ss1.length);</span><br><span class="line">/**</span><br><span class="line"> *该方法对应不同的数据类型都有各自的重载方法</span><br><span class="line"> *original - 要复制的数组</span><br><span class="line"> *newLength - 要返回的副本的长度</span><br><span class="line"> *newType - 要返回的副本的类型</span><br><span class="line"> *仔细观察发现，copyOf()内部调用了System.arraycopy()方法</span><br><span class="line"> *区别在于：</span><br><span class="line"> *arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置</span><br><span class="line"> *copyOf()是系统自动在内部新建一个数组，调用arraycopy()将original内容复制到copy中去，并且长度为newLength。返回copy; 即将原数组拷贝到一个长度为newLength的新数组中，并返回该数组。</span><br><span class="line"> *总结</span><br><span class="line"> *Array.copyOf()可以看作是受限的System.arraycopy()，它主要是用来将原数组全部拷贝到一个新长度的数组，适用于数组扩容。</span><br><span class="line"> */</span><br><span class="line">System.out.println(Arrays.toString(ss2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String[] ss1 = &#123; &quot;1&quot;, &quot;2&quot;, &quot;3&quot; &#125;;</span><br><span class="line">ss1 = Arrays.copyOf(ss1, ss1.length + 2);</span><br><span class="line">System.out.println(ss1.length);</span><br><span class="line">System.out.println(Arrays.toString(ss1));</span><br><span class="line">// 5</span><br><span class="line">// [1, 2, 3, null, null]</span><br><span class="line">&#125;</span><br><span class="line">常见面试题: 统计字符的位置</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String str = &quot;统计一个字符再字符串中的所有位置&quot;;</span><br><span class="line">int[] arry = countAll(str, &#x27;字&#x27;);</span><br><span class="line">System.out.println(Arrays.toString(arry));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int[] countAll(String str, char ch) &#123;</span><br><span class="line">int[] array = &#123;&#125;;// 创建一个空数组</span><br><span class="line">for (int i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">if (ch == str.charAt(i)) &#123;</span><br><span class="line">// charAt(i)遍历String每个字符</span><br><span class="line">array = Arrays.copyOf(array, array.length + 1);</span><br><span class="line">// 扩容</span><br><span class="line">array[array.length - 1] = i;</span><br><span class="line">// 刚扩容的位置</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//Java提供排序方法</span><br><span class="line">int[] ss1= &#123;2,3,1&#125;;</span><br><span class="line">Arrays.sort(ss1);</span><br><span class="line">System.out.println(Arrays.toString(ss1));</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// 方法1</span><br><span class="line">// 冒泡排序，前一个数与后一个数进行比较</span><br><span class="line">int[] ss1 = &#123; 2, 3, 1 &#125;;</span><br><span class="line">int temp = 0;</span><br><span class="line">for (int i = 0; i &lt; ss1.length - 1; i++) &#123;</span><br><span class="line">for (int j = i + 1; j &lt; ss1.length; j++) &#123;</span><br><span class="line">if (ss1[j] &lt; ss1[i]) &#123;</span><br><span class="line">temp = ss1[i];</span><br><span class="line">ss1[i] = ss1[j];</span><br><span class="line">ss1[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(ss1));</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// 方法2</span><br><span class="line">// 选择排序</span><br><span class="line">int[] ss1 = &#123; 2, 3, 1 &#125;;</span><br><span class="line">int temp = 0;</span><br><span class="line">for (int i = 0; i &lt; ss1.length - 1; i++) &#123;</span><br><span class="line">int min = i;</span><br><span class="line">for (int j = i + 1; j &lt; ss1.length; j++) &#123;</span><br><span class="line">if (ss1[min] &gt; ss1[j]) &#123;</span><br><span class="line">// 找到比选定下标小的数</span><br><span class="line">min = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (min != i) &#123;</span><br><span class="line">// 交换位置</span><br><span class="line">temp = ss1[i];</span><br><span class="line">ss1[i] = ss1[min];</span><br><span class="line">ss1[min] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(ss1));</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// 方法3</span><br><span class="line">// 插入排序</span><br><span class="line">int[] ss1 = &#123; 2, 3, 1 &#125;;</span><br><span class="line">int temp = 0;</span><br><span class="line">for (int i = 1; i &lt; ss1.length; i++) &#123;</span><br><span class="line">for (int j = i; j &gt; 0; j--) &#123;</span><br><span class="line">if (ss1[j] &lt; ss1[j - 1]) &#123;</span><br><span class="line">temp = ss1[j];</span><br><span class="line">ss1[j] = ss1[j - 1];</span><br><span class="line">ss1[j - 1] = temp;</span><br><span class="line">&#125; else</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(ss1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 有序数组,二分查找</span><br><span class="line">static int bingarySerarch(int[] array, int num) &#123;</span><br><span class="line">int low = 0;</span><br><span class="line">int high = array.length - 1;</span><br><span class="line">while (low &lt;= high) &#123;</span><br><span class="line">int mid = (low + high) / 2;</span><br><span class="line">if (num &gt; array[mid]) &#123;</span><br><span class="line">low = mid + 1;</span><br><span class="line">&#125; else if (num &lt; array[mid]) &#123;</span><br><span class="line">high = mid - 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">// 无序数组，采用遍历，也可以先排序，后采用二分查找</span><br><span class="line">static int search(int[] array, int num) &#123;</span><br><span class="line">int index = -1;</span><br><span class="line">for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">if (num == array[i]) &#123;</span><br><span class="line">index = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return index;</span><br><span class="line">&#125;</span><br><span class="line">// Java 提供的查找方式。查看源码，它的本质就是二分查找</span><br><span class="line">static void test(int[] array, int num) &#123;</span><br><span class="line">/**</span><br><span class="line"> * binarySearch(Object[], Object key) a: 要搜索的数组 key：要搜索的值</span><br><span class="line"> * 如果key在数组中，则返回搜索值的索引；否则返回-1或“-”（插入点）。插入点是索引键将要插入数组的那一点，即第一个大于该键的元素的索引。 技巧： [1]</span><br><span class="line"> * 搜索值不是数组元素，且在数组范围内，从1开始计数，得“ - 插入点索引值”； [2] 搜索值是数组元素，从0开始计数，得搜索值的索引值； [3]</span><br><span class="line"> * 搜索值不是数组元素，且大于数组内元素，索引值为 – (length + 1); [4] 搜索值不是数组元素，且小于数组内元素，索引值为 – 1。</span><br><span class="line"> */</span><br><span class="line">int index = Arrays.binarySearch(array, 8);</span><br><span class="line">System.out.println(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心数据结构(List、Map、Set)原理与使用技巧</title>
      <link href="/378fe56bd246.html"/>
      <url>/378fe56bd246.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>JDK提供了一组主要的数据结构实现，如List、Map、Set等常用数据结构。这些数据都继承自java.util.Collection接口，并位于java.util包内</p></blockquote><h1 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h1><p>最重要的三种List接口实现：ArrayList、Vector、LinkedList。它们的类图如下：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/378fe56bd246/1.png"></p><p>可以看到，3种List均来自AbstratList的实现。</p><p>而AbstratList直接实现了List接口，并扩展自AbstratCollection。</p><p>ArrayList和Vector使用了数组实现，可以认为，ArrayList封装了对内部数组的操作。比如向数组中添加、删除、插入新的元素或数组的扩展和重定义。对ArrayList或者Vector的操作，等价于对内部对象数组的操作。</p><p>ArrayList和Vector几乎使用了相同的算法，它们的唯一区别可以认为是对多线程的支持。ArrayList没有对一个方法做线程同步，因此不是线程安全的。Vector中绝大多数方法都做了线程同步，是一种线程安全的实现。因此ArrayList和Vector的性能特性相差无几。</p><p>LinkedList使用了循环双向链表数据结构。LinkedList由一系列表项连接而成。一个表项总是包含3个部分：元素内容、前驱表项和后驱表项。如图所示：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/378fe56bd246/2.png"></p><p>LinkedList的表项源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item = element;</span><br><span class="line">        this.next = next;</span><br><span class="line">        this.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论LinkedList是否为空，链表都有一个header表项，它既是链表的开始，也表示链表的结尾。它的后驱表项便是链表的第一个元素，前驱表项便是链表的最后一个元素。如图所示：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/378fe56bd246/3.png"></p><p>下面比较下ArrayList和LinkedList的不同。</p><h2 id="增加元素到列表尾端"><a href="#增加元素到列表尾端" class="headerlink" title="增加元素到列表尾端"></a>增加元素到列表尾端</h2><p>对于ArrayList来说，只要当前容量足够大，add()操作的效率是非常高的。</p><p>只有当ArrayList对容量的需求超过当前数组的大小时，才需要进行扩容。扩容会进行大量的数组复制操作。而复制时最终调用的是System.arraycopy()方法，因此，add()效率还是相当高的。</p><p>LinkedList由于使用了链表的结构，因此不需要维护容量的大小。这点比ArrayList有优势，不过，由于每次元素增加都需要新建Node对象，并进行更多的赋值操作。在频繁的系统调用中，对性能会产生一定影响。</p><h2 id="插入元素到列表任意位置"><a href="#插入元素到列表任意位置" class="headerlink" title="插入元素到列表任意位置"></a>插入元素到列表任意位置</h2><p>ArrayList是基于数组实现的，而数组是一块连续的内存空间，每次插入操作，都会进行一次数组复制。大量的数组复制会导致系统性能低下。</p><p>LinkedList是基于链表实现的，在任意位置插入和在尾端增加是一样的。所以，如果系统应用需要对List对象在任意位置进行频繁的插入操作，可以考虑用LinkedList替代ArrayList。</p><h2 id="容量参数"><a href="#容量参数" class="headerlink" title="容量参数"></a>容量参数</h2><p>容量参数是ArrayList 和 Vector等基于数组的List的特有性能参数，它表示初始数组的大小。</p><p>合理的设置容量参数，可以减少数组扩容，提升系统性能。</p><p>默认ArrayList的数组初始大小为10。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br></pre></td></tr></table></figure><h2 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h2><p>常用的三种列表遍历方式：ForEach操作、迭代器和for循环。</p><p>对于ForEach操作，反编译可知实际上是将ForEach循环体作为迭代器处理。不过ForEach比自定义的迭代器多了一步赋值操作，性能不如直接使用迭代器的方式。</p><p>使用For循环通过随机访问遍历列表，ArrayList表现很好，速度最快；但是LinkedList的表现非常差，应避免使用，这是因为对LinkedList的随机访问时，总会进行一次列表的遍历操作。</p><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><p>Map是一种非常常用的数据结构。围绕着Map接口，最主要的实现类有Hashtable, HashMap, LinkedHashMap 和 TreeMap，在Hashtable中，还有Properties 类的实现。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/378fe56bd246/4.png"></p><p>Hashtable和hashMap的区别在于Hashtable的大部分方法都做了线程同步，而HashMap没有，</p><p>因此，Hashtable是线程安全的，HashMap不是。</p><p>其次，Hashtable 不允许key或value使用null值，而HashMap可以。</p><p>第三，它们在内部对key的hash算法和hash值到内存索引的映射算法不同。</p><p>由于HashMap使用广泛，本文以HashMap为例，阐述它的实现原理。</p><h2 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h2><p>简单来说，HashMap就是将key做hash算法，然后将hash值映射到内存地址，直接取得key所对应的数据。</p><p>在HashMap中，底层数据结构使用的是数组。所谓的内存地址，就是数组的下标索引。</p><p>用代码简单表示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object[key_hash] = value;</span><br></pre></td></tr></table></figure><h2 id="Hash冲突"><a href="#Hash冲突" class="headerlink" title="Hash冲突"></a>Hash冲突</h2><p>当需要存放的两个元素1和2经hash计算后，发现对应在内存中的同一个地址。此时HashMap又会如何处理以保证数据的完整存放？</p><p>在HashMap的底层使用数组，但数组内的元素不是简单的值，而是一个Entity类的对象。每一个Entity表项包括key，value，next，hash几项。注意这里的next部分，它指向另外一个Entity。</p><p>当put()操作有冲突时，新的Entity会替换原有的值，为了保证旧值不丢失，会将next指向旧值。这便实现了在一个数组空间内存放多个值项。因此，HashMap实际上是一个链表的数组。</p><p>而在进行get()操作时，如果定位到的数组元素不含链表（当前entry的next指向null），则直接返回；如果定位到的数组元素包含链表，则需要遍历链表，通过key对象的equals方法逐一比对查找。</p><h2 id="容量参数-1"><a href="#容量参数-1" class="headerlink" title="容量参数"></a>容量参数</h2><p>和ArrayList一样，基于数组的结构，不可避免的需要在数组空间不足时，进行扩展。而数组的重组比较耗时，因此对其做一定的优化很有必要了。</p><p>HashMap提供了两个可以指定初始化大小的构造函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashMap(int initialCapacity) </span><br><span class="line">          构造一个带指定初始容量和默认负载因子 (0.75) 的空 HashMap。</span><br><span class="line"></span><br><span class="line">HashMap(int initialCapacity, float loadFactor) </span><br><span class="line">          构造一个带指定初始容量和负载因子的空 HashMap。</span><br></pre></td></tr></table></figure><p>其中，HashMap会使用大于等于initialCapacity并且是2的指数次幂的最小的整数作为内置数组的大小。</p><p>负载因子又叫做填充比，它是介于0和1之间的浮点数。</p><p>负载因子 = 实际元素个数 / 内部数组总大小</p><p>负载因子的作用就是决定HashMap的阈值（threshold）。</p><p>阈值 = 数组总容量 × 负载因子</p><p>当HashMap的实际容量超过阈值便会进行扩容，每次扩容将新的数组大小设置为原大小的1.5倍。</p><p>默认情况下，HashMap的初始大小是16，负载因子为0.75。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br></pre></td></tr></table></figure><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>LinkedHashMap继承自HashMap，因此，它具备了HashMap的优良特性，并在此基础上，LinkedHashMap又在内部增加了一个链表，用以存放元素的顺序。</p><p>因此，LinkedHashMap可以简单理解为一个维护了元素次序表的HashMap.</p><p>LinkedHashMap提供两种类型的顺序：一是元素插入时的顺序；二是最近访问的顺序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) </span><br><span class="line">          构造一个带指定初始容量、负载因子和排序模式的空 LinkedHashMap 实例</span><br></pre></td></tr></table></figure><p>其中accessOrder为true时，按照元素最后访问时间排序；当accessOrder为false 时，按照插入顺序排序。默认为 false 。</p><p>在内部实现中，LinkedHashMap通过继承HashMap.Entity类，实现LinkedHashMap.Entity，为HashMap.Entity增加了before和after属性用以记录某一表项的前驱和后继，并构成循环链表。</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap可以简单理解为一种可以进行排序的Map实现。与LinkedHashMap不同，LinkedHashMap是根据元素增加或者访问的先后顺序进行排序，而TreeMap则根据元素的Key进行排序。为了确定Key的排序算法，可以使用两种方式指定：</p><ul><li>在TreeMap的构造函数中注入一个Comparator：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TreeMap(Comparator&lt;? super K&gt; comparator) </span><br></pre></td></tr></table></figure><ul><li>使用一个实现了 Comparable 接口的 Key。</li></ul><p>TreeMap的内部实现是基于红黑树的。红黑树是一种平衡查找树，这里不做过多介绍。</p><p>TreeMap 其它排序接口如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">subMap(K fromKey, K toKey) </span><br><span class="line">          返回此映射的部分视图，其键值的范围从 fromKey（包括）到 toKey（不包括）。</span><br><span class="line"></span><br><span class="line">tailMap(K fromKey) </span><br><span class="line">          返回此映射的部分视图，其键大于等于 fromKey。</span><br><span class="line"></span><br><span class="line">firstKey() </span><br><span class="line">          返回此映射中当前第一个（最低）键。</span><br><span class="line"></span><br><span class="line">headMap(K toKey) </span><br><span class="line">          返回此映射的部分视图，其键值严格小于 toKey。</span><br><span class="line"></span><br><span class="line">一个简单示例如下：</span><br><span class="line">public class MyKey implements Comparable&lt;MyKey&gt; &#123;</span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    public MyKey(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(MyKey o) &#123;</span><br><span class="line">        if (o.id &lt; this.id)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else if (o.id &gt; this.id)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyKey myKey1 = new MyKey(1);</span><br><span class="line">        MyKey myKey2 = new MyKey(2);</span><br><span class="line">        MyKey myKey3 = new MyKey(3);</span><br><span class="line">        Map&lt;MyKey,Object&gt; map = new TreeMap&lt;&gt;();</span><br><span class="line">        map.put(myKey1,&quot;一号&quot;);</span><br><span class="line">        map.put(myKey3,&quot;三号&quot;);</span><br><span class="line">        map.put(myKey2,&quot;二号&quot;);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;MyKey&gt; iterator = map.keySet().iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(map.get(iterator.next()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h1><p>Set并没有在Collection接口之上增加额外的操作，Set集合中的元素是不能重复的。<br>其中最为重要的是HashSet、LinkedHashSet、TreeSet 的实现。这里不再一一赘述，因为所有的这些Set实现都只是对应的Map的一种封装而已。</p><h1 id="优化集合访问代码"><a href="#优化集合访问代码" class="headerlink" title="优化集合访问代码"></a>优化集合访问代码</h1><h2 id="分离循环中被重复调用的代码"><a href="#分离循环中被重复调用的代码" class="headerlink" title="分离循环中被重复调用的代码"></a>分离循环中被重复调用的代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">举个例子，当我们要使用for循环遍历集合时</span><br><span class="line">for (int i =0;i&lt;collection.size();i++)&#123;</span><br><span class="line">    //.....</span><br><span class="line">&#125;</span><br><span class="line">很明显，每次循环都会调用size()方法，并且每次都会返回相同的数值。分离所有类似的代码对提升循环性能有着积极地意义。因此，可以将上段代码改造成</span><br><span class="line">int size= collection.size();</span><br><span class="line">for (int i =0;i&lt;size;i++)&#123;</span><br><span class="line">    //.....</span><br><span class="line">&#125;</span><br><span class="line">当元素的数量越多时，这样的处理就越有意义。</span><br></pre></td></tr></table></figure><h2 id="省略相同的操作"><a href="#省略相同的操作" class="headerlink" title="省略相同的操作"></a>省略相同的操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">假设我们有一段类似的操作如下</span><br><span class="line">int size= collection.size();</span><br><span class="line">for (int i =0;i&lt;size;i++)&#123;</span><br><span class="line">    if (list.get(i)==1||list.get(i)==2||list.get(i)==3)&#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">虽然每次循环调用get(i)的返回值不同，但在同一次调用中，结果是相同的，因此可以提取这些相同的操作。</span><br><span class="line">int size= collection.size();</span><br><span class="line">int k=0;</span><br><span class="line">for (int i =0;i&lt;size;i++)&#123;</span><br><span class="line">    if ((k = list.get(i))==1||k==2||k==3)&#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="减少方法调用"><a href="#减少方法调用" class="headerlink" title="减少方法调用"></a>减少方法调用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">方法调用是需要消耗系统堆栈的，如果可以，则尽量访问内部元素，而不要调用对应的接口，函数调用是需要消耗系统资源的，直接访问元素会更高效。</span><br><span class="line">假设上面的代码是Vector.class的子类的部分代码，那么可以这么改写</span><br><span class="line">int size = this.elementCount;</span><br><span class="line">Object k=null;</span><br><span class="line">for (int i =0;i&lt;size;i++)&#123;</span><br><span class="line">    if ((k = elementData[i])==&quot;1&quot;||k==&quot;2&quot;||k==&quot;3&quot;)&#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">可以看到，原本的 size() 和 get() 方法被直接替代为访问原始变量，这对系统性能的提升是非常有用的。</span><br></pre></td></tr></table></figure><h1 id="RandomAccess接口"><a href="#RandomAccess接口" class="headerlink" title="RandomAccess接口"></a>RandomAccess接口</h1><p>RandomAccess接口是一个标志接口，本身并没有提供任何方法，任何实现RandomAccess接口的对象都可以认为是支持快速随机访问的对象。此接口的主要目的是标识那些可以支持快速随机访问的List实现。</p><p>在JDK中，任何一个基于数组的List实现都实现了RandomAccess接口，而基于链表的实现则没有。这很好理解，只有数组能够快速随机访问，（比如：通过 object[5]，object[6]可以直接查找并返回对象），而对链表的随机访问需要进行链表的遍历。</p><p>在实际操作中，可以根据list instanceof RandomAccess来判断对象是否实现 RandomAccess接口，从而选择是使用随机访问还是iterator迭代器进行访问。</p><p>在应用程序中，如果需要通过索引下标对 List 做随机访问，尽量不要使用 LinkedList，ArrayList和Vector都是不错的选择。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JQuery-A标签</title>
      <link href="/bef1ac8b1d67.html"/>
      <url>/bef1ac8b1d67.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">拦截元素发生默认的行为</span><br><span class="line">preventDefault() </span><br><span class="line"></span><br><span class="line">阻止冒泡事件</span><br><span class="line">stopPropagation()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Html </tag>
            
            <tag> JQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql基础</title>
      <link href="/1e8a3115b061.html"/>
      <url>/1e8a3115b061.html</url>
      
        <content type="html"><![CDATA[<p>远程连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;密码&#x27; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><p>初始化密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;密码&#x27;;</span><br></pre></td></tr></table></figure><p>更改表中字段字符集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表 DEFAULT CHARACTER SET utf8;</span><br></pre></td></tr></table></figure><p>查看字符集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE 表 ;</span><br></pre></td></tr></table></figure><blockquote class="blockquote-center">为了一个爱的人</blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建从零开始(三)</title>
      <link href="/a39447736c9e.html"/>
      <url>/a39447736c9e.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo优化"><a href="#Hexo优化" class="headerlink" title="Hexo优化"></a>Hexo优化</h1><p>先安装这些东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- npm install gulp -g</span><br><span class="line">- npm install gulp-clean-css --save</span><br><span class="line">- npm install gulp-uglify --save</span><br><span class="line">- npm install gulp-htmlmin --save</span><br><span class="line">- npm install gulp-htmlclean --save</span><br><span class="line">- npm install gulp-imagemin --save</span><br></pre></td></tr></table></figure><p>安装好了呢</p><p>配置gulpfile.js（名字必须是这个）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&#x27;gulp&#x27;);</span><br><span class="line">var gutil = require(&#x27;gulp-util&#x27;);</span><br><span class="line">var clean = require(&#x27;gulp-clean&#x27;);</span><br><span class="line">var debug = require(&#x27;gulp-debug&#x27;);</span><br><span class="line">var cache = require(&#x27;gulp-cache&#x27;);</span><br><span class="line">var babel = require(&#x27;gulp-babel&#x27;);</span><br><span class="line">var uglify = require(&#x27;gulp-uglify&#x27;);</span><br><span class="line">var changed = require(&#x27;gulp-changed&#x27;);</span><br><span class="line">var htmlmin = require(&#x27;gulp-htmlmin&#x27;);</span><br><span class="line">var imagemin = require(&#x27;gulp-imagemin&#x27;);</span><br><span class="line">var htmlclean = require(&#x27;gulp-htmlclean&#x27;);</span><br><span class="line">var minifycss = require(&#x27;gulp-clean-css&#x27;);</span><br><span class="line">var pngquant = require(&#x27;imagemin-pngquant&#x27;);</span><br><span class="line"></span><br><span class="line">// 压缩css文件</span><br><span class="line">gulp.task(&#x27;minify-css&#x27;, function() &#123;</span><br><span class="line">  return gulp.src(&#x27;./public/**/*.css&#x27;)</span><br><span class="line">    .pipe(minifycss())</span><br><span class="line">    .pipe(gulp.dest(&#x27;./public&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 压缩js文件，支持将ES6代码转换成ES5代码</span><br><span class="line">gulp.task(&#x27;minify-js&#x27;,[&#x27;minify-css&#x27;], function() &#123;</span><br><span class="line">  return gulp.src(&#x27;./public/**/*.js&#x27;)</span><br><span class="line">    .pipe(babel(&#123;</span><br><span class="line">      presets: [&#x27;es2015&#x27;]</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(uglify())</span><br><span class="line">    .pipe(gulp.dest(&#x27;./public&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 压缩html文件</span><br><span class="line">gulp.task(&#x27;minify-html&#x27;,[&#x27;minify-js&#x27;], function() &#123;</span><br><span class="line">  return gulp.src(&#x27;./public/**/*.html&#x27;)</span><br><span class="line">    .pipe(htmlclean())</span><br><span class="line">    .pipe(htmlmin(&#123;</span><br><span class="line">      removeComments: true,</span><br><span class="line">      minifyJS: true,</span><br><span class="line">      minifyCSS: true,</span><br><span class="line">      minifyURLs: true,</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(&#x27;./public&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 压缩图片(深度压缩)</span><br><span class="line">gulp.task(&#x27;minify-images&#x27;,[&#x27;minify-html&#x27;], function() &#123;</span><br><span class="line">  gulp.src(&#x27;./public/**/**/*.&#123;png,jpg,gif,ico&#125;&#x27;)</span><br><span class="line">    .pipe(cache(imagemin(&#123;                   //启用缓存，只压缩发生变化的图片</span><br><span class="line">      progressive: true,                     //是否无损压缩jpg图片</span><br><span class="line">      interlaced: false,                     //是否隔行扫描gif进行渲染</span><br><span class="line">      svgoPlugins: [&#123;removeViewBox: false&#125;], //是否移除svg的viewbox属性</span><br><span class="line">      multipass: false,                      //是否多次优化svg直到完全优化</span><br><span class="line">      optimizationLevel: 5,                   //优化等级，取值范围：0-7，默认值：3</span><br><span class="line">      use: [pngquant()]                      //使用pngquant深度压缩png图片的imagemin插件</span><br><span class="line">    &#125;)))</span><br><span class="line">    .pipe(gulp.dest(&#x27;./public&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// gulp3的写法</span><br><span class="line">gulp.task(&#x27;default&#x27;, [&#x27;minify-images&#x27;]);</span><br><span class="line"></span><br><span class="line">// gulp4的写法</span><br><span class="line">// gulp.task(&#x27;default&#x27;,gulp.series(gulp.parallel(&#x27;minify-css&#x27;, &#x27;minify-js&#x27;, &#x27;minify-images&#x27;, &#x27;minify-html&#x27;)))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据自己的情况增，删，改，然后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在hexo g 后 输入 gulp 或者 gulp --max_old_space_size=3000</span><br></pre></td></tr></table></figure><p>第二种是内存不足的时候干的</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建从零开始(二)</title>
      <link href="/57bfd13fa382.html"/>
      <url>/57bfd13fa382.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo配置"><a href="#Hexo配置" class="headerlink" title="Hexo配置"></a>Hexo配置</h1><p>Hexo配置文件在根目录下的_config.yml文件<br>所有的配置项后面的冒号（:）与值之间要有一个空格。<br>当然依旧是官方配置文件说明<a href="https://hexo.io/docs/configuration.html">https://hexo.io/docs/configuration.html</a></p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line">title: I had a crush on him #网站标题</span><br><span class="line">subtitle: #网站副标题</span><br><span class="line">description: 所有人的坚强 都是软弱生的茧 #网站描述</span><br><span class="line">keywords:</span><br><span class="line">author: Guard #网站作者名称</span><br><span class="line">language: zh-CN #网络语言，默认为英语</span><br><span class="line">timezone: Asia/Shanghai #网站时区</span><br><span class="line"></span><br><span class="line"># URL 网站设置</span><br><span class="line">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class="line">url: https://blog.guard.ren #网站的地址</span><br><span class="line">root: / #网站的根目录，如果是子文件夹下，则填写子文件夹路径</span><br><span class="line">permalink: :year/:title.html #文章链接地址格式 </span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"># Directory 目录设置</span><br><span class="line">source_dir: source #资源文件夹，默认是source</span><br><span class="line">public_dir: public #公共文件夹，默认是public</span><br><span class="line">tag_dir: tags #标签文件夹，默认是tags</span><br><span class="line">archive_dir: archives #档案文件夹，默认是archives</span><br><span class="line">category_dir: categories #分类文件夹，默认是categories</span><br><span class="line">code_dir: downloads/code #代码文件夹，默认是downloads/code</span><br><span class="line">i18n_dir: :lang #国际化文件夹，默认跟language相同</span><br><span class="line">skip_render: README.md #不需要渲染的文件夹或文件夹,放在[]中</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: :year/:title.md # 新帖子的文件名</span><br><span class="line">default_layout: post #默认布局模板</span><br><span class="line">titlecase: false # 将标题转换为标题</span><br><span class="line">external_link: true # 在新标签中打开外部链接</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: true</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight: #高亮显示</span><br><span class="line">  enable: true #默认开启</span><br><span class="line">  line_number: true #显示行号，默认开启</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace:</span><br><span class="line">  </span><br><span class="line"># 主页设置</span><br><span class="line"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><br><span class="line"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class="line"># order_by: Posts order. (Order by date descending by default)</span><br><span class="line">index_generator:</span><br><span class="line">  path: &#x27;&#x27;</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -date</span><br><span class="line">  </span><br><span class="line"># 类别和标签</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"># 日期/时间格式</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"></span><br><span class="line"># 分页</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"># 扩展</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 主题</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: landscape</span><br><span class="line"></span><br><span class="line"># 部署</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  # other deployer</span><br><span class="line">  type: git</span><br><span class="line">  repo: #github仓库地址</span><br><span class="line">  branch: master # github分支</span><br></pre></td></tr></table></figure><h1 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h1><p>上面的差不多就是Hexo的基础本身的了，当然主题啊什么感觉不好看，也有点简陋，所以下面就开始个性化设置，这都是看自己的喜好设置，不用全部设置上</p><h2 id="RSS订阅插件"><a href="#RSS订阅插件" class="headerlink" title="RSS订阅插件"></a>RSS订阅插件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p>Hexo的_config.yml，添加配置信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#sitemap</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br></pre></td></tr></table></figure><h2 id="SiteMap插件"><a href="#SiteMap插件" class="headerlink" title="SiteMap插件"></a>SiteMap插件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p>Hexo的_config.yml，添加配置信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#feed</span><br><span class="line">atom:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br></pre></td></tr></table></figure><h2 id="Git插件"><a href="#Git插件" class="headerlink" title="Git插件"></a>Git插件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h2 id="更换主题为next"><a href="#更换主题为next" class="headerlink" title="更换主题为next"></a>更换主题为next</h2><ul><li>下载next</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd hexo</span><br><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><ul><li>设置Hexo下的_config.yml</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 主题</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>next下也会有一个_config.yml,为了区分两个_config.yml，我讲称为Hexo的_config.yml，next的_config.yml</p><h2 id="next基础设置"><a href="#next基础设置" class="headerlink" title="next基础设置"></a>next基础设置</h2><h3 id="更换favicon"><a href="#更换favicon" class="headerlink" title="更换favicon"></a>更换favicon</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/guard.png</span><br><span class="line">  medium: /images/guard.png</span><br><span class="line">  apple_touch_icon: /images/guard.png</span><br><span class="line">  safari_pinned_tab: /images/guard.svg</span><br></pre></td></tr></table></figure><h3 id="隐藏底部版本"><a href="#隐藏底部版本" class="headerlink" title="隐藏底部版本"></a>隐藏底部版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  # Specify the date when the site was setup. If not defined, current year will be used.</span><br><span class="line">  #since: 2015</span><br><span class="line"></span><br><span class="line">  # 年份和版权信息之间的图标。</span><br><span class="line">  icon:</span><br><span class="line">    # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/</span><br><span class="line">    # `heart` is recommended with animation in red (#ff0000).</span><br><span class="line">    name: heart-o</span><br><span class="line">    # If you want to animate the icon, set it to true.</span><br><span class="line">    animated: true</span><br><span class="line">    # Change the color of icon, using Hex Code.</span><br><span class="line">    color: &quot;#808080&quot;</span><br><span class="line"></span><br><span class="line">  # 如果没有定义，将使用来自Hexo主配置的`author`。</span><br><span class="line">  copyright:</span><br><span class="line"></span><br><span class="line">  powered:</span><br><span class="line">    # Hexo link (Powered by Hexo).</span><br><span class="line">    enable: false</span><br><span class="line">    # Version info of Hexo after Hexo link (vX.X.X).</span><br><span class="line">    version: false</span><br><span class="line"></span><br><span class="line">  theme:</span><br><span class="line">    # Theme &amp; scheme info link (Theme - NexT.scheme).</span><br><span class="line">    enable: false</span><br><span class="line">    # Version info of NexT after scheme info (vX.X.X).</span><br><span class="line">    version: false</span><br><span class="line"></span><br><span class="line">  # Beian icp为中国用户提供的信息。在中国，每个法律网站的网站页脚都应该有一个beian icp。</span><br><span class="line">  # http://www.miitbeian.gov.cn</span><br><span class="line">  beian:</span><br><span class="line">    enable: false</span><br><span class="line">    icp:</span><br></pre></td></tr></table></figure><h3 id="许可证"><a href="#许可证" class="headerlink" title="许可证"></a>许可证</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa</span><br><span class="line">  sidebar: true</span><br><span class="line">  post: true</span><br><span class="line">  language:</span><br></pre></td></tr></table></figure><h3 id="右上角GitHub"><a href="#右上角GitHub" class="headerlink" title="右上角GitHub"></a>右上角GitHub</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">github_banner:</span><br><span class="line">  enable: true</span><br><span class="line">  permalink: https://github.com/isGuard</span><br><span class="line">  title: Follow me on GitHub</span><br></pre></td></tr></table></figure><h3 id="菜单设置"><a href="#菜单设置" class="headerlink" title="菜单设置"></a>菜单设置</h3><p>要创建对应为目录文件</p><p>如果是tags 最好就是在\scaffolds\post.md加一个tags: 以后每次创建文章就不用自己加了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br><span class="line"></span><br><span class="line"># 启用/禁用菜单图标/项目徽章.</span><br><span class="line">menu_settings:</span><br><span class="line">  icons: true</span><br><span class="line">  badges: false</span><br></pre></td></tr></table></figure><h3 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure><h3 id="社交链接"><a href="#社交链接" class="headerlink" title="社交链接"></a>社交链接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/isGuard || github</span><br><span class="line">  E-Mail: mailto:isguard@outlook.com || envelope</span><br><span class="line">  #Weibo: https://weibo.com/yourname || weibo</span><br><span class="line">  #Google: https://plus.google.com/yourname || google</span><br><span class="line">  #Twitter: https://twitter.com/yourname || twitter</span><br><span class="line">  #FB Page: https://www.facebook.com/yourname || facebook</span><br><span class="line">  #VK Group: https://vk.com/yourname || vk</span><br><span class="line">  #StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span><br><span class="line">  #YouTube: https://youtube.com/yourname || youtube</span><br><span class="line">  #Instagram: https://instagram.com/yourname || instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || skype</span><br><span class="line"></span><br><span class="line">social_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  icons_only: true</span><br><span class="line">  transition: true</span><br></pre></td></tr></table></figure><h3 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 博客卷</span><br><span class="line">links_icon: link</span><br><span class="line">links_title: 友链</span><br><span class="line">links_layout: block</span><br><span class="line">#links_layout: inline</span><br><span class="line">links:</span><br><span class="line">  #Title: http://example.com</span><br></pre></td></tr></table></figure><h3 id="边栏头像"><a href="#边栏头像" class="headerlink" title="边栏头像"></a>边栏头像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 边栏头像</span><br><span class="line">avatar:</span><br><span class="line">  # In theme directory (source/images): /images/avatar.gif</span><br><span class="line">  # In site directory (source/uploads): /uploads/avatar.gif</span><br><span class="line">  # 您还可以使用其他链接图像。</span><br><span class="line">  url: </span><br><span class="line">  # 如果是真的，那么化身就会被圈下来。</span><br><span class="line">  rounded: true</span><br><span class="line">  # 不透明度的值应该从0到1中选择以设置化身的不透明度。</span><br><span class="line">  opacity: 1</span><br><span class="line">  # 如果为true，则将使用光标旋转头像。</span><br><span class="line">  rotated: false</span><br><span class="line"></span><br><span class="line"># 边栏中的目录</span><br><span class="line">toc:</span><br><span class="line">  enable: true</span><br><span class="line">  # 自动将列表编号添加到toc。</span><br><span class="line">  number: true</span><br><span class="line">  # 如果为true，如果标题宽度大于侧边栏宽度，则所有单词将放在下一行。</span><br><span class="line">  wrap: false</span><br><span class="line">  # 如果为true，将显示帖子中的所有TOC级别，而不是其中的激活部分。</span><br><span class="line">  expand_all: false</span><br><span class="line">  # 生成的toc的最大航向深度。您可以通过Front Matter中的`toc_max_depth`在一个帖子中设置它。</span><br><span class="line">  max_depth: 6</span><br></pre></td></tr></table></figure><h3 id="阅读全文"><a href="#阅读全文" class="headerlink" title="阅读全文"></a>阅读全文</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 自动摘录（不推荐）.</span><br><span class="line"># 使用 &lt;!-- more --&gt;在帖子中准确控制摘录.</span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure><h3 id="修改文章底部的-号的标签"><a href="#修改文章底部的-号的标签" class="headerlink" title="修改文章底部的#号的标签"></a>修改文章底部的#号的标签</h3><p>打开themes/next/layout/_macro/下的post.swig文件</p><p>搜索rel=”tag”&gt;#</p><p>将 # 换成<i class="fa fa-tag"></i></p><h3 id="加入本地搜索"><a href="#加入本地搜索" class="headerlink" title="加入本地搜索"></a>加入本地搜索</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>Hexo的_config.yml,添加配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#search</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><p>next的_config.yml,添加配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # If auto, trigger search by changing input.</span><br><span class="line">  # If manual, trigger search by pressing enter key or search button.</span><br><span class="line">  trigger: auto</span><br><span class="line">  # Show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # Unescape html strings to the readable one.</span><br><span class="line">  unescape: false</span><br></pre></td></tr></table></figure><h3 id="添加Google统计"><a href="#添加Google统计" class="headerlink" title="添加Google统计"></a>添加Google统计</h3><p>访问<a href="https://analytics.google.com/">Google Analytics</a>,需要登录,按照提示填写网站信息开通GA服务获取统计ID</p><p>next的__config.yml,找到关键字google_analytics,删除注释#并填写获取到的统计ID</p><h3 id="不蒜子访问量统计"><a href="#不蒜子访问量统计" class="headerlink" title="不蒜子访问量统计"></a>不蒜子访问量统计</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Show Views / Visitors of the website / page with busuanzi.</span><br><span class="line"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span><br><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: false</span><br><span class="line">  post_views_icon: eye</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>大部分next上都有可以抽一部分时间看，应该都能配好，有什么疑问可以留言</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建从零开始(一)</title>
      <link href="/b6106669f562.html"/>
      <url>/b6106669f562.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Hexo是在网上无意间找到的，然后就爱上了</p><p>推荐理由：</p><ol><li>免费</li><li>开源</li><li>便捷</li><li>爱折腾</li></ol><p>最好掌握的技能或者现学，但至少要有点编程基础</p><ul><li>html+css+javascript</li><li>git</li><li>markdown</li><li>nodejs</li></ul><p>当然这都是比较简单的也不用了解太过完全，毕竟Google是个不错的方法</p><h1 id="安装Git客户端"><a href="#安装Git客户端" class="headerlink" title="安装Git客户端"></a>安装Git客户端</h1><blockquote><p>安装过的用户请跳过</p></blockquote><p>安装教程—&gt;<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git" title="Git">Git</a></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/b6106669f562/1.png"></p><h1 id="注册GitHub"><a href="#注册GitHub" class="headerlink" title="注册GitHub"></a>注册GitHub</h1><blockquote><p>已经有的又可以跳过了</p></blockquote><ol><li>打开网站<a href="https://github.com/">https://github.com/</a></li><li>然后对着上面疯狂输出就好了</li></ol><h1 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h1><p>这个位置</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/b6106669f562/2.png"></p><p>仓库名称必须为</p><p>用户名.github.io</p><p>其他都不重要了，用public，如果是付费用户就当我没说</p><h1 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h1><blockquote><p>已经有的又可以跳过了</p></blockquote><p>打开Git Bash终端：在桌面右键，会出现”Git Bash here”的选项，点击即可</p><ul><li>设置user name和email：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的GitHub用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的GitHub注册邮箱&quot;</span><br></pre></td></tr></table></figure><ul><li>生成ssh密钥:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</span><br></pre></td></tr></table></figure><p>如果是第一次配置那一直回车就好了</p><p>此时，在用户文件夹下就会有一个新的文件夹.ssh，里面有刚刚创建的ssh密钥文件id_rsa和id_rsa.pub。</p><p>注：id_rsa文件是私钥，要妥善保管，id_rsa.pub是公钥文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\用户名\.ssh</span><br></pre></td></tr></table></figure><ul><li>添加公钥到Github</li></ul><p>点击用户头像，然后点击显示的Settings(设置)选项</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/b6106669f562/3.png"></p><p>在用户设置栏，点击SSH and GPG keys选项，然后点击New SSH key(新建SSH)按钮</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/b6106669f562/4.png"></p><p>将id_rsa.pub中的内容复制到Key文本框中，然后点击Add SSH key(添加SSH)按钮，titale随意</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/b6106669f562/5.png"></p><ul><li>测试SSH</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>会确认信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><ul><li>输入yes后回车</li></ul><p>然后显示如下信息则OK</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi 你的用户名! You&#x27;ve successfully authenticated, </span><br><span class="line">but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><h1 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h1><p>就创建一个文件夹（blog什么的),然后进去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir blog</span><br><span class="line">cd blog</span><br></pre></td></tr></table></figure><h1 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h1><blockquote><p>Hexo官方也有安装教程<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p></blockquote><ul><li>先安装Nodejs</li></ul><p>官网 <a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a></p><ul><li>安装Hexo</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>hexo全局安装一次就够了，后面可以直接使用hexo相关的操作</p><ul><li>初始化Hexo</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><ul><li>安装依赖</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><ul><li>启动Hexo</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>启动之后，打开浏览器，在地址栏输入：<a href="http://localhost:4000，你会看到Hexo的示例页面">http://localhost:4000，你会看到Hexo的示例页面</a></p><h1 id="Hexo操作"><a href="#Hexo操作" class="headerlink" title="Hexo操作"></a>Hexo操作</h1><ul><li>新建文章</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &lt;title&gt;</span><br></pre></td></tr></table></figure><ul><li>生成静态页面</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>生成的静态内容在public文件夹内</p><ul><li>清除生成内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo c</span><br></pre></td></tr></table></figure><p>执行此操作会删除public文件夹中的内容</p><h1 id="部署Hexo到Github"><a href="#部署Hexo到Github" class="headerlink" title="部署Hexo到Github"></a>部署Hexo到Github</h1><ul><li>编辑配置文件</li></ul><p>编辑Hexo配置文件_config.yml，找到下面内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type:</span><br></pre></td></tr></table></figure><p>添加github仓库信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: #github仓库地址</span><br><span class="line">  branch: master # github分支</span><br></pre></td></tr></table></figure><blockquote><p>注意：type、repo、branch的前面有两个空格，后面的:后面有一个空格</p></blockquote><ul><li>安装git插件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ul><li>部署</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>如果没有意外，部署就成功了，可以打开 http://&lt;用户名&gt;.github.io 查看</p><h1 id="Hexo命令"><a href="#Hexo命令" class="headerlink" title="Hexo命令"></a>Hexo命令</h1><p>缩写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo g：hexo generate</span><br><span class="line">hexo c：hexo clean</span><br><span class="line">hexo s：hexo server</span><br><span class="line">hexo d：hexo deploy</span><br></pre></td></tr></table></figure><p>组合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g -s，就是清除、生成、启动</span><br><span class="line">hexo clean &amp;&amp; hexo g -d，就是清除、生成、部署</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Table适应手机端</title>
      <link href="/1c1b04db2c01.html"/>
      <url>/1c1b04db2c01.html</url>
      
        <content type="html"><![CDATA[<p>表格字段一多，在手机上就无法直视了</p><p>所以想着把表格转成ul</p><p>这段代码取之网络</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">$.fn.setTable = function () &#123;</span><br><span class="line">    var el=this;</span><br><span class="line">    this.start=function()&#123;</span><br><span class="line">        $(el).find(&quot;ul&quot;).remove();</span><br><span class="line">        $(el).map(function () &#123;</span><br><span class="line">            var list = &#x27;&#x27;;</span><br><span class="line">            var name = [];</span><br><span class="line">            if ($(this).find(&quot;th&quot;).length == 0) &#123;</span><br><span class="line">                name = false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                $(this).find(&quot;th&quot;).map(function () &#123;</span><br><span class="line">                    name.push($(this).html());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            $(this).find(&quot;tbody tr&quot;).map(function () &#123;</span><br><span class="line">                var ul = &#x27;&lt;ul&gt;&#x27;;</span><br><span class="line">                $(this).find(&quot;td&quot;).map(function (index, item) &#123;</span><br><span class="line">                    if(name) &#123;</span><br><span class="line">                        ul += &#x27;&lt;li&gt;&#x27; + name[index] + &quot;:&amp;nbsp;&quot; + $(this).html() + &#x27;&lt;/li&gt;&#x27;;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        ul += &#x27;&lt;li&gt;&#x27; +&quot;&amp;nbsp;&quot; + $(this).html() + &#x27;&lt;/li&gt;&#x27;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                ul += &#x27;&lt;/ul&gt;&#x27;;</span><br><span class="line">                list += ul;</span><br><span class="line">            &#125;);</span><br><span class="line">            $(this).find(&quot;table&quot;).hide();</span><br><span class="line">            $(this).append(list);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    var _this=this;</span><br><span class="line">    $(window).resize(function()&#123;</span><br><span class="line">        if($(window).width()&lt;767)&#123;</span><br><span class="line">           _this.start();</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">            $(el).find(&quot;table&quot;).show();</span><br><span class="line">            $(el).find(&quot;ul&quot;).hide();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    if($(window).width()&lt;767)&#123;</span><br><span class="line">        _this.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用也简单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt; </span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;js/table2ul.js&quot;&gt;&lt;/script&gt; </span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt; </span><br><span class="line">$(&quot;.table-list&quot;).setTable(); </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>上面是基础源码，这个修改一下应该是可以应付大部分了</p>]]></content>
      
      
      <categories>
          
          <category> Html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Html </tag>
            
            <tag> JQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流书</title>
      <link href="/dc5ef838632f.html"/>
      <url>/dc5ef838632f.html</url>
      
        <content type="html"><![CDATA[<p>མ་འཕུར་ན་མི་ཚེ་ཚར་རྒྱུ་རེད།</p><p>མ་འཕུར་ན་རེ་བ་བརླག་རྒྱུ་རེད།</p><hr><blockquote><p>我一辈子走过许多地方的路<br>行过许多地方的桥<br>看过许多次数的云<br>喝过许多种类的酒<br>却只爱过一个正当最好年龄的人<br>—— 边城</p><p>等待而已，也叫努力？<br>是在等别人离开，还是在等自己放弃？<br>—— 云边有个小卖部</p><p>我们就这样说了声再见<br>在我们内心深处说再见之前<br>—— 朗读者</p><p>I had a crush on him<br>—— 送你一颗子弹</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 流书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-8函数式编程2</title>
      <link href="/49d077e64aa6.html"/>
      <url>/49d077e64aa6.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言</p><p>Java 8 Lambdas，Richard Warburton 著（O’Reilly，2014）。版权所有， 978-1-449-37077-0</p><ul><li>如何编写出简单、干净、易读的代码 —— 尤其是对于集合的操作？</li><li>如何简单地使用并行计算提高性能？</li><li>如何准确地为问题建模，并且开发出更好的领域特定语言？</li><li>如何写出不易出错，并且更简单的并发代码？</li><li>如何测试和调试 Lambda 表达式？</li></ul><p>将<strong>Lambda 表达式</strong>加入 Java，并不只是为了提高开发人员的生产效率，业界也对这一特性有根本性的需求。</p></blockquote><h1 id="流"><a href="#流" class="headerlink" title="流"></a>流</h1><p>Java 8 中新增的特性旨在帮助程序员写出更好的代码，其中对核心类库的改进是很关键的一部分。</p><p>对核心类库的改进主要包括集合类的 API 和新引入的流（Stream）。</p><p>流使程序员得以站在更高的抽象层次上对集合进行操作。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul><li>Artist : 创作音乐的个人或团队<ul><li>name ：艺术家的名字</li><li>members ：乐队成员</li><li>origin ：乐队来自哪里</li><li>Track : 专辑中的一支曲目<ul><li>name : 曲目名称</li></ul></li><li>Album ： 专辑，若干曲目组成<ul><li>name ：专辑名</li><li>tracks ： 专辑上所有曲目的列表</li><li>musicians ：参与创作本专辑的艺术家列表 </li></ul></li></ul></li></ul><h2 id="从外部迭代到内部迭代"><a href="#从外部迭代到内部迭代" class="headerlink" title="从外部迭代到内部迭代"></a>从外部迭代到内部迭代</h2><p>Java 程序员在使用集合类时，一个通用的模式是在集合上进行迭代，然后处理返回的每一个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">使用 for 循环计算来自伦敦的艺术家人数</span><br><span class="line"></span><br><span class="line">int count = 0; </span><br><span class="line">for (Artist artist : allArtists) &#123; </span><br><span class="line">    if (artist.isFrom(&quot;London&quot;)) &#123; </span><br><span class="line">        count++; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">尽管这样的操作可行，但存在几个问题</span><br><span class="line">1.每次迭代集合类时，都需要写很多样板代码。</span><br><span class="line">2.将for 循环改造成并行方式运行也很麻烦，需要修改每个 for 循环才能实现。</span><br><span class="line">3.上述代码无法流畅传达程序员的意图。</span><br><span class="line">for 循环的样板代码模糊了代码的本意，程序员必须阅读整个循环体才能理解。</span><br><span class="line">若是单一的 for 循环，倒也问题不大，但面对一个满是循环（尤其是嵌套循环）的庞大代码库时，负担就重了。</span><br></pre></td></tr></table></figure><p>for 循环其实是一个封装了迭代的语法糖，看看它的工作原理。</p><p>首先调用 iterator 方法，产生一个新的 Iterator 对象，进而控制整个迭代过程，这就是<strong>外部迭代</strong>。</p><p>迭代过程通过显式调用 Iterator 对象的 hasNext 和 next 方法完成迭代。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用迭代器计算来自伦敦的艺术家人数</span><br><span class="line"></span><br><span class="line">int count = 0; </span><br><span class="line">Iterator&lt;Artist&gt; iterator = allArtists.iterator(); </span><br><span class="line">while(iterator.hasNext()) &#123; </span><br><span class="line">    Artist artist = iterator.next(); </span><br><span class="line">    if (artist.isFrom(&quot;London&quot;)) &#123; </span><br><span class="line">        count++; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内部迭代</strong></p><p>首先要注意 stream() 方法的调用，它和调用 iterator() 的作用一样。</p><p>该方法不是返回一个控制迭代的 Iterator 对象，而是返回内部迭代中的相应接口：Stream。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">使用内部迭代计算来自伦敦的艺术家人数</span><br><span class="line"></span><br><span class="line">long count = allArtists.stream()</span><br><span class="line">.filter(artist -&gt; artist.isFrom(&quot;London&quot;))</span><br><span class="line">.count();</span><br><span class="line"></span><br><span class="line">被分解为两步更简单的操作：</span><br><span class="line">找出所有来自伦敦的艺术家</span><br><span class="line">计算他们的人数</span><br></pre></td></tr></table></figure><p>每种操作都对应 Stream 接口的一个方法。<br>为了找出来自伦敦的艺术家，需要对 Stream 对象进行过滤：filter。过滤在这里是指“只保留通过某项测试的对象”。<br>测试由一个函数完成，根据艺术家是否来自伦敦，该函数返回 true 或者 false。<br>由于 Stream API 的函数式编程风格，我们并没有改变集合的内容，而是描述出 Stream 里的内容。<br>count() 方法计算给定 Stream 里包含多少个对象。</p><blockquote><p>Stream 是用函数式编程方式在集合类上进行复杂操作的工具。</p></blockquote><h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p>整个过程被分解为两种更简单的操作：过滤和计数，看似有化简为繁之嫌<br>但 迭代只有一个for循环 ，两种操作是否以为着需要两次循环？ 答案并不是，只需要对列表迭代一次。</p><p>通常，在Java中调用一个方法，计算机会随机执行操作：比如，System.out.println(“Hello World”);会在终端上输出一条信息。<br>Streatm里的一些方法却略有不同，他们虽是普通Java方法，但返回的Stream对象却不是一个新集合，而是<strong>创建新集合的配方</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">只过滤，不计数</span><br><span class="line"></span><br><span class="line">allArtists.stream().filter(artist -&gt; artist.isFrom(&quot;London&quot;));</span><br></pre></td></tr></table></figure><p>这行代码并未做什么实际性的工作，filter 只刻画出了 Stream，但没有产生新的集合。<br>像filter 这样只描述 Stream，最终不产生新集合的方法叫<strong>作惰性求值方法</strong>；<br>而像 count 这样最终会从 Stream 产生值的方法叫作<strong>及早求值方法</strong>。</p><p>在过滤器中加入一条 println 语句，来输出艺术家的名字，就能轻而易举地看出其中的不同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">由于使用了惰性求值，没有输出艺术家的名字</span><br><span class="line"></span><br><span class="line">allArtists.stream() </span><br><span class="line">          .filter(artist -&gt; &#123; </span><br><span class="line">              System.out.println(artist.getName()); </span><br><span class="line">              return artist.isFrom(&quot;London&quot;); </span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">运行这段代码，程序不会输出任何信息！</span><br></pre></td></tr></table></figure><p>如果将同样的输出语句加入一个拥有终止操作的流,艺术家的名字就会被输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long count = allArtists.stream() </span><br><span class="line">                       .filter(artist -&gt; &#123; </span><br><span class="line">                           System.out.println(artist.getName()); </span><br><span class="line">                           return artist.isFrom(&quot;London&quot;); </span><br><span class="line">                       &#125;) </span><br><span class="line">                       .count();</span><br></pre></td></tr></table></figure><p>判断一个操作是惰性求值还是及早求值很简单：只需看它的返回值。<br>如果返回值是 Stream，那么是惰性求值；如果返回值是另一个值或为空，那么就是及早求值。<br>使用这些操作的理想方式就是形成一个惰性求值的链，最后用一个及早求值的操作返回想要的结果，这正是它的合理之处。</p><h2 id="常用的流操作"><a href="#常用的流操作" class="headerlink" title="常用的流操作"></a>常用的流操作</h2><p>为了更好地理解 Stream API，掌握一些常用的 Stream 操作十分必要。除此处讲述的几种重要操作之外，该 API 的 Javadoc 中还有更多信息。</p><h3 id="collect-toList"><a href="#collect-toList" class="headerlink" title="collect(toList())"></a>collect(toList())</h3><blockquote><p>collect(toList()) 方法由 Stream 里的值生成一个列表，是一个及早求值操作。</p></blockquote><p>Stream 的 of 方法使用一组初始值生成新的 Stream。<br>事实上，collect 的用法不仅限于此，它是一个非常通用的强大结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; collected = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</span><br><span class="line">                               .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这段程序展示了如何使用 collect(toList()) 方法从 Stream 中生成一个列表。</span><br><span class="line">由于很多 Stream 操作都是惰性求值，因此调用 Stream 上一系列方法之后，还需要最后再调用一个类似 collect 的及早求值方法。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-8函数式编程1</title>
      <link href="/70ca5927dc18.html"/>
      <url>/70ca5927dc18.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言</p><p>Java 8 Lambdas，Richard Warburton 著（O’Reilly，2014）。版权所有， 978-1-449-37077-0</p><ul><li>如何编写出简单、干净、易读的代码 —— 尤其是对于集合的操作？</li><li>如何简单地使用并行计算提高性能？</li><li>如何准确地为问题建模，并且开发出更好的领域特定语言？</li><li>如何写出不易出错，并且更简单的并发代码？</li><li>如何测试和调试 Lambda 表达式？</li></ul><p>将<strong>Lambda 表达式</strong>加入 Java，并不只是为了提高开发人员的生产效率，业界也对这一特性有根本性的需求。</p></blockquote><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在开始探索 Lambda 表达式之前，首先我们要知道它因何而生。</p><h2 id="为什么需要再次修改Java"><a href="#为什么需要再次修改Java" class="headerlink" title="为什么需要再次修改Java"></a>为什么需要再次修改Java</h2><p>Java还欠缺高效的并行操作</p><p>面向对象编程是对数据进行抽象，函数式编程是对行为进行抽象</p><h2 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h2><p>在思考问题时，使用不可变值和函数，函数对一个值进行处理，映射成另一个值</p><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>Java 8 的最大变化是引入了 Lambda 表达式</p><h2 id="第一个Lambda表达式"><a href="#第一个Lambda表达式" class="headerlink" title="第一个Lambda表达式"></a>第一个Lambda表达式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">button.addActionListener(new ActionListener() &#123; </span><br><span class="line">    public void actionPerformed(ActionEvent event) &#123; </span><br><span class="line">        System.out.println(&quot;button clicked&quot;); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">==</span><br><span class="line"></span><br><span class="line">button.addActionListener(event -&gt; System.out.println(&quot;button clicked&quot;));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>和传入一个实现某接口的对象不同，我们传入了一段代码块——一个没有名字的函数。event 是参数名，和上面匿名内部类示例中的是同一个参数。-&gt; 将参数和 Lambda 表达式的主体分开，而主体是用户点击按钮时会运行的一些代码。</p><p>和使用匿名内部类的另一处不同在于声明 event 参数的方式。使用匿名内部类时需要显式地声明参数类型 ActionEvent  event，而在 Lambda 表达式中无需指定类型，程序依然可以编译。这是因为 javac 根据程序的上下文（addActionListener 方法的签名）在后台推断出了参数 event 的类型。这意味着如果参数类型不言而明，则无需显式指定。</p><blockquote><p>尽管与之前相比，Lambda 表达式中的参数需要的样板代码很少，但是 Java 8仍然是一种静态类型语言。为了增加可读性并迁就我们的习惯，声明参数时也可以包括类型信息，而且有时编译器不一定能根据上下文推断出参数的类型！</p></blockquote><h2 id="如何辨别Lambda表达式"><a href="#如何辨别Lambda表达式" class="headerlink" title="如何辨别Lambda表达式"></a>如何辨别Lambda表达式</h2><p>编写 Lambda 表达式的不同形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Runnable noArguments = () -&gt; System.out.println(&quot;Hello World&quot;); </span><br><span class="line"></span><br><span class="line">Lambda 表达式不包含参数，使用空括号 () 表示没有参数。</span><br><span class="line">该 Lambda 表达式实现了 Runnable 接口，该接口也只有一个 run 方法，没有参数，且返回类型为 void</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActionListener oneArgument = event -&gt; System.out.println(&quot;button clicked&quot;);</span><br><span class="line"> </span><br><span class="line">Lambda 表达式包含且只包含一个参数，可省略参数的括号。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Runnable multiStatement = () -&gt; &#123;</span><br><span class="line">System.out.print(&quot;Hello&quot;); </span><br><span class="line">System.out.println(&quot; World&quot;); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Lambda 表达式的主体不仅可以是一个表达式，而且也可以是一段代码块，使用大括号（&#123;&#125;）将代码块括起来。</span><br><span class="line">该代码块和普通方法遵循的规则别无二致，可以用返回或抛出异常来退出。</span><br><span class="line">只有一行代码的 Lambda 表达式也可使用大括号，用以明确 Lambda表达式从何处开始、到哪里结束。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; add = (x, y) -&gt; x + y;</span><br><span class="line"></span><br><span class="line">Lambda 表达式也可以表示包含多个参数的方法。</span><br><span class="line">这时就有必要思考怎样去阅读该 Lambda 表达式。</span><br><span class="line">这行代码并不是将两个数字相加，而是创建了一个函数，用来计算两个数字相加的结果。</span><br><span class="line">变量 add 的类型是 BinaryOperator&lt;Long&gt;，它不是两个数字的和，而是将两个数字相加的那行代码。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; addExplicit = (Long x, Long y) -&gt; x + y; </span><br><span class="line"></span><br><span class="line">显式声明参数类型</span><br></pre></td></tr></table></figure><blockquote><p>目标类型是指 Lambda 表达式所在上下文环境的类型。<br>比如，将 Lambda 表达式赋值给一个局部变量，或传递给一个方法作为参数，局部变量或方法参数的类型就是 Lambda 表达式的目标类型。</p></blockquote><p>Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。</p><p>Java 中初始化数组时，数组的类型就是根据上下文推断出来的。另一个常见的例子是 null，只有将 null 赋值给一个变量，才能知道它的类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final String[] array = &#123; &quot;hello&quot;, &quot;world&quot; &#125;;</span><br><span class="line">等号右边的代码并没有声明类型，系统根据上下文推断出类型信息</span><br></pre></td></tr></table></figure><h2 id="引用值，而不是变量"><a href="#引用值，而不是变量" class="headerlink" title="引用值，而不是变量"></a>引用值，而不是变量</h2><p>需要引用它所在方法里的变量。这时，需要将变量声明为 final</p><p>将变量声明为 final，意味着不能为其重复赋值。同时也意味着在使用 final 变量时，实际上是在使用赋给该变量的一个特定的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">匿名内部类中使用 final 局部变量</span><br><span class="line"></span><br><span class="line">final String name = getUserName(); </span><br><span class="line">button.addActionListener(new ActionListener() &#123; </span><br><span class="line">    public void actionPerformed(ActionEvent event) &#123; </span><br><span class="line">        System.out.println(&quot;hi &quot; + name); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Java 8 虽然放松了这一限制，可以引用非 final 变量，但是该变量在既成事实上必须是final。</p><p>虽然无需将变量声明为 final，但在 Lambda 表达式中，也无法用作非终态变量。</p><p>如果坚持用作非终态变量，编译器就会报错。</p><p>既成事实上的 final 是指只能给该变量赋值一次。</p><p>换句话说，Lambda 表达式引用的是值，而不是变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Lambda 表达式中引用既成事实上的 final 变量</span><br><span class="line">name 就是一个既成事实上的 final 变量</span><br><span class="line"></span><br><span class="line">String name = getUserName(); </span><br><span class="line">button.addActionListener(event -&gt; System.out.println(&quot;hi &quot; + name));</span><br></pre></td></tr></table></figure><p>final 就像代码中的线路噪声，省去之后代码更易读。</p><p>当然，有些情况下，显式地使用 final代码更易懂。</p><p>是否使用这种既成事实上的 final 变量，完全取决于个人喜好。</p><p>如果你试图给该变量多次赋值，然后在 Lambda 表达式中引用它，编译器就会报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">未使用既成事实上的 final 变量，导致无法通过编译（ Lambda 表达式中引用的局部变量必须是 final 或既成事实上的 final 变量）</span><br><span class="line"></span><br><span class="line">String name = getUserName(); </span><br><span class="line">name = formatUserName(name); </span><br><span class="line">button.addActionListener(event -&gt; System.out.println(&quot;hi &quot; + name));</span><br><span class="line"></span><br><span class="line">显示出错信息：local variables referenced from a Lambda expression must be final or effectively final</span><br></pre></td></tr></table></figure><h2 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h2><blockquote><p>函数接口是只有一个抽象方法的接口，用作 Lambda 表达式的类型。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ActionListener 接口：接受 ActionEvent 类型的参数，返回空</span><br><span class="line"></span><br><span class="line">public interface ActionListener extends EventListener &#123; </span><br><span class="line">    public void actionPerformed(ActionEvent event); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ActionListener 只有一个抽象方法：actionPerformed，被用来表示行为：接受一个参数，返回空。</span><br><span class="line">记住，由于 actionPerformed 定义在一个接口里，因此 abstract 关键字不是必需的。</span><br><span class="line">该接口也继承自一个不具有任何方法的父接口：EventListener。</span><br></pre></td></tr></table></figure><p>这就是函数接口，接口中单一方法的命名并不重要，只要方法签名和 Lambda 表达式的类型匹配即可。</p><p>可在函数接口中为参数起一个有意义的名字，增加代码易读性，便于更透彻地理解参数的用途。</p><p>Java一些重要的函数接口</p><table><thead><tr><th align="center">接口</th><th align="center">参数</th><th align="center">返回类型</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">Predicate<T></T></td><td align="center">T</td><td align="center">boolean</td><td align="center">用来判断真假</td></tr><tr><td align="center">Consumer<T></T></td><td align="center">T</td><td align="center">void</td><td align="center">输出一个值</td></tr><tr><td align="center">Function&lt;T,R&gt;</td><td align="center">T</td><td align="center">R</td><td align="center">获取Artist对象的名字</td></tr><tr><td align="center">Supplier<T></T></td><td align="center">None</td><td align="center">T</td><td align="center">工厂方法</td></tr><tr><td align="center">UnaryOperator<T></T></td><td align="center">T</td><td align="center">T</td><td align="center">逻辑非(!)</td></tr><tr><td align="center">BinaryOperator<T></T></td><td align="center">(T,T)</td><td align="center">T</td><td align="center">求两个数的乘积(*)</td></tr></tbody></table><h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><p>Lambda 表达式中的类型推断，实际上是 Java 7 就引入的目标类型推断的扩展。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; oldWordCounts = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">Map&lt;String, Integer&gt; diamondWordCounts = new HashMap&lt;&gt;(); </span><br></pre></td></tr></table></figure><p>javac 根据 Lambda 表达式上下文信息就能推断出参数的正确类型。</p><p>程序依然要经过类型检查来保证运行的安全性，但不用再显式声明类型罢了。这就是所谓的类型推断。</p><p>用 Lambda 表达式检测一个 Integer 是否大于 5。这实际上是一个 Predicate——用来判断真假的函数接口</p><p><code>Predicate&lt;Integer&gt; atLeast5 = x -&gt; x &gt; 5;</code></p><p>Predicate 也是一个 Lambda 表达式，和前文中 ActionListener 不同的是，它还返回一个值。</p><p>表达式 x  &gt;  5 是 Lambda 表达式的主体。</p><p>这样的情况下，返回值就是Lambda 表达式主体的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Predicate 接口的源码，接受一个对象，返回一个布尔值</span><br><span class="line"></span><br><span class="line">public interface Predicate&lt;T&gt; &#123; </span><br><span class="line">    boolean test(T t); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Predicate 只有一个泛型类型的参数，Integer 用于其中。</span><br><span class="line">Lambda表达式实现了 Predicate 接口，因此它的单一参数被推断为 Integer 类型。</span><br><span class="line">javac 还可检查Lambda 表达式的返回值是不是 boolean，这正是 Predicate 方法的返回类型。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">略显复杂的类型推断</span><br><span class="line"></span><br><span class="line">BinaryOperator&lt;Long&gt; addLongs = (x, y) -&gt; x + y;</span><br><span class="line"></span><br><span class="line">一个略显复杂的函数接口：BinaryOperator。</span><br><span class="line">该接口接受两个参数，返回一个值，参数和值的类型均相同。</span><br><span class="line">实例中所用的类型是 Long。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">没有泛型，代码则通不过编译</span><br><span class="line"></span><br><span class="line">BinaryOperator add = (x, y) -&gt; x + y;</span><br><span class="line"></span><br><span class="line">编译器给出的报错信息如下：</span><br><span class="line">Operator &#x27;&amp; #x002B;&#x27; cannot be applied to java.lang.Object, java.lang.Object.</span><br></pre></td></tr></table></figure><p>BinaryOperator 毕竟是一个具有泛型参数的函数接口，该类型既是参数 x 和 y 的类型，也是返回值的类型。<br>上面的例子中并没有给出变量add 的任何泛型信息，给出的正是原始类型的定义。<br>因此，编译器认为参数和返回值都是java.lang.Object 实例。</p><h2 id="要点回顾"><a href="#要点回顾" class="headerlink" title="要点回顾"></a>要点回顾</h2><ul><li>Lambda 表达式是一个匿名方法，将行为像数据一样进行传递。</li><li>Lambda 表达式的常见结构：BinaryOperator<Integer> add = (x, y) → x + y。</Integer></li><li>函数接口指仅具有单个抽象方法的接口，用来表示 Lambda 表达式的类型。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础回顾3</title>
      <link href="/a2cff47e45b4.html"/>
      <url>/a2cff47e45b4.html</url>
      
        <content type="html"><![CDATA[<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p>流是有起点和终点的有序字节序列</p><p>流的分类</p><ul><li>输入流/输出流：是当前程序为参照点，程序从外面读取数据这是输入流，把程序的数据保存到外面是输出流</li><li>字节流/字符流：如果是以字节为单位处理流中的数据就是字节流，如果是以字符为单位处理流中的数据就是字符流</li><li>节点流/处理流：如果直接从设备（数据源）上读写数据就是节点流，处理流是对节点流的包装</li></ul><p>在程序中从文件里读写数据需要使用IO流.Java定义了相关的流类，在java.io包中，如果这个类是以Stream单词结尾就是流类，如果是以Reader结尾就是字符输入流，以Writer单词结尾就是字符输出流。</p><ul><li>FileInputStream/FileOutputStream<ul><li>以节为单位读写文件内容</li></ul></li><li>FileReader/FileWriter<ul><li>FileReader/FileWriter只能读写与当前环境编码兼容的文本文件</li></ul></li><li>InputStreamReader/OutputStreamwriter<ul><li>如果文本文件与当前环境编码不兼容，使用InputStreamReader/OutputStreamwriter转换流读写</li></ul></li><li>BufferedReader/Bufferedwriter<ul><li>字符缓冲流BufferedReader/Bufferedwriter也是一种处理流，包装流</li></ul></li><li>ObjectinputStream/ObjectOutputStream<ul><li>对象序列化：把对象转换为01二进制序列就是对象序列化</li><li>对象反序列化：把一组01二进制序列转换为对象</li><li>注意：对象序列化/反序列化前提是对象的类要实现Serializable接口，该接口是一个标志性接口，没有任何方法</li></ul></li><li>PrintStream/PrintWriter</li><li>File类<ul><li>读取文件内容使用IO流，操作文件/文件来使用File类，如创建/遍历/删除文件来，查看文件的相关属性等操作</li></ul></li></ul><table><thead><tr><th align="center">File</th><th align="center"></th></tr></thead><tbody><tr><td align="center">getAbsolutePath</td><td align="center">返回绝对路径（从根目录开始的路径）</td></tr><tr><td align="center">getPath</td><td align="center">返回路径</td></tr><tr><td align="center">getParent</td><td align="center">返回上一级文件夹</td></tr><tr><td align="center">getName</td><td align="center">对象名</td></tr><tr><td align="center">length</td><td align="center">文件大小</td></tr><tr><td align="center">exists</td><td align="center">是否存在</td></tr><tr><td align="center">isFile</td><td align="center">是否为文件</td></tr><tr><td align="center">isAbsolute</td><td align="center">是否绝对路径</td></tr><tr><td align="center">lastModified</td><td align="center">最后一次修改的时间</td></tr></tbody></table><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>进程：进程就是操作系统运行的一个程序。</p><p>线程：线程就是进程的一个执行单元，一个进程至少有一个线程，如果进程有多个线程，则它就是多线程应用程序。每个线程都有独立的栈空间。</p><p>主线程：JVM启动主线程，主线程运行main方法</p><p>用户线程：开启的新的线程，也称子线程。</p><p>守护线程：守护线程是为其他线程提供服务的线程，不能独立运行，当JVM中只有守护线程时，JVM会退出。（垃圾回收器就是一个守护线程）</p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ul><li><p>继承Thread</p></li><li><p>实现Runnable接口</p></li><li><p>实现Callable接口</p></li></ul><h2 id="线程常用操作"><a href="#线程常用操作" class="headerlink" title="线程常用操作"></a>线程常用操作</h2><table><thead><tr><th align="center">Thread</th><th align="center"></th></tr></thead><tbody><tr><td align="center">activeCount</td><td align="center">当前活动线程的数量</td></tr><tr><td align="center">currentThread</td><td align="center">返回当前线程</td></tr><tr><td align="center">getContextClassLoader</td><td align="center">线程的上下文类加载器</td></tr><tr><td align="center">getId</td><td align="center">返回线程的ID，每个线程都有唯一的id</td></tr><tr><td align="center">getName</td><td align="center">返回线程名称</td></tr><tr><td align="center">getPriority</td><td align="center">返回线程优先级</td></tr><tr><td align="center">getState</td><td align="center">返回线程状态</td></tr><tr><td align="center">interrupt</td><td align="center">中断线程</td></tr><tr><td align="center">interrupted</td><td align="center">测试线程是否被中断</td></tr><tr><td align="center">isAlive</td><td align="center">测试线程是否结束</td></tr><tr><td align="center">isDaemon</td><td align="center">是否守护线程</td></tr><tr><td align="center">isInterrupted</td><td align="center">测试线程是否被中断</td></tr><tr><td align="center">join</td><td align="center">合并线程（加入）</td></tr><tr><td align="center">run</td><td align="center"></td></tr><tr><td align="center">setDaemon</td><td align="center">设置线程为守护线程</td></tr><tr><td align="center">setName</td><td align="center">设置线程名称</td></tr><tr><td align="center">setPriority</td><td align="center">设置优先级</td></tr><tr><td align="center">sleep</td><td align="center">线程休眠</td></tr><tr><td align="center">start</td><td align="center">开启线程</td></tr><tr><td align="center">stop</td><td align="center">终止线程</td></tr><tr><td align="center">toString</td><td align="center"></td></tr><tr><td align="center">yield</td><td align="center">线程让步</td></tr></tbody></table><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/a2cff47e45b4/1.png"></p><p>线程优先级</p><ul><li>每个线程都有一个优先级，取值范围：1~10</li><li>所有线程默认的优先级为：5</li><li>优先级越高，获得CPU执行权的记录越大</li></ul><p>线程休眠（Thread.sleep(2000)）</p><ul><li>静态方法，通过类名直接调用</li><li>睡眠的单位是毫秒</li><li>sleep()有受检异常需要预处理</li><li>sleep()方法所在的线程睡眠</li></ul><p>线程中断（t1.interrupt()）</p><ul><li>一般情况下，是把处于睡眠/等待中的线程给中断</li></ul><p>线程让步（Thread.yield()）</p><ul><li>把线程转换为就绪状态，重新争抢CPU执行权</li></ul><p>线程加入（合并，t1.join()）</p><p>终止线程</p><ul><li>想办法让run()</li><li>在线程中设置一个标志，定期判断这个标志是否发生变化，标志发生变化就退出run()方法</li></ul><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul><li>线程安全问题。<ul><li>当多个线程同时操作堆区或者方法区的某个数据时，可能会出现数据不一致的现象，称为线程安全问题。</li></ul></li><li>出现线程安全问题怎么办？<ul><li>每个线程都访问自己的局部变量。</li><li>如果多个线程必须同时操作实例变量/静态变量时，可以采用线程同步技术</li></ul></li><li>线程同步技术解决什么问题？<ul><li>当一个线程在操作期间，不允许其他的线程加入。</li><li>某一段代码在某一时刻只能由一个线程执行</li></ul></li></ul><p>同步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">synchronized（锁对象）&#123;</span><br><span class="line">同步代码块</span><br><span class="line">&#125;</span><br><span class="line">工作原理：</span><br><span class="line">1）任意对象都可以作为锁对象，每个对象有一个内置锁</span><br><span class="line">2）某一时刻，锁对象最多只能被一个线程持有。</span><br><span class="line">3）如果线程获得了锁对象后，会一直持有，直到执行完同步代码块后才释放</span><br><span class="line">4）线程要执行同步代码块，必须先获得锁对象。</span><br><span class="line">场景描述：假设有线程A和线程B两个线程都想要执行同步代码块。</span><br><span class="line">1）线程A获得CPU执行权，获得了锁对象后，开始执行同步代码块</span><br><span class="line">2）线程A在执行同步代码块期间，CPU执行权被线程B抢走了，线程A转为就绪状态</span><br><span class="line">3）线程B获得CPU执行权，也想要执行同步代码块，必须先获得锁对象，现在锁对象被线程A持有，线程B转到等待锁对象池中进行阻塞</span><br><span class="line">4）线程A重新获得CPU执行权，执行完同步代码块后释放锁对象。</span><br><span class="line">5）等待锁对象池中的线程B获得了锁对象，转为就绪状态。</span><br></pre></td></tr></table></figure><p>死锁</p><p>当多个线程同步时，获得锁的顺序不一致，导致线程相互等待的情况，称为死锁现象</p><p>如何避免</p><p>保证锁的顺序都一直</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/a2cff47e45b4/2.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础回顾2</title>
      <link href="/5d0a7171e2be.html"/>
      <url>/5d0a7171e2be.html</url>
      
        <content type="html"><![CDATA[<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>Object类是Java中所有类的根父类，Java中的类要么直接继承Object，要么间接继承Object类</p><p>Java中类的继承是可传递的，Object类中定义的方法，所有的类都能继承到</p><table><thead><tr><th align="center">Object</th><th align="center"></th></tr></thead><tbody><tr><td align="center">clone</td><td align="center">对象克隆</td></tr><tr><td align="center">equals</td><td align="center">用于判断两个对象的内容是否一样</td></tr><tr><td align="center">finalize</td><td align="center">当对象被垃圾回收器回收时，会执行对象的finalize()方法，但是垃圾回收器在什么时候回收这个对象不确定，即这个方法的执行时间不确定，一般不用</td></tr><tr><td align="center">getClass</td><td align="center">返回对象的运行时类对象，可以简单的理解为返回对象的类的字节码文件</td></tr><tr><td align="center">hashCode</td><td align="center">返回对象的哈希码</td></tr><tr><td align="center">notify</td><td align="center">在线程中用于唤醒等待中的线程</td></tr><tr><td align="center">notifyAll</td><td align="center"></td></tr><tr><td align="center">toString</td><td align="center">把对象转换为字符串</td></tr><tr><td align="center">wait</td><td align="center">在多线程中，让线程等待</td></tr></tbody></table><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>Collection存储数据时是单个存储的，只能存储引用类型数据</p><p><code>add(),remove(),contains(),iterator()</code></p><ul><li>list集合<ul><li>有序，可重复</li><li>为每个元素指定了一个索引值</li><li>add(index,0),remove(index),get(index),sort(Comparator)</li><li>ArrayList</li><li>Vector<ul><li>底层是数组，访问快，添加/删除慢</li><li>初始化容量：10</li><li>扩容：ArrayList是1.5倍，Vector是2倍</li><li>Vector是线程安全的，ArrayList不是线程安全的</li></ul></li><li>LinkedList<ul><li>底层是双向链表，添加/删除效率高，访问慢</li></ul></li></ul></li></ul><p>ArrayList应用于以查询访问为主，很少进行添加/删除操作<br>LinkedList应用于频繁的进行添加/删除操作的情况</p><ul><li>Set集合<ul><li>无序，不可重复</li><li>HashSet<ul><li>底层是HashMap</li><li>HashSet就是HashMap键的集合</li></ul></li><li>TreeSet<ul><li>底层是TreeMap</li><li>TreeSet就是TreeMap键的集合</li><li>TreeSet实现了SortedSet接口，可以对元素自然排序，要求元素必须是可比较的<ul><li>创建TreeSet时指定Comparator比较器</li><li>如果没有指定Comparator比较器，元素类需要实现Comparable接口</li></ul></li></ul></li></ul></li></ul><p>List集合与HashSet集合中判断是否同一个元素，需要调用对象的equals()方法，元素的类需要重写equals()方法</p><p>TreeSet集合判断是否同一个元素，根据Comparator/Comparable的比较结果是否为0判断，如果比较结果为0就认为是同一个元素</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/5d0a7171e2be/1.png"></p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><ul><li>HashSet底层是HashMap<ul><li>向HashSet中添加元素，实际上是把元素作为键添加到底层的HashMap中</li><li>HashSet就是HashMap键的集合</li></ul></li></ul><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><ul><li>TreeSet实现了SortedSet接口，可以对元素自然排序，要求集合中的元素必须是可比较的<ul><li>在创建TreeSet时，可以指定Comparator比较器</li><li>没有指定Comparator比较器，要求元素的类实现Comparable接口</li></ul></li><li>TreeSet底层是TreeMap<ul><li>向TreeSett中添加元素，实际上是把元素作为键添加到底层的TreeMap中</li><li>TreeSet就是TreeMap键的集合</li></ul></li></ul><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map是按&lt;键,值&gt;对的形式存储数据的</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/5d0a7171e2be/2.png"></p><table><thead><tr><th align="center">Map</th><th align="center"></th></tr></thead><tbody><tr><td align="center">clear</td><td align="center">清除所有的&lt;键,值&gt;对</td></tr><tr><td align="center">containsKey</td><td align="center">判断是否包含指定的键</td></tr><tr><td align="center">containsValue</td><td align="center">判断是否包含指定的值</td></tr><tr><td align="center">entrySet</td><td align="center">返回Entry的集合，一个&lt;键,值&gt;对就是一个entry</td></tr><tr><td align="center">equals</td><td align="center"></td></tr><tr><td align="center">get</td><td align="center">返回Key对应的值</td></tr><tr><td align="center">isEmpty</td><td align="center">判断是否为空</td></tr><tr><td align="center">ketSet</td><td align="center">返回键的集合</td></tr><tr><td align="center">put</td><td align="center">向Map中添加&lt;键,值&gt;对，如果这个键Key已存在，使用value替换原来的值，Map中的键是不重复的</td></tr><tr><td align="center">putAll</td><td align="center"></td></tr><tr><td align="center">remove</td><td align="center">只要key匹配就删除对应的&lt;键,值&gt;对</td></tr><tr><td align="center">remove</td><td align="center">要求&lt;键,值&gt;都匹配才会删除</td></tr><tr><td align="center">replace</td><td align="center">替换</td></tr><tr><td align="center">size</td><td align="center">返回&lt;键,值&gt;对的数量</td></tr><tr><td align="center">values</td><td align="center">返回值的集合</td></tr></tbody></table><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/5d0a7171e2be/3.png"></p><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><ul><li>底层都是哈希表（散列表），但是HashTable事线程安全的，HashMap不是线程安全的</li><li>HashMap的父类是AbstractMap,HashTable的父类是Dictionary</li><li>HashMap默认的初始化容量：16，HashTable默认的初始化容量：11</li><li>加载因子：0.75，当&lt;键,值&gt;对的数量大于数组的容量（哈希桶的容量）*加载因子时，数组要扩容</li><li>HashMap扩容默认：2倍大小，HashTable扩容默认：2倍+1</li><li>HashMap的键与值都可以为null，HashTable的键与值都不可以为null</li><li>HashMap在创建时，可以指定一个初始化容量，系统会调整为2的幂次方，为了快速计算出数组的下标</li><li>HashTable也可以指定初始化容量，系统不调整</li></ul><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><ul><li>继承了HashTable</li><li>他的键与值都是String字符串</li><li>常用于设置读取系统属性值</li></ul><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><ul><li>TreeMap实现了SortedMap，可以根据键自然排序，排序原理是二叉树原理</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础回顾1</title>
      <link href="/b17819308f04.html"/>
      <url>/b17819308f04.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java的加载与执行"><a href="#Java的加载与执行" class="headerlink" title="Java的加载与执行"></a>Java的加载与执行</h1><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/b17819308f04/1.png"></p><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><ul><li>btye：Java中最小的数据类型，在内存中占8位(bit)，即1个字节，取值范围-128~127，默认值0</li><li>short：短整型，在内存中占16位，即2个字节，取值范围-32768~32717，默认值0</li><li>int：整型，用于存储整数，在内在中占32位，即4个字节，取值范围-2147483648~2147483647，默认值0</li><li>long：长整型，在内存中占64位，即8个字节-2^63~2^63-1，默认值0L</li><li>float：浮点型，在内存中占32位，即4个字节，用于存储带小数点的数字（与double的区别在于float类型有效小数点只有6~7位），默认值0</li><li>double：双精度浮点型，用于存储带有小数点的数字，在内存中占64位，即8个字节，默认值0</li><li>char：字符型，用于存储单个字符，占16位，即2个字节，取值范围0~65535，默认值为空</li><li>boolean：布尔类型，占1个字节，用于判断真或假（仅有两个值，即true、false），默认值false</li></ul><h1 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h1><ul><li>\n：表示换一行</li><li>\t：表示制表符</li><li>\\：表示输出一个\</li><li>&quot;:表示输出一个”</li><li>&#39;:表示输出一个’</li><li>\u0000：表示unicode转义序列符，输出一个空格</li></ul><h1 id="变量的内存分析"><a href="#变量的内存分析" class="headerlink" title="变量的内存分析"></a>变量的内存分析</h1><ol><li>当运行程序时，在内存中JVM会自动分配空间</li><li>内存中包含：<ul><li>栈：存放方法及方法中的局部变量</li><li>堆：存方法对象</li><li>方法区：代码片段、常量池（常量池中存放的时字符串的值）、静态属性</li></ul></li><li>基本数据类型内存中存放真正的值、引用数据类型内存中存放地址</li></ol><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ol><li>算术运算符：+、-、*、/、%、++、–</li><li>链接运算符：+</li><li>赋值运算符：=、+=、-=、*=、/=、%=</li><li>关系运算符：&gt;、&lt;、&gt;=、&lt;=、==</li><li>逻辑运算符：&amp;、|、^、！、&amp;&amp;、||</li><li>三目运算符：条件 ？代码1 ：代码2</li></ol><h1 id="控制台输入"><a href="#控制台输入" class="headerlink" title="控制台输入"></a>控制台输入</h1><p><code>Scanner input = new Scanner(System.in);</code></p><h1 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if(代码1）&#123;</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">if(代码1）&#123;</span><br><span class="line"></span><br><span class="line">&#125;else if(代码2)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">if(代码1）&#123;</span><br><span class="line"></span><br><span class="line">&#125;else if(代码2)&#123;</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java中，字符串比较，使用==比较的时地址是否一致，equals()比较内容</p><h1 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h1><p>表达式 = byte、short、int、char、String（JDK7.0）、枚举</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">switsh(表达式)&#123;</span><br><span class="line">case 常量1：break；</span><br><span class="line">case 常量2： break；</span><br><span class="line">default：</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;=100;i++)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(条件)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line"></span><br><span class="line">&#125;while(条件)</span><br></pre></td></tr></table></figure><h2 id="跳过及中断"><a href="#跳过及中断" class="headerlink" title="跳过及中断"></a>跳过及中断</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">break；中断</span><br><span class="line">continue；跳过</span><br></pre></td></tr></table></figure><h1 id="方法的内存分析"><a href="#方法的内存分析" class="headerlink" title="方法的内存分析"></a>方法的内存分析</h1><ul><li>当执行该方法时，则方法进栈（压栈）</li><li>当方法执行完毕，则该方法出栈（弹栈），局部变量也随之释放</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主从Mysql设置</title>
      <link href="/3dc224c52b20.html"/>
      <url>/3dc224c52b20.html</url>
      
        <content type="html"><![CDATA[<p>什么是主从，详细百度去吧，我说说我自己的理解</p><ul><li><p>为了灾备</p></li><li><p>均衡负载，提高吞吐量</p></li></ul><h2 id="主备的原理"><a href="#主备的原理" class="headerlink" title="主备的原理"></a>主备的原理</h2><p>主服务器（master） 把数据同步到从服务器（slave）</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/3dc224c52b20/1.jpg"></p><h2 id="下面就是实现了"><a href="#下面就是实现了" class="headerlink" title="下面就是实现了"></a>下面就是实现了</h2><p>首先需要两个mysql（本地测试推荐：phpstudy里面复制两个mysql）</p><h3 id="修改my-ini"><a href="#修改my-ini" class="headerlink" title="修改my.ini"></a>修改my.ini</h3><p>— 唯一 ,要与备机的不同</p><p><code>server_id = 101</code></p><p>— 开启二进制日志</p><p><code>log-bin= mysql-bin</code></p><h3 id="设置服务"><a href="#设置服务" class="headerlink" title="设置服务"></a>设置服务</h3><p>— 设置服务</p><p><code>.\mysqld.exe install MySQL-3310 –defaults-file=”D:\PhpStudy\MySQL\my.ini”</code></p><p>— 删除服务</p><p><code>.\mysqld.exe remove MySQL-3310</code></p><p>— 开启服务</p><p><code>net start MySQL-3310</code></p><h3 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h3><p>— 查询连接账户</p><p><code>SELECT USER,HOST from user;</code></p><p>— 开启远程</p><p><code>grant all privileges on . to ‘root’@’%’ identified by ‘root’ with grant option;</code></p><h3 id="创建连接用户（主机配置）"><a href="#创建连接用户（主机配置）" class="headerlink" title="创建连接用户（主机配置）"></a>创建连接用户（主机配置）</h3><p>— CREATE USER ‘使用名’@’备机IP地址’ IDENTIFIED BY ‘密码’;#创建用户</p><p><code>create user ‘usermysql’@’localhost’ identified by ‘123456’;</code></p><p>— GRANT REPLICATION SLAVE ON . TO ‘使用名’@’备机IP地址’;#分配权限</p><p><code>grant replication slave on . to ‘usermysql’@’localhost’;</code></p><p>— 刷新权限</p><p><code>flush privileges;</code></p><p>— 查看master状态</p><p><code>show master status;</code></p><p>创建连接（从机配置）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO </span><br><span class="line">MASTER_HOST=’localhost’, #主机的IP</span><br><span class="line">MASTER_PORT=3306,</span><br><span class="line">MASTER_USER=’usermysql’, #之前创建的那个使用名</span><br><span class="line">MASTER_PASSWORD=’123456′, #密码</span><br><span class="line">MASTER_LOG_FILE=’mysql-bin.000001′, #这是主库中show master status;File下的那个值</span><br><span class="line">MASTER_LOG_POS=446;#这是主库Position下的那个值</span><br><span class="line"></span><br><span class="line">Slave_IO_Running: Yes</span><br><span class="line">Slave_SQL_Running: Yes </span><br><span class="line">看到这两个都是Yes就成了</span><br></pre></td></tr></table></figure><p>— 关闭</p><p><code>stop slave;</code></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学车科三</title>
      <link href="/65e4aa78c9e6.html"/>
      <url>/65e4aa78c9e6.html</url>
      
        <content type="html"><![CDATA[<h2 id="开始和结束"><a href="#开始和结束" class="headerlink" title="开始和结束"></a>开始和结束</h2><ul><li>开始的时候绕车一圈（触碰对角的感应器）</li><li>上车先调，座椅，镜子，灯（回拉一下）</li><li>打左灯（下拉）</li><li>等5秒再起步</li></ul><hr><ul><li>结束的时候右灯（上提），慢慢滑倒旁边</li><li>脚踩离合和刹车，空挡-手刹-熄火-解开安全带</li><li>等5秒再下车</li></ul><h2 id="路途中"><a href="#路途中" class="headerlink" title="路途中"></a>路途中</h2><ul><li>起步的时候，需要变道的时候方向盘打轻点，中途方向灯停止了需要在打一次</li><li>需要转向时，先打灯，有虚线在虚线前停下，没有则在斑马先后面停下，3秒看对面车辆，不能再斑马线上停车，一档，转过去</li><li>转向后，有很长直线，加速跑4档，不加速跑5秒，然后换3档</li><li>过直线斑马线-点刹</li><li>需要回车的时候-点刹</li><li>转弯时，最好提前变道</li><li>右转（上提），左转（下拉）</li><li>停车后，一档起步</li></ul><h2 id="灯光"><a href="#灯光" class="headerlink" title="灯光"></a>灯光</h2><ul><li>打开前照灯 （位置：左手边 从0扭到灯光）</li><li>远光灯（下推）</li><li>夜间没有路灯不良条件下行驶</li><li>近光灯（轻推，回到默认位置）</li><li>夜间同方向跟车行驶</li><li>夜间会车</li><li>夜间直行通过路口</li><li>夜间在有路灯的情况下行驶</li><li>远近交替灯光（回拉，放下）</li><li>夜间通过急弯、坡路、拱桥</li><li>没有信号灯控制的路口</li><li>夜间超车 </li><li>视廓灯（位置：左手边 扭到中间）+ 紧急报警灯（位置：右手边 红色三角）</li><li>夜间机动车在路上发生故障又难以移动</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 学车 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM配置</title>
      <link href="/a21c0106b4dc.html"/>
      <url>/a21c0106b4dc.html</url>
      
        <content type="html"><![CDATA[<h1 id="common"><a href="#common" class="headerlink" title="common"></a>common</h1><h2 id="获取上下文"><a href="#获取上下文" class="headerlink" title="获取上下文"></a>获取上下文</h2><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//获取上下文</span><br><span class="line">@Component(&quot;applicationContextHelper&quot;)</span><br><span class="line">public class ApplicationContextHelper implements ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    private static ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext context) throws BeansException &#123;</span><br><span class="line">        applicationContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; T popBean(Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        if (applicationContext == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return applicationContext.getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; T popBean(String name, Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        if (applicationContext == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return applicationContext.getBean(name, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ApplicationContext getApplicationContext() &#123;</span><br><span class="line">        if (applicationContext == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * bean里面有那些东西</span><br><span class="line">     */</span><br><span class="line">    public static void printAllBeans() &#123;</span><br><span class="line">        String[] beans = applicationContext.getBeanDefinitionNames();</span><br><span class="line">        for (String beanName : beans) &#123;</span><br><span class="line">            if (beanName.indexOf(&quot;zuohy&quot;) &gt; 0) &#123;</span><br><span class="line">                Class&lt;?&gt; beanType = applicationContext.getType(beanName);</span><br><span class="line">                System.out.println(&quot;BeanName:&quot; + beanName);</span><br><span class="line">                System.out.println(&quot;Bean的类型：&quot; + beanType);</span><br><span class="line">                System.out.println(&quot;Bean所在的包：&quot; + beanType.getPackage());</span><br><span class="line">                System.out.println(&quot;Bean：&quot; + ApplicationContextHelper.applicationContext.getBean(beanName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Http前后监听"><a href="#Http前后监听" class="headerlink" title="Http前后监听"></a>Http前后监听</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">//Http前后监听</span><br><span class="line">@Slf4j</span><br><span class="line">public class HttpInterceptor extends HandlerInterceptorAdapter &#123;</span><br><span class="line"></span><br><span class="line">    private static final String START_TIME = &quot;requestStartTime&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 请求实现 前</span><br><span class="line">     *</span><br><span class="line">     * @param request</span><br><span class="line">     * @param response</span><br><span class="line">     * @param handler</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        String url = request.getRequestURL().toString();</span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">        log.info(&quot;request start. url:&#123;&#125;, params:&#123;&#125;&quot;, url, JsonMapper.obj2String(parameterMap));</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        request.setAttribute(START_TIME, start);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 正常请求结束后</span><br><span class="line">     *</span><br><span class="line">     * @param request</span><br><span class="line">     * @param response</span><br><span class="line">     * @param handler</span><br><span class="line">     * @param modelAndView</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 任何请求结束后</span><br><span class="line">     *</span><br><span class="line">     * @param request</span><br><span class="line">     * @param response</span><br><span class="line">     * @param handler</span><br><span class="line">     * @param ex</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        String url = request.getRequestURL().toString();</span><br><span class="line">        long start = (Long) request.getAttribute(START_TIME);</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        log.info(&quot;request completion. url:&#123;&#125;, cost:&#123;&#125;&quot;, url, end - start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Json返回"><a href="#Json返回" class="headerlink" title="Json返回"></a>Json返回</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">public class JsonData &#123;</span><br><span class="line">    private boolean ret;</span><br><span class="line"></span><br><span class="line">    private String msg;</span><br><span class="line"></span><br><span class="line">    private Object data;</span><br><span class="line"></span><br><span class="line">    public JsonData(boolean ret) &#123;</span><br><span class="line">        this.ret = ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static JsonData success(String msg, Object object) &#123;</span><br><span class="line">        JsonData jsonData = new JsonData(true);</span><br><span class="line">        jsonData.msg = msg;</span><br><span class="line">        jsonData.data = object;</span><br><span class="line">        return jsonData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static JsonData success(Object object) &#123;</span><br><span class="line">        JsonData jsonData = new JsonData(true);</span><br><span class="line">        jsonData.data = object;</span><br><span class="line">        return jsonData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static JsonData success() &#123;</span><br><span class="line">        return new JsonData(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static JsonData fail(String msg) &#123;</span><br><span class="line">        JsonData jsonData = new JsonData(false);</span><br><span class="line">        jsonData.msg = msg;</span><br><span class="line">        return jsonData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Map&lt;String,Object&gt; toMap()&#123;</span><br><span class="line">        HashMap&lt;String,Object&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">        result.put(&quot;ret&quot;,ret);</span><br><span class="line">        result.put(&quot;msg&quot;,msg);</span><br><span class="line">        result.put(&quot;data&quot;,data);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class SpringExceptionResolver implements HandlerExceptionResolver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object o, Exception e) &#123;</span><br><span class="line">        String url = request.getRequestURL().toString();</span><br><span class="line">        ModelAndView mv;</span><br><span class="line">        String defaultMsg = &quot;System error&quot;;</span><br><span class="line">        // .json .do</span><br><span class="line">        // 要求项目中所有请求json数据,都用.json结尾</span><br><span class="line">        if (url.endsWith(&quot;.json&quot;)) &#123;</span><br><span class="line">            if (e instanceof PermissionException || e instanceof ParamException) &#123;</span><br><span class="line">                JsonData result = JsonData.fail(e.getMessage());</span><br><span class="line">                mv = new ModelAndView(&quot;jsonView&quot;, result.toMap());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                log.error(&quot;unknown json exception---url:&quot;+url,e);</span><br><span class="line">                JsonData result = JsonData.fail(defaultMsg);</span><br><span class="line">                mv = new ModelAndView(&quot;jsonView&quot;, result.toMap());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (url.endsWith(&quot;.do&quot;)) &#123;//要求项目中所有请求page页面,都用.do结尾</span><br><span class="line">            JsonData result = JsonData.fail(defaultMsg);</span><br><span class="line">            mv = new ModelAndView(&quot;exception&quot;, result.toMap());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.error(&quot;unknown page exception---url:&quot;+url,e);</span><br><span class="line">            JsonData result = JsonData.fail(defaultMsg);</span><br><span class="line">            mv = new ModelAndView(&quot;jsonView&quot;, result.toMap());</span><br><span class="line">        &#125;</span><br><span class="line">        return mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="exception"><a href="#exception" class="headerlink" title="exception"></a>exception</h1><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//自定义异常</span><br><span class="line">public class PermissionException extends RuntimeException &#123;</span><br><span class="line">    public PermissionException() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PermissionException(String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PermissionException(String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PermissionException(Throwable cause) &#123;</span><br><span class="line">        super(cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected PermissionException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) &#123;</span><br><span class="line">        super(message, cause, enableSuppression, writableStackTrace);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="校验异常"><a href="#校验异常" class="headerlink" title="校验异常"></a>校验异常</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//校验异常</span><br><span class="line">public class ParamException extends RuntimeException &#123;</span><br><span class="line">    public ParamException() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ParamException(String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ParamException(String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ParamException(Throwable cause) &#123;</span><br><span class="line">        super(cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected ParamException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) &#123;</span><br><span class="line">        super(message, cause, enableSuppression, writableStackTrace);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="xml及-properties"><a href="#xml及-properties" class="headerlink" title=".xml及.properties"></a><em>.xml及</em>.properties</h1><h2 id="spring-xml"><a href="#spring-xml" class="headerlink" title="spring.xml"></a>spring.xml</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 获取资源文件 --&gt;</span><br><span class="line">    &lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;</span><br><span class="line">        &lt;!-- 忽略无法处理的占位 --&gt;</span><br><span class="line">        &lt;property name=&quot;ignoreUnresolvablePlaceholders&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;locations&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;classpath:settings.properties&lt;/value&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 数据源 init开始 destroy关闭 --&gt;</span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;db.driverClassName&#125;&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;$&#123;db.url&#125;&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;$&#123;db.username&#125;&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;$&#123;db.password&#125;&quot;/&gt;</span><br><span class="line">        &lt;!-- 初始大小 --&gt;</span><br><span class="line">        &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;db.initialSize&#125;&quot;/&gt;</span><br><span class="line">        &lt;!-- 最小空余数量 --&gt;</span><br><span class="line">        &lt;property name=&quot;minIdle&quot; value=&quot;$&#123;db.minIdle&#125;&quot;/&gt;</span><br><span class="line">        &lt;!-- 最大连接 --&gt;</span><br><span class="line">        &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;db.maxActive&#125;&quot;/&gt;</span><br><span class="line">        &lt;!-- 最长等待时间 --&gt;</span><br><span class="line">        &lt;property name=&quot;maxWait&quot; value=&quot;$&#123;db.maxWait&#125;&quot;/&gt;</span><br><span class="line">        &lt;!-- --&gt;</span><br><span class="line">        &lt;property name=&quot;filters&quot; value=&quot;stat&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;proxyFilters&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;ref bean=&quot;wall-filter&quot;/&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- sqlSessionFactory --&gt;</span><br><span class="line">    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:mapper/*.xml&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 数据库操作 --&gt;</span><br><span class="line">    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;basePackage&quot; value=&quot;cn.zuohy.dao&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 事务 --&gt;</span><br><span class="line">    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- druid --&gt;</span><br><span class="line">    &lt;bean id=&quot;stat-filter&quot; class=&quot;com.alibaba.druid.filter.stat.StatFilter&quot;&gt;</span><br><span class="line">        &lt;!-- 发现慢sql --&gt;</span><br><span class="line">        &lt;property name=&quot;slowSqlMillis&quot; value=&quot;3000&quot;/&gt;</span><br><span class="line">        &lt;!-- 记录sql --&gt;</span><br><span class="line">        &lt;property name=&quot;logSlowSql&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;mergeSql&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;wall-filter&quot; class=&quot;com.alibaba.druid.wall.WallFilter&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dbType&quot; value=&quot;mysql&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;config&quot; ref=&quot;wall-config&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;!-- 开启批量 --&gt;</span><br><span class="line">    &lt;bean id=&quot;wall-config&quot; class=&quot;com.alibaba.druid.wall.WallConfig&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;multiStatementAllow&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h2 id="spring-servlet-xml"><a href="#spring-servlet-xml" class="headerlink" title="spring-servlet.xml"></a>spring-servlet.xml</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">                           http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;</span><br><span class="line">    &lt;!-- context Bean --&gt;</span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 启动包扫描 --&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;cn.zuohy.controller&quot;/&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;cn.zuohy.service&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 启动注解驱动的Spring mvc 功能 --&gt;</span><br><span class="line">    &lt;mvc:annotation-driven/&gt;</span><br><span class="line">&lt;!-- 静态 --&gt;</span><br><span class="line">    &lt;mvc:resources mapping=&quot;/static/**&quot; location=&quot;/static/&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 加载上下文获取 --&gt;</span><br><span class="line">    &lt;bean class=&quot;cn.zuohy.common.ApplicationContextHelper&quot; lazy-init=&quot;false&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 异常 --&gt;</span><br><span class="line">    &lt;bean class=&quot;cn.zuohy.common.SpringExceptionResolver&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 格式 --&gt;</span><br><span class="line">    &lt;bean class=&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- json --&gt;</span><br><span class="line">    &lt;bean id=&quot;jsonView&quot; class=&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- jsp --&gt;</span><br><span class="line">    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h2 id="settings-properties"><a href="#settings-properties" class="headerlink" title="settings.properties"></a>settings.properties</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line">db.url=jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;allowMultiQueries=true</span><br><span class="line">db.username=</span><br><span class="line">db.password=</span><br><span class="line">db.initialSize=3</span><br><span class="line">db.minIdle=3</span><br><span class="line">db.maxActive=20</span><br><span class="line">db.maxWait=60000</span><br></pre></td></tr></table></figure><h2 id="mybatis-config-xml"><a href="#mybatis-config-xml" class="headerlink" title="mybatis-config.xml"></a>mybatis-config.xml</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">        &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line">    &lt;!--&lt;typeAliases&gt;--&gt;</span><br><span class="line">        &lt;!----&gt;</span><br><span class="line">    &lt;!--&lt;/typeAliases&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;plugins&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;plugin interceptor=&quot;&quot;&gt;&lt;/plugin&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;/plugins&gt;--&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h2 id="logback-xml"><a href="#logback-xml" class="headerlink" title="logback.xml"></a>logback.xml</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- log输出形式 --&gt;</span><br><span class="line">    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger - %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 日志物理输出 --&gt;</span><br><span class="line">    &lt;!--&lt;appender name=&quot;permission&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;!– 生成路径 –&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;file&gt;$&#123;catalina.home&#125;/logs/permission.log&lt;/file&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;!– 日志压缩 –&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;FileNamePattern&gt;$&#123;catalina.home&#125;/logs/permission.%&#123;yyyy-MM-dd&#125;.log.gz&lt;/FileNamePattern&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;/rollingPolicy&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;!– 日志输出样式 –&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger - %msg%n&lt;/pattern&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;/layout&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;/appender&gt;--&gt;</span><br><span class="line">    &lt;!----&gt;</span><br><span class="line">    &lt;!--&lt;logger name=&quot;xxx&quot; leval=&quot;INFO&quot;&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;appender-ref ref=&quot;permission&quot;/&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;/logger&gt;--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- TEACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR--&gt;</span><br><span class="line">    &lt;root level=&quot;INFO&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;STDOUT&quot;/&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span><br><span class="line">         id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;display-name&gt;module&lt;/display-name&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- Spring beans 加载 --&gt;</span><br><span class="line">    &lt;listener&gt;</span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">    &lt;/listener&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt;</span><br><span class="line">    &lt;/context-param&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Spring mvc 配置--&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">            &lt;param-value&gt;classpath:spring-servlet.xml&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Encoding --&gt;</span><br><span class="line">    &lt;filter&gt;</span><br><span class="line">        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;</span><br><span class="line">        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">            &lt;param-value&gt;UTF-8&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;forceEncoding&lt;/param-name&gt;</span><br><span class="line">            &lt;param-value&gt;true&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line">    &lt;filter-mapping&gt;</span><br><span class="line">        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- druid --&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;DruidStatServlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;loginUsername&lt;/param-name&gt;</span><br><span class="line">            &lt;param-value&gt;druid&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;loginPassword&lt;/param-name&gt;</span><br><span class="line">            &lt;param-value&gt;druid&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;DruidStatServlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/sys/druid/*&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">    &lt;filter&gt;</span><br><span class="line">        &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt;</span><br><span class="line">        &lt;filter-class&gt;com.alibaba.druid.support.http.WebStatFilter&lt;/filter-class&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;exclusions&lt;/param-name&gt;</span><br><span class="line">            &lt;param-value&gt;*.js,*.css,*.jpg,*.png,*.ico,*.gif,/sys/druid/*&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line">    &lt;filter-mapping&gt;</span><br><span class="line">        &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 未指定访问index.jsp --&gt;</span><br><span class="line">    &lt;welcome-file-list&gt;</span><br><span class="line">        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;</span><br><span class="line">    &lt;/welcome-file-list&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">&lt;groupId&gt;cn.zuohy&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;module&lt;/artifactId&gt;</span><br><span class="line">&lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;name&gt;module Maven Webapp&lt;/name&gt;</span><br><span class="line">&lt;url&gt;http://maven.apache.org&lt;/url&gt;</span><br><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">&lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;</span><br><span class="line">&lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;spring.version&gt;5.1.3.RELEASE&lt;/spring.version&gt;</span><br><span class="line">&lt;logback.version&gt;1.2.3&lt;/logback.version&gt;</span><br><span class="line">&lt;mybatis.version&gt;3.4.6&lt;/mybatis.version&gt;</span><br><span class="line">&lt;mybatis-spring.version&gt;1.3.2&lt;/mybatis-spring.version&gt;</span><br><span class="line">&lt;druid.version&gt;1.1.12&lt;/druid.version&gt;</span><br><span class="line">&lt;mysql.version&gt;6.0.6&lt;/mysql.version&gt;</span><br><span class="line">&lt;lombok.version&gt;1.16.20&lt;/lombok.version&gt;</span><br><span class="line">&lt;jackson.varsion&gt;2.9.7&lt;/jackson.varsion&gt;</span><br><span class="line">&lt;slf4j.varsion&gt;1.7.25&lt;/slf4j.varsion&gt;</span><br><span class="line">&lt;tomcat-jsp-api.varsion&gt;8.0.53&lt;/tomcat-jsp-api.varsion&gt;</span><br><span class="line">&lt;validation-api.varsion&gt;2.0.1.Final&lt;/validation-api.varsion&gt;</span><br><span class="line">&lt;hibernate-validator.varsion&gt;6.0.13.Final&lt;/hibernate-validator.varsion&gt;</span><br><span class="line">&lt;commons-collections4.varsion&gt;4.2&lt;/commons-collections4.varsion&gt;</span><br><span class="line">&lt;commons-codec.varsion&gt;1.11&lt;/commons-codec.varsion&gt;</span><br><span class="line">&lt;commons-lang3.varsion&gt;3.8.1&lt;/commons-lang3.varsion&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- spring --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- Spring MVC + Spring web --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- mybatis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;mybatis-spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- druid --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- mysql --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- lombok --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- jackson --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jackson-datatype-guava&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;jackson.varsion&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jackson-core&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;jackson.varsion&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;jackson.varsion&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- logback --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;logback-core&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;logback.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;logback.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;slf4j.varsion&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- jsp-api --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;tomcat-jsp-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;tomcat-jsp-api.varsion&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- validation --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javax.validation&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;validation-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;validation-api.varsion&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;hibernate-validator.varsion&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- tools --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;commons-collections4.varsion&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;commons-codec&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-codec&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;commons-codec.varsion&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;commons-lang3.varsion&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;finalName&gt;module&lt;/finalName&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.1&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">&lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.6&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;!--编译之后包含xml --&gt;</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">&lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">&lt;includes&gt;</span><br><span class="line">&lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">&lt;/includes&gt;</span><br><span class="line">&lt;/resource&gt;</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">&lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">&lt;includes&gt;</span><br><span class="line">&lt;include&gt;**/*&lt;/include&gt;</span><br><span class="line">&lt;/includes&gt;</span><br><span class="line">&lt;/resource&gt;</span><br><span class="line">&lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><h1 id="util"><a href="#util" class="headerlink" title="util"></a>util</h1><h2 id="json和类的转换"><a href="#json和类的转换" class="headerlink" title="json和类的转换"></a>json和类的转换</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//json和类的转换</span><br><span class="line">@Slf4j</span><br><span class="line">public class JsonMapper &#123;</span><br><span class="line">    private static ObjectMapper objectMapper = new ObjectMapper();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        //config</span><br><span class="line">        objectMapper.disable(DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES);</span><br><span class="line">        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);</span><br><span class="line">        objectMapper.setFilterProvider(new SimpleFilterProvider().setFailOnUnknownId(false));</span><br><span class="line">        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; String obj2String(T src) &#123;</span><br><span class="line">        if (src == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            return src instanceof String ? (String) src : objectMapper.writeValueAsString(src);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.warn(&quot;parse Object to String exception, error:&#123;&#125;&quot;, e);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; T string2Obj(String src, TypeReference&lt;T&gt; typeReference) &#123;</span><br><span class="line">        if (src == null || typeReference == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (T) (typeReference.getType().equals(String.class) ? src : objectMapper.readValue(src, typeReference));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.warn(&quot;parse String to Object exception, String:&#123;&#125;, TypeReference&lt;T&gt;:&#123;&#125;, error:&#123;&#125;&quot;, src, typeReference, e);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Validator校验工具"><a href="#Validator校验工具" class="headerlink" title="Validator校验工具"></a>Validator校验工具</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//Validator校验工具</span><br><span class="line">public class BeanValidator &#123;</span><br><span class="line"></span><br><span class="line">    private static ValidatorFactory validatorFactory = Validation.buildDefaultValidatorFactory();</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; Map&lt;String, String&gt; validate(T t, Class... groups) &#123;</span><br><span class="line">        Validator validator = validatorFactory.getValidator();</span><br><span class="line">        Set validateResult = validator.validate(t, groups);</span><br><span class="line">        if (validateResult.isEmpty()) &#123;</span><br><span class="line">            return Collections.emptyMap();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            LinkedHashMap errors = Maps.newLinkedHashMap();</span><br><span class="line">            Iterator iterator = validateResult.iterator();</span><br><span class="line">            while (iterator.hasNext()) &#123;</span><br><span class="line">                ConstraintViolation violation = (ConstraintViolation) iterator.next();</span><br><span class="line">                errors.put(violation.getPropertyPath().toString(), violation.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            return errors;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Map&lt;String, String&gt; validateList(Collection&lt;?&gt; collection) &#123;</span><br><span class="line">        Preconditions.checkNotNull(collection);</span><br><span class="line">        Iterator iterator = collection.iterator();</span><br><span class="line">        Map errors;</span><br><span class="line">        do &#123;</span><br><span class="line">            if (!iterator.hasNext()) &#123;</span><br><span class="line">                return Collections.emptyMap();</span><br><span class="line">            &#125;</span><br><span class="line">            Object object = iterator.next();</span><br><span class="line">            errors = validate(object, new Class[0]);</span><br><span class="line">        &#125; while (errors.isEmpty());</span><br><span class="line">        return errors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Map&lt;String, String&gt; validateObject(Object first, Object... objects) &#123;</span><br><span class="line">        if (objects != null &amp;&amp; objects.length &gt; 0) &#123;</span><br><span class="line">            return validateList(Lists.asList(first, objects));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return validate(first, new Class[0]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  异常处理</span><br><span class="line">     * @param param</span><br><span class="line">     * @throws ParamException</span><br><span class="line">     */</span><br><span class="line">    public static void check(Object param) throws ParamException &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = BeanValidator.validateObject(param);</span><br><span class="line">        if (MapUtils.isNotEmpty(map)) &#123;</span><br><span class="line">            throw new ParamException(map.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM目录</title>
      <link href="/7434890e6022.html"/>
      <url>/7434890e6022.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>这个是自用的目录结构</p></blockquote><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">目录结构</span><br><span class="line">│  .classpath</span><br><span class="line">│  .project</span><br><span class="line">│  list.txt</span><br><span class="line">│  pom.xml</span><br><span class="line">│  </span><br><span class="line">├─.settings</span><br><span class="line">│      .jsdtscope</span><br><span class="line">│      org.eclipse.core.resources.prefs</span><br><span class="line">│      org.eclipse.jdt.core.prefs</span><br><span class="line">│      org.eclipse.m2e.core.prefs</span><br><span class="line">│      org.eclipse.wst.common.component</span><br><span class="line">│      org.eclipse.wst.common.project.facet.core.xml</span><br><span class="line">│      org.eclipse.wst.jsdt.ui.superType.container</span><br><span class="line">│      org.eclipse.wst.jsdt.ui.superType.name</span><br><span class="line">│      org.eclipse.wst.validation.prefs</span><br><span class="line">│      </span><br><span class="line">├─src</span><br><span class="line">│  ├─main</span><br><span class="line">│  │  ├─java</span><br><span class="line">│  │  │  └─cn</span><br><span class="line">│  │  │      └─zuohy</span><br><span class="line">│  │  │          ├─beans</span><br><span class="line">│  │  │          ├─common</span><br><span class="line">│  │  │          │      ApplicationContextHelper.java</span><br><span class="line">│  │  │          │      HttpInterceptor.java</span><br><span class="line">│  │  │          │      JsonData.java</span><br><span class="line">│  │  │          │      SpringExceptionResolver.java</span><br><span class="line">│  │  │          │      </span><br><span class="line">│  │  │          ├─controller</span><br><span class="line">│  │  │          │      TestController.java</span><br><span class="line">│  │  │          │      </span><br><span class="line">│  │  │          ├─dao</span><br><span class="line">│  │  │          ├─exception</span><br><span class="line">│  │  │          │      ParamException.java</span><br><span class="line">│  │  │          │      PermissionException.java</span><br><span class="line">│  │  │          │      </span><br><span class="line">│  │  │          ├─filter</span><br><span class="line">│  │  │          ├─model</span><br><span class="line">│  │  │          ├─param</span><br><span class="line">│  │  │          │      TestParam.java</span><br><span class="line">│  │  │          │      </span><br><span class="line">│  │  │          ├─service</span><br><span class="line">│  │  │          └─util</span><br><span class="line">│  │  │                  BeanValidator.java</span><br><span class="line">│  │  │                  JsonMapper.java</span><br><span class="line">│  │  │                  </span><br><span class="line">│  │  ├─resources</span><br><span class="line">│  │  │  │  logback.xml</span><br><span class="line">│  │  │  │  mybatis-config.xml</span><br><span class="line">│  │  │  │  settings.properties</span><br><span class="line">│  │  │  │  spring-servlet.xml</span><br><span class="line">│  │  │  │  spring.xml</span><br><span class="line">│  │  │  │  </span><br><span class="line">│  │  │  └─mapper</span><br><span class="line">│  │  └─webapp</span><br><span class="line">│  │      │  index.jsp</span><br><span class="line">│  │      │  </span><br><span class="line">│  │      ├─static</span><br><span class="line">│  │      └─WEB-INF</span><br><span class="line">│  │              web.xml</span><br><span class="line">│  │              </span><br><span class="line">│  └─test</span><br><span class="line">│      └─java</span><br><span class="line">└─target</span><br><span class="line">    ├─classes</span><br><span class="line">    │  │  logback.xml</span><br><span class="line">    │  │  mybatis-config.xml</span><br><span class="line">    │  │  settings.properties</span><br><span class="line">    │  │  spring-servlet.xml</span><br><span class="line">    │  │  spring.xml</span><br><span class="line">    │  │  </span><br><span class="line">    │  └─cn</span><br><span class="line">    │      └─zuohy</span><br><span class="line">    │          ├─beans</span><br><span class="line">    │          ├─common</span><br><span class="line">    │          │      ApplicationContextHelper.class</span><br><span class="line">    │          │      HttpInterceptor.class</span><br><span class="line">    │          │      JsonData.class</span><br><span class="line">    │          │      SpringExceptionResolver.class</span><br><span class="line">    │          │      </span><br><span class="line">    │          ├─controller</span><br><span class="line">    │          │      TestController.class</span><br><span class="line">    │          │      </span><br><span class="line">    │          ├─dao</span><br><span class="line">    │          ├─exception</span><br><span class="line">    │          │      ParamException.class</span><br><span class="line">    │          │      PermissionException.class</span><br><span class="line">    │          │      </span><br><span class="line">    │          ├─filter</span><br><span class="line">    │          ├─model</span><br><span class="line">    │          ├─param</span><br><span class="line">    │          │      TestParam.class</span><br><span class="line">    │          │      </span><br><span class="line">    │          ├─service</span><br><span class="line">    │          └─util</span><br><span class="line">    │                  BeanValidator.class</span><br><span class="line">    │                  JsonMapper.class</span><br><span class="line">    │                  </span><br><span class="line">    ├─m2e-wtp</span><br><span class="line">    │  └─web-resources</span><br><span class="line">    │      └─META-INF</span><br><span class="line">    │          │  MANIFEST.MF</span><br><span class="line">    │          │  </span><br><span class="line">    │          └─maven</span><br><span class="line">    │              └─cn.zuohy</span><br><span class="line">    │                  └─module</span><br><span class="line">    │                          pom.properties</span><br><span class="line">    │                          pom.xml</span><br><span class="line">    │                          </span><br><span class="line">    └─test-classes</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/7434890e6022/1.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Log4j配置</title>
      <link href="/d8aaf5d37cb0.html"/>
      <url>/d8aaf5d37cb0.html</url>
      
        <content type="html"><![CDATA[<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootLogger </span><br><span class="line">为总的</span><br><span class="line">log4j.appender.console.Threshold=DEBUG </span><br><span class="line">为控制台输出，这个决定着控制台是否输出sql语句</span><br></pre></td></tr></table></figure><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;!-- log4j日志文件管理包版本 --&gt;</span><br><span class="line">&lt;log4j.varsion&gt;1.2.17&lt;/log4j.varsion&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- log4j --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;log4j.varsion&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="log4j-properties"><a href="#log4j-properties" class="headerlink" title="log4j.properties"></a>log4j.properties</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">### Log4j配置 ### #允许DEBUG级别以上的日志可以打印到控制台和写入日志文件</span><br><span class="line">log4j.rootLogger=DEBUG,console,file</span><br><span class="line">#-----------------------------------# #1</span><br><span class="line">定义日志输出目的地为控制台</span><br><span class="line">log4j.appender.console=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.Target=System.out</span><br><span class="line">log4j.appender.console.Threshold=DEBUG</span><br><span class="line"></span><br><span class="line">####可以灵活地指定日志输出格式，下面一行是指定具体的格式</span><br><span class="line">### #%c: 输出日志信息所属的类目，通常就是所在类的全名 #%m: 输出代码中指定的消息,产生的日志具体信息 #%n:</span><br><span class="line">输出一个回车换行符，Windows平台为&quot;/r/n&quot;，Unix平台为&quot;/n&quot;输出日志信息换行</span><br><span class="line">log4j.appender.console.layout=org.apache.log4j.PatternLayout</span><br><span class="line"></span><br><span class="line">#日志记录格式（根据自己喜好更改）</span><br><span class="line">log4j.appender.console.layout.ConversionPattern=%d [%-5p] - %c (%F.%M:%L) - %m%n</span><br><span class="line"></span><br><span class="line">#-----------------------------------# #2</span><br><span class="line">文件大小到达指定尺寸的时候产生一个新的文件</span><br><span class="line">log4j.appender.file=org.apache.log4j.RollingFileAppender</span><br><span class="line"></span><br><span class="line">#日志文件输出目录</span><br><span class="line">log4j.appender.file.File=E\:/dummmmmmmy/logs/log.log</span><br><span class="line"></span><br><span class="line">#定义文件最大大小</span><br><span class="line">log4j.appender.file.MaxFileSize=1024kb</span><br><span class="line"></span><br><span class="line">#最多生成多少个文件</span><br><span class="line">log4j.appender.file.MaxBackupIndex=20</span><br><span class="line"></span><br><span class="line">###输出日志信息### #写到文件的日志的最低级别</span><br><span class="line">log4j.appender.file.Threshold=ERROR</span><br><span class="line">log4j.appender.file.layout=org.apache.log4j.PatternLayout</span><br><span class="line"></span><br><span class="line">#日志记录格式（根据自己喜好更改）</span><br><span class="line">log4j.appender.file.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH\:mm\:ss&#125; [%p] - %c - %F(%L) -%m%n #-----------------------------------#</span><br><span class="line"></span><br><span class="line">log4j.logger.cn.zuohy.websocke.dao=DEBUG --输出SQL语句</span><br><span class="line"></span><br><span class="line">#3 mybatis 显示SQL语句部分</span><br><span class="line">log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG</span><br><span class="line">log4j.logger.java.sql.Statement=DEBUG</span><br><span class="line">log4j.logger.java.sql.ResultSet=DEBUG</span><br><span class="line">log4j.logger.java.sql.PreparedStatement=DEBUG</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Log4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rest风格</title>
      <link href="/f6db78db1f90.html"/>
      <url>/f6db78db1f90.html</url>
      
        <content type="html"><![CDATA[<h2 id="RestAction"><a href="#RestAction" class="headerlink" title="RestAction"></a>RestAction</h2><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 测试GET,POST,PUT,DELETE</span><br><span class="line"> * </span><br><span class="line"> * @author dummmmmmmy</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/rest&quot;)</span><br><span class="line">public class RestAction &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private UserService userService;</span><br><span class="line"></span><br><span class="line">@RequestMapping(value = &quot;/index.action&quot;)</span><br><span class="line">public String userAction(ModelMap map) &#123;</span><br><span class="line">List&lt;User&gt; listUser = userService.listUser(&quot;admin&quot;, &quot;admin&quot;);</span><br><span class="line">map.put(&quot;listUser&quot;, listUser);</span><br><span class="line">return &quot;/rest/user&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RequestMapping(value = &quot;/user.json&quot;, method = RequestMethod.GET)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Result userJsonGet(@Param(&quot;userId&quot;) Integer userId) &#123;</span><br><span class="line">User user = userService.get(userId);</span><br><span class="line">return Result.success().add(&quot;user&quot;, user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RequestMapping(value = &quot;/user.json&quot;, method = RequestMethod.POST)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Result userJsonPost(User user) &#123;</span><br><span class="line">int tmp = userService.post(user);</span><br><span class="line">System.out.println(&quot;-------------返回:&quot; + tmp);</span><br><span class="line">System.out.println(&quot;-------------ID:&quot; + user.getUserId());</span><br><span class="line">return Result.success();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RequestMapping(value = &quot;/user.json&quot;, method = RequestMethod.PUT)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Result userJsonPut(User user) &#123;</span><br><span class="line">int tmp = userService.put(user);</span><br><span class="line">System.out.println(&quot;-------------返回:&quot; + tmp);</span><br><span class="line">return Result.success();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RequestMapping(value = &quot;/user.json&quot;, method = RequestMethod.DELETE)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Result userJsonDelete(@Param(&quot;userId&quot;) Integer userId) &#123;</span><br><span class="line">int tmp = userService.delete(userId);</span><br><span class="line">System.out.println(&quot;-------------返回:&quot; + tmp);</span><br><span class="line">return Result.success();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">&lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure><h2 id="form"><a href="#form" class="headerlink" title="form"></a>form</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;_method&quot; id=&quot;_method&quot; value=&quot;put&quot;&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Rest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket</title>
      <link href="/0cfa7e337349.html"/>
      <url>/0cfa7e337349.html</url>
      
        <content type="html"><![CDATA[<h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class SocketAction &#123;</span><br><span class="line"></span><br><span class="line">private MyHandler myHandler = new MyHandler();</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;/login/&#123;username&#125;&quot;)</span><br><span class="line">public String login(HttpSession session, @PathVariable(&quot;username&quot;) String username) &#123;</span><br><span class="line">System.out.println(&quot;login登录接口,username=&quot; + username);</span><br><span class="line">session.setAttribute(&quot;username&quot;, username);</span><br><span class="line">System.out.println(&quot;login&quot; + session.getAttribute(&quot;username&quot;));</span><br><span class="line">return &quot;/websocket/index&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;/message&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String sendMessage() &#123;</span><br><span class="line">boolean flag = myHandler.sendMessageToAllUsers(new TextMessage(&quot;你好&quot;));</span><br><span class="line">System.out.println(&quot;sendMessage&quot; + flag);</span><br><span class="line">return &quot;发送&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MyHandler"><a href="#MyHandler" class="headerlink" title="MyHandler"></a>MyHandler</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class MyHandler extends TextWebSocketHandler &#123;</span><br><span class="line">// 在线用户列表</span><br><span class="line">private static final Map&lt;String, WebSocketSession&gt; users;</span><br><span class="line">// 用户标识</span><br><span class="line">private static final String CLIENT_ID = &quot;username&quot;;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">users = new HashMap&lt;String, WebSocketSession&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * webSocket连接</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123;</span><br><span class="line">System.out.println(&quot;afterConnectionEstablished:成功建立连接&quot;);</span><br><span class="line">String username = getClientId(session);</span><br><span class="line">System.out.println(&quot;afterConnectionEstablished:&quot; + username);</span><br><span class="line">if (username != null) &#123;</span><br><span class="line">users.put(username, session);</span><br><span class="line">session.sendMessage(new TextMessage(&quot;afterConnectionEstablished:成功建立socket连接&quot;));</span><br><span class="line">System.out.println(&quot;afterConnectionEstablished&quot;+username);</span><br><span class="line">System.out.println(&quot;afterConnectionEstablished&quot;+session);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 收到消息</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception &#123;</span><br><span class="line">System.out.println(&quot;handleTextMessage&quot;+message.getPayload());</span><br><span class="line">WebSocketMessage&lt;?&gt; message1 = new TextMessage(&quot;handleTextMessage:&quot; + message);</span><br><span class="line">try &#123;</span><br><span class="line">session.sendMessage(message1);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception &#123;</span><br><span class="line">if (session.isOpen()) &#123;</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;handleTransportError&quot;+&quot;连接出错&quot;);</span><br><span class="line">users.remove(getClientId(session));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception &#123;</span><br><span class="line">System.out.println(&quot;afterConnectionClosed连接已关闭：&quot; + status);</span><br><span class="line">users.remove(getClientId(session));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean supportsPartialMessages() &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取用户标识</span><br><span class="line"> */</span><br><span class="line">private String getClientId(WebSocketSession session) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">String clientId = (String) session.getAttributes().get(CLIENT_ID);</span><br><span class="line">return clientId;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 发送信息给指定用户</span><br><span class="line"> */</span><br><span class="line">public boolean sendMessageToUser(String clientId, TextMessage message) &#123;</span><br><span class="line">if (users.get(clientId) == null) &#123;</span><br><span class="line">System.out.println(&quot;sendMessageToUser + 1&quot;);</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">WebSocketSession session = users.get(clientId);</span><br><span class="line">System.out.println(&quot;sendMessage:&quot; + session);</span><br><span class="line">if (!session.isOpen()) &#123;</span><br><span class="line">System.out.println(&quot;sendMessageToUser + 2&quot;);</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">session.sendMessage(message);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">System.out.println(&quot;sendMessageToUser&quot;+e);</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 广播信息</span><br><span class="line"> */</span><br><span class="line">public boolean sendMessageToAllUsers(TextMessage message) &#123;</span><br><span class="line">boolean allSendSuccess = true;</span><br><span class="line">Set&lt;String&gt; clientIds = users.keySet();</span><br><span class="line">WebSocketSession session = null;</span><br><span class="line">for (String clientId : clientIds) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">session = users.get(clientId);</span><br><span class="line">if (session.isOpen()) &#123;</span><br><span class="line">session.sendMessage(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">allSendSuccess = false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return allSendSuccess;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebSocketConfig"><a href="#WebSocketConfig" class="headerlink" title="WebSocketConfig"></a>WebSocketConfig</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Configuration // 标注在类上，相当于把该类作为spring的xml配置文件中的&lt;beans&gt;，作用为：配置spring容器(应用上下文)</span><br><span class="line">@EnableWebSocket</span><br><span class="line">public class WebSocketConfig implements WebSocketConfigurer &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 创建一个WebSocket配置类（这里也可以用配置文件来实现其实），实现接口来配置Websocket请求的路径和拦截器</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123;</span><br><span class="line">// 加个setAllowedOrigins(“*”)不然可能会报403的错误</span><br><span class="line">registry.addHandler(myHandler(), &quot;/myHandler&quot;).addInterceptors(new WebSocketInterceptor())</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line">//spring4.2以上加 .setAllowedOrigins(&quot;*&quot;)</span><br><span class="line">@Bean(name = &quot;myHandler&quot;)</span><br><span class="line">public WebSocketHandler myHandler() &#123;</span><br><span class="line">return new MyHandler();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 等价于 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=</span><br><span class="line"> * &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:websocket=</span><br><span class="line"> * &quot;http://www.springframework.org/schema/websocket&quot; xsi:schemaLocation=&quot;</span><br><span class="line"> * http://www.springframework.org/schema/beans</span><br><span class="line"> * http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line"> * http://www.springframework.org/schema/websocket</span><br><span class="line"> * http://www.springframework.org/schema/websocket/spring-websocket.xsd&quot;&gt;</span><br><span class="line"> * </span><br><span class="line"> * &lt;websocket:handlers&gt;</span><br><span class="line"> * &lt;websocket:mapping path=&quot;/myHandler&quot; handler=&quot;myHandler&quot;/&gt;</span><br><span class="line"> * &lt;/websocket:handlers&gt;</span><br><span class="line"> * </span><br><span class="line"> * &lt;bean id=&quot;myHandler&quot; class=&quot;org.springframework.samples.MyHandler&quot;/&gt;</span><br><span class="line"> * </span><br><span class="line"> * &lt;/beans&gt;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebSocketInterceptor"><a href="#WebSocketInterceptor" class="headerlink" title="WebSocketInterceptor"></a>WebSocketInterceptor</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Component //不好说明层面,但是交给Spring来管理</span><br><span class="line">public class WebSocketInterceptor implements HandshakeInterceptor &#123;</span><br><span class="line">/**</span><br><span class="line"> * 创建拦截器，用来记录用户标识，便于后面向特定用户发送消息</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler,</span><br><span class="line">Map&lt;String, Object&gt; attributes) throws Exception &#123;</span><br><span class="line">// object instanceof class</span><br><span class="line">// instanceof class可以是object对象的父类，自身类，不能是子类。</span><br><span class="line">// 在前两种情况下result的结果为true</span><br><span class="line">// 最后一种为false。但是class为子类时编译不会报错。运行结果为false。</span><br><span class="line">if (request instanceof ServletServerHttpRequest) &#123;</span><br><span class="line">ServletServerHttpRequest serverHttpRequest = (ServletServerHttpRequest) request;</span><br><span class="line">HttpSession session = serverHttpRequest.getServletRequest().getSession();</span><br><span class="line">if (session != null) &#123;</span><br><span class="line">attributes.put(&quot;username&quot;, session.getAttribute(&quot;username&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler,</span><br><span class="line">Exception exception) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;./static/js/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">$(function() &#123;</span><br><span class="line">// 创建一个Socket实例</span><br><span class="line"></span><br><span class="line">var socket = new WebSocket(&#x27;ws://localhost:8080/websocke/myHandler&#x27;);</span><br><span class="line">// 打开Socket</span><br><span class="line">socket.onopen = function(event) &#123;</span><br><span class="line"></span><br><span class="line">// 发送一个初始化消息</span><br><span class="line">socket.send(&#x27;I am the client and I\&#x27;m listening!&#x27;);</span><br><span class="line"></span><br><span class="line">// 监听消息</span><br><span class="line">socket.onmessage = function(event) &#123;</span><br><span class="line">console.log(&#x27;Client received a message&#x27;, event);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 监听Socket的关闭</span><br><span class="line">socket.onclose = function(event) &#123;</span><br><span class="line">console.log(&#x27;Client notified socket has closed&#x27;, event);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 关闭Socket....</span><br><span class="line">//socket.close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebService</title>
      <link href="/51c5316ba4dc.html"/>
      <url>/51c5316ba4dc.html</url>
      
        <content type="html"><![CDATA[<h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- WebService --&gt;</span><br><span class="line">&lt;cxf.version&gt;2.2.3&lt;/cxf.version</span><br><span class="line">&lt;!-- cxf.WebService --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;cxf-rt-frontend-jaxws&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;cxf.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;cxf-rt-transports-http&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;cxf.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;classpath:cxf-*.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line">&lt;listener&gt;</span><br><span class="line">&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt;</span><br><span class="line">&lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">&lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/ws/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure><h2 id="cxf-config-xml"><a href="#cxf-config-xml" class="headerlink" title="cxf-config.xml"></a>cxf-config.xml</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xmlns:jaxws=&quot;http://cxf.apache.org/jaxws&quot;</span><br><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">xmlns:jaxrs=&quot;http://cxf.apache.org/jaxrs&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd</span><br><span class="line">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">http://cxf.apache.org/jaxrs</span><br><span class="line">        http://cxf.apache.org/schemas/jaxrs.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;import resource=&quot;classpath*:META-INF/cxf/cxf.xml&quot; /&gt;</span><br><span class="line">&lt;import</span><br><span class="line">resource=&quot;classpath*:META-INF/cxf/cxf-extension-soap.xml&quot; /&gt;</span><br><span class="line">&lt;import resource=&quot;classpath*:META-INF/cxf/cxf-servlet.xml&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- id 不能重复 --&gt;</span><br><span class="line">&lt;jaxws:endpoint id=&quot;userWebService&quot;</span><br><span class="line">implementor=&quot;cn.zuohy.kiking.webservice.UserWebServiceImpl&quot;</span><br><span class="line">address=&quot;/userws&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- &lt;jaxrs:server id=&quot;restContainer&quot; address=&quot;/&quot;&gt; &lt;jaxrs:serviceBeans&gt; </span><br><span class="line">&lt;ref bean=&quot;roomService&quot; /&gt; &lt;/jaxrs:serviceBeans&gt; &lt;jaxrs:providers&gt; &lt;bean </span><br><span class="line">class=&quot;org.codehaus.jackson.jaxrs.JacksonJaxbJsonProvider&quot; /&gt; &lt;/jaxrs:providers&gt; </span><br><span class="line">&lt;jaxrs:extensionMappings&gt; &lt;entry key=&quot;json&quot; value=&quot;application/json&quot; /&gt; &lt;entry </span><br><span class="line">key=&quot;xml&quot; value=&quot;application/xml&quot; /&gt; &lt;/jaxrs:extensionMappings&gt; &lt;/jaxrs:server&gt; --&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@WebService</span><br><span class="line">public interface UserWebService &#123;</span><br><span class="line">// 使用@WebMethod注解标注WebServiceI接口中的方法</span><br><span class="line">@WebMethod</span><br><span class="line">List&lt;User&gt; listUser(@WebParam(name = &quot;userName&quot;) String userName, @WebParam(name = &quot;userPass&quot;) String userPass);</span><br><span class="line"></span><br><span class="line">@WebMethod</span><br><span class="line">List&lt;User&gt; list();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@WebService(endpointInterface = &quot;cn.zuohy.kiking.webservice.UserWebService&quot;, serviceName = &quot;userws&quot;)</span><br><span class="line">public class UserWebServiceImpl implements UserWebService &#123;</span><br><span class="line"></span><br><span class="line">private UserService userService;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public List&lt;User&gt; listUser(@WebParam(name = &quot;userName&quot;) String userName,</span><br><span class="line">@WebParam(name = &quot;userPass&quot;) String userPass) &#123;</span><br><span class="line">List&lt;User&gt; listUser = null;</span><br><span class="line">try &#123;</span><br><span class="line">// 子容器 父容器 矛盾，因为service是在子容器springmvc中生成的，而webService是父容器中生成（先生成）自行获取spring</span><br><span class="line">// mvc容器</span><br><span class="line">userService = (UserService) ContextUtils.getSpringMVCContext().getBean(&quot;userService&quot;);</span><br><span class="line">listUser = userService.listUser(userName, userPass);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">//listUser = userService.listUser(userName, userPass);</span><br><span class="line">return listUser;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public List&lt;User&gt; list() &#123;</span><br><span class="line">List&lt;User&gt; list = null;</span><br><span class="line">try &#123;</span><br><span class="line">// 子容器 父容器 矛盾，因为service是在子容器springmvc中生成的，而webService是父容器中生成（先生成）自行获取spring</span><br><span class="line">// mvc容器</span><br><span class="line">userService = (UserService) ContextUtils.getSpringMVCContext().getBean(&quot;userService&quot;);</span><br><span class="line">list = userService.list();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">//list = userService.list();</span><br><span class="line">return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提前获取SpringMVC</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ContextUtils &#123;</span><br><span class="line">public static WebApplicationContext getSpringMVCContext() &#123;</span><br><span class="line">WebApplicationContext rootWac = ContextLoader.getCurrentWebApplicationContext();</span><br><span class="line">// 获取servletContext</span><br><span class="line">ServletContext servletContext = rootWac.getServletContext();</span><br><span class="line">// 获取子容器，名字最后对应servlet名字</span><br><span class="line">//1.查看spring容器中的对象名称</span><br><span class="line">String[] beannames = rootWac.getBeanDefinitionNames();</span><br><span class="line">for(String beanname:beannames)&#123;</span><br><span class="line">System.out.println(beanname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(servletContext);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//2.查看servlet中容器列表</span><br><span class="line">Enumeration&lt;String&gt; servletnames  = servletContext.getAttributeNames();</span><br><span class="line">while(servletnames.hasMoreElements())&#123;</span><br><span class="line">System.out.println(servletnames.nextElement());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WebApplicationContext springmvc = WebApplicationContextUtils.getWebApplicationContext(servletContext,</span><br><span class="line">&quot;org.springframework.web.servlet.FrameworkServlet.CONTEXT.SpringMVC&quot;);</span><br><span class="line">return springmvc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apache-cxf-3.2.7 代码生成</span><br><span class="line"></span><br><span class="line">生成后：对应接口的实现类和Response添加@XmlType( namespace = &quot;http://namespace.thats.not.the.same.as.the.generated&quot;)</span><br><span class="line"></span><br><span class="line">信息: Creating Service &#123;http://webservice.websocke.zuohy.cn/&#125;userws from WSDL: http://localhost:8080/websocke/ws/userws?wsdl</span><br><span class="line">Exception in thread &quot;main&quot; javax.xml.ws.soap.SOAPFaultException: Fault occurred while processing.</span><br><span class="line">at org.apache.cxf.jaxws.JaxWsClientProxy.invoke(JaxWsClientProxy.java:1 43) $Proxy37.list(Unknown Source)</span><br><span class="line">at com.sun.proxy.</span><br><span class="line"></span><br><span class="line">这为请求错误</span><br></pre></td></tr></table></figure><h2 id="创建WSDL的url-确定命名空间以及文档中服务端口的name属性-然后请求接口"><a href="#创建WSDL的url-确定命名空间以及文档中服务端口的name属性-然后请求接口" class="headerlink" title="创建WSDL的url,确定命名空间以及文档中服务端口的name属性,然后请求接口"></a>创建WSDL的url,确定命名空间以及文档中服务端口的name属性,然后请求接口</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void clientsoap() throws Exception &#123;</span><br><span class="line">// 创建WSDL的URL，注意不是服务地址</span><br><span class="line">URL url = new URL(&quot;http://localhost:8080/websocke/ws/userws?wsdl&quot;);</span><br><span class="line"></span><br><span class="line">// 创建服务名称</span><br><span class="line">// 1.namespaceURI - 命名空间地址 (wsdl文档中的targetNamespace</span><br><span class="line">// targetNamespace=&quot;http://webserviceImp.gxa/&quot;)</span><br><span class="line">// 2.localPart - 服务视图名 (wsdl文档中服务名称，例如&lt;wsdl:service name=&quot;studentws&quot;&gt;)</span><br><span class="line">QName qname = new QName(&quot;http://webservice.websocke.zuohy.cn/&quot;, &quot;userws&quot;);</span><br><span class="line"></span><br><span class="line">// 创建服务视图</span><br><span class="line">// 参数解释：</span><br><span class="line">// 1.wsdlDocumentLocation - wsdl地址</span><br><span class="line">// 2.serviceName - 服务名称</span><br><span class="line">Service service = Service.create(url, qname);</span><br><span class="line">// 获取服务实现类</span><br><span class="line">// 参数解释:serviceEndpointInterface - 服务端口(wsdl文档中服务端口的name属性，例如&lt;wsdl:port</span><br><span class="line">// binding=&quot;tns:studentwsSoapBinding&quot; name=&quot;StudentWebServiceImpPort&quot;&gt;)</span><br><span class="line">UserWebService userWebService = service.getPort(UserWebService.class);</span><br><span class="line">// 调用查询方法</span><br><span class="line">List&lt;User&gt; users = userWebService.list();</span><br><span class="line">for (User user : users) &#123;</span><br><span class="line">System.out.println(user.getUserId()+&quot; &quot;+user.getUserName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">new UserWebServiceApp().clientsoap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> WebService </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Could-Not-Find-Result-Map</title>
      <link href="/fe248847c921.html"/>
      <url>/fe248847c921.html</url>
      
        <content type="html"><![CDATA[<p>今天在写代码的时候，写完代码测试的时候发现登陆的时候登陆不进去，然后在登陆的断点处，抛出了这个异常</p><p><code>Could not find result map ren.guard.dao.SysDeptMapper.int</code></p><p>就是在 SysDeptMapper .xml里面本该是</p><p><code>resultType=&#39;int&#39;</code></p><p>写成了</p><p><code>resultMap=&#39;int&#39;</code></p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis融入SSM</title>
      <link href="/3e4b52661133.html"/>
      <url>/3e4b52661133.html</url>
      
        <content type="html"><![CDATA[<p>根据个人的理解Redis融入SSM是需要在Spring里面给一个Redis的客户端，通过他来对Redis进行操作</p><span id="more"></span><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;jedis.version&gt;2.9.1&lt;/jedis.version&gt;</span><br><span class="line">     &lt;!-- redis客户端 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;$&#123;jedis.version&#125;&lt;/version&gt;</span><br><span class="line">           &lt;type&gt;jar&lt;/type&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="Redis-xml"><a href="#Redis-xml" class="headerlink" title="Redis.xml"></a>Redis.xml</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:property-placeholder location=&quot;classpath:settings.properties&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;shardedJedisPool&quot; class=&quot;redis.clients.jedis.ShardedJedisPool&quot; scope=&quot;singleton&quot;&gt;</span><br><span class="line">        &lt;constructor-arg index=&quot;0&quot; ref=&quot;jedisPoolConfig&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg index=&quot;1&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;bean class=&quot;redis.clients.jedis.JedisShardInfo&quot;&gt;</span><br><span class="line">                    &lt;constructor-arg name=&quot;host&quot; value=&quot;$&#123;redis.host&#125;&quot;/&gt;</span><br><span class="line">                    &lt;constructor-arg name=&quot;port&quot; value=&quot;$&#123;redis.port&#125;&quot;/&gt;</span><br><span class="line">                    &lt;constructor-arg name=&quot;timeout&quot; value=&quot;$&#123;redis.timeout&#125;&quot;/&gt;</span><br><span class="line">                    &lt;property name=&quot;password&quot; value=&quot;$&#123;redis.password&#125;&quot;/&gt;</span><br><span class="line">                &lt;/bean&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h2 id="settings-properties"><a href="#settings-properties" class="headerlink" title="settings.properties"></a>settings.properties</h2><p>没有密码可以去除<property name="”password”" value="”${redis.password}”/">和redis.password=</property></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis.host=</span><br><span class="line">redis.port=6379</span><br><span class="line">redis.timeout=300</span><br><span class="line">redis.password=</span><br></pre></td></tr></table></figure><h2 id="引用和启用客户端"><a href="#引用和启用客户端" class="headerlink" title="引用和启用客户端"></a>引用和启用客户端</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Service(&quot;redisPool&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class RedisPool &#123;</span><br><span class="line"></span><br><span class="line">    @Resource(name = &quot;shardedJedisPool&quot;)</span><br><span class="line">    private ShardedJedisPool shardedJedisPool;</span><br><span class="line">    //只有启用一个客户端</span><br><span class="line">    public ShardedJedis instance()&#123;</span><br><span class="line">        return shardedJedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">    //关闭客户端</span><br><span class="line">    public void safeClose(ShardedJedis shardedJedis)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if(shardedJedis!=null)&#123;</span><br><span class="line">                shardedJedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            log.error(&quot;return redis resource exception&quot;,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装客户端一些操作"><a href="#封装客户端一些操作" class="headerlink" title="封装客户端一些操作"></a>封装客户端一些操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class SysCacheService &#123;</span><br><span class="line"></span><br><span class="line">    @Resource(name = &quot;redisPool&quot;)</span><br><span class="line">    private RedisPool redisPool;</span><br><span class="line"></span><br><span class="line">    public void savaCache(String toSavedValue, int timeoutSeconds, CacheKeyConstants prefix) &#123;</span><br><span class="line">        savaCache(toSavedValue, timeoutSeconds, prefix, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void savaCache(String toSavedValue, int timeoutSeconds, CacheKeyConstants prefix, String... keys) &#123;</span><br><span class="line">        if (toSavedValue == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        ShardedJedis shardedJedis = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String cacheKey = generateCacheKey(prefix, keys);</span><br><span class="line">            shardedJedis = redisPool.instance();</span><br><span class="line">            shardedJedis.setex(cacheKey, timeoutSeconds, toSavedValue);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;save cache exception, prefix:&#123;&#125;,keys:&#123;&#125;&quot;, prefix.name(), JsonMapper.obj2String(keys), e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            redisPool.safeClose(shardedJedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getFromCache(CacheKeyConstants prefix, String... keys) &#123;</span><br><span class="line">        ShardedJedis shardedJedis = null;</span><br><span class="line">        String cacheKey = generateCacheKey(prefix, keys);</span><br><span class="line">        try &#123;</span><br><span class="line">            shardedJedis = redisPool.instance();</span><br><span class="line">            String value = shardedJedis.get(cacheKey);</span><br><span class="line">            return value;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;get from cache exception prefix:&#123;&#125;,keys:&#123;&#125;&quot;, prefix.name(), JsonMapper.obj2String(keys), e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            redisPool.safeClose(shardedJedis);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String generateCacheKey(CacheKeyConstants prefix, String... keys) &#123;</span><br><span class="line">        String key = prefix.name();</span><br><span class="line">        if (keys != null &amp;&amp; keys.length &gt; 0) &#123;</span><br><span class="line">            key += &quot;_&quot; + Joiner.on(&quot;_&quot;).join(keys);</span><br><span class="line">        &#125;</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中枚举类CacheKeyConstants</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Getter</span><br><span class="line">public enum CacheKeyConstants &#123;</span><br><span class="line"></span><br><span class="line">    SYSTEM_ACLS,</span><br><span class="line"></span><br><span class="line">    USER_ACLS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用实例："><a href="#调用实例：" class="headerlink" title="调用实例："></a>调用实例：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;SysAcl&gt; getCurrentUserAclListFromCache()&#123;</span><br><span class="line">       int userId = RequestHolder.getCurrentUser().getId();</span><br><span class="line">       String cacheValue = sysCacheService.getFromCache(CacheKeyConstants.USER_ACLS,String.valueOf(userId));</span><br><span class="line">       if(StringUtils.isBlank(cacheValue))&#123;</span><br><span class="line">           List&lt;SysAcl&gt; userAclList = getCurrentUserAclList();</span><br><span class="line">           if(CollectionUtils.isNotEmpty(userAclList))&#123;</span><br><span class="line">               sysCacheService.savaCache(JsonMapper.obj2String(userAclList),600,CacheKeyConstants.USER_ACLS,String.valueOf(userId));</span><br><span class="line">           &#125;</span><br><span class="line">           return userAclList;</span><br><span class="line">       &#125;</span><br><span class="line">       return JsonMapper.string2Obj(cacheValue, new TypeReference&lt;List&lt;SysAcl&gt;&gt;() &#123;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="JsonMapper"><a href="#JsonMapper" class="headerlink" title="JsonMapper"></a>JsonMapper</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//json和类的转换</span><br><span class="line">@Slf4j</span><br><span class="line">public class JsonMapper &#123;</span><br><span class="line">    private static ObjectMapper objectMapper = new ObjectMapper();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        //config</span><br><span class="line">        objectMapper.disable(DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES);</span><br><span class="line">        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);</span><br><span class="line">        objectMapper.setFilterProvider(new SimpleFilterProvider().setFailOnUnknownId(false));</span><br><span class="line">        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; String obj2String(T src) &#123;</span><br><span class="line">        if (src == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            return src instanceof String ? (String) src : objectMapper.writeValueAsString(src);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.warn(&quot;parse Object to String exception, error:&#123;&#125;&quot;, e);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; T string2Obj(String src, TypeReference&lt;T&gt; typeReference) &#123;</span><br><span class="line">        if (src == null || typeReference == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (T) (typeReference.getType().equals(String.class) ? src : objectMapper.readValue(src, typeReference));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.warn(&quot;parse String to Object exception, String:&#123;&#125;, TypeReference&lt;T&gt;:&#123;&#125;, error:&#123;&#125;&quot;, src, typeReference, e);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Travis-Api</title>
      <link href="/69bb6d2d9142.html"/>
      <url>/69bb6d2d9142.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一次接触留个纪念吧"><a href="#第一次接触留个纪念吧" class="headerlink" title="第一次接触留个纪念吧"></a>第一次接触留个纪念吧</h1><p>postman调试Travis-API</p><p>因为第一次用postman 不知道怎么设置请求头</p><p>需要设置 Headers里面设置请求头以及Token</p><blockquote class="blockquote-center">为了一个爱的人</blockquote>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 日常 </tag>
            
            <tag> Travis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo</title>
      <link href="/1698a47fcf6a.html"/>
      <url>/1698a47fcf6a.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一次用Hexo，说一下安装和配置遇到的问题"><a href="#第一次用Hexo，说一下安装和配置遇到的问题" class="headerlink" title="第一次用Hexo，说一下安装和配置遇到的问题"></a>第一次用Hexo，说一下安装和配置遇到的问题</h1><ol><li>最好用linux来配置（我选的Ubuntu）尤其是在配置Travis CI的时候遇到了Git Bash无法登陆和加密有问题</li><li>在Ubuntu下安装Ruby遇到了一大堆的问题尤其是OpenSSL，最后选择了<a href="https://gorails.com/setup/ubuntu/18.10#ruby" title="Ruby">Ruby</a></li><li>私库必须登陆，而且链接为<a href="https://travis-ci.com/" title="Ruby">https://travis-ci.com</a></li></ol><h1 id="第二次"><a href="#第二次" class="headerlink" title="第二次"></a>第二次</h1><p>这次用的是hexo+next6.0这次配置的也比较完全</p><ol><li>next6.0里面大部分的功能都是有的只需要基础的配置就好了</li><li>这次遇到的最大问题就是gulp压缩网站的时候3.9和4.0的写发不一样</li><li>计数的在混用</li><li>其他看next6.0的配置真的很齐全对源码的更改不用太多，配置好就可以用了</li><li>还有的配置部署，有空再弄了，倒是coding和github两个https不知道为什么就是弄不好，现在还是http先用着</li><li>对访问量做了修改测试一下</li></ol><hr><p>差不多是这些，还有其他问题想到了再来写</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>表格计算</title>
      <link href="/40901eb5b99a.html"/>
      <url>/40901eb5b99a.html</url>
      
        <content type="html"><![CDATA[<p>某次无聊中， atm 发现了一个很老的程序。这个程序的功能类似于 Excel ，它对一个表格进行操作。<br>不妨设表格有 n 行，每行有 m 个格子。<br>每个格子的内容可以是一个正整数，也可以是一个公式。<br>公式包括三种：</p><ol><li>SUM(x1,y1:x2,y2) 表示求左上角是第 x1 行第 y1 个格子，右下角是第 x2 行第 y2 个格子这个矩形内所有格子的值的和。</li><li>AVG(x1,y1:x2,y2) 表示求左上角是第 x1 行第 y1 个格子，右下角是第 x2 行第 y2 个格子这个矩形内所有格子的值的平均数。</li><li>STD(x1,y1:x2,y2) 表示求左上角是第 x1 行第 y1 个格子，右下角是第 x2 行第 y2 个格子这个矩形内所有格子的值的标准差。</li></ol><p>标准差即为方差的平方根。<br>方差就是：每个数据与平均值的差的平方的平均值，用来衡量单个数据离开平均数的程度。</p><p>公式都不会出现嵌套。</p><p>如果这个格子内是一个数，则这个格子的值等于这个数，否则这个格子的值等于格子公式求值结果。</p><p>输入这个表格后，程序会输出每个格子的值。atm 觉得这个程序很好玩，他也想实现一下这个程序。</p><p>「输入格式」<br>第一行两个数 n, m 。<br>接下来 n 行输入一个表格。每行 m 个由空格隔开的字符串，分别表示对应格子的内容。<br>输入保证不会出现循环依赖的情况，即不会出现两个格子 a 和 b 使得 a 的值依赖 b 的值且 b 的值依赖 a 的值。</p><p>「输出格式」<br>输出一个表格，共 n 行，每行 m 个保留两位小数的实数。<br>数据保证不会有格子的值超过 1e6 。</p><p>「样例输入」<br>3 2<br>1 SUM(2,1:3,1)<br>2 AVG(1,1:1,2)<br>SUM(1,1:2,1) STD(1,1:2,2)</p><p>「样例输出」<br>1.00 5.00<br>2.00 3.00<br>3.00 1.48</p><p>「数据范围」<br>对于 30% 的数据，满足： n, m &lt;= 5<br>对于 100% 的数据，满足： n, m &lt;= 50</p><p>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 512M<br>CPU消耗 &lt; 2000ms</p><p>请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。</p><p>所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。<br>注意：不要使用package语句。不要使用jdk1.7及以上版本的特性。<br>注意：主类的名字必须是：Main，否则按无效代码处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">static String[][] form;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">input();// 输入</span><br><span class="line">for (int i = 0; i &lt; form.length; i++) &#123;</span><br><span class="line">for (int j = 0; j &lt; form[i].length; j++) &#123;</span><br><span class="line">form[i][j] = judgment(form[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">out();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断</span><br><span class="line">private static String judgment(String str) &#123;</span><br><span class="line"></span><br><span class="line">if (str.charAt(0) == &#x27;A&#x27;) &#123;// 平均数</span><br><span class="line">return average(str);</span><br><span class="line">&#125; else if (str.charAt(0) == &#x27;S&#x27;) &#123;</span><br><span class="line">if (str.charAt(1) == &#x27;U&#x27;) &#123; // 和</span><br><span class="line">return with(str);</span><br><span class="line">&#125; else &#123;// 标准差</span><br><span class="line">return standardDeviation(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;// 数</span><br><span class="line">return String.format(&quot;%.2f&quot;, Double.parseDouble(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 标准差</span><br><span class="line">private static String standardDeviation(String str) &#123;</span><br><span class="line">int[] number = axis(str);</span><br><span class="line">ArrayList squ = new ArrayList&lt;&gt;();</span><br><span class="line">double ave = 0, square = 0, num = 0;</span><br><span class="line">for (int i = number[0]; i &lt;= number[2]; i++) &#123;</span><br><span class="line">for (int j = number[1]; j &lt;= number[3]; j++) &#123;</span><br><span class="line">ave += Double.parseDouble(judgment(form[i][j]));</span><br><span class="line">squ.add(Double.parseDouble(judgment(form[i][j])));</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ave = ave / num;</span><br><span class="line">for (int i = 0; i &lt; squ.size(); i++) &#123;</span><br><span class="line">square += (squ.get(i) - ave) * (squ.get(i) - ave);</span><br><span class="line">&#125;</span><br><span class="line">return String.format(&quot;%.2f&quot;, Math.sqrt(square / num));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 和</span><br><span class="line">private static String with(String str) &#123;</span><br><span class="line">int[] number = axis(str);</span><br><span class="line">double sum = 0;</span><br><span class="line">for (int i = number[0]; i &lt;= number[2]; i++) &#123;</span><br><span class="line">for (int j = number[1]; j &lt;= number[3]; j++) &#123;</span><br><span class="line">sum += Double.parseDouble(judgment(form[i][j]));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return String.format(&quot;%.2f&quot;, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 平均数</span><br><span class="line">private static String average(String str) &#123;</span><br><span class="line">int[] number = axis(str);</span><br><span class="line">double ave = 0, num = 0;</span><br><span class="line">for (int i = number[0]; i &lt;= number[2]; i++) &#123;</span><br><span class="line">for (int j = number[1]; j &lt;= number[3]; j++) &#123;</span><br><span class="line">ave += Double.parseDouble(judgment(form[i][j]));</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return String.format(&quot;%.2f&quot;, ave / num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int[] axis(String str) &#123;</span><br><span class="line">int[] number = new int[4];</span><br><span class="line">int a = str.indexOf(&quot;(&quot;);</span><br><span class="line">int b = str.indexOf(&quot;,&quot;);</span><br><span class="line">int c = str.indexOf(&quot;:&quot;);</span><br><span class="line">int d = str.lastIndexOf(&quot;,&quot;);</span><br><span class="line">int e = str.indexOf(&quot;)&quot;);</span><br><span class="line">String x1 = str.substring(a + 1, b);</span><br><span class="line">String y1 = str.substring(b + 1, c);</span><br><span class="line">String x2 = str.substring(c + 1, d);</span><br><span class="line">String y2 = str.substring(d + 1, e);</span><br><span class="line">number[0] = Integer.parseInt(x1) - 1;</span><br><span class="line">number[1] = Integer.parseInt(y1) - 1;</span><br><span class="line">number[2] = Integer.parseInt(x2) - 1;</span><br><span class="line">number[3] = Integer.parseInt(y2) - 1;</span><br><span class="line">return number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输入</span><br><span class="line">private static void input() &#123;</span><br><span class="line">Scanner scanner = new Scanner(System.in);</span><br><span class="line">int row = scanner.nextInt();</span><br><span class="line">int col = scanner.nextInt();</span><br><span class="line">form = new String[row][col];</span><br><span class="line">for (int i = 0; i &lt; form.length; i++) &#123;</span><br><span class="line">for (int j = 0; j &lt; form[i].length; j++) &#123;</span><br><span class="line">form[i][j] = scanner.next();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">scanner.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">private static void out() &#123;</span><br><span class="line">for (int i = 0; i &lt; form.length; i++) &#123;</span><br><span class="line">for (int j = 0; j &lt; form[i].length; j++) &#123;</span><br><span class="line">System.out.print(form[i][j] + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>穿越雷区</title>
      <link href="/9865be07681a.html"/>
      <url>/9865be07681a.html</url>
      
        <content type="html"><![CDATA[<p>X星的坦克战车很奇怪，它必须交替地穿越正能量辐射区和负能量辐射区才能保持正常运转，否则将报废。<br>某坦克需要从A区到B区去（A，B区本身是安全区，没有正能量或负能量特征），怎样走才能路径最短？</p><p>已知的地图是一个方阵，上面用字母标出了A，B区，其它区都标了正号或负号分别表示正负能量辐射区。<br>例如：<br>A + – + –<br>– + – – +<br>– + + + –</p><ul><li>– + – +<br>B + – + –</li></ul><p>坦克车只能水平或垂直方向上移动到相邻的区。</p><p>数据格式要求：</p><p>输入第一行是一个整数n，表示方阵的大小， 4&lt;=n&lt;100<br>接下来是n行，每行有n个数据，可能是A，B，+，-中的某一个，中间用空格分开。<br>A，B都只出现一次。</p><p>要求输出一个整数，表示坦克从A区到B区的最少移动步数。<br>如果没有方案，则输出-1</p><p>例如：<br>用户输入：<br>5<br>A + – + –<br>– + – – +<br>– + + + –</p><ul><li>– + – +<br>B + – + –</li></ul><p>则程序应该输出：<br>10</p><p>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 512M<br>CPU消耗 &lt; 2000ms</p><p>请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。</p><p>所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。<br>注意：不要使用package语句。不要使用jdk1.7及以上版本的特性。<br>注意：主类的名字必须是：Main，否则按无效代码处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">static String[][] figure;</span><br><span class="line">static int[] start = new int[2];</span><br><span class="line">static int min = Integer.MAX_VALUE;</span><br><span class="line">static int count = 0;</span><br><span class="line">static int[] direction = new int[] &#123; 0, 1, 1, 0, 0, -1, -1, 0 &#125;;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String[][] image = input();</span><br><span class="line">initial(image, start[0], start[1]);</span><br><span class="line">System.out.println(min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 开始</span><br><span class="line">private static void initial(String[][] image, int x, int y) &#123;</span><br><span class="line">// 判断四个方向</span><br><span class="line">for (int i = 0; i &lt; 8; i += 2) &#123; //下一步的坐标 int x2 = x + direction[i]; int y2 = y + direction[i + 1]; if (x2 &gt;= 0 &amp;&amp; x2 &lt; image.length &amp;&amp; y2 &gt;= 0 &amp;&amp; y2 &lt; image.length) &#123; //结束 if (figure[x][y].equals(&quot;B&quot;) || count &gt; min) &#123;</span><br><span class="line">if (min &gt; count) &#123;</span><br><span class="line">min = count;</span><br><span class="line">&#125;</span><br><span class="line">// 找到退一步</span><br><span class="line">count--;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//相反，没走过</span><br><span class="line">if (!(figure[x][y].equals(figure[x2][y2])) &amp;&amp; !(image[x2][y2].equals(&quot;0&quot;))) &#123;</span><br><span class="line">image[x][y] = &quot;0&quot;;</span><br><span class="line">//out(image);</span><br><span class="line">count++;</span><br><span class="line">initial(image, x2, y2);</span><br><span class="line">image[x][y] = figure[x][y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 找不到退一步</span><br><span class="line">count--;</span><br><span class="line">&#125;</span><br><span class="line">//测试显示</span><br><span class="line">private static void out(String[][] image) &#123;</span><br><span class="line">for (int i = 0; i &lt; image.length; i++) &#123;</span><br><span class="line">System.out.println(Arrays.toString(image[i]));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输入</span><br><span class="line">private static String[][] input() &#123;</span><br><span class="line">Scanner scanner = new Scanner(System.in);</span><br><span class="line">int number = scanner.nextInt();</span><br><span class="line">figure = new String[number][number];</span><br><span class="line">String[][] image = new String[number][number];</span><br><span class="line">for (int i = 0; i &lt; number; i++) &#123;</span><br><span class="line">for (int j = 0; j &lt; number; j++) &#123;</span><br><span class="line">image[i][j] = figure[i][j] = scanner.next();</span><br><span class="line"></span><br><span class="line">if (figure[i][j].equals(&quot;A&quot;)) &#123;</span><br><span class="line">start[0] = i;</span><br><span class="line">start[1] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">scanner.close();</span><br><span class="line">return image;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>显示二叉树</title>
      <link href="/083b7d32f844.html"/>
      <url>/083b7d32f844.html</url>
      
        <content type="html"><![CDATA[<p>排序二叉树的特征是：<br>某个节点的左子树的所有节点值都不大于本节点值。<br>某个节点的右子树的所有节点值都不小于本节点值。</p><p>为了能形象地观察二叉树的建立过程，小明写了一段程序来显示出二叉树的结构来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">BiTree tree = new BiTree(500);</span><br><span class="line">tree.add(new BiTree(200));</span><br><span class="line">tree.add(new BiTree(509));</span><br><span class="line">tree.add(new BiTree(100));</span><br><span class="line">tree.add(new BiTree(250));</span><br><span class="line">tree.add(new BiTree(507));</span><br><span class="line">tree.add(new BiTree(600));</span><br><span class="line">tree.add(new BiTree(650));</span><br><span class="line">tree.add(new BiTree(450));</span><br><span class="line">tree.add(new BiTree(510));</span><br><span class="line">tree.add(new BiTree(440));</span><br><span class="line">tree.add(new BiTree(220));</span><br><span class="line">tree.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class BiTree &#123;</span><br><span class="line">private int v;</span><br><span class="line">private BiTree l;// 左</span><br><span class="line">private BiTree r;// 右</span><br><span class="line"></span><br><span class="line">public BiTree(int v) &#123;</span><br><span class="line">this.v = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void add(BiTree the) &#123;</span><br><span class="line">if (the.v &lt; v) &#123;</span><br><span class="line">if (l == null)</span><br><span class="line">l = the;</span><br><span class="line">else</span><br><span class="line">l.add(the);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if (r == null)</span><br><span class="line">r = the;</span><br><span class="line">else</span><br><span class="line">r.add(the);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getHeight() &#123;</span><br><span class="line">int h = 2;</span><br><span class="line">int hl = l == null ? 0 : l.getHeight();</span><br><span class="line">int hr = r == null ? 0 : r.getHeight();</span><br><span class="line">return h + Math.max(hl, hr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getWidth() &#123;</span><br><span class="line">int w = (&quot;&quot; + v).length();</span><br><span class="line">if (l != null)</span><br><span class="line">w += l.getWidth();</span><br><span class="line">if (r != null)</span><br><span class="line">w += r.getWidth();</span><br><span class="line">return w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void show() &#123;</span><br><span class="line">char[][] buf = new char[getHeight()][getWidth()];</span><br><span class="line">printInBuf(buf, 0, 0);</span><br><span class="line">showBuf(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void showBuf(char[][] x) &#123;</span><br><span class="line">for (int i = 0; i &lt; x.length; i++) &#123;</span><br><span class="line">for (int j = 0; j &lt; x[i].length; j++)</span><br><span class="line">System.out.print(x[i][j] == 0 ? &#x27; &#x27; : x[i][j]);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void printInBuf(char[][] buf, int x, int y) &#123;</span><br><span class="line">String sv = &quot;&quot; + v;</span><br><span class="line">int p1 = l == null ? x : l.getRootPos(x);</span><br><span class="line">int p2 = getRootPos(x);</span><br><span class="line">int p3 = r == null ? p2 : r.getRootPos(p2 + sv.length());</span><br><span class="line">buf[y][p2] = &#x27;|&#x27;;</span><br><span class="line">for (int i = p1; i &lt;= p3; i++)</span><br><span class="line">buf[y + 1][i] = &#x27;-&#x27;;</span><br><span class="line">for (int i = 0; i &lt; sv.length(); i++)</span><br><span class="line">buf[y + 1][p2 + i] = sv.charAt(i);// 填空位置</span><br><span class="line">if (p1 &lt; p2) buf[y + 1][p1] = &#x27;/&#x27;; if (p3 &gt; p2)</span><br><span class="line">buf[y + 1][p3] = &#x27;\\&#x27;;</span><br><span class="line">if (l != null)</span><br><span class="line">l.printInBuf(buf, x, y + 2);</span><br><span class="line">if (r != null)</span><br><span class="line">r.printInBuf(buf, p2 + sv.length(), y + 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int getRootPos(int x) &#123;</span><br><span class="line">return l == null ? x : x + l.getWidth();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五星填数</title>
      <link href="/c6c507ac38c4.html"/>
      <url>/c6c507ac38c4.html</url>
      
        <content type="html"><![CDATA[<p>如【图1.png】的五星图案节点填上数字：1~12，除去7和11。<br>要求每条直线上数字和相等。</p><p>如图就是恰当的填法。</p><p>请你利用计算机搜索所有可能的填法有多少种。<br>注意：旋转或镜像后相同的算同一种填法。</p><p>请提交表示方案数目的整数，不要填写任何其它内容。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/c6c507ac38c4/1.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">static int connt = 0;</span><br><span class="line">static int[] num = new int[] &#123; 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 &#125;;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Assignment(0);</span><br><span class="line">System.out.println(connt/10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void Assignment(int n) &#123;</span><br><span class="line">if (with(num) &amp;&amp; n == 10) &#123;</span><br><span class="line">System.out.println(Arrays.toString(num));</span><br><span class="line">connt++;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = n; i &lt; num.length; i++) &#123;</span><br><span class="line">int tmp = num[i];</span><br><span class="line">num[i] = num[n];</span><br><span class="line">num[n] = tmp;</span><br><span class="line">Assignment(n + 1);</span><br><span class="line">//回溯</span><br><span class="line">int temp1 = num[i];</span><br><span class="line">num[i] = num[n];</span><br><span class="line">num[n] = temp1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean with(int[] Times) &#123;</span><br><span class="line">int tmp = Times[0] + Times[5] + Times[6] + Times[2];</span><br><span class="line">if (tmp == Times[1] + Times[6] + Times[7] + Times[3])</span><br><span class="line">return false;</span><br><span class="line">if (tmp == Times[2] + Times[7] + Times[8] + Times[4])</span><br><span class="line">return false;</span><br><span class="line">if (tmp == Times[3] + Times[8] + Times[9] + Times[0])</span><br><span class="line">return false;</span><br><span class="line">if (tmp == Times[4] + Times[9] + Times[5] + Times[1])</span><br><span class="line">return false;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分机号</title>
      <link href="/7c039cfe73f4.html"/>
      <url>/7c039cfe73f4.html</url>
      
        <content type="html"><![CDATA[<p>X老板脾气古怪，他们公司的电话分机号都是3位数，老板规定，所有号码必须是降序排列，且不能有重复的数位。比如：</p><p>751,520,321 都满足要求，而，<br>766,918,201 就不符合要求。</p><p>现在请你计算一下，按照这样的规定，一共有多少个可用的3位分机号码？</p><p>请直接提交该数字，不要填写任何多余的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int num = 0;</span><br><span class="line">for (int i = 9; i &gt;= 0; i--) &#123;</span><br><span class="line">for (int j = 9; j &gt;= 0; j--) &#123;</span><br><span class="line">for (int k = 9; k &gt;= 0; k--) &#123;</span><br><span class="line">if (i &gt; j &amp;&amp; j &gt; k) &#123;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成回文数</title>
      <link href="/eea72e773574.html"/>
      <url>/eea72e773574.html</url>
      
        <content type="html"><![CDATA[<p>所谓回文数就是左右对称的数字，比如：<br>585,5885,123321…<br>当然，单个的数字也可以算作是对称的。</p><p>小明发现了一种生成回文数的方法：<br>比如，取数字19，把它与自己的翻转数相加：<br>19 + 91 = 110，如果不是回文数，就再进行这个过程：<br>110 + 011 = 121 这次是回文数了。</p><p>200以内的数字中，绝大多数都可以在30步以内变成回文数，只有一个数字很特殊，就算迭代了1000次，它还是顽固地拒绝回文！</p><p>请你提交该顽固数字，不要填写任何多余的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.math.BigInteger;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">StringBuffer buffer = new StringBuffer();</span><br><span class="line">Long i = 10L;</span><br><span class="line">BigInteger tmp = new BigInteger(i + &quot;&quot;);</span><br><span class="line">int count = 0;</span><br><span class="line">while (i &lt;= 200) &#123;</span><br><span class="line">while (!isHuiWen(tmp) &amp;&amp; i &lt;= 200) &#123;</span><br><span class="line">buffer.append(tmp);</span><br><span class="line">// Long tmp2 = Long.valueOf(buffer.reverse().toString().trim());</span><br><span class="line">// tmp = tmp + tmp2;</span><br><span class="line">BigInteger big = new BigInteger(buffer.toString());</span><br><span class="line">BigInteger big2 = new BigInteger(buffer.reverse().toString());</span><br><span class="line">tmp = big.add(big2);</span><br><span class="line">buffer.delete(0, buffer.length());</span><br><span class="line">count++;</span><br><span class="line"></span><br><span class="line">if (count &gt; 9999) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">count = 0;</span><br><span class="line">i++;</span><br><span class="line">tmp = new BigInteger(i + &quot;&quot;);</span><br><span class="line">buffer.delete(0, buffer.length());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean isHuiWen(BigInteger tmp) &#123;</span><br><span class="line">StringBuffer buffer1 = new StringBuffer();</span><br><span class="line">StringBuffer buffer2 = new StringBuffer();</span><br><span class="line">buffer1.append(tmp);</span><br><span class="line">buffer2.append(tmp).reverse();</span><br><span class="line">boolean flag = false;</span><br><span class="line">// int i = 0;</span><br><span class="line">// while (buffer1.length() / 2 &gt; i) &#123;</span><br><span class="line">// if (!(buffer1.charAt(i) == buffer2.charAt(i))) &#123;</span><br><span class="line">// flag = false;</span><br><span class="line">// break;</span><br><span class="line">// &#125;</span><br><span class="line">// i++;</span><br><span class="line">// &#125;</span><br><span class="line">if (buffer1.toString().equals(buffer2.toString())) &#123;</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line">return flag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空心菱形</title>
      <link href="/d149732b2cfe.html"/>
      <url>/d149732b2cfe.html</url>
      
        <content type="html"><![CDATA[<p>小明刚刚开发了一个小程序，可以打印出任意规模的空心菱形，规模为6时，如下图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">****** ******</span><br><span class="line">***** *****</span><br><span class="line">****  ****</span><br><span class="line">***   ***</span><br><span class="line">**    **</span><br><span class="line">*           *</span><br><span class="line">**         **</span><br><span class="line">***   ***</span><br><span class="line">****  ****</span><br><span class="line">***** *****</span><br><span class="line">****** ******</span><br><span class="line">（如果有对齐问题，参看【图1.png】）</span><br></pre></td></tr></table></figure><p>他一高兴，踢掉了电源，最后一次修改没有保存…..<br>毛病出在划线的部分。<br>请你帮助小明分析程序，填写划线部分缺失的代码。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/d149732b2cfe/1.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">static String pr(int m, int n) &#123;</span><br><span class="line">String s = &quot;&quot;;</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">s += &quot; &quot;;</span><br><span class="line">for (int i = 0; i &lt; m; i++)</span><br><span class="line">s = &quot;*&quot; + s + &quot;*&quot;;</span><br><span class="line">return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void f(int n) &#123;</span><br><span class="line">String s = pr(1, n * 2 - 1) + &quot;\n&quot;;</span><br><span class="line">String s2 = s;</span><br><span class="line"></span><br><span class="line">for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">s = pr(1 + i, n * 2 - i * 2 - 1) + &quot;\n&quot;; // 填空位置</span><br><span class="line">s2 = s + s2 + s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.print(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">f(10);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>奇怪的数列</title>
      <link href="/f563a9569919.html"/>
      <url>/f563a9569919.html</url>
      
        <content type="html"><![CDATA[<p>从X星截获一份电码，是一些数字，如下：<br>13<br>1113<br>3113<br>132113<br>1113122113<br>….</p><p>YY博士经彻夜研究，发现了规律：<br>第一行的数字随便是什么，以后每一行都是对上一行“读出来”<br>比如第2行，是对第1行的描述，意思是：1个1，1个3，所以是：1113<br>第3行，意思是：3个1,1个3，所以是：3113</p><p>请你编写一个程序，可以从初始数字开始，连续进行这样的变换。</p><p>数据格式：</p><p>第一行输入一个数字组成的串，不超过100位<br>第二行，一个数字n，表示需要你连续变换多少次，n不超过20</p><p>输出一个串，表示最后一次变换完的结果。</p><p>例如：<br>用户输出：<br>5<br>7</p><p>则程序应该输出：<br>13211321322115</p><p>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 512M<br>CPU消耗 &lt; 1000ms</p><p>请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。</p><p>所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。<br>注意：不要使用package语句。不要使用jdk1.7及以上版本的特性。<br>注意：主类的名字必须是：Main，否则按无效代码处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Scanner scanner = new Scanner(System.in);</span><br><span class="line">String input = scanner.next();</span><br><span class="line">int num = scanner.nextInt();</span><br><span class="line">String number = list(input);</span><br><span class="line">for (int i = 1; i &lt; num; i++) &#123;</span><br><span class="line">number = list(number);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(number);</span><br><span class="line">scanner.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static String list(String input) &#123;</span><br><span class="line">int i = 0;</span><br><span class="line">int tmp;</span><br><span class="line">String index = &quot;&quot;;</span><br><span class="line">while (i &lt; input.length()) &#123;</span><br><span class="line">tmp = 1;</span><br><span class="line">while (flag(i, input)) &#123;</span><br><span class="line">i++;</span><br><span class="line">tmp++;</span><br><span class="line">&#125;</span><br><span class="line">index = index + tmp + String.valueOf(input.charAt(i));</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">return index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean flag(int i, String input) &#123;</span><br><span class="line">String valueOf = String.valueOf(input.charAt(i));</span><br><span class="line">if (i + 1 &lt; input.length()) &#123;</span><br><span class="line">String valueOf2 = String.valueOf(input.charAt(i + 1));</span><br><span class="line">if (valueOf.equals(valueOf2)) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切开字符串</title>
      <link href="/2f190b34c2b3.html"/>
      <url>/2f190b34c2b3.html</url>
      
        <content type="html"><![CDATA[<p>Pear有一个字符串，不过他希望把它切成两段。<br>这是一个长度为N（&lt;=10^5）的字符串。<br>Pear希望选择一个位置，把字符串不重复不遗漏地切成两段，长度分别是t和N-t（这两段都必须非空）。<br>Pear用如下方式评估切割的方案：<br>定义“正回文子串”为：长度为奇数的回文子串。<br>设切成的两段字符串中，前一段中有A个不相同的正回文子串，后一段中有B个不相同的非正回文子串，则该方案的得分为A<em>B。<br>注意，后一段中的B表示的是：“…非正回文…”，而不是: “…正回文…”。<br>那么所有的切割方案中，A</em>B的最大值是多少呢？<br>【输入数据】<br>输入第一行一个正整数N（&lt;=10^5）<br>接下来一行一个字符串，长度为N。该字符串仅包含小写英文字母。<br>【输出数据】<br>一行一个正整数，表示所求的A*B的最大值。<br>【样例输入】<br>10<br>bbaaabcaba<br>【样例输出】<br>38<br>【数据范围】<br>对于20%的数据，N&lt;=100<br>对于40%的数据，N&lt;=1000<br>对于100%的数据，N&lt;=10^5<br>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 512M<br>CPU消耗 &lt; 2000ms<br>请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。<br>所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。<br>注意：不要使用package语句。不要使用jdk1.7及以上版本的特性。<br>注意：主类的名字必须是：Main，否则按无效代码处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.Set;</span><br><span class="line">public class Main &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int max = -1;</span><br><span class="line">String[] str = input();</span><br><span class="line">System.out.println(1);</span><br><span class="line">for (int i = 0; i &lt; str.length; i += 2) &#123;</span><br><span class="line">int x = palindrome(str[i]);</span><br><span class="line">int y = notPalindrome(str[i + 1]);</span><br><span class="line">max = Math.max(max, x * y);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(max);</span><br><span class="line">&#125;</span><br><span class="line">// 非回文</span><br><span class="line">private static int notPalindrome(String str) &#123;</span><br><span class="line">int sum = 0;</span><br><span class="line">Set set = new HashSet&lt;&gt;();</span><br><span class="line">for (int i = 1; i &lt;= str.length(); i++) &#123;</span><br><span class="line">for (int j = 0; j &lt;= str.length() - i; j++) &#123;</span><br><span class="line">set.add(str.substring(j, i + j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Iterator iterator = set.iterator();</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">if (!verification(iterator.next())) &#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// String[] array = set.toArray(new String[0]);</span><br><span class="line">// for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">// if (!verification(array[i])) &#123;</span><br><span class="line">// sum++;</span><br><span class="line">// &#125;</span><br><span class="line">// &#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line">// 回问</span><br><span class="line">private static int palindrome(String str) &#123;</span><br><span class="line">int sum = 0;</span><br><span class="line">Set set = new HashSet&lt;&gt;();</span><br><span class="line">for (int i = 1; i &lt;= str.length(); i++) &#123;</span><br><span class="line">for (int j = 0; j &lt;= str.length() - i; j++) &#123;</span><br><span class="line">set.add(str.substring(j, i + j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Iterator iterator = set.iterator();</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">if (verification(iterator.next())) &#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// String[] array = set.toArray(new String[0]);</span><br><span class="line">// for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">// if (verification(array[i])) &#123;</span><br><span class="line">// sum++;</span><br><span class="line">// &#125;</span><br><span class="line">// &#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line">private static boolean verification(String str) &#123;</span><br><span class="line">StringBuffer sb = new StringBuffer(str);</span><br><span class="line">String s = sb.reverse().toString();</span><br><span class="line">if (str.length() % 2 == 0) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if (str.equals(s)) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private static String[] input() &#123;</span><br><span class="line">Scanner scanner = new Scanner(System.in);</span><br><span class="line">int number = scanner.nextInt();</span><br><span class="line">String[] str = new String[(number - 1) * 2];</span><br><span class="line">String s = scanner.next();</span><br><span class="line">int j = 1;</span><br><span class="line">for (int i = 0; i &lt; str.length; i += 2) &#123;</span><br><span class="line">str[i] = s.substring(0, j);</span><br><span class="line">str[i + 1] = s.substring(j, s.length());</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">scanner.close();</span><br><span class="line">return str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只能解决20%</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>居民集会</title>
      <link href="/5e4e6842d754.html"/>
      <url>/5e4e6842d754.html</url>
      
        <content type="html"><![CDATA[<p>蓝桥村的居民都生活在一条公路的边上，公路的长度为L，每户家庭的位置都用这户家庭到公路的起点的距离来计算，第i户家庭距起点的距离为di。</p><p>每年，蓝桥村都要举行一次集会。今年，由于村里的人口太多，村委会决定要在4个地方举行集会，其中3个位于公路中间，1个位最公路的终点。</p><p>已知每户家庭都会向着远离公路起点的方向去参加集会，参加集会的路程开销为家庭内的人数ti与距离的乘积。</p><p>给定每户家庭的位置di和人数ti，请为村委会寻找最好的集会举办地：p1, p2, p3, p4 (p1&lt;=p2&lt;=p3&lt;=p4=L),使得村内所有人的路程开销和最小。</p><p>【输入格式】<br>输入的第一行包含两个整数n, L，分别表示蓝桥村的家庭数和公路长度。<br>接下来n行，每行两个整数di, ti，分别表示第i户家庭距离公路起点的距离和家庭中的人数。</p><p>【输出格式】<br>输出一行，包含一个整数，表示村内所有人路程的开销和。<br>【样例输入】<br>6 10<br>1 3<br>2 2<br>4 5<br>5 20<br>6 5<br>8 7<br>【样例输出】<br>18<br>【样例说明】<br>在距起点2, 5, 8, 10这4个地方集会，6个家庭需要的走的距离分别为1, 0, 1, 0, 2, 0，总的路程开销为1<em>3+0</em>2+1<em>5+0</em>20+2<em>5+0</em>7=18。</p><p>【数据规模与约定】<br>对于10%的评测数据，1&lt;=n&lt;=300。<br>对于30%的评测数据，1&lt;=n&lt;=2000，1&lt;=L&lt;=10000，0&lt;=di&lt;=L，di&lt;=di+1，0&lt;=ti&lt;=20。<br>对于100%的评测数据，1&lt;=n&lt;=100000，1&lt;=L&lt;=1000000，0&lt;=di&lt;=L，di&lt;=di+1，0&lt;=ti&lt;=1000000。</p><p>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 512M<br>CPU消耗 &lt; 8000ms</p><p>请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。</p><p>所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。<br>注意：不要使用package语句。不要使用jdk1.7及以上版本的特性。<br>注意：主类的名字必须是：Main，否则按无效代码处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">static int n = 0, l = 0;// 家庭数和公路长度</span><br><span class="line">static int[][] family;// 家庭距离公路起点的距离和家庭中的人数</span><br><span class="line">static int sum = 0;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Scanner scanner = new Scanner(System.in);</span><br><span class="line">n = scanner.nextInt();</span><br><span class="line">l = scanner.nextInt();</span><br><span class="line">family = new int[n][2];</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">family[i][0] = scanner.nextInt();</span><br><span class="line">family[i][1] = scanner.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">scanner.close();</span><br><span class="line">punctuation(l);</span><br><span class="line">System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void punctuation(int num) &#123;</span><br><span class="line">int tmp = 0;</span><br><span class="line">for (int i = 0; i &lt;= num; i++) &#123;</span><br><span class="line">for (int j = i; j &lt;= num; j++) &#123;</span><br><span class="line">for (int k = 0; k &lt;= num; k++) &#123;</span><br><span class="line">tmp = overhead(i, j, k);</span><br><span class="line">if (tmp &lt;= sum) &#123;</span><br><span class="line">sum = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int overhead(int i, int j, int k) &#123;</span><br><span class="line">int number = 0;</span><br><span class="line">int with = 0;</span><br><span class="line">for (int l = 0; l &lt; n; l++) &#123;</span><br><span class="line">number = family[l][0];</span><br><span class="line">int contrast = Compared(number, i, j, k);</span><br><span class="line">with += (contrast - number) * family[l][1];</span><br><span class="line">&#125;</span><br><span class="line">if (i == 0 &amp;&amp; j == 0 &amp;&amp; k == 0) &#123;</span><br><span class="line">sum = with;</span><br><span class="line">&#125;</span><br><span class="line">return with;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int Compared(int number, int i, int j, int k) &#123;</span><br><span class="line">if (number &lt;= i) &#123;</span><br><span class="line">return i;</span><br><span class="line">&#125; else if (number &lt;= j) &#123;</span><br><span class="line">return j;</span><br><span class="line">&#125; else if (number &lt;= k) &#123;</span><br><span class="line">return k;</span><br><span class="line">&#125; else if (number &lt;= l) &#123;</span><br><span class="line">return l;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四阶幻方</title>
      <link href="/ee5c0e48c3d1.html"/>
      <url>/ee5c0e48c3d1.html</url>
      
        <content type="html"><![CDATA[<p>把1~16的数字填入4×4的方格中，使得行、列以及两个对角线的和都相等，满足这样的特征时称为：四阶幻方。<br>四阶幻方可能有很多方案。如果固定左上角为1，请计算一共有多少种方案。<br>比如：<br>1 2 15 16<br>12 14 3 5<br>13 7 10 4<br>8 11 6 9<br>以及：<br>1 12 13 8<br>2 14 7 11<br>15 3 10 6<br>16 5 4 9<br>就可以算为两种不同的方案。<br>请提交左上角固定为1时的所有方案数字，不要填写任何多余内容或说明文字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">static int[] num = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 &#125;;</span><br><span class="line">static int su = 0;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">sun(1);</span><br><span class="line">&#125;</span><br><span class="line">private static void sun(int i) &#123;</span><br><span class="line">if (sum() &amp;&amp; i == num.length) &#123;</span><br><span class="line">su++;</span><br><span class="line">System.out.println(su);</span><br><span class="line">&#125;</span><br><span class="line">int tmp = 0;</span><br><span class="line">for (int j = i; j &lt; num.length; j++) &#123;</span><br><span class="line">tmp = num[j];</span><br><span class="line">num[j] = num[i];</span><br><span class="line">num[i] = tmp;</span><br><span class="line">sun(i + 1);</span><br><span class="line">tmp = num[j];</span><br><span class="line">num[j] = num[i];</span><br><span class="line">num[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private static boolean sum() &#123;</span><br><span class="line">int tmp = num[0] + num[1] + num[2] + num[3];</span><br><span class="line">for (int i = 0; i &lt; num.length; i += 4) &#123;</span><br><span class="line">if (tmp != num[i] + num[i + 1] + num[i + 2] + num[i + 3])</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">if (tmp != num[i] + num[i + 4] + num[i + 8] + num[i + 12])</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">if (tmp != num[0] + num[5] + num[10] + num[15])</span><br><span class="line">return false;</span><br><span class="line">if (tmp != num[3] + num[6] + num[9] + num[12])</span><br><span class="line">return false;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理论有解</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>胡同门牌号</title>
      <link href="/543613fef7da.html"/>
      <url>/543613fef7da.html</url>
      
        <content type="html"><![CDATA[<p>小明家住在一条胡同里。胡同里的门牌号都是连续的正整数，由于历史原因，最小的号码并不是从1开始排的。<br>有一天小明突然发现了有趣的事情：<br>如果除去小明家不算，胡同里的其它门牌号加起来，刚好是100！<br>并且，小明家的门牌号刚好等于胡同里其它住户的个数！<br>请你根据这些信息，推算小明家的门牌号是多少？<br>请提交该整数，不要填写任何多余的内容或说明性文字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">for (int i = 2; i &lt; 100; i++) &#123;</span><br><span class="line">for (int j = i + 1; j &lt; 100; j++) &#123;</span><br><span class="line">for (int k = i; k &lt;= j; k++) &#123;</span><br><span class="line">if ((i + j) * (j - i + 1) / 2 - k == 100 &amp;&amp; k == j - i) &#123;</span><br><span class="line">System.out.println(i + &quot; &quot; + j + &quot; &quot; + k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第39级台阶</title>
      <link href="/e8d6d5f114d9.html"/>
      <url>/e8d6d5f114d9.html</url>
      
        <content type="html"><![CDATA[<p>小明刚刚看完电影《第39级台阶》，离开电影院的时候，他数了数礼堂前的台阶数，恰好是39级！站在台阶前，他突然又想着一个问题：如果我每一步只能迈上1个或2个台阶。先迈左脚，然后左右交替，最后一步是迈右脚，也就是说一共要走偶数步。那么，上完39级台阶，有多少种不同的上法呢？</p><p>请你利用计算机的优势，帮助小明寻找答案。要求提交的是一个整数。</p><p>解：</p><p>阶乘》递归</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static int count = 0;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(pace(0, 0));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int pace(int step, int frequency) &#123;</span><br><span class="line">if (step &gt; 39) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">if (step == 39) &#123;</span><br><span class="line">if (frequency % 2 == 0) &#123;</span><br><span class="line">count++;</span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">pace(step + 1, frequency + 1);</span><br><span class="line">pace(step + 2, frequency + 1);</span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
